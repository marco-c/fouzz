diff --git a/js/ductwork/debugger/JSDebugger.cpp b/js/ductwork/debugger/JSDebugger.cpp
--- a/js/ductwork/debugger/JSDebugger.cpp
+++ b/js/ductwork/debugger/JSDebugger.cpp
@@ -31,17 +31,17 @@ JSDebugger::~JSDebugger() = default;
 
 NS_IMETHODIMP
 JSDebugger::AddClass(JS::Handle<JS::Value> global, JSContext* cx) {
-  if (!global.isObject()) {
+  if (!global.isObject()) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_INVALID_ARG;
   }
 
   JS::RootedObject obj(cx, &global.toObject());
   obj = js::UncheckedUnwrap(obj, /* stopAtWindowProxy = */ false);
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
 
-  if (!JS_IsGlobalObject(obj)) {
+  if (!JS_IsGlobalObject(obj)) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_INVALID_ARG;
   }
 
diff --git a/js/src/builtin/Array.cpp b/js/src/builtin/Array.cpp
--- a/js/src/builtin/Array.cpp
+++ b/js/src/builtin/Array.cpp
@@ -289,12 +289,12 @@ static bool HasAndGetElement(JSContext* 
       if (nobj->as<ArgumentsObject>().maybeGetElement(uint32_t(index), vp)) {
         *hole = false;
         return true;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
   }
 
   RootedId id(cx);
-  if (!ToId(cx, index, &id)) {
+  if (!ToId(cx, index, &id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -326,13 +326,13 @@ bool ElementAdder::append(JSContext* cx,
     NativeObject* resObj = &resObj_->as<NativeObject>();
     DenseElementResult result =
         resObj->setOrExtendDenseElements(cx, index_, v.address(), 1);
-    if (result == DenseElementResult::Failure) {
+    if (result == DenseElementResult::Failure) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (result == DenseElementResult::Incomplete) {
-      if (!DefineDataElement(cx, resObj_, index_, v)) {
+      if (!DefineDataElement(cx, resObj_, index_, v)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
   } else {
     vp_[index_] = v;
@@ -341,7 +341,7 @@ bool ElementAdder::append(JSContext* cx,
   return true;
 }
 
-void ElementAdder::appendHole() {
+void ElementAdder::appendHole() {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(getBehavior_ == ElementAdder::CheckHasElemPreserveHoles);
   MOZ_ASSERT(index_ < length_);
   if (!resObj_) {
@@ -357,18 +357,18 @@ bool js::GetElementsWithAdder(JSContext*
 
   RootedValue val(cx);
   for (uint32_t i = begin; i < end; i++) {
-    if (adder->getBehavior() == ElementAdder::CheckHasElemPreserveHoles) {
+    if (adder->getBehavior() == ElementAdder::CheckHasElemPreserveHoles) {MOZ_RELEASE_ASSERT(0);
       bool hole;
-      if (!HasAndGetElement(cx, obj, receiver, i, &hole, &val)) {
+      if (!HasAndGetElement(cx, obj, receiver, i, &hole, &val)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
-      if (hole) {
+      if (hole) {MOZ_RELEASE_ASSERT(0);
         adder->appendHole();
         continue;
       }
     } else {
       MOZ_ASSERT(adder->getBehavior() == ElementAdder::GetElement);
-      if (!GetElement(cx, obj, receiver, i, &val)) {
+      if (!GetElement(cx, obj, receiver, i, &val)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -514,7 +514,7 @@ static bool DeleteArrayElement(JSContext
         } else {
           aobj->setDenseElementHole(idx);
         }
-        if (!SuppressDeletedElement(cx, obj, idx)) {
+        if (!SuppressDeletedElement(cx, obj, idx)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -559,7 +559,7 @@ static bool DeletePropertiesOrThrow(JSCo
   }
 
   for (uint64_t k = len; k > finalLength; k--) {
-    if (!CheckForInterrupt(cx)) {
+    if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -656,7 +656,7 @@ bool js::ArraySetLength(JSContext* cx, H
 
     // Step 4.
     double d;
-    if (!ToNumber(cx, value, &d)) {
+    if (!ToNumber(cx, value, &d)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -782,7 +782,7 @@ bool js::ArraySetLength(JSContext* cx, H
 
         // Steps 15b-d.
         ObjectOpResult deleteSucceeded;
-        if (!DeleteElement(cx, arr, oldLen, deleteSucceeded)) {
+        if (!DeleteElement(cx, arr, oldLen, deleteSucceeded)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         if (!deleteSucceeded) {
@@ -807,12 +807,12 @@ bool js::ArraySetLength(JSContext* cx, H
       Vector<uint32_t> indexes(cx);
       {
         RootedIdVector props(cx);
-        if (!GetPropertyKeys(cx, arr, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
+        if (!GetPropertyKeys(cx, arr, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         for (size_t i = 0; i < props.length(); i++) {
-          if (!CheckForInterrupt(cx)) {
+          if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
 
@@ -822,7 +822,7 @@ bool js::ArraySetLength(JSContext* cx, H
           }
 
           if (index >= newLen && index < oldLen) {
-            if (!indexes.append(index)) {
+            if (!indexes.append(index)) {MOZ_RELEASE_ASSERT(0);
               return false;
             }
           }
@@ -834,7 +834,7 @@ bool js::ArraySetLength(JSContext* cx, H
         // We should use radix sort to be O(n), but this is uncommon
         // enough that we'll punt til someone complains.
         Vector<uint32_t> scratch(cx);
-        if (!scratch.resize(count)) {
+        if (!scratch.resize(count)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         MOZ_ALWAYS_TRUE(MergeSort(indexes.begin(), count, scratch.begin(),
@@ -848,7 +848,7 @@ bool js::ArraySetLength(JSContext* cx, H
 
         // Steps 15b-d.
         ObjectOpResult deleteSucceeded;
-        if (!DeleteElement(cx, arr, index, deleteSucceeded)) {
+        if (!DeleteElement(cx, arr, index, deleteSucceeded)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         if (!deleteSucceeded) {
@@ -869,7 +869,7 @@ bool js::ArraySetLength(JSContext* cx, H
     RootedShape lengthShape(cx, arr->lookup(cx, id));
     MOZ_ASSERT(lengthShape->isCustomDataProperty());
     unsigned attrs = lengthShape->attributes() | JSPROP_READONLY;
-    if (!NativeObject::changeCustomDataPropAttributes(cx, arr, id, attrs)) {
+    if (!NativeObject::changeCustomDataPropAttributes(cx, arr, id, attrs)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1050,7 +1050,7 @@ static MOZ_ALWAYS_INLINE bool IsArraySpe
 
   jsid speciesId = SYMBOL_TO_JSID(cx->wellKnownSymbols().species);
   JSFunction* getter;
-  if (!GetGetterPure(cx, &ctor.toObject(), speciesId, &getter)) {
+  if (!GetGetterPure(cx, &ctor.toObject(), speciesId, &getter)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1083,25 +1083,25 @@ static bool ArraySpeciesCreate(JSContext
 
 JSString* js::ArrayToSource(JSContext* cx, HandleObject obj) {
   AutoCycleDetector detector(cx, obj);
-  if (!detector.init()) {
+  if (!detector.init()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   JSStringBuilder sb(cx);
 
   if (detector.foundCycle()) {
-    if (!sb.append("[]")) {
+    if (!sb.append("[]")) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return sb.finishString();
   }
 
-  if (!sb.append('[')) {
+  if (!sb.append('[')) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   uint64_t length;
-  if (!GetLengthProperty(cx, obj, &length)) {
+  if (!GetLengthProperty(cx, obj, &length)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1109,7 +1109,7 @@ JSString* js::ArrayToSource(JSContext* c
   for (uint64_t index = 0; index < length; index++) {
     bool hole;
     if (!CheckForInterrupt(cx) ||
-        !HasAndGetElement(cx, obj, index, &hole, &elt)) {
+        !HasAndGetElement(cx, obj, index, &hole, &elt)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1119,21 +1119,21 @@ JSString* js::ArrayToSource(JSContext* c
       str = cx->runtime()->emptyString;
     } else {
       str = ValueToSource(cx, elt);
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
 
     /* Append element to buffer. */
-    if (!sb.append(str)) {
+    if (!sb.append(str)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (index + 1 != length) {
-      if (!sb.append(", ")) {
+      if (!sb.append(", ")) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     } else if (hole) {
-      if (!sb.append(',')) {
+      if (!sb.append(',')) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -1148,7 +1148,7 @@ JSString* js::ArrayToSource(JSContext* c
 }
 
 static bool array_toSource(JSContext* cx, unsigned argc, Value* vp) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1203,7 +1203,7 @@ static bool ArrayJoinDenseKernel(JSConte
              "initialized length shouldn't exceed UINT32_MAX");
   uint32_t initLengthClamped = uint32_t(initLength);
   while (*numProcessed < initLengthClamped) {
-    if (!CheckForInterrupt(cx)) {
+    if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1212,15 +1212,15 @@ static bool ArrayJoinDenseKernel(JSConte
 
     // Steps 7.c-d.
     if (elem.isString()) {
-      if (!sb.append(elem.toString())) {
+      if (!sb.append(elem.toString())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (elem.isNumber()) {
-      if (!NumberValueToStringBuffer(cx, elem, sb)) {
+      if (!NumberValueToStringBuffer(cx, elem, sb)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (elem.isBoolean()) {
-      if (!BooleanToStringBuffer(elem.toBoolean(), sb)) {
+      if (!BooleanToStringBuffer(elem.toBoolean(), sb)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (elem.isObject() || elem.isSymbol()) {
@@ -1260,7 +1260,7 @@ static bool ArrayJoinKernel(JSContext* c
 
   if (IsPackedArrayOrNoExtraIndexedProperties(obj, length)) {
     if (!ArrayJoinDenseKernel<SeparatorOp>(cx, sepOp, obj.as<NativeObject>(),
-                                           length, sb, &numProcessed)) {
+                                           length, sb, &numProcessed)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1269,7 +1269,7 @@ static bool ArrayJoinKernel(JSContext* c
   if (numProcessed != length) {
     RootedValue v(cx);
     for (uint64_t i = numProcessed; i < length;) {
-      if (!CheckForInterrupt(cx)) {
+      if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -1298,7 +1298,7 @@ static bool ArrayJoinKernel(JSContext* c
 // ES2017 draft rev 1b0184bc17fc09a8ddcf4aeec9b6d9fcac4eafce
 // 22.1.3.13 Array.prototype.join ( separator )
 bool js::array_join(JSContext* cx, unsigned argc, Value* vp) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1314,7 +1314,7 @@ bool js::array_join(JSContext* cx, unsig
   }
 
   AutoCycleDetector detector(cx, obj);
-  if (!detector.init()) {
+  if (!detector.init()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1337,7 +1337,7 @@ bool js::array_join(JSContext* cx, unsig
       return false;
     }
     sepstr = s->ensureLinear(cx);
-    if (!sepstr) {
+    if (!sepstr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -1366,7 +1366,7 @@ bool js::array_join(JSContext* cx, unsig
 
   // Step 5.
   JSStringBuilder sb(cx);
-  if (sepstr->hasTwoByteChars() && !sb.ensureTwoByteChars()) {
+  if (sepstr->hasTwoByteChars() && !sb.ensureTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1374,18 +1374,18 @@ bool js::array_join(JSContext* cx, unsig
   // so that we don't have to unnecessarily grow the buffer.
   size_t seplen = sepstr->length();
   if (seplen > 0) {
-    if (length > UINT32_MAX) {
+    if (length > UINT32_MAX) {MOZ_RELEASE_ASSERT(0);
       ReportAllocationOverflow(cx);
       return false;
     }
     CheckedInt<uint32_t> res =
         CheckedInt<uint32_t>(seplen) * (uint32_t(length) - 1);
-    if (!res.isValid()) {
+    if (!res.isValid()) {MOZ_RELEASE_ASSERT(0);
       ReportAllocationOverflow(cx);
       return false;
     }
 
-    if (!sb.reserve(res.value())) {
+    if (!sb.reserve(res.value())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1393,7 +1393,7 @@ bool js::array_join(JSContext* cx, unsig
   // Various optimized versions of steps 6-7.
   if (seplen == 0) {
     EmptySeparatorOp op;
-    if (!ArrayJoinKernel(cx, op, obj, length, sb)) {
+    if (!ArrayJoinKernel(cx, op, obj, length, sb)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else if (seplen == 1) {
@@ -1405,13 +1405,13 @@ bool js::array_join(JSContext* cx, unsig
       }
     } else {
       CharSeparatorOp<char16_t> op(c);
-      if (!ArrayJoinKernel(cx, op, obj, length, sb)) {
+      if (!ArrayJoinKernel(cx, op, obj, length, sb)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
   } else {
     StringSeparatorOp op(sepstr);
-    if (!ArrayJoinKernel(cx, op, obj, length, sb)) {
+    if (!ArrayJoinKernel(cx, op, obj, length, sb)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1431,7 +1431,7 @@ bool js::array_join(JSContext* cx, unsig
 // ES2017 Intl draft rev 78bbe7d1095f5ff3760ac4017ed366026e4cb276
 // 13.4.1 Array.prototype.toLocaleString ([ locales [ , options ]])
 static bool array_toLocaleString(JSContext* cx, unsigned argc, Value* vp) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1444,13 +1444,13 @@ static bool array_toLocaleString(JSConte
   }
 
   // Avoid calling into self-hosted code if the array is empty.
-  if (obj->is<ArrayObject>() && obj->as<ArrayObject>().length() == 0) {
+  if (obj->is<ArrayObject>() && obj->as<ArrayObject>().length() == 0) {MOZ_RELEASE_ASSERT(0);
     args.rval().setString(cx->names().empty);
     return true;
   }
 
   AutoCycleDetector detector(cx, obj);
-  if (!detector.init()) {
+  if (!detector.init()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1492,11 +1492,11 @@ static bool SetArrayElements(JSContext* 
   RootedId id(cx);
   const Value* end = vector + count;
   while (vector < end) {
-    if (!CheckForInterrupt(cx)) {
+    if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!ToId(cx, start++, &id)) {
+    if (!ToId(cx, start++, &id)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1534,7 +1534,7 @@ static DenseElementResult ArrayReverseDe
      * all the elements in the array if it were full.
      */
     DenseElementResult result = obj->ensureDenseElements(cx, length, 0);
-    if (result != DenseElementResult::Success) {
+    if (result != DenseElementResult::Success) {MOZ_RELEASE_ASSERT(0);
       return result;
     }
 
@@ -1565,7 +1565,7 @@ static DenseElementResult ArrayReverseDe
   for (; lo < hi; lo++, hi--) {
     origlo = obj->getDenseElement(lo);
     orighi = obj->getDenseElement(hi);
-    if (!setElementMaybeHole(cx, obj, lo, orighi)) {
+    if (!setElementMaybeHole(cx, obj, lo, orighi)) {MOZ_RELEASE_ASSERT(0);
       return DenseElementResult::Failure;
     }
     if (!setElementMaybeHole(cx, obj, hi, origlo)) {
@@ -1592,7 +1592,7 @@ static bool array_reverse(JSContext* cx,
 
   // Step 2.
   uint64_t len;
-  if (!GetLengthProperty(cx, obj, &len)) {
+  if (!GetLengthProperty(cx, obj, &len)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1634,10 +1634,10 @@ static bool array_reverse(JSContext* cx,
         return false;
       }
     } else if (hole && !hole2) {
-      if (!SetArrayElement(cx, obj, i, hival)) {
+      if (!SetArrayElement(cx, obj, i, hival)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
-      if (!DeletePropertyOrThrow(cx, obj, len - i - 1)) {
+      if (!DeletePropertyOrThrow(cx, obj, len - i - 1)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (!hole && hole2) {
@@ -1659,7 +1659,7 @@ static bool array_reverse(JSContext* cx,
 
 static inline bool CompareStringValues(JSContext* cx, const Value& a,
                                        const Value& b, bool* lessOrEqualp) {
-  if (!CheckForInterrupt(cx)) {
+  if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1739,7 +1739,7 @@ template <typename Char1, typename Char2
 static inline bool CompareSubStringValues(JSContext* cx, const Char1* s1,
                                           size_t len1, const Char2* s2,
                                           size_t len2, bool* lessOrEqualp) {
-  if (!CheckForInterrupt(cx)) {
+  if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1871,7 +1871,7 @@ static ComparatorMatchResult MatchNumeri
   }
 
   JSScript* script = JSFunction::getOrCreateScript(cx, fun);
-  if (!script) {
+  if (!script) {MOZ_RELEASE_ASSERT(0);
     return Match_Failure;
   }
 
@@ -1916,7 +1916,7 @@ static inline bool MergeSortByKey(K keys
   MOZ_ASSERT(vec.length() >= len);
 
   /* Sort keys. */
-  if (!MergeSort(keys, len, scratch, comparator)) {
+  if (!MergeSort(keys, len, scratch, comparator)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1971,14 +1971,14 @@ static bool SortLexicographically(JSCont
   Vector<StringifiedElement, 0, TempAllocPolicy> strElements(cx);
 
   /* MergeSort uses the upper half as scratch space. */
-  if (!strElements.resize(2 * len)) {
+  if (!strElements.resize(2 * len)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   /* Convert Values to strings. */
   size_t cursor = 0;
   for (size_t i = 0; i < len; i++) {
-    if (!CheckForInterrupt(cx)) {
+    if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2008,13 +2008,13 @@ static bool SortNumerically(JSContext* c
   Vector<NumericElement, 0, TempAllocPolicy> numElements(cx);
 
   /* MergeSort uses the upper half as scratch space. */
-  if (!numElements.resize(2 * len)) {
+  if (!numElements.resize(2 * len)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   /* Convert Values to numerics. */
   for (size_t i = 0; i < len; i++) {
-    if (!CheckForInterrupt(cx)) {
+    if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2042,7 +2042,7 @@ static bool FillWithUndefined(JSContext*
     }
 
     NativeObject* nobj = &obj->as<NativeObject>();
-    if (!nobj->isExtensible()) {
+    if (!nobj->isExtensible()) {MOZ_RELEASE_ASSERT(0);
       break;
     }
 
@@ -2053,9 +2053,9 @@ static bool FillWithUndefined(JSContext*
 
     DenseElementResult result = nobj->ensureDenseElements(cx, start, count);
     if (result != DenseElementResult::Success) {
-      if (result == DenseElementResult::Failure) {
+      if (result == DenseElementResult::Failure) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(result == DenseElementResult::Incomplete);
       break;
     }
@@ -2095,7 +2095,7 @@ bool js::intrinsic_ArrayNativeSort(JSCon
   ComparatorMatchResult comp;
   if (fval.isObject()) {
     comp = MatchNumericComparator(cx, &fval.toObject());
-    if (comp == Match_Failure) {
+    if (comp == Match_Failure) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2112,7 +2112,7 @@ bool js::intrinsic_ArrayNativeSort(JSCon
   RootedObject obj(cx, &args.thisv().toObject());
 
   uint64_t length;
-  if (!GetLengthProperty(cx, obj, &length)) {
+  if (!GetLengthProperty(cx, obj, &length)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (length < 2) {
@@ -2121,7 +2121,7 @@ bool js::intrinsic_ArrayNativeSort(JSCon
     return true;
   }
 
-  if (length > UINT32_MAX) {
+  if (length > UINT32_MAX) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return false;
   }
@@ -2143,7 +2143,7 @@ bool js::intrinsic_ArrayNativeSort(JSCon
   size_t n, undefs;
   {
     Rooted<GCVector<Value>> vec(cx, GCVector<Value>(cx));
-    if (!vec.reserve(2 * size_t(len))) {
+    if (!vec.reserve(2 * size_t(len))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2163,7 +2163,7 @@ bool js::intrinsic_ArrayNativeSort(JSCon
       HandleArrayObject array = obj.as<ArrayObject>();
 
       for (uint32_t i = 0; i < len; i++) {
-        if (!CheckForInterrupt(cx)) {
+        if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -2179,12 +2179,12 @@ bool js::intrinsic_ArrayNativeSort(JSCon
       }
     } else {
       for (uint32_t i = 0; i < len; i++) {
-        if (!CheckForInterrupt(cx)) {
+        if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         bool hole;
-        if (!HasAndGetElement(cx, obj, i, &hole, &v)) {
+        if (!HasAndGetElement(cx, obj, i, &hole, &v)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         if (hole) {
@@ -2219,13 +2219,13 @@ bool js::intrinsic_ArrayNativeSort(JSCon
       if (allStrings) {
         MOZ_ALWAYS_TRUE(vec.resize(n * 2));
         if (!MergeSort(vec.begin(), n, vec.begin() + n,
-                       SortComparatorStrings(cx))) {
+                       SortComparatorStrings(cx))) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else if (allInts) {
         MOZ_ALWAYS_TRUE(vec.resize(n * 2));
         if (!MergeSort(vec.begin(), n, vec.begin() + n,
-                       SortComparatorLexicographicInt32())) {
+                       SortComparatorLexicographicInt32())) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
@@ -2237,11 +2237,11 @@ bool js::intrinsic_ArrayNativeSort(JSCon
       if (allInts) {
         MOZ_ALWAYS_TRUE(vec.resize(n * 2));
         if (!MergeSort(vec.begin(), n, vec.begin() + n,
-                       SortComparatorInt32s[comp])) {
+                       SortComparatorInt32s[comp])) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
-        if (!SortNumerically(cx, &vec, n, comp)) {
+        if (!SortNumerically(cx, &vec, n, comp)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -2254,7 +2254,7 @@ bool js::intrinsic_ArrayNativeSort(JSCon
 
   /* Set undefs that sorted after the rest of elements. */
   if (undefs > 0) {
-    if (!FillWithUndefined(cx, obj, n, undefs)) {
+    if (!FillWithUndefined(cx, obj, n, undefs)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     n += undefs;
@@ -2314,7 +2314,7 @@ bool js::array_push(JSContext* cx, unsig
         obj->as<NativeObject>().setOrExtendDenseElements(
             cx, uint32_t(length), args.array(), args.length());
     if (result != DenseElementResult::Incomplete) {
-      if (result == DenseElementResult::Failure) {
+      if (result == DenseElementResult::Failure) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -2379,7 +2379,7 @@ bool js::array_pop(JSContext* cx, unsign
     index--;
 
     // Steps 4.c, 4.f.
-    if (!GetArrayElement(cx, obj, index, args.rval())) {
+    if (!GetArrayElement(cx, obj, index, args.rval())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2492,13 +2492,13 @@ bool js::array_shift(JSContext* cx, unsi
   uint64_t startIndex;
   DenseElementResult result = ArrayShiftDenseKernel(cx, obj, args.rval());
   if (result != DenseElementResult::Incomplete) {
-    if (result == DenseElementResult::Failure) {
+    if (result == DenseElementResult::Failure) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (len <= UINT32_MAX) {
       return SetLengthProperty(cx, obj, newlen);
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     startIndex = UINT32_MAX - 1;
   } else {
@@ -2513,7 +2513,7 @@ bool js::array_shift(JSContext* cx, unsi
   // Steps 5-6.
   RootedValue value(cx);
   for (uint64_t i = startIndex; i < newlen; i++) {
-    if (!CheckForInterrupt(cx)) {
+    if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     bool hole;
@@ -2585,9 +2585,9 @@ static bool array_unshift(JSContext* cx,
         DenseElementResult result =
             nobj->ensureDenseElements(cx, uint32_t(length), args.length());
         if (result != DenseElementResult::Success) {
-          if (result == DenseElementResult::Failure) {
+          if (result == DenseElementResult::Failure) {MOZ_RELEASE_ASSERT(0);
             return false;
-          }
+          }MOZ_RELEASE_ASSERT(0);
           MOZ_ASSERT(result == DenseElementResult::Incomplete);
           break;
         }
@@ -2618,7 +2618,7 @@ static bool array_unshift(JSContext* cx,
         do {
           --last;
           --upperIndex;
-          if (!CheckForInterrupt(cx)) {
+          if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
           bool hole;
@@ -2733,7 +2733,7 @@ static ArrayObject* CopyDenseArrayElemen
   }
 
   ArrayObject* narr = NewDenseFullyAllocatedArray(cx, newlength);
-  if (!narr) {
+  if (!narr) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2768,14 +2768,14 @@ static bool CopyArrayElements(JSContext*
       if (!hole) {
         DenseElementResult edResult = result->ensureDenseElements(cx, index, 1);
         if (edResult != DenseElementResult::Success) {
-          if (edResult == DenseElementResult::Failure) {
+          if (edResult == DenseElementResult::Failure) {MOZ_RELEASE_ASSERT(0);
             return false;
-          }
+          }MOZ_RELEASE_ASSERT(0);
 
           MOZ_ASSERT(edResult == DenseElementResult::Incomplete);
-          if (!DefineDataElement(cx, result, index, value)) {
+          if (!DefineDataElement(cx, result, index, value)) {MOZ_RELEASE_ASSERT(0);
             return false;
-          }
+          }MOZ_RELEASE_ASSERT(0);
 
           break;
         }
@@ -2786,10 +2786,10 @@ static bool CopyArrayElements(JSContext*
   }
 
   // Copy any remaining elements.
-  for (uint64_t i = startIndex; i < count; i++) {
+  for (uint64_t i = startIndex; i < count; i++) {MOZ_RELEASE_ASSERT(0);
     bool hole;
     if (!CheckForInterrupt(cx) ||
-        !HasAndGetElement(cx, obj, begin + i, &hole, &value)) {
+        !HasAndGetElement(cx, obj, begin + i, &hole, &value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2821,7 +2821,7 @@ static bool array_splice_impl(JSContext*
 
   /* Step 3. */
   double relativeStart;
-  if (!ToInteger(cx, args.get(0), &relativeStart)) {
+  if (!ToInteger(cx, args.get(0), &relativeStart)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2844,7 +2844,7 @@ static bool array_splice_impl(JSContext*
   } else {
     /* Steps 7.b. */
     double deleteCountDouble;
-    if (!ToInteger(cx, args[1], &deleteCountDouble)) {
+    if (!ToInteger(cx, args[1], &deleteCountDouble)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2882,7 +2882,7 @@ static bool array_splice_impl(JSContext*
         /* Steps 9-12. */
         arr = CopyDenseArrayElements(cx, obj.as<NativeObject>(),
                                      uint32_t(actualStart), count);
-        if (!arr) {
+        if (!arr) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -2895,7 +2895,7 @@ static bool array_splice_impl(JSContext*
 
       /* Steps 10-11. */
       if (!CopyArrayElements(cx, obj, actualStart, count,
-                             arr.as<ArrayObject>())) {
+                             arr.as<ArrayObject>())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -2912,7 +2912,7 @@ static bool array_splice_impl(JSContext*
     for (uint64_t k = 0; k < actualDeleteCount; k++) {
       /* Step 11.a (implicit). */
 
-      if (!CheckForInterrupt(cx)) {
+      if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -2932,7 +2932,7 @@ static bool array_splice_impl(JSContext*
     }
 
     /* Step 12. */
-    if (!SetLengthProperty(cx, arr, actualDeleteCount)) {
+    if (!SetLengthProperty(cx, arr, actualDeleteCount)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2975,7 +2975,7 @@ static bool array_splice_impl(JSContext*
            from++, to++) {
         /* Steps 15.b.i-ii (implicit). */
 
-        if (!CheckForInterrupt(cx)) {
+        if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -3046,7 +3046,7 @@ static bool array_splice_impl(JSContext*
     };
 
     DenseElementResult res = extendElements(cx, obj);
-    if (res == DenseElementResult::Failure) {
+    if (res == DenseElementResult::Failure) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (res == DenseElementResult::Success) {
@@ -3071,7 +3071,7 @@ static bool array_splice_impl(JSContext*
 
       RootedValue fromValue(cx);
       for (uint64_t k = len - actualDeleteCount; k > actualStart; k--) {
-        if (!CheckForInterrupt(cx)) {
+        if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -3151,7 +3151,7 @@ static bool GetIndexedPropertiesInRange(
   *success = false;
 
   // TODO: Add IdIsIndex with support for large indices.
-  if (end > UINT32_MAX) {
+  if (end > UINT32_MAX) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
   MOZ_ASSERT(begin <= UINT32_MAX);
@@ -3161,7 +3161,7 @@ static bool GetIndexedPropertiesInRange(
   JSObject* pobj = obj;
   do {
     if (!pobj->is<NativeObject>() || pobj->getClass()->getResolve() ||
-        pobj->getOpsLookupProperty()) {
+        pobj->getOpsLookupProperty()) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
   } while ((pobj = pobj->staticPrototype()));
@@ -3173,19 +3173,19 @@ static bool GetIndexedPropertiesInRange(
     NativeObject* nativeObj = &pobj->as<NativeObject>();
     uint32_t initLen = nativeObj->getDenseInitializedLength();
     for (uint32_t i = begin; i < initLen && i < end; i++) {
-      if (nativeObj->getDenseElement(i).isMagic(JS_ELEMENTS_HOLE)) {
+      if (nativeObj->getDenseElement(i).isMagic(JS_ELEMENTS_HOLE)) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
-      if (!indexes.append(i)) {
+      if (!indexes.append(i)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
     // Append typed array elements.
     if (nativeObj->is<TypedArrayObject>()) {
       size_t len = nativeObj->as<TypedArrayObject>().length().get();
       for (uint32_t i = begin; i < len && i < end; i++) {
-        if (!indexes.append(i)) {
+        if (!indexes.append(i)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -3211,7 +3211,7 @@ static bool GetIndexedPropertiesInRange(
           return true;
         }
 
-        if (!indexes.append(i)) {
+        if (!indexes.append(i)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -3221,10 +3221,10 @@ static bool GetIndexedPropertiesInRange(
   // Sort the indexes.
   Vector<uint32_t> tmp(cx);
   size_t n = indexes.length();
-  if (!tmp.resize(n)) {
+  if (!tmp.resize(n)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!MergeSort(indexes.begin(), n, tmp.begin(), SortComparatorIndexes())) {
+  if (!MergeSort(indexes.begin(), n, tmp.begin(), SortComparatorIndexes())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3253,7 +3253,7 @@ static bool SliceSparse(JSContext* cx, H
 
   Vector<uint32_t> indexes(cx);
   bool success;
-  if (!GetIndexedPropertiesInRange(cx, obj, begin, end, indexes, &success)) {
+  if (!GetIndexedPropertiesInRange(cx, obj, begin, end, indexes, &success)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3270,7 +3270,7 @@ static bool SliceSparse(JSContext* cx, H
     MOZ_ASSERT(begin <= index && index < end);
 
     bool hole;
-    if (!HasAndGetElement(cx, obj, index, &hole, &value)) {
+    if (!HasAndGetElement(cx, obj, index, &hole, &value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3290,7 +3290,7 @@ static JSObject* SliceArguments(JSContex
   MOZ_ASSERT(begin + count <= argsobj->initialLength());
 
   ArrayObject* result = NewDenseFullyAllocatedArray(cx, count);
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   result->setDenseInitializedLength(count);
@@ -3333,7 +3333,7 @@ static bool ArraySliceOrdinary(JSContext
                "if end <= UINT32_MAX, then begin <= UINT32_MAX");
     JSObject* narr = CopyDenseArrayElements(cx, obj.as<NativeObject>(),
                                             uint32_t(begin), count);
-    if (!narr) {
+    if (!narr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3346,7 +3346,7 @@ static bool ArraySliceOrdinary(JSContext
     if (!argsobj->hasOverriddenLength() && !argsobj->isAnyElementDeleted()) {
       MOZ_ASSERT(begin <= UINT32_MAX, "begin is limited by |argsobj|'s length");
       JSObject* narr = SliceArguments(cx, argsobj, uint32_t(begin), count);
-      if (!narr) {
+      if (!narr) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -3356,7 +3356,7 @@ static bool ArraySliceOrdinary(JSContext
   }
 
   RootedArrayObject narr(cx, NewDensePartlyAllocatedArray(cx, count));
-  if (!narr) {
+  if (!narr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3364,7 +3364,7 @@ static bool ArraySliceOrdinary(JSContext
     if (js::GetElementsOp op = obj->getOpsGetElements()) {
       ElementAdder adder(cx, narr, count,
                          ElementAdder::CheckHasElemPreserveHoles);
-      if (!op(cx, obj, uint32_t(begin), uint32_t(end), &adder)) {
+      if (!op(cx, obj, uint32_t(begin), uint32_t(end), &adder)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -3375,7 +3375,7 @@ static bool ArraySliceOrdinary(JSContext
 
   if (obj->is<NativeObject>() && obj->as<NativeObject>().isIndexed() &&
       count > 1000) {
-    if (!SliceSparse(cx, obj, begin, end, narr)) {
+    if (!SliceSparse(cx, obj, begin, end, narr)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -3412,7 +3412,7 @@ bool js::array_slice(JSContext* cx, unsi
   if (args.length() > 0) {
     double d;
     /* Step 3. */
-    if (!ToInteger(cx, args[0], &d)) {
+    if (!ToInteger(cx, args[0], &d)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3421,7 +3421,7 @@ bool js::array_slice(JSContext* cx, unsi
 
     if (args.hasDefined(1)) {
       /* Step 5. */
-      if (!ToInteger(cx, args[1], &d)) {
+      if (!ToInteger(cx, args[1], &d)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -3450,13 +3450,13 @@ bool js::array_slice(JSContext* cx, unsi
   /* Step 10. */
   RootedValue kValue(cx);
   while (k < final) {
-    if (!CheckForInterrupt(cx)) {
+    if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     /* Steps 10.a-b, and 10.c.i. */
     bool kNotPresent;
-    if (!HasAndGetElement(cx, obj, k, &kNotPresent, &kValue)) {
+    if (!HasAndGetElement(cx, obj, k, &kNotPresent, &kValue)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3492,7 +3492,7 @@ static bool ArraySliceDenseKernel(JSCont
   uint32_t begin = NormalizeSliceTerm(beginArg, length);
   uint32_t end = NormalizeSliceTerm(endArg, length);
 
-  if (begin > end) {
+  if (begin > end) {MOZ_RELEASE_ASSERT(0);
     begin = end;
   }
 
@@ -3520,7 +3520,7 @@ JSObject* js::ArraySliceDense(JSContext*
 
   if (result && IsArraySpecies(cx, obj)) {
     if (!ArraySliceDenseKernel(cx, &obj->as<ArrayObject>(), begin, end,
-                               &result->as<ArrayObject>())) {
+                               &result->as<ArrayObject>())) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     return result;
@@ -3689,7 +3689,7 @@ static inline bool ArrayConstructorImpl(
     // We're emulating |new Array(n)| with |std_Array(n)| in self-hosted JS,
     // and the proto should be %ArrayPrototype% regardless of the callee.
     proto = GlobalObject::getOrCreateArrayPrototype(cx, cx->global());
-    if (!proto) {
+    if (!proto) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -3767,14 +3767,14 @@ static JSObject* CreateArrayPrototype(JS
   MOZ_ASSERT(key == JSProto_Array);
   RootedObject proto(
       cx, GlobalObject::getOrCreateObjectPrototype(cx, cx->global()));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedShape shape(cx, EmptyShape::getInitialShape(
                             cx, &ArrayObject::class_, cx->realm(),
                             TaggedProto(proto), gc::AllocKind::OBJECT0));
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3794,13 +3794,13 @@ static bool array_proto_finish(JSContext
   // Add Array.prototype[@@unscopables]. ECMA-262 draft (2016 Mar 19) 22.1.3.32.
   RootedObject unscopables(
       cx, NewTenuredObjectWithGivenProto<PlainObject>(cx, nullptr));
-  if (!unscopables) {
+  if (!unscopables) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedValue value(cx, BooleanValue(true));
 #ifdef NIGHTLY_BUILD
-  if (!DefineDataProperty(cx, unscopables, cx->names().at, value)) {
+  if (!DefineDataProperty(cx, unscopables, cx->names().at, value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 #endif
@@ -3885,7 +3885,7 @@ static MOZ_ALWAYS_INLINE ArrayObject* Ne
   RootedObject proto(cx, protoArg);
   if (!proto) {
     proto = GlobalObject::getOrCreateArrayPrototype(cx, cx->global());
-    if (!proto) {
+    if (!proto) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -3921,7 +3921,7 @@ static MOZ_ALWAYS_INLINE ArrayObject* Ne
   RootedShape shape(cx, EmptyShape::getInitialShape(
                             cx, &ArrayObject::class_, cx->realm(),
                             TaggedProto(proto), gc::AllocKind::OBJECT0));
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3935,7 +3935,7 @@ static MOZ_ALWAYS_INLINE ArrayObject* Ne
   }
 
   if (shape->isEmptyShape()) {
-    if (!AddLengthProperty(cx, arr)) {
+    if (!AddLengthProperty(cx, arr)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     shape = arr->lastProperty();
@@ -3993,7 +3993,7 @@ ArrayObject* js::NewDenseCopiedArray(
     HandleObject proto /* = nullptr */,
     NewObjectKind newKind /* = GenericObject */) {
   ArrayObject* arr = NewArray<UINT32_MAX>(cx, length, proto, newKind);
-  if (!arr) {
+  if (!arr) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -4020,7 +4020,7 @@ ArrayObject* js::NewDenseFullyAllocatedA
   Rooted<ArrayObject*> arr(
       cx,
       ArrayObject::createArray(cx, allocKind, heap, shape, length, metadata));
-  if (!arr) {
+  if (!arr) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -4083,7 +4083,7 @@ void js::ArraySpeciesLookup::initialize(
 
   // Leave the cache uninitialized if the Array class itself is not yet
   // initialized.
-  if (!arrayProto) {
+  if (!arrayProto) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -4100,7 +4100,7 @@ void js::ArraySpeciesLookup::initialize(
 
   // Look up Array.prototype[@@iterator] and ensure it's a data property.
   Shape* ctorShape = arrayProto->lookup(cx, NameToId(cx->names().constructor));
-  if (!ctorShape || !ctorShape->isDataProperty()) {
+  if (!ctorShape || !ctorShape->isDataProperty()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -4110,7 +4110,7 @@ void js::ArraySpeciesLookup::initialize(
   if (!IsFunctionObject(arrayProto->getSlot(ctorShape->slot()), &ctorFun)) {
     return;
   }
-  if (ctorFun != arrayCtor) {
+  if (ctorFun != arrayCtor) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -4125,7 +4125,7 @@ void js::ArraySpeciesLookup::initialize(
   // function.
   uint32_t speciesGetterSlot = speciesShape->slot();
   JSObject* speciesGetter = arrayCtor->getGetter(speciesGetterSlot);
-  if (!speciesGetter || !speciesGetter->is<JSFunction>()) {
+  if (!speciesGetter || !speciesGetter->is<JSFunction>()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
   JSFunction* speciesFun = &speciesGetter->as<JSFunction>();
@@ -4169,7 +4169,7 @@ bool js::ArraySpeciesLookup::isArrayStat
   // Ensure that Array.prototype.constructor contains the canonical Array
   // constructor function.
   if (arrayProto_->getSlot(arrayProtoConstructorSlot_) !=
-      ObjectValue(*arrayConstructor_)) {
+      ObjectValue(*arrayConstructor_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/builtin/AtomicsObject.cpp b/js/src/builtin/AtomicsObject.cpp
--- a/js/src/builtin/AtomicsObject.cpp
+++ b/js/src/builtin/AtomicsObject.cpp
@@ -583,7 +583,7 @@ static FutexThread::WaitResult AtomicsWa
 
   // Steps 14, 18-22.
   FutexWaiter w(byteOffset, cx);
-  if (FutexWaiter* waiters = sarb->waiters()) {
+  if (FutexWaiter* waiters = sarb->waiters()) {MOZ_RELEASE_ASSERT(0);
     w.lower_pri = waiters;
     w.back = waiters->back;
     waiters->back->lower_pri = &w;
@@ -597,7 +597,7 @@ static FutexThread::WaitResult AtomicsWa
 
   if (w.lower_pri == &w) {
     sarb->setWaiters(nullptr);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     w.lower_pri->back = w.back;
     w.back->lower_pri = w.lower_pri;
     if (sarb->waiters() == &w) {
@@ -632,13 +632,13 @@ static bool DoAtomicsWait(JSContext* cx,
   if (!timeoutv.isUndefined()) {
     // Step 6.
     double timeout_ms;
-    if (!ToNumber(cx, timeoutv, &timeout_ms)) {
+    if (!ToNumber(cx, timeoutv, &timeout_ms)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // Step 7.
     if (!mozilla::IsNaN(timeout_ms)) {
-      if (timeout_ms < 0) {
+      if (timeout_ms < 0) {MOZ_RELEASE_ASSERT(0);
         timeout = mozilla::Some(mozilla::TimeDuration::FromSeconds(0.0));
       } else if (!mozilla::IsInfinite(timeout_ms)) {
         timeout =
@@ -690,33 +690,33 @@ static bool atomics_wait(JSContext* cx, 
 
   // Step 1.
   Rooted<TypedArrayObject*> unwrappedTypedArray(cx);
-  if (!ValidateIntegerTypedArray(cx, objv, true, &unwrappedTypedArray)) {
+  if (!ValidateIntegerTypedArray(cx, objv, true, &unwrappedTypedArray)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(unwrappedTypedArray->type() == Scalar::Int32 ||
              unwrappedTypedArray->type() == Scalar::BigInt64);
 
   // https://github.com/tc39/ecma262/pull/1908
-  if (!unwrappedTypedArray->isSharedMemory()) {
+  if (!unwrappedTypedArray->isSharedMemory()) {MOZ_RELEASE_ASSERT(0);
     return ReportBadArrayType(cx);
   }
 
   // Step 2.
   size_t intIndex;
-  if (!ValidateAtomicAccess(cx, unwrappedTypedArray, index, &intIndex)) {
+  if (!ValidateAtomicAccess(cx, unwrappedTypedArray, index, &intIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (unwrappedTypedArray->type() == Scalar::Int32) {
     // Step 5.
     int32_t value;
-    if (!ToInt32(cx, valv, &value)) {
+    if (!ToInt32(cx, valv, &value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // Steps 6-25.
     return DoAtomicsWait(cx, unwrappedTypedArray, intIndex, value, timeoutv, r);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MOZ_ASSERT(unwrappedTypedArray->type() == Scalar::BigInt64);
 
@@ -746,14 +746,14 @@ int64_t js::atomics_notify_impl(SharedAr
 
   // Steps 10, 13-14.
   FutexWaiter* waiters = sarb->waiters();
-  if (waiters && count) {
+  if (waiters && count) {MOZ_RELEASE_ASSERT(0);
     FutexWaiter* iter = waiters;
-    do {
+    do {MOZ_RELEASE_ASSERT(0);
       FutexWaiter* c = iter;
       iter = iter->lower_pri;
-      if (c->offset != byteOffset || !c->cx->fx.isWaiting()) {
+      if (c->offset != byteOffset || !c->cx->fx.isWaiting()) {MOZ_RELEASE_ASSERT(0);
         continue;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       c->cx->fx.notify(FutexThread::NotifyExplicit);
       // Overflow will be a problem only in two cases:
       // (1) 128-bit systems with substantially more than 2^64 bytes of
@@ -783,7 +783,7 @@ static bool atomics_notify(JSContext* cx
 
   // Step 1.
   Rooted<TypedArrayObject*> unwrappedTypedArray(cx);
-  if (!ValidateIntegerTypedArray(cx, objv, true, &unwrappedTypedArray)) {
+  if (!ValidateIntegerTypedArray(cx, objv, true, &unwrappedTypedArray)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(unwrappedTypedArray->type() == Scalar::Int32 ||
@@ -791,7 +791,7 @@ static bool atomics_notify(JSContext* cx
 
   // Step 2.
   size_t intIndex;
-  if (!ValidateAtomicAccess(cx, unwrappedTypedArray, index, &intIndex)) {
+  if (!ValidateAtomicAccess(cx, unwrappedTypedArray, index, &intIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -799,14 +799,14 @@ static bool atomics_notify(JSContext* cx
   int64_t count;
   if (countv.isUndefined()) {
     count = -1;
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     double dcount;
-    if (!ToInteger(cx, countv, &dcount)) {
+    if (!ToInteger(cx, countv, &dcount)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (dcount < 0.0) {
+    if (dcount < 0.0) {MOZ_RELEASE_ASSERT(0);
       dcount = 0.0;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     count = dcount < double(1ULL << 63) ? int64_t(dcount) : -1;
   }
 
@@ -907,7 +907,7 @@ FutexThread::WaitResult js::FutexThread:
   // Disallow waiting when a runtime is processing an interrupt.
   // See explanation below.
 
-  if (state_ == WaitingInterrupted) {
+  if (state_ == WaitingInterrupted) {MOZ_RELEASE_ASSERT(0);
     UnlockGuard<Mutex> unlock(locked);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_ATOMICS_WAIT_NOT_ALLOWED);
@@ -953,7 +953,7 @@ FutexThread::WaitResult js::FutexThread:
 
     if (isTimed) {
       mozilla::Unused << cond_->wait_until(locked, *sliceEnd);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       cond_->wait(locked);
     }
 
@@ -1029,7 +1029,7 @@ void js::FutexThread::notify(NotifyReaso
   MOZ_ASSERT(isWaiting());
 
   if ((state_ == WaitingInterrupted || state_ == WaitingNotifiedForInterrupt) &&
-      reason == NotifyExplicit) {
+      reason == NotifyExplicit) {MOZ_RELEASE_ASSERT(0);
     state_ = Woken;
     return;
   }
diff --git a/js/src/builtin/BigInt.cpp b/js/src/builtin/BigInt.cpp
--- a/js/src/builtin/BigInt.cpp
+++ b/js/src/builtin/BigInt.cpp
@@ -99,7 +99,7 @@ bool BigIntObject::toString_impl(JSConte
   // Steps 4-5.
   if (args.hasDefined(0)) {
     double d;
-    if (!ToInteger(cx, args[0], &d)) {
+    if (!ToInteger(cx, args[0], &d)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (d < 2 || d > 36) {
diff --git a/js/src/builtin/Boolean.cpp b/js/src/builtin/Boolean.cpp
--- a/js/src/builtin/Boolean.cpp
+++ b/js/src/builtin/Boolean.cpp
@@ -57,7 +57,7 @@ MOZ_ALWAYS_INLINE bool bool_toSource_imp
 
   JSStringBuilder sb(cx);
   if (!sb.append("(new Boolean(") || !BooleanToStringBuffer(b, sb) ||
-      !sb.append("))")) {
+      !sb.append("))")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -125,7 +125,7 @@ static bool Boolean(JSContext* cx, unsig
     }
 
     JSObject* obj = BooleanObject::create(cx, b, proto);
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
diff --git a/js/src/builtin/DataViewObject.cpp b/js/src/builtin/DataViewObject.cpp
--- a/js/src/builtin/DataViewObject.cpp
+++ b/js/src/builtin/DataViewObject.cpp
@@ -179,7 +179,7 @@ bool DataViewObject::constructWrapped(JS
   MOZ_ASSERT(bufobj->is<WrapperObject>());
 
   RootedObject unwrapped(cx, CheckedUnwrapStatic(bufobj));
-  if (!unwrapped) {
+  if (!unwrapped) {MOZ_RELEASE_ASSERT(0);
     ReportAccessDenied(cx);
     return false;
   }
@@ -188,21 +188,21 @@ bool DataViewObject::constructWrapped(JS
   BufferSize byteOffset(0);
   BufferSize byteLength(0);
   if (!getAndCheckConstructorArgs(cx, unwrapped, args, &byteOffset,
-                                  &byteLength)) {
+                                  &byteLength)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Make sure to get the [[Prototype]] for the created view from this
   // compartment.
   RootedObject proto(cx);
-  if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_DataView, &proto)) {
+  if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_DataView, &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Rooted<GlobalObject*> global(cx, cx->realm()->maybeGlobal());
   if (!proto) {
     proto = GlobalObject::getOrCreateDataViewPrototype(cx, global);
-    if (!proto) {
+    if (!proto) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -215,13 +215,13 @@ bool DataViewObject::constructWrapped(JS
     buffer = &unwrapped->as<ArrayBufferObjectMaybeShared>();
 
     RootedObject wrappedProto(cx, proto);
-    if (!cx->compartment()->wrap(cx, &wrappedProto)) {
+    if (!cx->compartment()->wrap(cx, &wrappedProto)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     dv = DataViewObject::create(cx, byteOffset, byteLength, buffer,
                                 wrappedProto);
-    if (!dv) {
+    if (!dv) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -455,7 +455,7 @@ bool DataViewObject::write(JSContext* cx
   }
 
   // See the comment in ElementSpecific::doubleToNative.
-  if (js::SupportDifferentialTesting() && TypeIsFloatingPoint<NativeType>()) {
+  if (js::SupportDifferentialTesting() && TypeIsFloatingPoint<NativeType>()) {MOZ_RELEASE_ASSERT(0);
     value = JS::CanonicalizeNaN(value);
   }
 
@@ -1023,7 +1023,7 @@ JS_FRIEND_API JSObject* JS_NewDataView(J
                                        size_t byteOffset, size_t byteLength) {
   JSProtoKey key = JSProto_DataView;
   RootedObject constructor(cx, GlobalObject::getOrCreateConstructor(cx, key));
-  if (!constructor) {
+  if (!constructor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/builtin/Eval.cpp b/js/src/builtin/Eval.cpp
--- a/js/src/builtin/Eval.cpp
+++ b/js/src/builtin/Eval.cpp
@@ -47,7 +47,7 @@ static void AssertInnerizedEnvironmentCh
 }
 
 static bool IsEvalCacheCandidate(JSScript* script) {
-  if (!script->isDirectEvalInFunction()) {
+  if (!script->isDirectEvalInFunction()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -253,7 +253,7 @@ static bool EvalKernel(JSContext* cx, Ha
       cx->global() == &env->as<GlobalLexicalEnvironmentObject>().global());
 
   RootedLinearString linearStr(cx, str->ensureLinear(cx));
-  if (!linearStr) {
+  if (!linearStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -318,7 +318,7 @@ static bool EvalKernel(JSContext* cx, Ha
         enclosing->hasOnChain(ScopeKind::NonSyntactic));
 
     AutoStableStringChars linearChars(cx);
-    if (!linearChars.initTwoByte(cx, linearStr)) {
+    if (!linearChars.initTwoByte(cx, linearStr)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -328,7 +328,7 @@ static bool EvalKernel(JSContext* cx, Ha
     SourceOwnership ownership = linearChars.maybeGiveOwnershipToCaller()
                                     ? SourceOwnership::TakeOwnership
                                     : SourceOwnership::Borrowed;
-    if (!srcBuf.init(cx, chars, linearStr->length(), ownership)) {
+    if (!srcBuf.init(cx, chars, linearStr->length(), ownership)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -405,17 +405,17 @@ JS_FRIEND_API bool js::ExecuteInFrameScr
     JSContext* cx, HandleObject objArg, HandleScript scriptArg,
     MutableHandleObject envArg) {
   RootedObject varEnv(cx, NonSyntacticVariablesObject::create(cx));
-  if (!varEnv) {
+  if (!varEnv) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObjectVector envChain(cx);
-  if (!envChain.append(objArg)) {
+  if (!envChain.append(objArg)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject env(cx);
-  if (!js::CreateObjectsForEnvironmentChain(cx, envChain, varEnv, &env)) {
+  if (!js::CreateObjectsForEnvironmentChain(cx, envChain, varEnv, &env)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -428,7 +428,7 @@ JS_FRIEND_API bool js::ExecuteInFrameScr
   Rooted<NonSyntacticLexicalEnvironmentObject*> lexicalEnv(
       cx,
       realm.getOrCreateNonSyntacticLexicalEnvironment(cx, env, varEnv, objArg));
-  if (!lexicalEnv) {
+  if (!lexicalEnv) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -442,7 +442,7 @@ JS_FRIEND_API bool js::ExecuteInFrameScr
 
 JS_FRIEND_API JSObject* JS::NewJSMEnvironment(JSContext* cx) {
   RootedObject varEnv(cx, NonSyntacticVariablesObject::create(cx));
-  if (!varEnv) {
+  if (!varEnv) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -490,12 +490,12 @@ JS_FRIEND_API bool JS::ExecuteInJSMEnvir
 
     // Wrap the target objects in WithEnvironments.
     RootedObject envChain(cx);
-    if (!js::CreateObjectsForEnvironmentChain(cx, targetObj, env, &envChain)) {
+    if (!js::CreateObjectsForEnvironmentChain(cx, targetObj, env, &envChain)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // See CreateNonSyntacticEnvironmentChain
-    if (!JSObject::setQualifiedVarObj(cx, envChain)) {
+    if (!JSObject::setQualifiedVarObj(cx, envChain)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -512,7 +512,7 @@ JS_FRIEND_API bool JS::ExecuteInJSMEnvir
 
 JS_FRIEND_API JSObject* JS::GetJSMEnvironmentOfScriptedCaller(JSContext* cx) {
   FrameIter iter(cx);
-  if (iter.done()) {
+  if (iter.done()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/builtin/FinalizationRegistryObject.cpp b/js/src/builtin/FinalizationRegistryObject.cpp
--- a/js/src/builtin/FinalizationRegistryObject.cpp
+++ b/js/src/builtin/FinalizationRegistryObject.cpp
@@ -94,7 +94,7 @@ const JSClassOps FinalizationRegistratio
 FinalizationRegistrationsObject* FinalizationRegistrationsObject::create(
     JSContext* cx) {
   auto records = cx->make_unique<WeakFinalizationRecordVector>(cx->zone());
-  if (!records) {
+  if (!records) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -242,19 +242,19 @@ bool FinalizationRegistryObject::constru
 
   Rooted<UniquePtr<ObjectWeakMap>> registrations(
       cx, cx->make_unique<ObjectWeakMap>(cx));
-  if (!registrations) {
+  if (!registrations) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedFinalizationQueueObject queue(
       cx, FinalizationQueueObject::create(cx, cleanupCallback));
-  if (!queue) {
+  if (!queue) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedFinalizationRegistryObject registry(
       cx, NewObjectWithClassProto<FinalizationRegistryObject>(cx, proto));
-  if (!registry) {
+  if (!registry) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -387,13 +387,13 @@ bool FinalizationRegistryObject::registe
   Rooted<FinalizationQueueObject*> queue(cx, registry->queue());
   Rooted<FinalizationRecordObject*> record(
       cx, FinalizationRecordObject::create(cx, queue, heldValue));
-  if (!record) {
+  if (!record) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Add the record to the registrations if an unregister token was supplied.
   if (unregisterToken &&
-      !addRegistration(cx, registry, unregisterToken, record)) {
+      !addRegistration(cx, registry, unregisterToken, record)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -406,20 +406,20 @@ bool FinalizationRegistryObject::registe
   // Fully unwrap the target to pass it to the GC.
   RootedObject unwrappedTarget(cx);
   unwrappedTarget = CheckedUnwrapDynamic(target, cx);
-  if (!unwrappedTarget) {
+  if (!unwrappedTarget) {MOZ_RELEASE_ASSERT(0);
     ReportAccessDenied(cx);
     return false;
   }
 
   // If the target is a DOM wrapper, preserve it.
-  if (!preserveDOMWrapper(cx, target)) {
+  if (!preserveDOMWrapper(cx, target)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Wrap the record into the compartment of the target.
   RootedObject wrappedRecord(cx, record);
   AutoRealm ar(cx, unwrappedTarget);
-  if (!JS_WrapObject(cx, &wrappedRecord)) {
+  if (!JS_WrapObject(cx, &wrappedRecord)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -469,7 +469,7 @@ bool FinalizationRegistryObject::addRegi
     recordsObject = &obj->as<FinalizationRegistrationsObject>();
   } else {
     recordsObject = FinalizationRegistrationsObject::create(cx);
-    if (!recordsObject || !map.add(cx, unregisterToken, recordsObject)) {
+    if (!recordsObject || !map.add(cx, unregisterToken, recordsObject)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -484,7 +484,7 @@ bool FinalizationRegistryObject::addRegi
 
 /* static */ void FinalizationRegistryObject::removeRegistrationOnError(
     HandleFinalizationRegistryObject registry, HandleObject unregisterToken,
-    HandleFinalizationRecordObject record) {
+    HandleFinalizationRecordObject record) {MOZ_RELEASE_ASSERT(0);
   // Remove a registration if something went wrong before we added it to the
   // target zone's map. Note that this can't remove a registration after that
   // point.
@@ -648,7 +648,7 @@ FinalizationQueueObject* FinalizationQue
 
   Rooted<UniquePtr<FinalizationRecordVector>> recordsToBeCleanedUp(
       cx, cx->make_unique<FinalizationRecordVector>(cx->zone()));
-  if (!recordsToBeCleanedUp) {
+  if (!recordsToBeCleanedUp) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -656,7 +656,7 @@ FinalizationQueueObject* FinalizationQue
   RootedFunction doCleanupFunction(
       cx, NewNativeFunction(cx, doCleanup, 0, funName,
                             gc::AllocKind::FUNCTION_EXTENDED));
-  if (!doCleanupFunction) {
+  if (!doCleanupFunction) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -665,7 +665,7 @@ FinalizationQueueObject* FinalizationQue
   // back. Instead store a CCW to a plain object in the same compartment as the
   // global (this uses Object.prototype).
   RootedObject incumbentObject(cx);
-  if (!GetObjectFromIncumbentGlobal(cx, &incumbentObject) || !incumbentObject) {
+  if (!GetObjectFromIncumbentGlobal(cx, &incumbentObject) || !incumbentObject) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/builtin/JSON.cpp b/js/src/builtin/JSON.cpp
--- a/js/src/builtin/JSON.cpp
+++ b/js/src/builtin/JSON.cpp
@@ -157,11 +157,11 @@ static size_t QuoteHelper(const JSLinear
 
 static bool Quote(JSContext* cx, StringBuffer& sb, JSString* str) {
   JSLinearString* linear = str->ensureLinear(cx);
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (linear->hasTwoByteChars() && !sb.ensureTwoByteChars()) {
+  if (linear->hasTwoByteChars() && !sb.ensureTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -173,12 +173,12 @@ static bool Quote(JSContext* cx, StringB
   size_t sbInitialLen = sb.length();
 
   CheckedInt<size_t> reservedLen = CheckedInt<size_t>(len) * 6 + 2;
-  if (MOZ_UNLIKELY(!reservedLen.isValid())) {
+  if (MOZ_UNLIKELY(!reservedLen.isValid())) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return false;
   }
 
-  if (!sb.growByUninitialized(reservedLen.value())) {
+  if (!sb.growByUninitialized(reservedLen.value())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -232,19 +232,19 @@ static bool Str(JSContext* cx, const Val
 
 static bool WriteIndent(StringifyContext* scx, uint32_t limit) {
   if (!scx->gap.empty()) {
-    if (!scx->sb.append('\n')) {
+    if (!scx->sb.append('\n')) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (scx->gap.isUnderlyingBufferLatin1()) {
       for (uint32_t i = 0; i < limit; i++) {
         if (!scx->sb.append(scx->gap.rawLatin1Begin(),
-                            scx->gap.rawLatin1End())) {
+                            scx->gap.rawLatin1End())) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
     } else {
-      for (uint32_t i = 0; i < limit; i++) {
+      for (uint32_t i = 0; i < limit; i++) {MOZ_RELEASE_ASSERT(0);
         if (!scx->sb.append(scx->gap.rawTwoByteBegin(),
                             scx->gap.rawTwoByteEnd())) {
           return false;
@@ -300,7 +300,7 @@ static bool PreprocessValue(JSContext* c
   if (vp.isObject() || vp.isBigInt()) {
     RootedValue toJSON(cx);
     RootedObject obj(cx, JS::ToObject(cx, vp));
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -310,7 +310,7 @@ static bool PreprocessValue(JSContext* c
 
     if (IsCallable(toJSON)) {
       keyStr = KeyStringifier<KeyType>::toString(cx, key);
-      if (!keyStr) {
+      if (!keyStr) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -328,7 +328,7 @@ static bool PreprocessValue(JSContext* c
 
     if (!keyStr) {
       keyStr = KeyStringifier<KeyType>::toString(cx, key);
-      if (!keyStr) {
+      if (!keyStr) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -345,7 +345,7 @@ static bool PreprocessValue(JSContext* c
     RootedObject obj(cx, &vp.get().toObject());
 
     ESClass cls;
-    if (!JS::GetBuiltinClass(cx, obj, &cls)) {
+    if (!JS::GetBuiltinClass(cx, obj, &cls)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -362,7 +362,7 @@ static bool PreprocessValue(JSContext* c
       }
       vp.setString(str);
     } else if (cls == ESClass::Boolean) {
-      if (!Unbox(cx, obj, vp)) {
+      if (!Unbox(cx, obj, vp)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (cls == ESClass::BigInt) {
@@ -437,7 +437,7 @@ static bool JO(JSContext* cx, HandleObje
     return false;
   }
 
-  if (!scx->sb.append('{')) {
+  if (!scx->sb.append('{')) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -467,7 +467,7 @@ static bool JO(JSContext* cx, HandleObje
   bool wroteMember = false;
   RootedId id(cx);
   for (size_t i = 0, len = propertyList.length(); i < len; i++) {
-    if (!CheckForInterrupt(cx)) {
+    if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -501,17 +501,17 @@ static bool JO(JSContext* cx, HandleObje
     }
 
     /* Output a comma unless this is the first member to write. */
-    if (wroteMember && !scx->sb.append(',')) {
+    if (wroteMember && !scx->sb.append(',')) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     wroteMember = true;
 
-    if (!WriteIndent(scx, scx->depth)) {
+    if (!WriteIndent(scx, scx->depth)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     JSString* s = IdToString(cx, id);
-    if (!s) {
+    if (!s) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -547,7 +547,7 @@ static bool JA(JSContext* cx, HandleObje
     return false;
   }
 
-  if (!scx->sb.append('[')) {
+  if (!scx->sb.append('[')) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -560,14 +560,14 @@ static bool JA(JSContext* cx, HandleObje
   /* Steps 7-10. */
   if (length != 0) {
     /* Steps 4, 10b(i). */
-    if (!WriteIndent(scx, scx->depth)) {
+    if (!WriteIndent(scx, scx->depth)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     /* Steps 7-10. */
     RootedValue outputValue(cx);
     for (uint32_t i = 0; i < length; i++) {
-      if (!CheckForInterrupt(cx)) {
+      if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -606,7 +606,7 @@ static bool JA(JSContext* cx, HandleObje
         return false;
       }
       if (IsFilteredValue(outputValue)) {
-        if (!scx->sb.append("null")) {
+        if (!scx->sb.append("null")) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
@@ -617,10 +617,10 @@ static bool JA(JSContext* cx, HandleObje
 
       /* Steps 3, 4, 10b(i). */
       if (i < length - 1) {
-        if (!scx->sb.append(',')) {
+        if (!scx->sb.append(',')) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
-        if (!WriteIndent(scx, scx->depth)) {
+        if (!WriteIndent(scx, scx->depth)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -639,7 +639,7 @@ static bool Str(JSContext* cx, const Val
   /* Step 11 must be handled by the caller. */
   MOZ_ASSERT(!IsFilteredValue(v));
 
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -763,7 +763,7 @@ bool js::Stringify(JSContext* cx, Mutabl
       /* Step 4b(iii)(5). */
       RootedValue item(cx);
       for (; k < len; k++) {
-        if (!CheckForInterrupt(cx)) {
+        if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -775,12 +775,12 @@ bool js::Stringify(JSContext* cx, Mutabl
         /* Step 4b(iii)(5)(c-g). */
         RootedId id(cx);
         if (item.isNumber() || item.isString()) {
-          if (!PrimitiveValueToId<CanGC>(cx, item, &id)) {
+          if (!PrimitiveValueToId<CanGC>(cx, item, &id)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         } else {
           ESClass cls;
-          if (!GetClassOfValue(cx, item, &cls)) {
+          if (!GetClassOfValue(cx, item, &cls)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
 
@@ -789,7 +789,7 @@ bool js::Stringify(JSContext* cx, Mutabl
           }
 
           JSAtom* atom = ToAtom<CanGC>(cx, item);
-          if (!atom) {
+          if (!atom) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
 
@@ -800,7 +800,7 @@ bool js::Stringify(JSContext* cx, Mutabl
         auto p = idSet.lookupForAdd(id);
         if (!p) {
           /* Step 4b(iii)(5)(g)(i). */
-          if (!idSet.add(p, id) || !propertyList.append(id)) {
+          if (!idSet.add(p, id) || !propertyList.append(id)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -815,7 +815,7 @@ bool js::Stringify(JSContext* cx, Mutabl
     RootedObject spaceObj(cx, &space.toObject());
 
     ESClass cls;
-    if (!JS::GetBuiltinClass(cx, spaceObj, &cls)) {
+    if (!JS::GetBuiltinClass(cx, spaceObj, &cls)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -841,17 +841,17 @@ bool js::Stringify(JSContext* cx, Mutabl
     double d;
     MOZ_ALWAYS_TRUE(ToInteger(cx, space, &d));
     d = std::min(10.0, d);
-    if (d >= 1 && !gap.appendN(' ', uint32_t(d))) {
+    if (d >= 1 && !gap.appendN(' ', uint32_t(d))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else if (space.isString()) {
     /* Step 7. */
     JSLinearString* str = space.toString()->ensureLinear(cx);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     size_t len = std::min(size_t(10), str->length());
-    if (!gap.appendSubstring(str, 0, len)) {
+    if (!gap.appendSubstring(str, 0, len)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -867,12 +867,12 @@ bool js::Stringify(JSContext* cx, Mutabl
 
     /* Step 9. */
     wrapper = NewBuiltinClassInstance<PlainObject>(cx);
-    if (!wrapper) {
+    if (!wrapper) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     /* Steps 10-11. */
-    if (!NativeDefineDataProperty(cx, wrapper, emptyId, vp, JSPROP_ENUMERATE)) {
+    if (!NativeDefineDataProperty(cx, wrapper, emptyId, vp, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -893,7 +893,7 @@ bool js::Stringify(JSContext* cx, Mutabl
 /* ES5 15.12.2 Walk. */
 static bool Walk(JSContext* cx, HandleObject holder, HandleId name,
                  HandleValue reviver, MutableHandleValue vp) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -923,11 +923,11 @@ static bool Walk(JSContext* cx, HandleOb
       RootedId id(cx);
       RootedValue newElement(cx);
       for (uint32_t i = 0; i < length; i++) {
-        if (!CheckForInterrupt(cx)) {
+        if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
-        if (!IndexToId(cx, i, &id)) {
+        if (!IndexToId(cx, i, &id)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -962,13 +962,13 @@ static bool Walk(JSContext* cx, HandleOb
       RootedId id(cx);
       RootedValue newElement(cx);
       for (size_t i = 0, len = keys.length(); i < len; i++) {
-        if (!CheckForInterrupt(cx)) {
+        if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         /* Step 2b(ii)(1). */
         id = keys[i];
-        if (!Walk(cx, obj, id, reviver, &newElement)) {
+        if (!Walk(cx, obj, id, reviver, &newElement)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -1002,7 +1002,7 @@ static bool Walk(JSContext* cx, HandleOb
 
 static bool Revive(JSContext* cx, HandleValue reviver, MutableHandleValue vp) {
   RootedPlainObject obj(cx, NewBuiltinClassInstance<PlainObject>(cx));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1058,7 +1058,7 @@ static bool json_parse(JSContext* cx, un
   }
 
   JSLinearString* linear = str->ensureLinear(cx);
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1096,7 +1096,7 @@ bool json_stringify(JSContext* cx, unsig
   // for the API, because we want to support streaming writers.
   if (!sb.empty()) {
     JSString* str = sb.finishString();
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     args.rval().setString(str);
diff --git a/js/src/builtin/MapObject.cpp b/js/src/builtin/MapObject.cpp
--- a/js/src/builtin/MapObject.cpp
+++ b/js/src/builtin/MapObject.cpp
@@ -35,7 +35,7 @@ bool HashableValue::setValue(JSContext* 
   if (v.isString()) {
     // Atomize so that hash() and operator==() are fast and infallible.
     JSString* str = AtomizeString(cx, v.toString(), DoNotPinAtom);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     value = StringValue(str);
@@ -174,12 +174,12 @@ bool GlobalObject::initMapIteratorProto(
                                         Handle<GlobalObject*> global) {
   Rooted<JSObject*> base(
       cx, GlobalObject::getOrCreateIteratorPrototype(cx, global));
-  if (!base) {
+  if (!base) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedPlainObject proto(
       cx, GlobalObject::createBlankPrototypeInheriting<PlainObject>(cx, base));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!JS_DefineFunctions(cx, proto, MapIteratorObject::methods) ||
@@ -207,13 +207,13 @@ MapIteratorObject* MapIteratorObject::cr
   Rooted<GlobalObject*> global(cx, &mapobj->global());
   Rooted<JSObject*> proto(
       cx, GlobalObject::getOrCreateMapIteratorPrototype(cx, global));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   MapIteratorObject* iterobj =
       NewObjectWithGivenProto<MapIteratorObject>(cx, proto);
-  if (!iterobj) {
+  if (!iterobj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -227,14 +227,14 @@ MapIteratorObject* MapIteratorObject::cr
   if (!buffer) {
     // Retry with |iterobj| and |buffer| forcibly tenured.
     iterobj = NewTenuredObjectWithGivenProto<MapIteratorObject>(cx, proto);
-    if (!iterobj) {
+    if (!iterobj) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     iterobj->init(mapobj, kind);
 
     buffer = nursery.allocateBufferSameLocation(iterobj, BufferSize);
-    if (!buffer) {
+    if (!buffer) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return nullptr;
     }
@@ -281,7 +281,7 @@ size_t MapIteratorObject::objectMoved(JS
   }
 
   Nursery& nursery = iter->runtimeFromMainThread()->gc.nursery();
-  if (!nursery.isInside(range)) {
+  if (!nursery.isInside(range)) {MOZ_RELEASE_ASSERT(0);
     nursery.removeMallocedBufferDuringMinorGC(range);
     return 0;
   }
@@ -578,7 +578,7 @@ template <typename ObjectT>
 bool MapObject::getKeysAndValuesInterleaved(
     HandleObject obj, JS::MutableHandle<GCVector<JS::Value>> entries) {
   ValueMap* map = obj->as<MapObject>().getData();
-  if (!map) {
+  if (!map) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -595,12 +595,12 @@ bool MapObject::getKeysAndValuesInterlea
 bool MapObject::set(JSContext* cx, HandleObject obj, HandleValue k,
                     HandleValue v) {
   ValueMap* map = obj->as<MapObject>().getData();
-  if (!map) {
+  if (!map) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Rooted<HashableValue> key(cx);
-  if (!key.setValue(cx, k)) {
+  if (!key.setValue(cx, k)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -617,17 +617,17 @@ MapObject* MapObject::create(JSContext* 
                              HandleObject proto /* = nullptr */) {
   auto map = cx->make_unique<ValueMap>(cx->zone(),
                                        cx->realm()->randomHashCodeScrambler());
-  if (!map) {
+  if (!map) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!map->init()) {
+  if (!map->init()) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
 
   MapObject* mapObj = NewObjectWithClassProto<MapObject>(cx, proto);
-  if (!mapObj) {
+  if (!mapObj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -681,7 +681,7 @@ bool MapObject::construct(JSContext* cx,
   }
 
   Rooted<MapObject*> obj(cx, MapObject::create(cx, proto));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -747,7 +747,7 @@ bool MapObject::get(JSContext* cx, Handl
   ValueMap& map = extract(obj);
   Rooted<HashableValue> k(cx);
 
-  if (!k.setValue(cx, key)) {
+  if (!k.setValue(cx, key)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -820,11 +820,11 @@ bool MapObject::set(JSContext* cx, unsig
 }
 
 bool MapObject::delete_(JSContext* cx, HandleObject obj, HandleValue key,
-                        bool* rval) {
+                        bool* rval) {MOZ_RELEASE_ASSERT(0);
   ValueMap& map = extract(obj);
   Rooted<HashableValue> k(cx);
 
-  if (!k.setValue(cx, key)) {
+  if (!k.setValue(cx, key)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -978,12 +978,12 @@ bool GlobalObject::initSetIteratorProto(
                                         Handle<GlobalObject*> global) {
   Rooted<JSObject*> base(
       cx, GlobalObject::getOrCreateIteratorPrototype(cx, global));
-  if (!base) {
+  if (!base) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedPlainObject proto(
       cx, GlobalObject::createBlankPrototypeInheriting<PlainObject>(cx, base));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!JS_DefineFunctions(cx, proto, SetIteratorObject::methods) ||
@@ -1003,13 +1003,13 @@ SetIteratorObject* SetIteratorObject::cr
   Rooted<GlobalObject*> global(cx, &setobj->global());
   Rooted<JSObject*> proto(
       cx, GlobalObject::getOrCreateSetIteratorPrototype(cx, global));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   SetIteratorObject* iterobj =
       NewObjectWithGivenProto<SetIteratorObject>(cx, proto);
-  if (!iterobj) {
+  if (!iterobj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1023,14 +1023,14 @@ SetIteratorObject* SetIteratorObject::cr
   if (!buffer) {
     // Retry with |iterobj| and |buffer| forcibly tenured.
     iterobj = NewTenuredObjectWithGivenProto<SetIteratorObject>(cx, proto);
-    if (!iterobj) {
+    if (!iterobj) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     iterobj->init(setobj, kind);
 
     buffer = nursery.allocateBufferSameLocation(iterobj, BufferSize);
-    if (!buffer) {
+    if (!buffer) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return nullptr;
     }
@@ -1077,7 +1077,7 @@ size_t SetIteratorObject::objectMoved(JS
   }
 
   Nursery& nursery = iter->runtimeFromMainThread()->gc.nursery();
-  if (!nursery.isInside(range)) {
+  if (!nursery.isInside(range)) {MOZ_RELEASE_ASSERT(0);
     nursery.removeMallocedBufferDuringMinorGC(range);
     return 0;
   }
@@ -1207,7 +1207,7 @@ const JSPropertySpec SetObject::staticPr
 
   RootedValue valuesFn(cx);
   RootedId valuesId(cx, NameToId(cx->names().values));
-  if (!NativeGetProperty(cx, nativeProto, valuesId, &valuesFn)) {
+  if (!NativeGetProperty(cx, nativeProto, valuesId, &valuesFn)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1229,7 +1229,7 @@ const JSPropertySpec SetObject::staticPr
 bool SetObject::keys(JSContext* cx, HandleObject obj,
                      JS::MutableHandle<GCVector<JS::Value>> keys) {
   ValueSet* set = obj->as<SetObject>().getData();
-  if (!set) {
+  if (!set) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1244,12 +1244,12 @@ bool SetObject::keys(JSContext* cx, Hand
 
 bool SetObject::add(JSContext* cx, HandleObject obj, HandleValue k) {
   ValueSet* set = obj->as<SetObject>().getData();
-  if (!set) {
+  if (!set) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Rooted<HashableValue> key(cx);
-  if (!key.setValue(cx, k)) {
+  if (!key.setValue(cx, k)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1264,17 +1264,17 @@ SetObject* SetObject::create(JSContext* 
                              HandleObject proto /* = nullptr */) {
   auto set = cx->make_unique<ValueSet>(cx->zone(),
                                        cx->realm()->randomHashCodeScrambler());
-  if (!set) {
+  if (!set) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!set->init()) {
+  if (!set->init()) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
 
   SetObject* obj = NewObjectWithClassProto<SetObject>(cx, proto);
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1341,7 +1341,7 @@ bool SetObject::construct(JSContext* cx,
   }
 
   Rooted<SetObject*> obj(cx, SetObject::create(cx, proto));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1349,7 +1349,7 @@ bool SetObject::construct(JSContext* cx,
     RootedValue iterable(cx, args[0]);
     bool optimized = false;
     if (!IsOptimizableInitForSet<GlobalObject::getOrCreateSetPrototype,
-                                 isBuiltinAdd>(cx, obj, iterable, &optimized)) {
+                                 isBuiltinAdd>(cx, obj, iterable, &optimized)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1363,10 +1363,10 @@ bool SetObject::construct(JSContext* cx,
         keyVal.set(array->getDenseElement(index));
         MOZ_ASSERT(!keyVal.isMagic(JS_ELEMENTS_HOLE));
 
-        if (!key.setValue(cx, keyVal)) {
+        if (!key.setValue(cx, keyVal)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
-        if (!PostWriteBarrier(obj, key.value()) || !set->put(key)) {
+        if (!PostWriteBarrier(obj, key.value()) || !set->put(key)) {MOZ_RELEASE_ASSERT(0);
           ReportOutOfMemory(cx);
           return false;
         }
@@ -1440,7 +1440,7 @@ bool SetObject::has_impl(JSContext* cx, 
 }
 
 bool SetObject::has(JSContext* cx, HandleObject obj, HandleValue key,
-                    bool* rval) {
+                    bool* rval) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(SetObject::is(obj));
 
   ValueSet& set = extract(obj);
@@ -1486,7 +1486,7 @@ bool SetObject::delete_(JSContext* cx, H
   ValueSet& set = extract(obj);
   Rooted<HashableValue> k(cx);
 
-  if (!k.setValue(cx, key)) {
+  if (!k.setValue(cx, key)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1559,7 +1559,7 @@ bool SetObject::entries(JSContext* cx, u
   return CallNonGenericMethod(cx, is, entries_impl, args);
 }
 
-bool SetObject::clear(JSContext* cx, HandleObject obj) {
+bool SetObject::clear(JSContext* cx, HandleObject obj) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(SetObject::is(obj));
   ValueSet& set = extract(obj);
   if (!set.clear()) {
@@ -1657,7 +1657,7 @@ bool CallObjFunc(bool (*ObjFunc)(JSConte
     // Retrieve the iterator while in the unwrapped map/set's compartment,
     // otherwise we'll crash on a compartment assert.
     JSAutoRealm ar(cx, unwrappedObj);
-    if (!ObjFunc(cx, iterType, unwrappedObj, rval)) {
+    if (!ObjFunc(cx, iterType, unwrappedObj, rval)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1697,11 +1697,11 @@ JS_PUBLIC_API bool JS::MapGet(JSContext*
 
     // If we passed in a wrapper, wrap our key into its compartment now.
     if (obj != unwrappedObj) {
-      if (!JS_WrapValue(cx, &wrappedKey)) {
+      if (!JS_WrapValue(cx, &wrappedKey)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
-    if (!MapObject::get(cx, unwrappedObj, wrappedKey, rval)) {
+    if (!MapObject::get(cx, unwrappedObj, wrappedKey, rval)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1783,7 +1783,7 @@ JS_PUBLIC_API uint32_t JS::SetSize(JSCon
 }
 
 JS_PUBLIC_API bool JS::SetAdd(JSContext* cx, HandleObject obj,
-                              HandleValue key) {
+                              HandleValue key) {MOZ_RELEASE_ASSERT(0);
   CHECK_THREAD(cx);
   cx->check(obj, key);
 
@@ -1791,12 +1791,12 @@ JS_PUBLIC_API bool JS::SetAdd(JSContext*
   // this is essentially a noop.
   RootedObject unwrappedObj(cx);
   unwrappedObj = UncheckedUnwrap(obj);
-  {
+  {MOZ_RELEASE_ASSERT(0);
     JSAutoRealm ar(cx, unwrappedObj);
 
     // If we passed in a wrapper, wrap key before adding to the set
     RootedValue wrappedKey(cx, key);
-    if (obj != unwrappedObj) {
+    if (obj != unwrappedObj) {MOZ_RELEASE_ASSERT(0);
       if (!JS_WrapValue(cx, &wrappedKey)) {
         return false;
       }
diff --git a/js/src/builtin/ModuleObject.cpp b/js/src/builtin/ModuleObject.cpp
--- a/js/src/builtin/ModuleObject.cpp
+++ b/js/src/builtin/ModuleObject.cpp
@@ -126,7 +126,7 @@ bool GlobalObject::initImportEntryProto(
 
   RootedObject proto(
       cx, GlobalObject::createBlankPrototype<PlainObject>(cx, global));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -144,7 +144,7 @@ ImportEntryObject* ImportEntryObject::cr
     HandleAtom localName, uint32_t lineNumber, uint32_t columnNumber) {
   RootedObject proto(
       cx, GlobalObject::getOrCreateImportEntryPrototype(cx, cx->global()));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -201,7 +201,7 @@ bool GlobalObject::initExportEntryProto(
 
   RootedObject proto(
       cx, GlobalObject::createBlankPrototype<PlainObject>(cx, global));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -223,7 +223,7 @@ ExportEntryObject* ExportEntryObject::cr
 
   RootedObject proto(
       cx, GlobalObject::getOrCreateExportEntryPrototype(cx, cx->global()));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -275,7 +275,7 @@ bool GlobalObject::initRequestedModulePr
 
   RootedObject proto(
       cx, GlobalObject::createBlankPrototype<PlainObject>(cx, global));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -294,7 +294,7 @@ RequestedModuleObject* RequestedModuleOb
                                                      uint32_t columnNumber) {
   RootedObject proto(
       cx, GlobalObject::getOrCreateRequestedModulePrototype(cx, cx->global()));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -525,15 +525,15 @@ static bool ValidatePropertyDescriptor(
     JSContext* cx, Handle<PropertyDescriptor> desc, bool expectedWritable,
     bool expectedEnumerable, bool expectedConfigurable,
     HandleValue expectedValue, ObjectOpResult& result) {
-  if (desc.isAccessorDescriptor()) {
+  if (desc.isAccessorDescriptor()) {MOZ_RELEASE_ASSERT(0);
     return result.fail(JSMSG_CANT_REDEFINE_PROP);
   }
 
-  if (desc.hasWritable() && desc.writable() != expectedWritable) {
+  if (desc.hasWritable() && desc.writable() != expectedWritable) {MOZ_RELEASE_ASSERT(0);
     return result.fail(JSMSG_CANT_REDEFINE_PROP);
   }
 
-  if (desc.hasEnumerable() && desc.enumerable() != expectedEnumerable) {
+  if (desc.hasEnumerable() && desc.enumerable() != expectedEnumerable) {MOZ_RELEASE_ASSERT(0);
     return result.fail(JSMSG_CANT_REDEFINE_PROP);
   }
 
@@ -543,7 +543,7 @@ static bool ValidatePropertyDescriptor(
 
   if (desc.hasValue()) {
     bool same;
-    if (!SameValue(cx, desc.value(), expectedValue, &same)) {
+    if (!SameValue(cx, desc.value(), expectedValue, &same)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!same) {
@@ -658,12 +658,12 @@ bool ModuleNamespaceObject::ProxyHandler
   RootedObject exports(cx, &ns->exports());
   uint32_t count;
   if (!GetLengthProperty(cx, exports, &count) ||
-      !props.reserve(props.length() + count + 1)) {
+      !props.reserve(props.length() + count + 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Rooted<ValueVector> names(cx, ValueVector(cx));
-  if (!names.resize(count) || !GetElements(cx, exports, count, names.begin())) {
+  if (!names.resize(count) || !GetElements(cx, exports, count, names.begin())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -757,17 +757,17 @@ static void InitFunctionDeclarations(
 ModuleObject* ModuleObject::create(JSContext* cx) {
   RootedObject proto(
       cx, GlobalObject::getOrCreateModulePrototype(cx, cx->global()));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedModuleObject self(cx, NewObjectWithGivenProto<ModuleObject>(cx, proto));
-  if (!self) {
+  if (!self) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   IndirectBindingMap* bindings = cx->new_<IndirectBindingMap>();
-  if (!bindings) {
+  if (!bindings) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -826,7 +826,7 @@ IndirectBindingMap& ModuleObject::import
       getReservedSlot(ImportBindingsSlot).toPrivate());
 }
 
-ModuleNamespaceObject* ModuleObject::namespace_() {
+ModuleNamespaceObject* ModuleObject::namespace_() {MOZ_RELEASE_ASSERT(0);
   Value value = getReservedSlot(NamespaceSlot);
   if (value.isUndefined()) {
     return nullptr;
@@ -1134,7 +1134,7 @@ bool ModuleObject::instantiateFunctionDe
   // |self| initially manages this vector.
   frontend::FunctionDeclarationVector* funDecls =
       GetFunctionDeclarations(self.get());
-  if (!funDecls) {
+  if (!funDecls) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(
         cx, "Module function declarations have already been instantiated");
     return false;
@@ -1149,7 +1149,7 @@ bool ModuleObject::instantiateFunctionDe
   for (GCThingIndex funIndex : *funDecls) {
     fun.set(self->script()->getFunction(funIndex));
     obj = Lambda(cx, fun, env);
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1204,7 +1204,7 @@ ModuleNamespaceObject* ModuleObject::cre
   MOZ_ASSERT(exports->is<ArrayObject>());
 
   auto bindings = cx->make_unique<IndirectBindingMap>();
-  if (!bindings) {
+  if (!bindings) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1324,7 +1324,7 @@ bool GlobalObject::initModuleProto(JSCon
 
   RootedObject proto(
       cx, GlobalObject::createBlankPrototype<PlainObject>(cx, global));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1373,7 +1373,7 @@ bool ModuleBuilder::buildTables(frontend
   metadata.requestedModules = std::move(requestedModules_);
 
   // Step 5.
-  if (!metadata.importEntries.reserve(importEntries_.count())) {
+  if (!metadata.importEntries.reserve(importEntries_.count())) {MOZ_RELEASE_ASSERT(0);
     js::ReportOutOfMemory(cx_);
     return false;
   }
@@ -1387,13 +1387,13 @@ bool ModuleBuilder::buildTables(frontend
     if (!exp.specifier) {
       frontend::StencilModuleEntry* importEntry = importEntryFor(exp.localName);
       if (!importEntry) {
-        if (!metadata.localExportEntries.append(exp)) {
+        if (!metadata.localExportEntries.append(exp)) {MOZ_RELEASE_ASSERT(0);
           js::ReportOutOfMemory(cx_);
           return false;
         }
       } else {
         if (!importEntry->importName) {
-          if (!metadata.localExportEntries.append(exp)) {
+          if (!metadata.localExportEntries.append(exp)) {MOZ_RELEASE_ASSERT(0);
             js::ReportOutOfMemory(cx_);
             return false;
           }
@@ -1402,14 +1402,14 @@ bool ModuleBuilder::buildTables(frontend
           auto entry = frontend::StencilModuleEntry::exportFromEntry(
               importEntry->specifier, importEntry->importName, exp.exportName,
               exp.lineno, exp.column);
-          if (!metadata.indirectExportEntries.append(entry)) {
+          if (!metadata.indirectExportEntries.append(entry)) {MOZ_RELEASE_ASSERT(0);
             js::ReportOutOfMemory(cx_);
             return false;
           }
         }
       }
     } else if (!exp.importName && !exp.exportName) {
-      if (!metadata.starExportEntries.append(exp)) {
+      if (!metadata.starExportEntries.append(exp)) {MOZ_RELEASE_ASSERT(0);
         js::ReportOutOfMemory(cx_);
         return false;
       }
@@ -1441,7 +1441,7 @@ static ArrayObject* ModuleBuilderInitArr
     const frontend::StencilModuleMetadata::EntryVector& vector) {
   RootedArrayObject resultArray(
       cx, NewDenseFullyAllocatedArray(cx, vector.length()));
-  if (!resultArray) {
+  if (!resultArray) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1520,7 +1520,7 @@ bool frontend::StencilModuleMetadata::in
       cx, ModuleBuilderInitArray(cx, atomCache,
                                  ModuleArrayType::RequestedModuleObject,
                                  requestedModules));
-  if (!requestedModulesObject) {
+  if (!requestedModulesObject) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1528,7 +1528,7 @@ bool frontend::StencilModuleMetadata::in
       cx,
       ModuleBuilderInitArray(cx, atomCache, ModuleArrayType::ImportEntryObject,
                              importEntries));
-  if (!importEntriesObject) {
+  if (!importEntriesObject) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1536,7 +1536,7 @@ bool frontend::StencilModuleMetadata::in
       cx,
       ModuleBuilderInitArray(cx, atomCache, ModuleArrayType::ExportEntryObject,
                              localExportEntries));
-  if (!localExportEntriesObject) {
+  if (!localExportEntriesObject) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1544,7 +1544,7 @@ bool frontend::StencilModuleMetadata::in
       cx,
       ModuleBuilderInitArray(cx, atomCache, ModuleArrayType::ExportEntryObject,
                              indirectExportEntries));
-  if (!indirectExportEntriesObject) {
+  if (!indirectExportEntriesObject) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1552,20 +1552,20 @@ bool frontend::StencilModuleMetadata::in
       cx,
       ModuleBuilderInitArray(cx, atomCache, ModuleArrayType::ExportEntryObject,
                              starExportEntries));
-  if (!starExportEntriesObject) {
+  if (!starExportEntriesObject) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Copy the vector of declarations to the ModuleObject.
   FunctionDeclarationVector functionDeclsCopy;
-  if (!functionDeclsCopy.appendAll(functionDecls)) {
+  if (!functionDeclsCopy.appendAll(functionDecls)) {MOZ_RELEASE_ASSERT(0);
     js::ReportOutOfMemory(cx);
     return false;
   }
   InitFunctionDeclarations(module.get(), std::move(functionDeclsCopy));
 
   Rooted<ListObject*> asyncParentModulesList(cx, ListObject::create(cx));
-  if (!asyncParentModulesList) {
+  if (!asyncParentModulesList) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1592,7 +1592,7 @@ bool ModuleBuilder::processImport(fronte
   MOZ_ASSERT(moduleSpec->isKind(ParseNodeKind::StringExpr));
 
   auto module = moduleSpec->atom();
-  if (!maybeAppendRequestedModule(module, moduleSpec)) {
+  if (!maybeAppendRequestedModule(module, moduleSpec)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1793,7 +1793,7 @@ bool ModuleBuilder::processExportObjectB
     if (node->isKind(ParseNodeKind::Spread)) {
       target = node->as<UnaryNode>().kid();
     } else {
-      if (node->isKind(ParseNodeKind::MutateProto)) {
+      if (node->isKind(ParseNodeKind::MutateProto)) {MOZ_RELEASE_ASSERT(0);
         target = node->as<UnaryNode>().kid();
       } else {
         target = node->as<BinaryNode>().right();
@@ -1825,7 +1825,7 @@ bool ModuleBuilder::processExportFrom(fr
 
   auto module = moduleSpec->atom();
 
-  if (!maybeAppendRequestedModule(module, moduleSpec)) {
+  if (!maybeAppendRequestedModule(module, moduleSpec)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1864,7 +1864,7 @@ bool ModuleBuilder::processExportFrom(fr
       entry = StencilModuleEntry::exportBatchFromEntry(module, line, column);
     }
 
-    if (!exportEntries_.append(entry)) {
+    if (!exportEntries_.append(entry)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (exportName && !exportNames_.put(exportName)) {
@@ -1905,7 +1905,7 @@ bool ModuleBuilder::appendExportEntry(
   markUsedByStencil(exportName);
   auto entry = frontend::StencilModuleEntry::exportAsEntry(
       localName, exportName, line, column);
-  if (!exportEntries_.append(entry)) {
+  if (!exportEntries_.append(entry)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1946,7 +1946,7 @@ ArrayObject* js::CreateArray(JSContext* 
                              const JS::Rooted<GCVector<T>>& vector) {
   uint32_t length = vector.length();
   RootedArrayObject array(cx, NewDenseFullyAllocatedArray(cx, length));
-  if (!array) {
+  if (!array) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1967,12 +1967,12 @@ JSObject* js::GetOrCreateModuleMetaObjec
 
   RootedObject metaObject(cx,
                           NewObjectWithGivenProto<PlainObject>(cx, nullptr));
-  if (!metaObject) {
+  if (!metaObject) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   JS::ModuleMetadataHook func = cx->runtime()->moduleMetadataHook;
-  if (!func) {
+  if (!func) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Module metadata hook not set");
     return nullptr;
   }
@@ -2072,14 +2072,14 @@ void js::AsyncModuleExecutionFulfilled(J
   }
 
   RootedArrayObject sortedList(cx);
-  if (!ModuleObject::GatherAsyncParentCompletions(cx, module, &sortedList)) {
+  if (!ModuleObject::GatherAsyncParentCompletions(cx, module, &sortedList)) {MOZ_RELEASE_ASSERT(0);
     // We have OOM'd -- all bets are off, reject the promise. Not much more we
     // can do.
     MOZ_ASSERT(cx->isExceptionPending());
     RootedValue exception(cx);
-    if (!cx->getPendingException(&exception)) {
+    if (!cx->getPendingException(&exception)) {MOZ_RELEASE_ASSERT(0);
       return;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     cx->clearPendingException();
     AsyncModuleExecutionRejected(cx, module, exception);
   }
@@ -2094,7 +2094,7 @@ void js::AsyncModuleExecutionFulfilled(J
   for (uint32_t i = 0; i < length; i++) {
     m = &sortedList->getDenseElement(i).toObject().as<ModuleObject>();
     // Step 2.
-    if (!m->isAsyncEvaluating()) {
+    if (!m->isAsyncEvaluating()) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(m->hadEvaluationError());
       return;
     }
@@ -2107,15 +2107,15 @@ void js::AsyncModuleExecutionFulfilled(J
       MOZ_ASSERT(m->isAsyncEvaluating());
       ModuleObject::execute(cx, m, &ignored);
     } else {
-      if (!ModuleObject::execute(cx, m, &ignored)) {
+      if (!ModuleObject::execute(cx, m, &ignored)) {MOZ_RELEASE_ASSERT(0);
         MOZ_ASSERT(cx->isExceptionPending());
         RootedValue exception(cx);
-        if (!cx->getPendingException(&exception)) {
+        if (!cx->getPendingException(&exception)) {MOZ_RELEASE_ASSERT(0);
           return;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         cx->clearPendingException();
         AsyncModuleExecutionRejected(cx, m, exception);
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         m->setAsyncEvaluatingFalse();
         if (m->hasTopLevelCapability()) {
           MOZ_ASSERT(m->getCycleRoot() == m);
@@ -2137,7 +2137,7 @@ void js::AsyncModuleExecutionRejected(JS
              module->status() == MODULE_STATUS_EVALUATED_ERROR);
 
   // Step 2.
-  if (!module->isAsyncEvaluating()) {
+  if (!module->isAsyncEvaluating()) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(module->hadEvaluationError());
     return;
   }
@@ -2188,12 +2188,12 @@ bool ModuleObject::topLevelCapabilityRej
 JSObject* js::StartDynamicModuleImport(JSContext* cx, HandleScript script,
                                        HandleValue specifierArg) {
   RootedObject promiseConstructor(cx, JS::GetPromiseConstructor(cx));
-  if (!promiseConstructor) {
+  if (!promiseConstructor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedObject promiseObject(cx, JS::NewPromiseObject(cx, nullptr));
-  if (!promiseObject) {
+  if (!promiseObject) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2208,7 +2208,7 @@ JSObject* js::StartDynamicModuleImport(J
     JS_ReportErrorASCII(
         cx,
         "Dynamic module import is disabled or not supported in this context");
-    if (!RejectPromiseWithPendingError(cx, promise)) {
+    if (!RejectPromiseWithPendingError(cx, promise)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     return promise;
@@ -2216,7 +2216,7 @@ JSObject* js::StartDynamicModuleImport(J
 
   RootedString specifier(cx, ToString(cx, specifierArg));
   if (!specifier) {
-    if (!RejectPromiseWithPendingError(cx, promise)) {
+    if (!RejectPromiseWithPendingError(cx, promise)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     return promise;
@@ -2254,7 +2254,7 @@ static bool OnRootModuleRejected(JSConte
 
 bool js::OnModuleEvaluationFailure(JSContext* cx,
                                    HandleObject evaluationPromise) {
-  if (evaluationPromise == nullptr) {
+  if (evaluationPromise == nullptr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2289,12 +2289,12 @@ static bool OnResolvedDynamicModule(JSCo
   RootedObject result(cx,
                       CallModuleResolveHook(cx, referencingPrivate, specifier));
 
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return RejectPromiseWithPendingError(cx, promise);
   }
 
   RootedModuleObject module(cx, &result->as<ModuleObject>());
-  if (module->status() != MODULE_STATUS_EVALUATED) {
+  if (module->status() != MODULE_STATUS_EVALUATED) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(
         cx, "Unevaluated or errored module returned by module resolve hook");
     return RejectPromiseWithPendingError(cx, promise);
@@ -2335,11 +2335,11 @@ bool FinishDynamicModuleImport_impl(JSCo
                                     HandleString specifier,
                                     HandleObject promiseArg) {
   Rooted<ListObject*> resolutionArgs(cx, ListObject::create(cx));
-  if (!resolutionArgs->append(cx, referencingPrivate)) {
+  if (!resolutionArgs->append(cx, referencingPrivate)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   Rooted<Value> stringValue(cx, StringValue(specifier));
-  if (!resolutionArgs->append(cx, stringValue)) {
+  if (!resolutionArgs->append(cx, stringValue)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2348,7 +2348,7 @@ bool FinishDynamicModuleImport_impl(JSCo
   RootedFunction onResolved(
       cx, NewHandlerWithExtraValue(cx, OnResolvedDynamicModule, promiseArg,
                                    resolutionArgsValue));
-  if (!onResolved) {
+  if (!onResolved) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2407,12 +2407,12 @@ bool js::FinishDynamicModuleImport_NoTLA
 
   RootedObject result(cx,
                       CallModuleResolveHook(cx, referencingPrivate, specifier));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return RejectPromiseWithPendingError(cx, promise);
   }
 
   RootedModuleObject module(cx, &result->as<ModuleObject>());
-  if (module->status() != MODULE_STATUS_EVALUATED) {
+  if (module->status() != MODULE_STATUS_EVALUATED) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(
         cx, "Unevaluated or errored module returned by module resolve hook");
     return RejectPromiseWithPendingError(cx, promise);
@@ -2470,10 +2470,10 @@ XDRResult js::XDRExportEntries(XDRState<
       expObj.set(ExportEntryObject::create(cx, exportName, moduleRequest,
                                            importName, localName, lineNumber,
                                            columnNumber));
-      if (!expObj) {
+      if (!expObj) {MOZ_RELEASE_ASSERT(0);
         return xdr->fail(JS::TranscodeResult::Throw);
       }
-      if (!expVec.append(expObj)) {
+      if (!expVec.append(expObj)) {MOZ_RELEASE_ASSERT(0);
         return xdr->fail(JS::TranscodeResult::Throw);
       }
     }
@@ -2599,7 +2599,7 @@ XDRResult js::XDRModuleObject(XDRState<m
   if (mode == XDR_DECODE) {
     enclosingScope.set(&cx->global()->emptyGlobalScope());
     module.set(ModuleObject::create(cx));
-    if (!module) {
+    if (!module) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Throw);
     }
   }
@@ -2614,7 +2614,7 @@ XDRResult js::XDRModuleObject(XDRState<m
 
   /* Environment Slot */
   if (mode == XDR_DECODE) {
-    if (!ModuleObject::createEnvironment(cx, module)) {
+    if (!ModuleObject::createEnvironment(cx, module)) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Throw);
     }
   }
@@ -2635,14 +2635,14 @@ XDRResult js::XDRModuleObject(XDRState<m
     }
     MOZ_TRY(XDRRequestedModuleObject(xdr, &reqObj));
     if (mode == XDR_DECODE) {
-      if (!reqVec.append(reqObj)) {
+      if (!reqVec.append(reqObj)) {MOZ_RELEASE_ASSERT(0);
         return xdr->fail(JS::TranscodeResult::Throw);
       }
     }
   }
   if (mode == XDR_DECODE) {
     RootedArrayObject reqArr(cx, js::CreateArray(cx, reqVec));
-    if (!reqArr) {
+    if (!reqArr) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Throw);
     }
     requestedModules.set(reqArr);
@@ -2661,7 +2661,7 @@ XDRResult js::XDRModuleObject(XDRState<m
     }
     MOZ_TRY(XDRImportEntryObject(xdr, &impObj));
     if (mode == XDR_DECODE) {
-      if (!impVec.append(impObj)) {
+      if (!impVec.append(impObj)) {MOZ_RELEASE_ASSERT(0);
         return xdr->fail(JS::TranscodeResult::Throw);
       }
     }
@@ -2669,7 +2669,7 @@ XDRResult js::XDRModuleObject(XDRState<m
 
   if (mode == XDR_DECODE) {
     RootedArrayObject impArr(cx, js::CreateArray(cx, impVec));
-    if (!impArr) {
+    if (!impArr) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Throw);
     }
     importEntries.set(impArr);
@@ -2693,7 +2693,7 @@ XDRResult js::XDRModuleObject(XDRState<m
     MOZ_TRY(xdr->codeUint32(&funIndex));
 
     if (mode == XDR_DECODE) {
-      if (!GetFunctionDeclarations(module.get())->append(funIndex)) {
+      if (!GetFunctionDeclarations(module.get())->append(funIndex)) {MOZ_RELEASE_ASSERT(0);
         ReportOutOfMemory(cx);
         return xdr->fail(JS::TranscodeResult::Throw);
       }
diff --git a/js/src/builtin/Object.cpp b/js/src/builtin/Object.cpp
--- a/js/src/builtin/Object.cpp
+++ b/js/src/builtin/Object.cpp
@@ -66,7 +66,7 @@ bool js::obj_construct(JSContext* cx, un
     }
   } else if (args.length() > 0 && !args[0].isNullOrUndefined()) {
     obj = ToObject(cx, args[0]);
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -145,12 +145,12 @@ bool js::obj_propertyIsEnumerable(JSCont
 static bool obj_toSource(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject obj(cx, ToObject(cx, args.thisv()));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -209,7 +209,7 @@ static bool ArgsAndBodySubstring(Range<c
   RangedPtr<const CharT> s = start;
   RangedPtr<const CharT> e = chars.end();
 
-  if (s == e) {
+  if (s == e) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -243,12 +243,12 @@ static bool ArgsAndBodySubstring(Range<c
 
   // Jump over the function's name.
   if (Consume(s, e, "[")) {
-    if (!ConsumeUntil(s, e, ']')) {
+    if (!ConsumeUntil(s, e, ']')) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     s++;  // Skip ']'.
     ConsumeSpaces(s, e);
-    if (s >= e || *s != '(') {
+    if (s >= e || *s != '(') {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -272,23 +272,23 @@ JSString* js::ObjectToSource(JSContext* 
   bool outermost = cx->cycleDetectorVector().empty();
 
   AutoCycleDetector detector(cx, obj);
-  if (!detector.init()) {
+  if (!detector.init()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
-  if (detector.foundCycle()) {
+  if (detector.foundCycle()) {MOZ_RELEASE_ASSERT(0);
     return NewStringCopyZ<CanGC>(cx, "{}");
   }
 
   JSStringBuilder buf(cx);
-  if (outermost && !buf.append('(')) {
+  if (outermost && !buf.append('(')) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
-  if (!buf.append('{')) {
+  if (!buf.append('{')) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedIdVector idv(cx);
-  if (!GetPropertyKeys(cx, obj, JSITER_OWNONLY | JSITER_SYMBOLS, &idv)) {
+  if (!GetPropertyKeys(cx, obj, JSITER_OWNONLY | JSITER_SYMBOLS, &idv)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -454,24 +454,24 @@ JSString* js::ObjectToSource(JSContext* 
   RootedValue val(cx);
   for (size_t i = 0; i < idv.length(); ++i) {
     id = idv[i];
-    if (!GetOwnPropertyDescriptor(cx, obj, id, &desc)) {
+    if (!GetOwnPropertyDescriptor(cx, obj, id, &desc)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (desc.isNothing()) {
+    if (desc.isNothing()) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
     if (desc->isAccessorDescriptor()) {
       if (desc->hasGetterObject() && desc->getterObject()) {
         val.setObject(*desc->getterObject());
-        if (!AddProperty(id, val, PropertyKind::Getter)) {
+        if (!AddProperty(id, val, PropertyKind::Getter)) {MOZ_RELEASE_ASSERT(0);
           return nullptr;
         }
       }
       if (desc->hasSetterObject() && desc->setterObject()) {
         val.setObject(*desc->setterObject());
-        if (!AddProperty(id, val, PropertyKind::Setter)) {
+        if (!AddProperty(id, val, PropertyKind::Setter)) {MOZ_RELEASE_ASSERT(0);
           return nullptr;
         }
       }
@@ -482,18 +482,18 @@ JSString* js::ObjectToSource(JSContext* 
 
     JSFunction* fun;
     if (IsFunctionObject(val, &fun) && fun->isMethod()) {
-      if (!AddProperty(id, val, PropertyKind::Method)) {
+      if (!AddProperty(id, val, PropertyKind::Method)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       continue;
     }
 
-    if (!AddProperty(id, val, PropertyKind::Normal)) {
+    if (!AddProperty(id, val, PropertyKind::Normal)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
 
-  if (!buf.append('}')) {
+  if (!buf.append('}')) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (outermost && !buf.append(')')) {
@@ -517,7 +517,7 @@ static JSString* GetBuiltinTagSlow(JSCon
 
   // Steps 6-14.
   ESClass cls;
-  if (!JS::GetBuiltinClass(cx, obj, &cls)) {
+  if (!JS::GetBuiltinClass(cx, obj, &cls)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -670,7 +670,7 @@ bool js::obj_toString(JSContext* cx, uns
 
     // Step 3.
     obj = ToObject(cx, args.thisv());
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -714,7 +714,7 @@ bool js::obj_toString(JSContext* cx, uns
 
   // Step 17.
   StringBuffer sb(cx);
-  if (!sb.append("[object ") || !sb.append(tag.toString()) || !sb.append(']')) {
+  if (!sb.append("[object ") || !sb.append(tag.toString()) || !sb.append(']')) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -898,7 +898,7 @@ static bool CanAddNewPropertyExcludingPr
     if (!propShape.enumerable()) {
       continue;
     }
-    if (MOZ_UNLIKELY(!shapes.append(&propShape))) {
+    if (MOZ_UNLIKELY(!shapes.append(&propShape))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -912,7 +912,7 @@ static bool CanAddNewPropertyExcludingPr
   if (toWasEmpty && !hasPropsWithNonDefaultAttrs &&
       toPlain->canReuseShapeForNewProperties(fromPlain->shape())) {
     Shape* newShape = fromPlain->shape();
-    if (!toPlain->setLastProperty(cx, newShape)) {
+    if (!toPlain->setLastProperty(cx, newShape)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     for (size_t i = shapes.length(); i > 0; i--) {
@@ -990,7 +990,7 @@ static bool TryAssignNative(JSContext* c
     if (MOZ_UNLIKELY(JSID_IS_SYMBOL(r.front().propidRaw()))) {
       return true;
     }
-    if (MOZ_UNLIKELY(!shapes.append(&r.front()))) {
+    if (MOZ_UNLIKELY(!shapes.append(&r.front()))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1017,7 +1017,7 @@ static bool TryAssignNative(JSContext* c
       // |from| changed shape or the property is not a data property, so
       // we have to do the slower enumerability check and GetProp.
       bool enumerable;
-      if (!PropertyIsEnumerable(cx, from, nextKey, &enumerable)) {
+      if (!PropertyIsEnumerable(cx, from, nextKey, &enumerable)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (!enumerable) {
@@ -1065,7 +1065,7 @@ static bool AssignSlow(JSContext* cx, Ha
     }
 
     // Step 4.c.ii.1.
-    if (MOZ_UNLIKELY(!GetProperty(cx, from, from, nextKey, &propValue))) {
+    if (MOZ_UNLIKELY(!GetProperty(cx, from, from, nextKey, &propValue))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1082,7 +1082,7 @@ JS_PUBLIC_API bool JS_AssignObject(JSCon
                                    JS::HandleObject src) {
   bool optimized = false;
 
-  if (!TryAssignPlain(cx, target, src, &optimized)) {
+  if (!TryAssignPlain(cx, target, src, &optimized)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (optimized) {
@@ -1123,7 +1123,7 @@ static bool obj_assign(JSContext* cx, un
 
     // Step 4.b.i.
     from = ToObject(cx, args[i]);
-    if (!from) {
+    if (!from) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1192,7 +1192,7 @@ static bool ObjectDefineProperties(JSCon
   // Step 3.
   RootedIdVector keys(cx);
   if (!GetPropertyKeys(
-          cx, props, JSITER_OWNONLY | JSITER_SYMBOLS | JSITER_HIDDEN, &keys)) {
+          cx, props, JSITER_OWNONLY | JSITER_SYMBOLS | JSITER_HIDDEN, &keys)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1211,7 +1211,7 @@ static bool ObjectDefineProperties(JSCon
     nextKey = keys[i];
 
     // Step 5.a.
-    if (!GetOwnPropertyDescriptor(cx, props, nextKey, &keyDesc)) {
+    if (!GetOwnPropertyDescriptor(cx, props, nextKey, &keyDesc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1250,14 +1250,14 @@ bool js::obj_create(JSContext* cx, unsig
   CallArgs args = CallArgsFromVp(argc, vp);
 
   // Step 1.
-  if (!args.requireAtLeast(cx, "Object.create", 1)) {
+  if (!args.requireAtLeast(cx, "Object.create", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (!args[0].isObjectOrNull()) {
     UniqueChars bytes =
         DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, args[0], nullptr);
-    if (!bytes) {
+    if (!bytes) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1270,7 +1270,7 @@ bool js::obj_create(JSContext* cx, unsig
   // Step 2.
   RootedObject proto(cx, args[0].toObjectOrNull());
   RootedPlainObject obj(cx, ObjectCreateImpl(cx, proto));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1325,7 +1325,7 @@ static bool FromPropertyDescriptorToArra
   RootedArrayObject result(cx);
   if (!desc->isAccessorDescriptor()) {
     result = NewDenseFullyAllocatedArray(cx, 2);
-    if (!result) {
+    if (!result) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     result->setDenseInitializedLength(2);
@@ -1335,7 +1335,7 @@ static bool FromPropertyDescriptorToArra
     result->initDenseElement(PROP_DESC_VALUE_INDEX, desc->value());
   } else {
     result = NewDenseFullyAllocatedArray(cx, 3);
-    if (!result) {
+    if (!result) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     result->setDenseInitializedLength(3);
@@ -1440,12 +1440,12 @@ static bool TryEnumerableOwnPropertiesNa
 
   // Resolve lazy properties on |nobj|.
   if (JSEnumerateOp enumerate = nobj->getClass()->getEnumerate()) {
-    if (!enumerate(cx, nobj)) {
+    if (!enumerate(cx, nobj)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // Ensure no extra indexed properties were added through enumerate().
-    if (nobj->isIndexed()) {
+    if (nobj->isIndexed()) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
   }
@@ -1471,7 +1471,7 @@ static bool TryEnumerableOwnPropertiesNa
       static_assert(NativeObject::MAX_DENSE_ELEMENTS_COUNT <= JSID_INT_MAX,
                     "dense elements don't exceed JSID_INT_MAX");
       str = Int32ToString<CanGC>(cx, i);
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1481,12 +1481,12 @@ static bool TryEnumerableOwnPropertiesNa
       value.setString(str);
     } else if (kind == EnumerableOwnPropertiesKind::KeysAndValues) {
       key.setString(str);
-      if (!NewValuePair(cx, key, value, &value)) {
+      if (!NewValuePair(cx, key, value, &value)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
 
-    if (!properties.append(value)) {
+    if (!properties.append(value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1505,7 +1505,7 @@ static bool TryEnumerableOwnPropertiesNa
     }
 
     MOZ_ASSERT(properties.empty(), "typed arrays cannot have dense elements");
-    if (!properties.resize(len)) {
+    if (!properties.resize(len)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1515,7 +1515,7 @@ static bool TryEnumerableOwnPropertiesNa
         static_assert(NativeObject::MAX_DENSE_ELEMENTS_COUNT <= JSID_INT_MAX,
                       "dense elements don't exceed JSID_INT_MAX");
         str = Int32ToString<CanGC>(cx, i);
-        if (!str) {
+        if (!str) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -1524,15 +1524,15 @@ static bool TryEnumerableOwnPropertiesNa
           kind == EnumerableOwnPropertiesKind::Names) {
         value.setString(str);
       } else if (kind == EnumerableOwnPropertiesKind::Values) {
-        if (!tobj->getElement<CanGC>(cx, i, &value)) {
+        if (!tobj->getElement<CanGC>(cx, i, &value)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
         key.setString(str);
-        if (!tobj->getElement<CanGC>(cx, i, &value)) {
+        if (!tobj->getElement<CanGC>(cx, i, &value)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
-        if (!NewValuePair(cx, key, value, &value)) {
+        if (!NewValuePair(cx, key, value, &value)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -1585,12 +1585,12 @@ static bool TryEnumerableOwnPropertiesNa
       } else {
         key.setString(JSID_TO_STRING(id));
         value.set(nobj->getSlot(shape->slot()));
-        if (!NewValuePair(cx, key, value, &value)) {
+        if (!NewValuePair(cx, key, value, &value)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
 
-      if (!properties.append(value)) {
+      if (!properties.append(value)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1612,12 +1612,12 @@ static bool TryEnumerableOwnPropertiesNa
     RootedShape objShape(cx, nobj->lastProperty());
     for (Shape::Range<NoGC> r(objShape); !r.empty(); r.popFront()) {
       Shape* shape = &r.front();
-      if (JSID_IS_SYMBOL(shape->propid())) {
+      if (JSID_IS_SYMBOL(shape->propid())) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
       MOZ_ASSERT(!JSID_IS_INT(shape->propid()), "Unexpected indexed property");
 
-      if (!shapes.append(shape)) {
+      if (!shapes.append(shape)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1630,7 +1630,7 @@ static bool TryEnumerableOwnPropertiesNa
       // If |obj| still has the same shape, it must still be a NativeObject with
       // the properties in |shapes|.
       if (obj->shape() == objShape && shape->isDataProperty()) {
-        if (!shape->enumerable()) {
+        if (!shape->enumerable()) {MOZ_RELEASE_ASSERT(0);
           continue;
         }
         value = obj->as<NativeObject>().getSlot(shape->slot());
@@ -1639,7 +1639,7 @@ static bool TryEnumerableOwnPropertiesNa
         // so we have to do the slower enumerability check and
         // GetProperty.
         bool enumerable;
-        if (!PropertyIsEnumerable(cx, obj, id, &enumerable)) {
+        if (!PropertyIsEnumerable(cx, obj, id, &enumerable)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         if (!enumerable) {
@@ -1652,12 +1652,12 @@ static bool TryEnumerableOwnPropertiesNa
 
       if (kind == EnumerableOwnPropertiesKind::KeysAndValues) {
         key.setString(JSID_TO_STRING(id));
-        if (!NewValuePair(cx, key, value, &value)) {
+        if (!NewValuePair(cx, key, value, &value)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
 
-      if (!properties.append(value)) {
+      if (!properties.append(value)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1701,14 +1701,14 @@ static bool EnumerableOwnProperties(JSCo
 
   // Step 2.
   RootedIdVector ids(cx);
-  if (!GetPropertyKeys(cx, obj, JSITER_OWNONLY | JSITER_HIDDEN, &ids)) {
+  if (!GetPropertyKeys(cx, obj, JSITER_OWNONLY | JSITER_HIDDEN, &ids)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Step 3.
   RootedValueVector properties(cx);
   size_t len = ids.length();
-  if (!properties.resize(len)) {
+  if (!properties.resize(len)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1726,7 +1726,7 @@ static bool EnumerableOwnProperties(JSCo
     MOZ_ASSERT(!JSID_IS_SYMBOL(id));
 
     if (kind != EnumerableOwnPropertiesKind::Values) {
-      if (!IdToStringOrSymbol(cx, id, &key)) {
+      if (!IdToStringOrSymbol(cx, id, &key)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1742,15 +1742,15 @@ static bool EnumerableOwnProperties(JSCo
           continue;
         }
         if (shape->isDataProperty()) {
-          if (!NativeGetExistingProperty(cx, nobj, nobj, shape, &value)) {
+          if (!NativeGetExistingProperty(cx, nobj, nobj, shape, &value)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
-        } else if (!GetProperty(cx, obj, obj, id, &value)) {
+        } else if (!GetProperty(cx, obj, obj, id, &value)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
     } else {
-      if (!GetOwnPropertyDescriptor(cx, obj, id, &desc)) {
+      if (!GetOwnPropertyDescriptor(cx, obj, id, &desc)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -1763,7 +1763,7 @@ static bool EnumerableOwnProperties(JSCo
       // (Omitted because Object.keys doesn't use this implementation.)
 
       // Step 4.a.ii.2.a.
-      if (!GetProperty(cx, obj, obj, id, &value)) {
+      if (!GetProperty(cx, obj, obj, id, &value)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1771,7 +1771,7 @@ static bool EnumerableOwnProperties(JSCo
     // Steps 4.a.ii.2.b-c.
     if (kind == EnumerableOwnPropertiesKind::Values) {
       properties[out++].set(value);
-    } else if (!NewValuePair(cx, key, value, properties[out++])) {
+    } else if (!NewValuePair(cx, key, value, properties[out++])) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1804,7 +1804,7 @@ static bool obj_keys(JSContext* cx, unsi
   static constexpr EnumerableOwnPropertiesKind kind =
       EnumerableOwnPropertiesKind::Keys;
   if (!TryEnumerableOwnPropertiesNative<kind>(cx, obj, args.rval(),
-                                              &optimized)) {
+                                              &optimized)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (optimized) {
@@ -1851,7 +1851,7 @@ bool js::IdToStringOrSymbol(JSContext* c
                             MutableHandleValue result) {
   if (JSID_IS_INT(id)) {
     JSString* str = Int32ToString<CanGC>(cx, JSID_TO_INT(id));
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     result.setString(str);
@@ -1877,7 +1877,7 @@ bool js::GetOwnPropertyKeys(JSContext* c
 
   // Step 5 (Inlined CreateArrayFromList).
   RootedArrayObject array(cx, NewDenseFullyAllocatedArray(cx, keys.length()));
-  if (!array) {
+  if (!array) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1949,7 +1949,7 @@ static bool obj_defineProperties(JSConte
   }
 
   /* Step 2. */
-  if (!args.requireAtLeast(cx, "Object.defineProperties", 2)) {
+  if (!args.requireAtLeast(cx, "Object.defineProperties", 2)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2128,7 +2128,7 @@ static const JSFunctionSpec object_stati
 
 static JSObject* CreateObjectConstructor(JSContext* cx, JSProtoKey key) {
   Rooted<GlobalObject*> self(cx, cx->global());
-  if (!GlobalObject::ensureConstructor(cx, self, JSProto_Function)) {
+  if (!GlobalObject::ensureConstructor(cx, self, JSProto_Function)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2154,7 +2154,7 @@ static JSObject* CreateObjectPrototype(J
    */
   RootedPlainObject objectProto(
       cx, NewTenuredObjectWithGivenProto<PlainObject>(cx, nullptr));
-  if (!objectProto) {
+  if (!objectProto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2177,7 +2177,7 @@ static bool FinishObjectClassInit(JSCont
   RootedId evalId(cx, NameToId(cx->names().eval));
   JSObject* evalobj =
       DefineFunction(cx, global, evalId, IndirectEval, 1, JSPROP_RESOLVING);
-  if (!evalobj) {
+  if (!evalobj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   global->setOriginalEval(evalobj);
@@ -2193,7 +2193,7 @@ static bool FinishObjectClassInit(JSCont
 
   Rooted<NativeObject*> holder(cx,
                                GlobalObject::getIntrinsicsHolder(cx, global));
-  if (!holder) {
+  if (!holder) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/builtin/Profilers.cpp b/js/src/builtin/Profilers.cpp
--- a/js/src/builtin/Profilers.cpp
+++ b/js/src/builtin/Profilers.cpp
@@ -73,7 +73,7 @@ static bool StartOSXProfiling(const char
 }
 #endif
 
-JS_PUBLIC_API bool JS_StartProfiling(const char* profileName, pid_t pid) {
+JS_PUBLIC_API bool JS_StartProfiling(const char* profileName, pid_t pid) {MOZ_RELEASE_ASSERT(0);
   bool ok = true;
 #ifdef __APPLE__
   ok = StartOSXProfiling(profileName, pid);
@@ -86,7 +86,7 @@ JS_PUBLIC_API bool JS_StartProfiling(con
   return ok;
 }
 
-JS_PUBLIC_API bool JS_StopProfiling(const char* profileName) {
+JS_PUBLIC_API bool JS_StopProfiling(const char* profileName) {MOZ_RELEASE_ASSERT(0);
   bool ok = true;
 #ifdef __APPLE__
 #  ifdef MOZ_INSTRUMENTS
@@ -105,10 +105,10 @@ JS_PUBLIC_API bool JS_StopProfiling(cons
  * Start or stop whatever platform- and configuration-specific profiling
  * backends are available.
  */
-static bool ControlProfilers(bool toState) {
+static bool ControlProfilers(bool toState) {MOZ_RELEASE_ASSERT(0);
   bool ok = true;
 
-  if (!probes::ProfilingActive && toState) {
+  if (!probes::ProfilingActive && toState) {MOZ_RELEASE_ASSERT(0);
 #ifdef __APPLE__
 #  if defined(MOZ_INSTRUMENTS)
     const char* profiler;
@@ -127,7 +127,7 @@ static bool ControlProfilers(bool toStat
       ok = false;
     }
 #endif
-  } else if (probes::ProfilingActive && !toState) {
+  } else if (probes::ProfilingActive && !toState) {MOZ_RELEASE_ASSERT(0);
 #ifdef __APPLE__
 #  ifdef MOZ_INSTRUMENTS
     Instruments::Pause();
@@ -175,7 +175,7 @@ JS_PUBLIC_API bool JS_DumpProfile(const 
 
 static UniqueChars RequiredStringArg(JSContext* cx, const CallArgs& args,
                                      size_t argi, const char* caller) {
-  if (args.length() <= argi) {
+  if (args.length() <= argi) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "%s: not enough arguments", caller);
     return nullptr;
   }
@@ -188,19 +188,19 @@ static UniqueChars RequiredStringArg(JSC
   return JS_EncodeStringToLatin1(cx, args[argi].toString());
 }
 
-static bool StartProfiling(JSContext* cx, unsigned argc, Value* vp) {
+static bool StartProfiling(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (args.length() == 0) {
+  if (args.length() == 0) {MOZ_RELEASE_ASSERT(0);
     args.rval().setBoolean(JS_StartProfiling(nullptr, getpid()));
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   UniqueChars profileName = RequiredStringArg(cx, args, 0, "startProfiling");
-  if (!profileName) {
+  if (!profileName) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (args.length() == 1) {
+  if (args.length() == 1) {MOZ_RELEASE_ASSERT(0);
     args.rval().setBoolean(JS_StartProfiling(profileName.get(), getpid()));
     return true;
   }
@@ -214,12 +214,12 @@ static bool StartProfiling(JSContext* cx
   return true;
 }
 
-static bool StopProfiling(JSContext* cx, unsigned argc, Value* vp) {
+static bool StopProfiling(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (args.length() == 0) {
+  if (args.length() == 0) {MOZ_RELEASE_ASSERT(0);
     args.rval().setBoolean(JS_StopProfiling(nullptr));
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   UniqueChars profileName = RequiredStringArg(cx, args, 0, "stopProfiling");
   if (!profileName) {
@@ -229,12 +229,12 @@ static bool StopProfiling(JSContext* cx,
   return true;
 }
 
-static bool PauseProfilers(JSContext* cx, unsigned argc, Value* vp) {
+static bool PauseProfilers(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (args.length() == 0) {
+  if (args.length() == 0) {MOZ_RELEASE_ASSERT(0);
     args.rval().setBoolean(JS_PauseProfilers(nullptr));
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   UniqueChars profileName = RequiredStringArg(cx, args, 0, "pauseProfiling");
   if (!profileName) {
@@ -244,12 +244,12 @@ static bool PauseProfilers(JSContext* cx
   return true;
 }
 
-static bool ResumeProfilers(JSContext* cx, unsigned argc, Value* vp) {
+static bool ResumeProfilers(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (args.length() == 0) {
+  if (args.length() == 0) {MOZ_RELEASE_ASSERT(0);
     args.rval().setBoolean(JS_ResumeProfilers(nullptr));
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   UniqueChars profileName = RequiredStringArg(cx, args, 0, "resumeProfiling");
   if (!profileName) {
@@ -260,20 +260,20 @@ static bool ResumeProfilers(JSContext* c
 }
 
 /* Usage: DumpProfile([filename[, profileName]]) */
-static bool DumpProfile(JSContext* cx, unsigned argc, Value* vp) {
+static bool DumpProfile(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   bool ret;
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (args.length() == 0) {
+  if (args.length() == 0) {MOZ_RELEASE_ASSERT(0);
     ret = JS_DumpProfile(nullptr, nullptr);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     UniqueChars filename = RequiredStringArg(cx, args, 0, "dumpProfile");
-    if (!filename) {
+    if (!filename) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (args.length() == 1) {
+    if (args.length() == 1) {MOZ_RELEASE_ASSERT(0);
       ret = JS_DumpProfile(filename.get(), nullptr);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       UniqueChars profileName = RequiredStringArg(cx, args, 1, "dumpProfile");
       if (!profileName) {
         return false;
@@ -460,17 +460,17 @@ JS_FRIEND_API bool js_DumpCallgrind(cons
 static bool perfInitialized = false;
 static pid_t perfPid = 0;
 
-bool js_StartPerf() {
+bool js_StartPerf() {MOZ_RELEASE_ASSERT(0);
   const char* outfile = "mozperf.data";
 
-  if (perfPid != 0) {
+  if (perfPid != 0) {MOZ_RELEASE_ASSERT(0);
     UnsafeError("js_StartPerf: called while perf was already running!\n");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Bail if MOZ_PROFILE_WITH_PERF is empty or undefined.
   if (!getenv("MOZ_PROFILE_WITH_PERF") ||
-      !strlen(getenv("MOZ_PROFILE_WITH_PERF"))) {
+      !strlen(getenv("MOZ_PROFILE_WITH_PERF"))) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -478,18 +478,18 @@ bool js_StartPerf() {
    * Delete mozperf.data the first time through -- we're going to append to it
    * later on, so we want it to be clean when we start out.
    */
-  if (!perfInitialized) {
+  if (!perfInitialized) {MOZ_RELEASE_ASSERT(0);
     perfInitialized = true;
     unlink(outfile);
     char cwd[4096];
     printf("Writing perf profiling data to %s/%s\n", getcwd(cwd, sizeof(cwd)),
            outfile);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   pid_t mainPid = getpid();
 
   pid_t childPid = fork();
-  if (childPid == 0) {
+  if (childPid == 0) {MOZ_RELEASE_ASSERT(0);
     /* perf record --pid $mainPID --output=$outfile $MOZ_PROFILE_PERF_FLAGS */
 
     char mainPidStr[16];
@@ -498,33 +498,33 @@ bool js_StartPerf() {
                                  mainPidStr, "--output", outfile};
 
     Vector<const char*, 0, SystemAllocPolicy> args;
-    if (!args.append(defaultArgs, std::size(defaultArgs))) {
+    if (!args.append(defaultArgs, std::size(defaultArgs))) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     const char* flags = getenv("MOZ_PROFILE_PERF_FLAGS");
-    if (!flags) {
+    if (!flags) {MOZ_RELEASE_ASSERT(0);
       flags = "--call-graph";
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     UniqueChars flags2 = DuplicateString(flags);
-    if (!flags2) {
+    if (!flags2) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Split |flags2| on spaces.
     char* toksave;
     char* tok = strtok_r(flags2.get(), " ", &toksave);
-    while (tok) {
-      if (!args.append(tok)) {
+    while (tok) {MOZ_RELEASE_ASSERT(0);
+      if (!args.append(tok)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       tok = strtok_r(nullptr, " ", &toksave);
     }
 
-    if (!args.append((char*)nullptr)) {
+    if (!args.append((char*)nullptr)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     execvp("perf", const_cast<char**>(args.begin()));
 
@@ -543,13 +543,13 @@ bool js_StartPerf() {
   return false;
 }
 
-bool js_StopPerf() {
-  if (perfPid == 0) {
+bool js_StopPerf() {MOZ_RELEASE_ASSERT(0);
+  if (perfPid == 0) {MOZ_RELEASE_ASSERT(0);
     UnsafeError("js_StopPerf: perf is not running.\n");
     return true;
   }
 
-  if (kill(perfPid, SIGINT)) {
+  if (kill(perfPid, SIGINT)) {MOZ_RELEASE_ASSERT(0);
     UnsafeError("js_StopPerf: kill failed\n");
 
     // Try to reap the process anyway.
diff --git a/js/src/builtin/Promise.cpp b/js/src/builtin/Promise.cpp
--- a/js/src/builtin/Promise.cpp
+++ b/js/src/builtin/Promise.cpp
@@ -351,7 +351,7 @@ class MutableWrappedPtrOperations<Promis
       AutoRealm ar(cx, unwrappedArray());
 
       RootedValue rootedVal(cx, val);
-      if (!cx->compartment()->wrap(cx, &rootedVal)) {
+      if (!cx->compartment()->wrap(cx, &rootedVal)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       unwrappedArray()->setDenseElement(index, rootedVal);
@@ -490,7 +490,7 @@ class PromiseDebugInfo : public NativeOb
     if (!debugInfo) {
       RootedValue idVal(cx, promise->getFixedSlot(PromiseSlot_DebugInfo));
       debugInfo = create(cx, promise);
-      if (!debugInfo) {
+      if (!debugInfo) {MOZ_RELEASE_ASSERT(0);
         cx->clearPendingException();
         return;
       }
@@ -520,7 +520,7 @@ class PromiseDebugInfo : public NativeOb
     if (stack) {
       // The exception stack is always unwrapped so it might be in
       // a different compartment.
-      if (!cx->compartment()->wrap(cx, &stack)) {
+      if (!cx->compartment()->wrap(cx, &stack)) {MOZ_RELEASE_ASSERT(0);
         cx->clearPendingException();
         return;
       }
@@ -602,7 +602,7 @@ static bool AbruptRejectPromise(JSContex
   // Step 1.a.
   RootedValue reason(cx);
   RootedSavedFrame stack(cx);
-  if (!MaybeGetAndClearExceptionAndStack(cx, &reason, &stack)) {
+  if (!MaybeGetAndClearExceptionAndStack(cx, &reason, &stack)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -872,7 +872,7 @@ static bool RejectPromiseFunction(JSCont
   resolveFn.set(NewNativeFunction(cx, ResolvePromiseFunction, 1, funName,
                                   gc::AllocKind::FUNCTION_EXTENDED,
                                   GenericObject));
-  if (!resolveFn) {
+  if (!resolveFn) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1003,7 +1003,7 @@ static bool Promise_then_impl(JSContext*
                               JSMSG_CANNOT_RESOLVE_PROMISE_WITH_ITSELF);
     RootedValue selfResolutionError(cx);
     RootedSavedFrame stack(cx);
-    if (!MaybeGetAndClearExceptionAndStack(cx, &selfResolutionError, &stack)) {
+    if (!MaybeGetAndClearExceptionAndStack(cx, &selfResolutionError, &stack)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1019,7 +1019,7 @@ static bool Promise_then_impl(JSContext*
   RootedValue error(cx);
   RootedSavedFrame errorStack(cx);
   if (!status) {
-    if (!MaybeGetAndClearExceptionAndStack(cx, &error, &errorStack)) {
+    if (!MaybeGetAndClearExceptionAndStack(cx, &error, &errorStack)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1061,7 +1061,7 @@ static bool Promise_then_impl(JSContext*
   if (!isBuiltinThen) {
     RootedValue promiseVal(cx, ObjectValue(*promise));
     if (!EnqueuePromiseResolveThenableJob(cx, promiseVal, resolutionVal,
-                                          thenVal)) {
+                                          thenVal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -1160,7 +1160,7 @@ static bool PromiseReactionJob(JSContext
     reaction = &unwrappedReactionObj->as<PromiseReactionRecord>();
     MOZ_RELEASE_ASSERT(reaction->is<PromiseReactionRecord>());
     ar.emplace(cx, reaction);
-    if (!cx->compartment()->wrap(cx, &handlerArg)) {
+    if (!cx->compartment()->wrap(cx, &handlerArg)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1190,7 +1190,7 @@ static bool PromiseReactionJob(JSContext
     ar2.emplace(cx, handlerObj);
 
     // We need to wrap the reaction to store it on the job function.
-    if (!cx->compartment()->wrap(cx, &reactionVal)) {
+    if (!cx->compartment()->wrap(cx, &reactionVal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1200,7 +1200,7 @@ static bool PromiseReactionJob(JSContext
   RootedFunction job(
       cx, NewNativeFunction(cx, PromiseReactionJob, 0, funName,
                             gc::AllocKind::FUNCTION_EXTENDED, GenericObject));
-  if (!job) {
+  if (!job) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1222,17 +1222,17 @@ static bool PromiseReactionJob(JSContext
   RootedObject promise(cx, reaction->promise());
   if (promise) {
     if (promise->is<PromiseObject>()) {
-      if (!cx->compartment()->wrap(cx, &promise)) {
+      if (!cx->compartment()->wrap(cx, &promise)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (IsWrapper(promise)) {
       // `promise` can be already-wrapped promise object at this point.
       JSObject* unwrappedPromise = UncheckedUnwrap(promise);
       if (unwrappedPromise->is<PromiseObject>()) {
-        if (!cx->compartment()->wrap(cx, &promise)) {
+        if (!cx->compartment()->wrap(cx, &promise)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         promise = nullptr;
       }
     } else {
@@ -1379,7 +1379,7 @@ CreatePromiseObjectWithoutResolutionFunc
 
   // Steps 3-7.
   Rooted<PromiseObject*> promise(cx, CreatePromiseObjectInternal(cx));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1446,7 +1446,7 @@ CreatePromiseObjectWithoutResolutionFunc
   RootedFunction executor(
       cx, NewNativeFunction(cx, GetCapabilitiesExecutor, 2, funName,
                             gc::AllocKind::FUNCTION_EXTENDED, GenericObject));
-  if (!executor) {
+  if (!executor) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1538,7 +1538,7 @@ static bool GetCapabilitiesExecutor(JSCo
     // avoid that situation, we synthesize a generic error that doesn't
     // expose any privileged information but can safely be used in the
     // rejection handler.
-    if (!cx->compartment()->wrap(cx, &reason)) {
+    if (!cx->compartment()->wrap(cx, &reason)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (reason.isObject() && !CheckedUnwrapStatic(&reason.toObject())) {
@@ -1657,12 +1657,12 @@ static bool ForEachReaction(JSContext* c
       ok = RejectPromiseInternal(cx, promiseToResolve, argument);
     }
 
-    if (!ok) {
+    if (!ok) {MOZ_RELEASE_ASSERT(0);
       resolutionMode = RejectMode;
       if (!MaybeGetAndClearExceptionAndStack(cx, &handlerResult,
-                                             &unwrappedRejectionStack)) {
+                                             &unwrappedRejectionStack)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
   }
 
@@ -1836,7 +1836,7 @@ static bool PromiseReactionJob(JSContext
     MOZ_RELEASE_ASSERT(reactionObj->is<PromiseReactionRecord>());
   } else {
     reactionObj = UncheckedUnwrap(reactionObj);
-    if (JS_IsDeadWrapper(reactionObj)) {
+    if (JS_IsDeadWrapper(reactionObj)) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                 JSMSG_DEAD_OBJECT);
       return false;
@@ -1891,7 +1891,7 @@ static bool PromiseReactionJob(JSContext
           handlerNum == PromiseHandlerAsyncFromSyncIteratorValueUnwrapDone;
       // 25.1.4.2.5 Async-from-Sync Iterator Value Unwrap Functions, steps 1-2.
       PlainObject* resultObj = CreateIterResultObject(cx, argument, done);
-      if (!resultObj) {
+      if (!resultObj) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -1961,7 +1961,7 @@ static bool PromiseResolveThenableJob(JS
   // Step 1.
   RootedObject resolveFn(cx);
   RootedObject rejectFn(cx);
-  if (!CreateResolvingFunctions(cx, promise, &resolveFn, &rejectFn)) {
+  if (!CreateResolvingFunctions(cx, promise, &resolveFn, &rejectFn)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2029,7 +2029,7 @@ static bool PromiseResolveBuiltinThenabl
   // Steps 3-4.
   RootedValue exception(cx);
   RootedSavedFrame stack(cx);
-  if (!MaybeGetAndClearExceptionAndStack(cx, &exception, &stack)) {
+  if (!MaybeGetAndClearExceptionAndStack(cx, &exception, &stack)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2069,12 +2069,12 @@ static bool PromiseResolveBuiltinThenabl
   AutoRealm ar(cx, then);
 
   // Wrap the `promiseToResolve` and `thenable` arguments.
-  if (!cx->compartment()->wrap(cx, &promiseToResolve)) {
+  if (!cx->compartment()->wrap(cx, &promiseToResolve)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MOZ_ASSERT(thenable.isObject());
-  if (!cx->compartment()->wrap(cx, &thenable)) {
+  if (!cx->compartment()->wrap(cx, &thenable)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2082,7 +2082,7 @@ static bool PromiseResolveBuiltinThenabl
   RootedFunction job(
       cx, NewNativeFunction(cx, PromiseResolveThenableJob, 0, funName,
                             gc::AllocKind::FUNCTION_EXTENDED, GenericObject));
-  if (!job) {
+  if (!job) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2172,7 +2172,7 @@ static JSFunction* GetRejectFunctionFrom
 
 static JSFunction* GetResolveFunctionFromPromise(PromiseObject* promise) {
   Value rejectFunVal = promise->getFixedSlot(PromiseSlot_RejectFunction);
-  if (rejectFunVal.isUndefined()) {
+  if (rejectFunVal.isUndefined()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   JSObject* rejectFunObj = &rejectFunVal.toObject();
@@ -2183,7 +2183,7 @@ static JSFunction* GetResolveFunctionFro
     rejectFunObj = UncheckedUnwrap(rejectFunObj);
   }
 
-  if (!rejectFunObj->is<JSFunction>()) {
+  if (!rejectFunObj->is<JSFunction>()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2191,7 +2191,7 @@ static JSFunction* GetResolveFunctionFro
 
   // Only the original RejectPromiseFunction has a reference to the resolve
   // function.
-  if (rejectFun->maybeNative() != &RejectPromiseFunction) {
+  if (rejectFun->maybeNative() != &RejectPromiseFunction) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2337,7 +2337,7 @@ static bool PromiseConstructor(JSContext
       Handle<GlobalObject*> global = cx->global();
       JSObject* promiseCtor =
           GlobalObject::getOrCreatePromiseConstructor(cx, global);
-      if (!promiseCtor) {
+      if (!promiseCtor) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -2347,7 +2347,7 @@ static bool PromiseConstructor(JSContext
       if (newTarget == promiseCtor) {
         needsWrapping = true;
         proto = GlobalObject::getOrCreatePromisePrototype(cx, cx->global());
-        if (!proto) {
+        if (!proto) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -2355,7 +2355,7 @@ static bool PromiseConstructor(JSContext
   }
 
   if (needsWrapping) {
-    if (!cx->compartment()->wrap(cx, &proto)) {
+    if (!cx->compartment()->wrap(cx, &proto)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -2393,7 +2393,7 @@ PromiseObject* PromiseObject::create(JSC
   if (needsWrapping) {
     MOZ_ASSERT(proto);
     usedProto = CheckedUnwrapStatic(proto);
-    if (!usedProto) {
+    if (!usedProto) {MOZ_RELEASE_ASSERT(0);
       ReportAccessDenied(cx);
       return nullptr;
     }
@@ -2402,12 +2402,12 @@ PromiseObject* PromiseObject::create(JSC
   // Steps 3-7.
   Rooted<PromiseObject*> promise(
       cx, CreatePromiseObjectInternal(cx, usedProto, needsWrapping, false));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedObject promiseObj(cx, promise);
-  if (needsWrapping && !cx->compartment()->wrap(cx, &promiseObj)) {
+  if (needsWrapping && !cx->compartment()->wrap(cx, &promiseObj)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2417,7 +2417,7 @@ PromiseObject* PromiseObject::create(JSC
   // can unwrap the Promise if required.
   RootedObject resolveFn(cx);
   RootedObject rejectFn(cx);
-  if (!CreateResolvingFunctions(cx, promiseObj, &resolveFn, &rejectFn)) {
+  if (!CreateResolvingFunctions(cx, promiseObj, &resolveFn, &rejectFn)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2427,7 +2427,7 @@ PromiseObject* PromiseObject::create(JSC
   if (needsWrapping) {
     AutoRealm ar(cx, promise);
     RootedObject wrappedRejectFn(cx, rejectFn);
-    if (!cx->compartment()->wrap(cx, &wrappedRejectFn)) {
+    if (!cx->compartment()->wrap(cx, &wrappedRejectFn)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     promise->initFixedSlot(PromiseSlot_RejectFunction,
@@ -2560,7 +2560,7 @@ enum class CombinatorKind { All, AllSett
   {
     JSObject* promiseCtor =
         GlobalObject::getOrCreatePromiseConstructor(cx, cx->global());
-    if (!promiseCtor) {
+    if (!promiseCtor) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2684,7 +2684,7 @@ static bool PromiseAllResolveElementFunc
   // Step 1.
   RootedObject C(cx,
                  GlobalObject::getOrCreatePromiseConstructor(cx, cx->global()));
-  if (!C) {
+  if (!C) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2692,7 +2692,7 @@ static bool PromiseAllResolveElementFunc
 
   // Step 3.
   Rooted<PromiseCapability> resultCapability(cx);
-  if (!NewPromiseCapability(cx, C, &resultCapability, false)) {
+  if (!NewPromiseCapability(cx, C, &resultCapability, false)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2709,7 +2709,7 @@ static bool PromiseAllResolveElementFunc
     Rooted<PromiseCombinatorElements> values(cx);
     {
       auto* valuesArray = NewDenseFullyAllocatedArray(cx, promiseCount);
-      if (!valuesArray) {
+      if (!valuesArray) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       valuesArray->ensureDenseInitializedLength(0, promiseCount);
@@ -2725,7 +2725,7 @@ static bool PromiseAllResolveElementFunc
     Rooted<PromiseCombinatorDataHolder*> dataHolder(cx);
     dataHolder = PromiseCombinatorDataHolder::New(
         cx, resultCapability.promise(), values, resultCapability.resolve());
-    if (!dataHolder) {
+    if (!dataHolder) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -2750,7 +2750,7 @@ static bool PromiseAllResolveElementFunc
       // Steps j-o.
       JSFunction* resolveFunc = NewPromiseCombinatorElementFunction(
           cx, PromiseAllResolveElementFunction, dataHolder, index);
-      if (!resolveFunc) {
+      if (!resolveFunc) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -2771,7 +2771,7 @@ static bool PromiseAllResolveElementFunc
       nextPromise = &UncheckedUnwrap(nextPromiseObj)->as<PromiseObject>();
 
       if (!PerformPromiseThen(cx, nextPromise, resolveFunVal, rejectFunVal,
-                              resultCapabilityWithoutResolving)) {
+                              resultCapabilityWithoutResolving)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -2856,7 +2856,7 @@ static bool PromiseAllResolveElementFunc
     // allocation time will be wrong.  So it goes.
     Rooted<PromiseObject*> temporaryPromise(
         cx, CreatePromiseObjectWithoutResolutionFunctions(cx));
-    if (!temporaryPromise) {
+    if (!temporaryPromise) {MOZ_RELEASE_ASSERT(0);
       cx->clearPendingException();
       return true;
     }
@@ -2867,7 +2867,7 @@ static bool PromiseAllResolveElementFunc
 
   // Reject the promise only if it's still pending.
   Handle<PromiseObject*> promise = promiseObj.as<PromiseObject>();
-  if (promise->state() != JS::PromiseState::Pending) {
+  if (promise->state() != JS::PromiseState::Pending) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -2901,7 +2901,7 @@ template <typename T>
     bool resolveReturnsUndefined, T getResolveAndReject) {
   RootedObject promiseCtor(
       cx, GlobalObject::getOrCreatePromiseConstructor(cx, cx->global()));
-  if (!promiseCtor) {
+  if (!promiseCtor) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2988,13 +2988,13 @@ template <typename T>
         // Inline the call to Promise.resolve.
         JSObject* res =
             CommonStaticResolveRejectImpl(cx, CVal, nextValue, ResolveMode);
-        if (!res) {
+        if (!res) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         nextPromise.setObject(*res);
       }
-    } else if (promiseResolve.isUndefined()) {
+    } else if (promiseResolve.isUndefined()) {MOZ_RELEASE_ASSERT(0);
       // |promiseResolve| is undefined when the Promise constructor was
       // initially in its default state, i.e. if it had been retrieved, it would
       // have been set to |Promise.resolve|.
@@ -3004,9 +3004,9 @@ template <typename T>
       // Inline the call to Promise.resolve.
       JSObject* res =
           CommonStaticResolveRejectImpl(cx, CVal, nextValue, ResolveMode);
-      if (!res) {
+      if (!res) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       nextPromise.setObject(*res);
     } else {
@@ -3019,7 +3019,7 @@ template <typename T>
 
     // Get the resolving functions for this iteration.
     // 25.6.4.1.1, steps 8.j-q.
-    if (!getResolveAndReject(&resolveFunVal, &rejectFunVal)) {
+    if (!getResolveAndReject(&resolveFunVal, &rejectFunVal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3035,7 +3035,7 @@ template <typename T>
     // 25.6.4.1.1, step 8.r.
     // 25.6.4.3.1, step 5.i.
     nextPromiseObj = ToObject(cx, nextPromise);
-    if (!nextPromiseObj) {
+    if (!nextPromiseObj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3070,7 +3070,7 @@ template <typename T>
       if (getThen) {
         thenSpecies = SpeciesConstructor(cx, nextPromiseObj, JSProto_Promise,
                                          IsPromiseSpecies);
-        if (!thenSpecies) {
+        if (!thenSpecies) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
@@ -3099,7 +3099,7 @@ template <typename T>
         addToDependent = false;
       } else {
         // 25.6.5.4, step 4.
-        if (!NewPromiseCapability(cx, thenSpecies, &thenCapability, true)) {
+        if (!NewPromiseCapability(cx, thenSpecies, &thenCapability, true)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -3107,7 +3107,7 @@ template <typename T>
       // 25.6.5.4, step 5.
       Handle<PromiseObject*> promise = nextPromiseObj.as<PromiseObject>();
       if (!PerformPromiseThen(cx, promise, resolveFunVal, rejectFunVal,
-                              thenCapability)) {
+                              thenCapability)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -3124,7 +3124,7 @@ template <typename T>
       // values can't be Promise objects. This can happen if Promise.all
       // is called on an object with a `resolve` method that returns
       // primitives.
-      if (!nextPromise.isObject()) {
+      if (!nextPromise.isObject()) {MOZ_RELEASE_ASSERT(0);
         addToDependent = false;
       }
     }
@@ -3145,17 +3145,17 @@ template <typename T>
       mozilla::Maybe<AutoRealm> ar;
       if (IsProxy(nextPromiseObj)) {
         nextPromiseObj = CheckedUnwrapStatic(nextPromiseObj);
-        if (!nextPromiseObj) {
+        if (!nextPromiseObj) {MOZ_RELEASE_ASSERT(0);
           ReportAccessDenied(cx);
           return false;
         }
-        if (JS_IsDeadWrapper(nextPromiseObj)) {
+        if (JS_IsDeadWrapper(nextPromiseObj)) {MOZ_RELEASE_ASSERT(0);
           JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                     JSMSG_DEAD_OBJECT);
           return false;
         }
         ar.emplace(cx, nextPromiseObj);
-        if (!cx->compartment()->wrap(cx, &blockedPromise)) {
+        if (!cx->compartment()->wrap(cx, &blockedPromise)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -3209,13 +3209,13 @@ template <typename T>
     {
       AutoRealm ar(cx, unwrappedPromiseObj);
       auto* array = NewDenseEmptyArray(cx);
-      if (!array) {
+      if (!array) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       elements.initialize(array);
     }
 
-    if (!cx->compartment()->wrap(cx, elements.value())) {
+    if (!cx->compartment()->wrap(cx, elements.value())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -3324,7 +3324,7 @@ static bool PromiseCombinatorElementFunc
 
   // Step 3.
   Rooted<PromiseCombinatorElements> values(cx);
-  if (!NewPromiseCombinatorElements(cx, resultCapability, &values)) {
+  if (!NewPromiseCombinatorElements(cx, resultCapability, &values)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3336,7 +3336,7 @@ static bool PromiseCombinatorElementFunc
   Rooted<PromiseCombinatorDataHolder*> dataHolder(cx);
   dataHolder = PromiseCombinatorDataHolder::New(
       cx, resultCapability.promise(), values, resultCapability.resolve());
-  if (!dataHolder) {
+  if (!dataHolder) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3414,7 +3414,7 @@ static bool PromiseAllResolveElementFunc
   // Step 8 (moved to step 10).
 
   // Step 9.
-  if (!values.setElement(cx, index, xVal)) {
+  if (!values.setElement(cx, index, xVal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3516,7 +3516,7 @@ static bool Promise_static_allSettled(JS
 
   // Step 3.
   Rooted<PromiseCombinatorElements> values(cx);
-  if (!NewPromiseCombinatorElements(cx, resultCapability, &values)) {
+  if (!NewPromiseCombinatorElements(cx, resultCapability, &values)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3528,7 +3528,7 @@ static bool Promise_static_allSettled(JS
   Rooted<PromiseCombinatorDataHolder*> dataHolder(cx);
   dataHolder = PromiseCombinatorDataHolder::New(
       cx, resultCapability.promise(), values, resultCapability.resolve());
-  if (!dataHolder) {
+  if (!dataHolder) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3614,7 +3614,7 @@ static bool PromiseAllSettledElementFunc
 
   // Step 6.
   Rooted<PromiseCombinatorElements> values(cx);
-  if (!GetPromiseCombinatorElements(cx, data, &values)) {
+  if (!GetPromiseCombinatorElements(cx, data, &values)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3633,7 +3633,7 @@ static bool PromiseAllSettledElementFunc
 
   // Step 9.
   RootedPlainObject obj(cx, NewBuiltinClassInstance<PlainObject>(cx));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3645,7 +3645,7 @@ static bool PromiseAllSettledElementFunc
   } else {
     statusValue.setString(cx->names().rejected);
   }
-  if (!NativeDefineDataProperty(cx, obj, id, statusValue, JSPROP_ENUMERATE)) {
+  if (!NativeDefineDataProperty(cx, obj, id, statusValue, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3655,13 +3655,13 @@ static bool PromiseAllSettledElementFunc
   } else {
     id = NameToId(cx->names().reason);
   }
-  if (!NativeDefineDataProperty(cx, obj, id, valueOrReason, JSPROP_ENUMERATE)) {
+  if (!NativeDefineDataProperty(cx, obj, id, valueOrReason, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Steps 4, 12.
   RootedValue objVal(cx, ObjectValue(*obj));
-  if (!values.setElement(cx, index, objVal)) {
+  if (!values.setElement(cx, index, objVal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3727,7 +3727,7 @@ static void ThrowAggregateError(JSContex
 
   // Step 3.
   Rooted<PromiseCombinatorElements> errors(cx);
-  if (!NewPromiseCombinatorElements(cx, resultCapability, &errors)) {
+  if (!NewPromiseCombinatorElements(cx, resultCapability, &errors)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3739,7 +3739,7 @@ static void ThrowAggregateError(JSContex
   Rooted<PromiseCombinatorDataHolder*> dataHolder(cx);
   dataHolder = PromiseCombinatorDataHolder::New(
       cx, resultCapability.promise(), errors, resultCapability.reject());
-  if (!dataHolder) {
+  if (!dataHolder) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3818,12 +3818,12 @@ static bool PromiseAnyRejectElementFunct
 
   // Step 6.
   Rooted<PromiseCombinatorElements> errors(cx);
-  if (!GetPromiseCombinatorElements(cx, data, &errors)) {
+  if (!GetPromiseCombinatorElements(cx, data, &errors)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Step 9.
-  if (!errors.setElement(cx, index, xVal)) {
+  if (!errors.setElement(cx, index, xVal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3840,7 +3840,7 @@ static bool PromiseAnyRejectElementFunct
 
     RootedValue reason(cx);
     RootedSavedFrame stack(cx);
-    if (!MaybeGetAndClearExceptionAndStack(cx, &reason, &stack)) {
+    if (!MaybeGetAndClearExceptionAndStack(cx, &reason, &stack)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3878,7 +3878,7 @@ static void ThrowAggregateError(JSContex
   // allocation site, which should point to calling site of |Promise.any|.
   if (promise->is<PromiseObject>()) {
     allocationSite = promise->as<PromiseObject>().allocationSite();
-    if (allocationSite) {
+    if (allocationSite) {MOZ_RELEASE_ASSERT(0);
       asyncStack.emplace(
           cx, allocationSite, "Promise.any",
           JS::AutoSetAsyncStackForNewCalls::AsyncCallKind::IMPLICIT);
@@ -3888,7 +3888,7 @@ static void ThrowAggregateError(JSContex
   // AutoSetAsyncStackForNewCalls requires a new activation before it takes
   // effect, so call into the self-hosting helper to set-up new call frames.
   RootedValue error(cx);
-  if (!GetAggregateError(cx, JSMSG_PROMISE_ANY_REJECTION, &error)) {
+  if (!GetAggregateError(cx, JSMSG_PROMISE_ANY_REJECTION, &error)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -3900,7 +3900,7 @@ static void ThrowAggregateError(JSContex
     if (errorObj->type() == JSEXN_AGGREGATEERR) {
       RootedValue errorsVal(cx, JS::ObjectValue(*errors.unwrappedArray()));
       if (!NativeDefineDataProperty(cx, errorObj, cx->names().errors, errorsVal,
-                                    0)) {
+                                    0)) {MOZ_RELEASE_ASSERT(0);
         return;
       }
 
@@ -4030,7 +4030,7 @@ PromiseObject* PromiseObject::unforgeabl
 
   Rooted<PromiseObject*> promise(
       cx, CreatePromiseObjectWithoutResolutionFunctions(cx));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -4105,7 +4105,7 @@ PromiseObject* PromiseObject::unforgeabl
 
   Rooted<PromiseObject*> promise(
       cx, CreatePromiseObjectWithoutResolutionFunctions(cx));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -4208,7 +4208,7 @@ static PromiseReactionRecord* NewReactio
 
   RootedObject incumbentGlobalObject(cx);
   if (incumbentGlobalObjectOption == IncumbentGlobalObject::Yes) {
-    if (!GetObjectFromIncumbentGlobal(cx, &incumbentGlobalObject)) {
+    if (!GetObjectFromIncumbentGlobal(cx, &incumbentGlobalObject)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -4303,14 +4303,14 @@ static bool PromiseThenNewPromiseCapabil
                                    JSMSG_INCOMPATIBLE_PROTO, "Promise", "then",
                                    promiseObj->getClass()->name);
       }));
-  if (!unwrappedPromise) {
+  if (!unwrappedPromise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   // Steps 3-4.
   Rooted<PromiseObject*> newPromise(
       cx, CreatePromiseObjectWithoutResolutionFunctions(cx));
-  if (!newPromise) {
+  if (!newPromise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   newPromise->copyUserInteractionFlagsFrom(*unwrappedPromise);
@@ -4376,7 +4376,7 @@ static bool PromiseThenNewPromiseCapabil
   Rooted<PromiseReactionRecord*> reaction(
       cx, NewReactionRecord(cx, resultCapability, onFulfilled, onRejected,
                             IncumbentGlobalObject::Yes));
-  if (!reaction) {
+  if (!reaction) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4410,7 +4410,7 @@ static bool OriginalPromiseThenBuiltin(J
   if (rvalUsed) {
     PromiseObject* resultPromise =
         CreatePromiseObjectWithoutResolutionFunctions(cx);
-    if (!resultPromise) {
+    if (!resultPromise) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -4421,7 +4421,7 @@ static bool OriginalPromiseThenBuiltin(J
 
   // Step 5.
   if (!PerformPromiseThen(cx, promise, onFulfilled, onRejected,
-                          resultCapability)) {
+                          resultCapability)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4528,7 +4528,7 @@ template <typename T>
   // promise using the Promise constructor.
   Rooted<PromiseObject*> unwrappedPromise(
       cx, UnwrapAndDowncastObject<PromiseObject>(cx, promise));
-  if (!unwrappedPromise) {
+  if (!unwrappedPromise) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4592,14 +4592,14 @@ bool js::AsyncFromSyncIteratorMethod(JSC
   // Step 2: Let promiseCapability be ! NewPromiseCapability(%Promise%).
   Rooted<PromiseObject*> resultPromise(
       cx, CreatePromiseObjectWithoutResolutionFunctions(cx));
-  if (!resultPromise) {
+  if (!resultPromise) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Step 3: If Type(O) is not Object, or if O does not have a
   //         [[SyncIteratorRecord]] internal slot, then
   if (!thisVal.isObject() ||
-      !thisVal.toObject().is<AsyncFromSyncIteratorObject>()) {
+      !thisVal.toObject().is<AsyncFromSyncIteratorObject>()) {MOZ_RELEASE_ASSERT(0);
     // NB: See https://github.com/tc39/proposal-async-iteration/issues/105
     // for why this check shouldn't be necessary as long as we can ensure
     // the Async-from-Sync iterator can't be accessed directly by user
@@ -4607,15 +4607,15 @@ bool js::AsyncFromSyncIteratorMethod(JSC
 
     // Step 3.a: Let invalidIteratorError be a newly created TypeError object.
     RootedValue badGeneratorError(cx);
-    if (!GetTypeError(cx, JSMSG_NOT_AN_ASYNC_ITERATOR, &badGeneratorError)) {
+    if (!GetTypeError(cx, JSMSG_NOT_AN_ASYNC_ITERATOR, &badGeneratorError)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // Step 3.b: Perform ! Call(promiseCapability.[[Reject]], undefined,
     //                          « invalidIteratorError »).
-    if (!RejectPromiseInternal(cx, resultPromise, badGeneratorError)) {
+    if (!RejectPromiseInternal(cx, resultPromise, badGeneratorError)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Step 3.c: Return promiseCapability.[[Promise]].
     args.rval().setObject(*resultPromise);
@@ -4646,7 +4646,7 @@ bool js::AsyncFromSyncIteratorMethod(JSC
     if (func.isNullOrUndefined()) {
       // Step 7.a: Let iterResult be ! CreateIterResultObject(value, true).
       PlainObject* resultObj = CreateIterResultObject(cx, args.get(0), true);
-      if (!resultObj) {
+      if (!resultObj) {MOZ_RELEASE_ASSERT(0);
         return AbruptRejectPromise(cx, args, resultPromise, nullptr);
       }
 
@@ -4654,7 +4654,7 @@ bool js::AsyncFromSyncIteratorMethod(JSC
 
       // Step 7.b: Perform ! Call(promiseCapability.[[Resolve]], undefined,
       //                          « iterResult »).
-      if (!ResolvePromiseInternal(cx, resultPromise, resultVal)) {
+      if (!ResolvePromiseInternal(cx, resultPromise, resultVal)) {MOZ_RELEASE_ASSERT(0);
         return AbruptRejectPromise(cx, args, resultPromise, nullptr);
       }
 
@@ -4678,7 +4678,7 @@ bool js::AsyncFromSyncIteratorMethod(JSC
     if (func.isNullOrUndefined()) {
       // Step 7.a: Perform ! Call(promiseCapability.[[Reject]], undefined, «
       // value »).
-      if (!RejectPromiseInternal(cx, resultPromise, args.get(0))) {
+      if (!RejectPromiseInternal(cx, resultPromise, args.get(0))) {MOZ_RELEASE_ASSERT(0);
         return AbruptRejectPromise(cx, args, resultPromise, nullptr);
       }
 
@@ -4908,7 +4908,7 @@ enum class ResumeNextKind { Enqueue, Rej
     MOZ_ASSERT(!generator->isAwaitingYieldReturn());
 
     // Step 4: If state is "awaiting-return", return undefined.
-    if (generator->isAwaitingReturn()) {
+    if (generator->isAwaitingReturn()) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
 
@@ -4922,7 +4922,7 @@ enum class ResumeNextKind { Enqueue, Rej
     // Step 8: Assert: next is an AsyncGeneratorRequest record.
     Rooted<AsyncGeneratorRequest*> request(
         cx, AsyncGeneratorObject::peekRequest(generator));
-    if (!request) {
+    if (!request) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5050,18 +5050,18 @@ enum class ResumeNextKind { Enqueue, Rej
     // Step 2.
     Rooted<PromiseObject*> resultPromise(
         cx, CreatePromiseObjectForAsyncGenerator(cx));
-    if (!resultPromise) {
+    if (!resultPromise) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // Step 3.a.
     RootedValue badGeneratorError(cx);
-    if (!GetTypeError(cx, JSMSG_NOT_AN_ASYNC_GENERATOR, &badGeneratorError)) {
+    if (!GetTypeError(cx, JSMSG_NOT_AN_ASYNC_GENERATOR, &badGeneratorError)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // Step 3.b.
-    if (!RejectPromiseInternal(cx, resultPromise, badGeneratorError)) {
+    if (!RejectPromiseInternal(cx, resultPromise, badGeneratorError)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5084,19 +5084,19 @@ enum class ResumeNextKind { Enqueue, Rej
 
     mozilla::Maybe<AutoRealm> ar;
     RootedValue completionVal(cx, completionValue);
-    if (asyncGenObj->compartment() != cx->compartment()) {
+    if (asyncGenObj->compartment() != cx->compartment()) {MOZ_RELEASE_ASSERT(0);
       ar.emplace(cx, asyncGenObj);
       wrapResult = true;
 
-      if (!cx->compartment()->wrap(cx, &completionVal)) {
+      if (!cx->compartment()->wrap(cx, &completionVal)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
     // Step 2.
     Rooted<PromiseObject*> resultPromise(
         cx, CreatePromiseObjectForAsyncGenerator(cx));
-    if (!resultPromise) {
+    if (!resultPromise) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5104,12 +5104,12 @@ enum class ResumeNextKind { Enqueue, Rej
     Rooted<AsyncGeneratorRequest*> request(
         cx, AsyncGeneratorObject::createRequest(cx, asyncGenObj, completionKind,
                                                 completionVal, resultPromise));
-    if (!request) {
+    if (!request) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // Steps 4, 6.
-    if (!AsyncGeneratorObject::enqueueRequest(cx, asyncGenObj, request)) {
+    if (!AsyncGeneratorObject::enqueueRequest(cx, asyncGenObj, request)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5240,7 +5240,7 @@ static bool Promise_then_impl(JSContext*
 
   // Step 5.
   if (!PerformPromiseThen(cx, unwrappedPromise, onFulfilled, onRejected,
-                          resultCapability)) {
+                          resultCapability)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5340,7 +5340,7 @@ bool js::Promise_then(JSContext* cx, uns
     // Instead of creating separate reaction records for fulfillment and
     // rejection, we create a combined record. All places we use the record
     // can handle that.
-    if (!AddPromiseReaction(cx, unwrappedPromise, reaction)) {
+    if (!AddPromiseReaction(cx, unwrappedPromise, reaction)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -5358,7 +5358,7 @@ bool js::Promise_then(JSContext* cx, uns
 
     // We might be operating on a promise from another compartment. In that
     // case, we need to wrap the result/reason value before using it.
-    if (!cx->compartment()->wrap(cx, &valueOrReason)) {
+    if (!cx->compartment()->wrap(cx, &valueOrReason)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5398,7 +5398,7 @@ bool js::Promise_then(JSContext* cx, uns
   mozilla::Maybe<AutoRealm> ar;
   if (unwrappedPromise->compartment() != cx->compartment()) {
     ar.emplace(cx, unwrappedPromise);
-    if (!cx->compartment()->wrap(cx, &reactionVal)) {
+    if (!cx->compartment()->wrap(cx, &reactionVal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -5420,7 +5420,7 @@ bool js::Promise_then(JSContext* cx, uns
   // always safely unwrap.
   if (IsProxy(reactionsObj)) {
     reactionsObj = UncheckedUnwrap(reactionsObj);
-    if (JS_IsDeadWrapper(reactionsObj)) {
+    if (JS_IsDeadWrapper(reactionsObj)) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                 JSMSG_DEAD_OBJECT);
       return false;
@@ -5432,7 +5432,7 @@ bool js::Promise_then(JSContext* cx, uns
     // If a single reaction existed so far, create a list and store the
     // old and the new reaction in it.
     ArrayObject* reactions = NewDenseFullyAllocatedArray(cx, 2);
-    if (!reactions) {
+    if (!reactions) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5515,7 +5515,7 @@ bool PromiseObject::dependentPromises(JS
       obj.set(UncheckedUnwrap(obj));
     }
 
-    if (JS_IsDeadWrapper(obj)) {
+    if (JS_IsDeadWrapper(obj)) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                 JSMSG_DEAD_OBJECT);
       return false;
@@ -5552,11 +5552,11 @@ bool PromiseObject::forEachReactionRecor
   }
 
   return ForEachReaction(cx, reactionsVal, [&](MutableHandleObject obj) {
-    if (IsProxy(obj)) {
+    if (IsProxy(obj)) {MOZ_RELEASE_ASSERT(0);
       obj.set(UncheckedUnwrap(obj));
     }
 
-    if (JS_IsDeadWrapper(obj)) {
+    if (JS_IsDeadWrapper(obj)) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                 JSMSG_DEAD_OBJECT);
       return false;
@@ -5569,17 +5569,17 @@ bool PromiseObject::forEachReactionRecor
     if (reaction->isAsyncFunction()) {
       Rooted<AsyncFunctionGeneratorObject*> generator(
           cx, reaction->asyncFunctionGenerator());
-      if (!builder.asyncFunction(cx, generator)) {
+      if (!builder.asyncFunction(cx, generator)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (reaction->isAsyncGenerator()) {
       Rooted<AsyncGeneratorObject*> generator(cx, reaction->asyncGenerator());
-      if (!builder.asyncGenerator(cx, generator)) {
+      if (!builder.asyncGenerator(cx, generator)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (reaction->isDefaultResolvingHandler()) {
       Rooted<PromiseObject*> promise(cx, reaction->defaultResolvingPromise());
-      if (!builder.direct(cx, promise)) {
+      if (!builder.direct(cx, promise)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -5701,7 +5701,7 @@ void PromiseObject::copyUserInteractionF
   FrameIter iter(cx);
 
   // The current frame should be the async function.
-  if (iter.done()) {
+  if (iter.done()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5739,7 +5739,7 @@ void PromiseObject::copyUserInteractionF
   if (IsSelfHostedFunctionWithName(fun, cx->names().InterpretGeneratorResume)) {
     ++iter;
 
-    if (iter.done()) {
+    if (iter.done()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
diff --git a/js/src/builtin/ReflectParse.cpp b/js/src/builtin/ReflectParse.cpp
--- a/js/src/builtin/ReflectParse.cpp
+++ b/js/src/builtin/ReflectParse.cpp
@@ -251,7 +251,7 @@ static bool GetPropertyDefault(JSContext
                                HandleValue defaultValue,
                                MutableHandleValue result) {
   bool found;
-  if (!HasProperty(cx, obj, id, &found)) {
+  if (!HasProperty(cx, obj, id, &found)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!found) {
@@ -293,7 +293,7 @@ class NodeBuilder {
 
   [[nodiscard]] bool init(HandleObject userobj = nullptr) {
     if (src) {
-      if (!atomValue(src, &srcval)) {
+      if (!atomValue(src, &srcval)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -306,24 +306,24 @@ class NodeBuilder {
         callbacks[i].setNull();
       }
       return true;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     userv.setObject(*userobj);
 
     RootedValue nullVal(cx, NullValue());
     RootedValue funv(cx);
-    for (unsigned i = 0; i < AST_LIMIT; i++) {
+    for (unsigned i = 0; i < AST_LIMIT; i++) {MOZ_RELEASE_ASSERT(0);
       const char* name = callbackNames[i];
       RootedAtom atom(cx, Atomize(cx, name, strlen(name)));
-      if (!atom) {
+      if (!atom) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }MOZ_RELEASE_ASSERT(0);
+      RootedId id(cx, AtomToId(atom));
+      if (!GetPropertyDefault(cx, userobj, id, nullVal, &funv)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
-      RootedId id(cx, AtomToId(atom));
-      if (!GetPropertyDefault(cx, userobj, id, nullVal, &funv)) {
-        return false;
-      }
-
-      if (funv.isNullOrUndefined()) {
+
+      if (funv.isNullOrUndefined()) {MOZ_RELEASE_ASSERT(0);
         callbacks[i].setNull();
         continue;
       }
@@ -350,7 +350,7 @@ class NodeBuilder {
                                     MutableHandleValue dst) {
     // The end of the implementation of callback(). All arguments except
     // loc have already been stored in range [0, i).
-    if (saveLoc) {
+    if (saveLoc) {MOZ_RELEASE_ASSERT(0);
       if (!newNodeLoc(pos, args[i])) {
         return false;
       }
@@ -377,7 +377,7 @@ class NodeBuilder {
   //     bool callback(HandleValue fun, HandleValue... args, TokenPos* pos,
   //                   MutableHandleValue dst);
   template <typename... Arguments>
-  [[nodiscard]] bool callback(HandleValue fun, Arguments&&... args) {
+  [[nodiscard]] bool callback(HandleValue fun, Arguments&&... args) {MOZ_RELEASE_ASSERT(0);
     InvokeArgs iargs(cx);
     if (!iargs.init(cx, sizeof...(args) - 2 + size_t(saveLoc))) {
       return false;
@@ -459,7 +459,7 @@ class NodeBuilder {
                               NodeVector& elts, TokenPos* pos,
                               MutableHandleValue dst) {
     RootedValue array(cx);
-    if (!newArray(elts, &array)) {
+    if (!newArray(elts, &array)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -762,12 +762,12 @@ bool NodeBuilder::createNode(ASTType typ
 
 bool NodeBuilder::newArray(NodeVector& elts, MutableHandleValue dst) {
   const size_t len = elts.length();
-  if (len > UINT32_MAX) {
+  if (len > UINT32_MAX) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return false;
   }
   RootedObject array(cx, NewDenseFullyAllocatedArray(cx, uint32_t(len)));
-  if (!array) {
+  if (!array) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -777,7 +777,7 @@ bool NodeBuilder::newArray(NodeVector& e
     MOZ_ASSERT_IF(val.isMagic(), val.whyMagic() == JS_SERIALIZE_NO_NODE);
 
     /* Represent "no node" as an array hole by not adding the value. */
-    if (val.isMagic(JS_SERIALIZE_NO_NODE)) {
+    if (val.isMagic(JS_SERIALIZE_NO_NODE)) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
@@ -800,7 +800,7 @@ bool NodeBuilder::newNodeLoc(TokenPos* p
   RootedObject to(cx);
   RootedValue val(cx);
 
-  if (!newObject(&loc)) {
+  if (!newObject(&loc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -813,35 +813,35 @@ bool NodeBuilder::newNodeLoc(TokenPos* p
   parser->tokenStream.computeLineAndColumn(pos->end, &endLineNum,
                                            &endColumnIndex);
 
-  if (!newObject(&to)) {
+  if (!newObject(&to)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   val.setObject(*to);
-  if (!defineProperty(loc, "start", val)) {
+  if (!defineProperty(loc, "start", val)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   val.setNumber(startLineNum);
-  if (!defineProperty(to, "line", val)) {
+  if (!defineProperty(to, "line", val)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   val.setNumber(startColumnIndex);
-  if (!defineProperty(to, "column", val)) {
+  if (!defineProperty(to, "column", val)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!newObject(&to)) {
+  if (!newObject(&to)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   val.setObject(*to);
-  if (!defineProperty(loc, "end", val)) {
+  if (!defineProperty(loc, "end", val)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   val.setNumber(endLineNum);
-  if (!defineProperty(to, "line", val)) {
+  if (!defineProperty(to, "line", val)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   val.setNumber(endColumnIndex);
-  if (!defineProperty(to, "column", val)) {
+  if (!defineProperty(to, "column", val)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1024,7 +1024,7 @@ bool NodeBuilder::switchStatement(Handle
                                   bool lexical, TokenPos* pos,
                                   MutableHandleValue dst) {
   RootedValue array(cx);
-  if (!newArray(elts, &array)) {
+  if (!newArray(elts, &array)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1066,7 +1066,7 @@ bool NodeBuilder::binaryExpression(Binar
   MOZ_ASSERT(op > BINOP_ERR && op < BINOP_LIMIT);
 
   RootedValue opName(cx);
-  if (!atomValue(binopNames[op], &opName)) {
+  if (!atomValue(binopNames[op], &opName)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1084,7 +1084,7 @@ bool NodeBuilder::unaryExpression(UnaryO
   MOZ_ASSERT(unop > UNOP_ERR && unop < UNOP_LIMIT);
 
   RootedValue opName(cx);
-  if (!atomValue(unopNames[unop], &opName)) {
+  if (!atomValue(unopNames[unop], &opName)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1104,7 +1104,7 @@ bool NodeBuilder::assignmentExpression(A
   MOZ_ASSERT(aop > AOP_ERR && aop < AOP_LIMIT);
 
   RootedValue opName(cx);
-  if (!atomValue(aopNames[aop], &opName)) {
+  if (!atomValue(aopNames[aop], &opName)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1120,7 +1120,7 @@ bool NodeBuilder::assignmentExpression(A
 bool NodeBuilder::updateExpression(HandleValue expr, bool incr, bool prefix,
                                    TokenPos* pos, MutableHandleValue dst) {
   RootedValue opName(cx);
-  if (!atomValue(incr ? "++" : "--", &opName)) {
+  if (!atomValue(incr ? "++" : "--", &opName)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1189,7 +1189,7 @@ bool NodeBuilder::callExpression(HandleV
                                  TokenPos* pos, MutableHandleValue dst,
                                  bool isOptional) {
   RootedValue array(cx);
-  if (!newArray(args, &array)) {
+  if (!newArray(args, &array)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1205,7 +1205,7 @@ bool NodeBuilder::callExpression(HandleV
 bool NodeBuilder::newExpression(HandleValue callee, NodeVector& args,
                                 TokenPos* pos, MutableHandleValue dst) {
   RootedValue array(cx);
-  if (!newArray(args, &array)) {
+  if (!newArray(args, &array)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1241,7 +1241,7 @@ bool NodeBuilder::arrayExpression(NodeVe
 bool NodeBuilder::callSiteObj(NodeVector& raw, NodeVector& cooked,
                               TokenPos* pos, MutableHandleValue dst) {
   RootedValue rawVal(cx);
-  if (!newArray(raw, &rawVal)) {
+  if (!newArray(raw, &rawVal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1294,7 +1294,7 @@ bool NodeBuilder::propertyPattern(Handle
                                   bool isShorthand, TokenPos* pos,
                                   MutableHandleValue dst) {
   RootedValue kindName(cx);
-  if (!atomValue("init", &kindName)) {
+  if (!atomValue("init", &kindName)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1327,7 +1327,7 @@ bool NodeBuilder::propertyInitializer(Ha
   if (!atomValue(kind == PROP_INIT     ? "init"
                  : kind == PROP_GETTER ? "get"
                                        : "set",
-                 &kindName)) {
+                 &kindName)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1381,7 +1381,7 @@ bool NodeBuilder::yieldExpression(Handle
 bool NodeBuilder::importDeclaration(NodeVector& elts, HandleValue moduleSpec,
                                     TokenPos* pos, MutableHandleValue dst) {
   RootedValue array(cx);
-  if (!newArray(elts, &array)) {
+  if (!newArray(elts, &array)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1422,7 +1422,7 @@ bool NodeBuilder::exportDeclaration(Hand
                                     HandleValue isDefault, TokenPos* pos,
                                     MutableHandleValue dst) {
   RootedValue array(cx, NullValue());
-  if (decl.isNull() && !newArray(elts, &array)) {
+  if (decl.isNull() && !newArray(elts, &array)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1450,7 +1450,7 @@ bool NodeBuilder::exportSpecifier(Handle
 
 bool NodeBuilder::exportNamespaceSpecifier(HandleValue exportName,
                                            TokenPos* pos,
-                                           MutableHandleValue dst) {
+                                           MutableHandleValue dst) {MOZ_RELEASE_ASSERT(0);
   RootedValue cb(cx, callbacks[AST_EXPORT_NAMESPACE_SPEC]);
   if (!cb.isNull()) {
     return callback(cb, exportName, pos, dst);
@@ -1476,7 +1476,7 @@ bool NodeBuilder::variableDeclaration(No
   if (!newArray(elts, &array) || !atomValue(kind == VARDECL_CONST ? "const"
                                             : kind == VARDECL_LET ? "let"
                                                                   : "var",
-                                            &kindName)) {
+                                            &kindName)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1502,7 +1502,7 @@ bool NodeBuilder::variableDeclarator(Han
 bool NodeBuilder::switchCase(HandleValue expr, NodeVector& elts, TokenPos* pos,
                              MutableHandleValue dst) {
   RootedValue array(cx);
-  if (!newArray(elts, &array)) {
+  if (!newArray(elts, &array)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1560,10 +1560,10 @@ bool NodeBuilder::function(ASTType type,
                            GeneratorStyle generatorStyle, bool isAsync,
                            bool isExpression, MutableHandleValue dst) {
   RootedValue array(cx), defarray(cx);
-  if (!newArray(args, &array)) {
+  if (!newArray(args, &array)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!newArray(defaults, &defarray)) {
+  if (!newArray(defaults, &defarray)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1573,7 +1573,7 @@ bool NodeBuilder::function(ASTType type,
   RootedValue isExpressionVal(cx, BooleanValue(isExpression));
 
   RootedValue cb(cx, callbacks[type]);
-  if (!cb.isNull()) {
+  if (!cb.isNull()) {MOZ_RELEASE_ASSERT(0);
     return callback(cb, opt(id), array, body, isGeneratorVal, isExpressionVal,
                     pos, dst);
   }
@@ -1603,7 +1603,7 @@ bool NodeBuilder::classMethod(HandleValu
   if (!atomValue(kind == PROP_INIT     ? "method"
                  : kind == PROP_GETTER ? "get"
                                        : "set",
-                 &kindName)) {
+                 &kindName)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1932,7 +1932,7 @@ BinaryOperator ASTSerializer::binop(Pars
 bool ASTSerializer::statements(ListNode* stmtList, NodeVector& elts) {
   MOZ_ASSERT(stmtList->isKind(ParseNodeKind::StatementList));
 
-  if (!elts.reserve(stmtList->count())) {
+  if (!elts.reserve(stmtList->count())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1950,7 +1950,7 @@ bool ASTSerializer::statements(ListNode*
 }
 
 bool ASTSerializer::expressions(ListNode* exprList, NodeVector& elts) {
-  if (!elts.reserve(exprList->count())) {
+  if (!elts.reserve(exprList->count())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2031,7 +2031,7 @@ bool ASTSerializer::variableDeclaration(
   }
 
   NodeVector dtors(cx);
-  if (!dtors.reserve(declList->count())) {
+  if (!dtors.reserve(declList->count())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (ParseNode* decl : declList->contents()) {
@@ -2079,7 +2079,7 @@ bool ASTSerializer::importDeclaration(Bi
   MOZ_ASSERT(moduleSpecNode->isKind(ParseNodeKind::StringExpr));
 
   NodeVector elts(cx);
-  if (!elts.reserve(specList->count())) {
+  if (!elts.reserve(specList->count())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2087,7 +2087,7 @@ bool ASTSerializer::importDeclaration(Bi
     RootedValue elt(cx);
     if (item->is<UnaryNode>()) {
       auto* spec = &item->as<UnaryNode>();
-      if (!importNamespaceSpecifier(spec, &elt)) {
+      if (!importNamespaceSpecifier(spec, &elt)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -2204,7 +2204,7 @@ bool ASTSerializer::exportDeclaration(Pa
 
   RootedValue moduleSpec(cx, NullValue());
   if (exportNode->isKind(ParseNodeKind::ExportFromStmt)) {
-    if (!literal(exportNode->as<BinaryNode>().right(), &moduleSpec)) {
+    if (!literal(exportNode->as<BinaryNode>().right(), &moduleSpec)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2262,7 +2262,7 @@ bool ASTSerializer::switchStatement(Swit
       switchStmt->pn_pos.encloses(switchStmt->lexicalForCaseList().pn_pos));
 
   RootedValue disc(cx);
-  if (!expression(&switchStmt->discriminant(), &disc)) {
+  if (!expression(&switchStmt->discriminant(), &disc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2270,7 +2270,7 @@ bool ASTSerializer::switchStatement(Swit
       &switchStmt->lexicalForCaseList().scopeBody()->as<ListNode>();
 
   NodeVector cases(cx);
-  if (!cases.reserve(caseList->count())) {
+  if (!cases.reserve(caseList->count())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2317,7 +2317,7 @@ bool ASTSerializer::tryStatement(TryNode
   MOZ_ASSERT_IF(finallyNode, tryNode->pn_pos.encloses(finallyNode->pn_pos));
 
   RootedValue body(cx);
-  if (!statement(bodyNode, &body)) {
+  if (!statement(bodyNode, &body)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2382,7 +2382,7 @@ bool ASTSerializer::classDefinition(Clas
 }
 
 bool ASTSerializer::statement(ParseNode* pn, MutableHandleValue dst) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2688,7 +2688,7 @@ bool ASTSerializer::classField(ClassFiel
   // node, but rather a variable reference.
   // Behavior for "there is no initializer" should be { ..., "init": null }
   if (value->getKind() != ParseNodeKind::RawUndefinedExpr) {
-    if (!expression(value, &val)) {
+    if (!expression(value, &val)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -2708,19 +2708,19 @@ bool ASTSerializer::leftAssociate(ListNo
 
   ParseNode* head = node->head();
   RootedValue left(cx);
-  if (!expression(head, &left)) {
+  if (!expression(head, &left)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (ParseNode* next : node->contentsFrom(head->pn_next)) {
     RootedValue right(cx);
-    if (!expression(next, &right)) {
+    if (!expression(next, &right)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     TokenPos subpos(node->pn_pos.begin, next->pn_pos.end);
 
     if (logop) {
-      if (!builder.logicalExpression(pnk, left, right, &subpos, &left)) {
+      if (!builder.logicalExpression(pnk, left, right, &subpos, &left)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -2758,12 +2758,12 @@ bool ASTSerializer::rightAssociate(ListN
   head = prev;
 
   RootedValue right(cx);
-  if (!expression(head, &right)) {
+  if (!expression(head, &right)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (ParseNode* next = head->pn_next; next; next = next->pn_next) {
     RootedValue left(cx);
-    if (!expression(next, &left)) {
+    if (!expression(next, &left)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2782,7 +2782,7 @@ bool ASTSerializer::rightAssociate(ListN
 }
 
 bool ASTSerializer::expression(ParseNode* pn, MutableHandleValue dst) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3410,7 +3410,7 @@ bool ASTSerializer::arrayPattern(ListNod
   MOZ_ASSERT(array->isKind(ParseNodeKind::ArrayExpr));
 
   NodeVector elts(cx);
-  if (!elts.reserve(array->count())) {
+  if (!elts.reserve(array->count())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3420,9 +3420,9 @@ bool ASTSerializer::arrayPattern(ListNod
     } else if (item->isKind(ParseNodeKind::Spread)) {
       RootedValue target(cx);
       RootedValue spread(cx);
-      if (!pattern(item->as<UnaryNode>().kid(), &target)) {
+      if (!pattern(item->as<UnaryNode>().kid(), &target)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       if (!builder.spreadExpression(target, &item->pn_pos, &spread))
         return false;
       elts.infallibleAppend(spread);
@@ -3442,7 +3442,7 @@ bool ASTSerializer::objectPattern(ListNo
   MOZ_ASSERT(obj->isKind(ParseNodeKind::ObjectExpr));
 
   NodeVector elts(cx);
-  if (!elts.reserve(obj->count())) {
+  if (!elts.reserve(obj->count())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3450,9 +3450,9 @@ bool ASTSerializer::objectPattern(ListNo
     if (propdef->isKind(ParseNodeKind::Spread)) {
       RootedValue target(cx);
       RootedValue spread(cx);
-      if (!pattern(propdef->as<UnaryNode>().kid(), &target)) {
+      if (!pattern(propdef->as<UnaryNode>().kid(), &target)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       if (!builder.spreadExpression(target, &propdef->pn_pos, &spread))
         return false;
       elts.infallibleAppend(spread);
@@ -3465,15 +3465,15 @@ bool ASTSerializer::objectPattern(ListNo
 
     RootedValue key(cx);
     ParseNode* target;
-    if (propdef->isKind(ParseNodeKind::MutateProto)) {
+    if (propdef->isKind(ParseNodeKind::MutateProto)) {MOZ_RELEASE_ASSERT(0);
       RootedValue pname(cx, StringValue(cx->names().proto));
-      if (!builder.literal(pname, &propdef->pn_pos, &key)) {
+      if (!builder.literal(pname, &propdef->pn_pos, &key)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       target = propdef->as<UnaryNode>().kid();
     } else {
       BinaryNode* prop = &propdef->as<BinaryNode>();
-      if (!propertyName(prop->left(), &key)) {
+      if (!propertyName(prop->left(), &key)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       target = prop->right();
@@ -3494,7 +3494,7 @@ bool ASTSerializer::objectPattern(ListNo
 }
 
 bool ASTSerializer::pattern(ParseNode* pn, MutableHandleValue dst) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3547,11 +3547,11 @@ bool ASTSerializer::function(FunctionNod
   RootedAtom funcAtom(cx);
   if (funbox->explicitName()) {
     funcAtom.set(parser->liftParserAtomToJSAtom(funbox->explicitName()));
-    if (!funcAtom) {
+    if (!funcAtom) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
-  if (!optIdentifier(funcAtom, nullptr, &id)) {
+  if (!optIdentifier(funcAtom, nullptr, &id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3582,7 +3582,7 @@ bool ASTSerializer::functionArgsAndBody(
   if (pn->isKind(ParseNodeKind::ParamsBody)) {
     argsList = &pn->as<ListNode>();
     bodyNode = argsList->last();
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     argsList = nullptr;
     bodyNode = pn;
   }
@@ -3627,7 +3627,7 @@ bool ASTSerializer::functionArgsAndBody(
 bool ASTSerializer::functionArgs(ParseNode* pn, ListNode* argsList,
                                  NodeVector& args, NodeVector& defaults,
                                  MutableHandleValue rest) {
-  if (!argsList) {
+  if (!argsList) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -3656,13 +3656,13 @@ bool ASTSerializer::functionArgs(ParseNo
     MOZ_ASSERT(pat->isKind(ParseNodeKind::Name) ||
                pat->isKind(ParseNodeKind::ArrayExpr) ||
                pat->isKind(ParseNodeKind::ObjectExpr));
-    if (!pattern(pat, &node)) {
+    if (!pattern(pat, &node)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (rest.isUndefined() && arg->pn_next == argsList->last()) {
       rest.setObject(node.toObject());
     } else {
-      if (!args.append(node)) {
+      if (!args.append(node)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -3671,11 +3671,11 @@ bool ASTSerializer::functionArgs(ParseNo
     if (defNode) {
       defaultsNull = false;
       RootedValue def(cx);
-      if (!expression(defNode, &def) || !defaults.append(def)) {
+      if (!expression(defNode, &def) || !defaults.append(def)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
-      if (!defaults.append(NullValue())) {
+      if (!defaults.append(NullValue())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -3711,12 +3711,12 @@ bool ASTSerializer::functionBody(ParseNo
 static bool reflect_parse(JSContext* cx, uint32_t argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (!args.requireAtLeast(cx, "Reflect.parse", 1)) {
+  if (!args.requireAtLeast(cx, "Reflect.parse", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedString src(cx, ToString<CanGC>(cx, args[0]));
-  if (!src) {
+  if (!src) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3729,7 +3729,7 @@ static bool reflect_parse(JSContext* cx,
   RootedValue arg(cx, args.get(1));
 
   if (!arg.isNullOrUndefined()) {
-    if (!arg.isObject()) {
+    if (!arg.isObject()) {MOZ_RELEASE_ASSERT(0);
       ReportValueError(cx, JSMSG_UNEXPECTED_TYPE, JSDVG_SEARCH_STACK, arg,
                        nullptr, "not an object");
       return false;
@@ -3742,7 +3742,7 @@ static bool reflect_parse(JSContext* cx,
     /* config.loc */
     RootedId locId(cx, NameToId(cx->names().loc));
     RootedValue trueVal(cx, BooleanValue(true));
-    if (!GetPropertyDefault(cx, config, locId, trueVal, &prop)) {
+    if (!GetPropertyDefault(cx, config, locId, trueVal, &prop)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3752,18 +3752,18 @@ static bool reflect_parse(JSContext* cx,
       /* config.source */
       RootedId sourceId(cx, NameToId(cx->names().source));
       RootedValue nullVal(cx, NullValue());
-      if (!GetPropertyDefault(cx, config, sourceId, nullVal, &prop)) {
+      if (!GetPropertyDefault(cx, config, sourceId, nullVal, &prop)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       if (!prop.isNullOrUndefined()) {
         RootedString str(cx, ToString<CanGC>(cx, prop));
-        if (!str) {
+        if (!str) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         filename = EncodeLatin1(cx, str);
-        if (!filename) {
+        if (!filename) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -3772,7 +3772,7 @@ static bool reflect_parse(JSContext* cx,
       RootedId lineId(cx, NameToId(cx->names().line));
       RootedValue oneValue(cx, Int32Value(1));
       if (!GetPropertyDefault(cx, config, lineId, oneValue, &prop) ||
-          !ToUint32(cx, prop, &lineno)) {
+          !ToUint32(cx, prop, &lineno)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -3780,27 +3780,27 @@ static bool reflect_parse(JSContext* cx,
     /* config.builder */
     RootedId builderId(cx, NameToId(cx->names().builder));
     RootedValue nullVal(cx, NullValue());
-    if (!GetPropertyDefault(cx, config, builderId, nullVal, &prop)) {
+    if (!GetPropertyDefault(cx, config, builderId, nullVal, &prop)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (!prop.isNullOrUndefined()) {
-      if (!prop.isObject()) {
+      if (!prop.isObject()) {MOZ_RELEASE_ASSERT(0);
         ReportValueError(cx, JSMSG_UNEXPECTED_TYPE, JSDVG_SEARCH_STACK, prop,
                          nullptr, "not an object");
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       builder = &prop.toObject();
     }
 
     /* config.target */
     RootedId targetId(cx, NameToId(cx->names().target));
     RootedValue scriptVal(cx, StringValue(cx->names().script));
-    if (!GetPropertyDefault(cx, config, targetId, scriptVal, &prop)) {
+    if (!GetPropertyDefault(cx, config, targetId, scriptVal, &prop)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!prop.isString()) {
+    if (!prop.isString()) {MOZ_RELEASE_ASSERT(0);
       ReportValueError(cx, JSMSG_UNEXPECTED_TYPE, JSDVG_SEARCH_STACK, prop,
                        nullptr, "not 'script' or 'module'");
       return false;
@@ -3809,11 +3809,11 @@ static bool reflect_parse(JSContext* cx,
     RootedString stringProp(cx, prop.toString());
     bool isScript = false;
     bool isModule = false;
-    if (!EqualStrings(cx, stringProp, cx->names().script, &isScript)) {
+    if (!EqualStrings(cx, stringProp, cx->names().script, &isScript)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!EqualStrings(cx, stringProp, cx->names().module, &isModule)) {
+    if (!EqualStrings(cx, stringProp, cx->names().module, &isModule)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3821,7 +3821,7 @@ static bool reflect_parse(JSContext* cx,
       target = ParseGoal::Script;
     } else if (isModule) {
       target = ParseGoal::Module;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx,
                           "Bad target value, expected 'script' or 'module'");
       return false;
@@ -3830,17 +3830,17 @@ static bool reflect_parse(JSContext* cx,
 
   /* Extract the builder methods first to report errors before parsing. */
   ASTSerializer serialize(cx, loc, filename.get(), lineno);
-  if (!serialize.init(builder)) {
+  if (!serialize.init(builder)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JSLinearString* linear = src->ensureLinear(cx);
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   AutoStableStringChars linearChars(cx);
-  if (!linearChars.initTwoByte(cx, linear)) {
+  if (!linearChars.initTwoByte(cx, linear)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3852,18 +3852,18 @@ static bool reflect_parse(JSContext* cx,
 
   Rooted<CompilationInput> input(cx, CompilationInput(options));
   if (target == ParseGoal::Script) {
-    if (!input.get().initForGlobal(cx)) {
+    if (!input.get().initForGlobal(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
-    if (!input.get().initForModule(cx)) {
+    if (!input.get().initForModule(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   LifoAllocScope allocScope(&cx->tempLifoAlloc());
   frontend::CompilationState compilationState(cx, allocScope, input.get());
-  if (!compilationState.init(cx)) {
+  if (!compilationState.init(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3871,7 +3871,7 @@ static bool reflect_parse(JSContext* cx,
       cx, options, chars.begin().get(), chars.length(),
       /* foldConstants = */ false, compilationState,
       /* syntaxParser = */ nullptr);
-  if (!parser.checkOptions()) {
+  if (!parser.checkOptions()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3884,7 +3884,7 @@ static bool reflect_parse(JSContext* cx,
       return false;
     }
   } else {
-    if (!GlobalObject::ensureModulePrototypesCreated(cx, cx->global())) {
+    if (!GlobalObject::ensureModulePrototypesCreated(cx, cx->global())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3914,7 +3914,7 @@ static bool reflect_parse(JSContext* cx,
 
 JS_PUBLIC_API bool JS_InitReflectParse(JSContext* cx, HandleObject global) {
   RootedValue reflectVal(cx);
-  if (!GetProperty(cx, global, global, cx->names().Reflect, &reflectVal)) {
+  if (!GetProperty(cx, global, global, cx->names().Reflect, &reflectVal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!reflectVal.isObject()) {
diff --git a/js/src/builtin/RegExp.cpp b/js/src/builtin/RegExp.cpp
--- a/js/src/builtin/RegExp.cpp
+++ b/js/src/builtin/RegExp.cpp
@@ -84,7 +84,7 @@ bool js::CreateRegExpMatchResult(JSConte
                  : RegExpRealm::ResultTemplateKind::Normal;
   ArrayObject* templateObject =
       cx->realm()->regExps.getOrCreateMatchResultTemplateObject(cx, kind);
-  if (!templateObject) {
+  if (!templateObject) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -95,7 +95,7 @@ bool js::CreateRegExpMatchResult(JSConte
   // Steps 20-21: Allocate the match result object.
   RootedArrayObject arr(cx, NewDenseFullyAllocatedArrayWithTemplate(
                                 cx, numPairs, templateObject));
-  if (!arr) {
+  if (!arr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -111,7 +111,7 @@ bool js::CreateRegExpMatchResult(JSConte
     } else {
       JSLinearString* str =
           NewDependentString(cx, input, pair.start, pair.length());
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       arr->setDenseInitializedLength(i + 1);
@@ -131,7 +131,7 @@ bool js::CreateRegExpMatchResult(JSConte
             cx, RegExpRealm::ResultTemplateKind::Indices);
     indices =
         NewDenseFullyAllocatedArrayWithTemplate(cx, numPairs, indicesTemplate);
-    if (!indices) {
+    if (!indices) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -139,7 +139,7 @@ bool js::CreateRegExpMatchResult(JSConte
     if (re->numNamedCaptures() > 0) {
       RootedPlainObject groupsTemplate(cx, re->getGroupsTemplate());
       indicesGroups = CreateGroupsObject(cx, groupsTemplate);
-      if (!indicesGroups) {
+      if (!indicesGroups) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       indices->setSlot(RegExpRealm::IndicesGroupsSlot,
@@ -159,7 +159,7 @@ bool js::CreateRegExpMatchResult(JSConte
         indices->initDenseElement(i, UndefinedValue());
       } else {
         RootedArrayObject indexPair(cx, NewDenseFullyAllocatedArray(cx, 2));
-        if (!indexPair) {
+        if (!indexPair) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         indexPair->setDenseInitializedLength(2);
@@ -179,7 +179,7 @@ bool js::CreateRegExpMatchResult(JSConte
     RootedPlainObject groupsTemplate(cx, re->getGroupsTemplate());
     groupsInDictionaryMode = groupsTemplate->inDictionaryMode();
     groups = CreateGroupsObject(cx, groupsTemplate);
-    if (!groups) {
+    if (!groups) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -194,7 +194,7 @@ bool js::CreateRegExpMatchResult(JSConte
   if (groupsInDictionaryMode) {
     RootedIdVector keys(cx);
     RootedPlainObject groupsTemplate(cx, re->getGroupsTemplate());
-    if (!GetPropertyKeys(cx, groupsTemplate, 0, &keys)) {
+    if (!GetPropertyKeys(cx, groupsTemplate, 0, &keys)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     MOZ_ASSERT(keys.length() == re->numNamedCaptures());
@@ -204,14 +204,14 @@ bool js::CreateRegExpMatchResult(JSConte
       key = keys[i];
       uint32_t idx = re->getNamedCaptureIndex(i);
       val = arr->getDenseElement(idx);
-      if (!NativeDefineDataProperty(cx, groups, key, val, JSPROP_ENUMERATE)) {
+      if (!NativeDefineDataProperty(cx, groups, key, val, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       // MakeIndicesArray: Step 13.e (reordered)
       if (hasIndices) {
         val = indices->getDenseElement(idx);
         if (!NativeDefineDataProperty(cx, indicesGroups, key, val,
-                                      JSPROP_ENUMERATE)) {
+                                      JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -304,7 +304,7 @@ bool js::ExecuteRegExpLegacy(JSContext* 
                              HandleLinearString input, size_t* lastIndex,
                              bool test, MutableHandleValue rval) {
   RootedRegExpShared shared(cx, RegExpObject::getShared(cx, reobj));
-  if (!shared) {
+  if (!shared) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -432,7 +432,7 @@ bool js::RegExpCreate(JSContext* cx, Han
                       HandleValue flagsValue, MutableHandleValue rval) {
   /* Step 1. */
   Rooted<RegExpObject*> regexp(cx, RegExpAlloc(cx, GenericObject));
-  if (!regexp) {
+  if (!regexp) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -493,7 +493,7 @@ MOZ_ALWAYS_INLINE bool regexp_compile_im
   // Step 3.
   RootedValue patternValue(cx, args.get(0));
   ESClass cls;
-  if (!GetClassOfValue(cx, patternValue, &cls)) {
+  if (!GetClassOfValue(cx, patternValue, &cls)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (cls == ESClass::RegExp) {
@@ -514,7 +514,7 @@ MOZ_ALWAYS_INLINE bool regexp_compile_im
     {
       // Step 3b.
       RegExpShared* shared = RegExpToShared(cx, patternObj);
-      if (!shared) {
+      if (!shared) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -599,7 +599,7 @@ bool js::regexp_construct(JSContext* cx,
 
   // Step 4.
   ESClass cls;
-  if (!GetClassOfValue(cx, patternValue, &cls)) {
+  if (!GetClassOfValue(cx, patternValue, &cls)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (cls == ESClass::RegExp) {
@@ -613,7 +613,7 @@ bool js::regexp_construct(JSContext* cx,
     {
       // Step 4.a.
       shared = RegExpToShared(cx, patternObj);
-      if (!shared) {
+      if (!shared) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       sourceAtom = shared->getSource();
@@ -623,19 +623,19 @@ bool js::regexp_construct(JSContext* cx,
       flags = shared->getFlags();
 
       // If the RegExpShared is in another Zone, don't reuse it.
-      if (cx->zone() != shared->zone()) {
+      if (cx->zone() != shared->zone()) {MOZ_RELEASE_ASSERT(0);
         shared = nullptr;
       }
     }
 
     // Step 7.
     RootedObject proto(cx);
-    if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_RegExp, &proto)) {
+    if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_RegExp, &proto)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     Rooted<RegExpObject*> regexp(cx, RegExpAlloc(cx, GenericObject, proto));
-    if (!regexp) {
+    if (!regexp) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -644,7 +644,7 @@ bool js::regexp_construct(JSContext* cx,
       // Step 4.c / 21.2.3.2.2 RegExpInitialize step 4.
       RegExpFlags flagsArg = RegExpFlag::NoFlags;
       RootedString flagStr(cx, ToString<CanGC>(cx, args[1]));
-      if (!flagStr) {
+      if (!flagStr) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (!ParseRegExpFlags(cx, flagStr, &flagsArg)) {
@@ -664,7 +664,7 @@ bool js::regexp_construct(JSContext* cx,
         shared = CheckPatternSyntax(cx, sourceAtom, flagsArg);
         if (!shared) {
           return false;
-        }
+        }MOZ_RELEASE_ASSERT(0);
       }
       flags = flagsArg;
     }
@@ -711,7 +711,7 @@ bool js::regexp_construct(JSContext* cx,
   }
 
   Rooted<RegExpObject*> regexp(cx, RegExpAlloc(cx, GenericObject, proto));
-  if (!regexp) {
+  if (!regexp) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -736,7 +736,7 @@ bool js::regexp_construct_raw_flags(JSCo
 
   // Step 4.a.
   RootedAtom sourceAtom(cx, AtomizeString(cx, args[0].toString()));
-  if (!sourceAtom) {
+  if (!sourceAtom) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -767,7 +767,7 @@ static bool RegExpGetter(JSContext* cx, 
     obj = &args.thisv().toObject();
     if (IsWrapper(obj)) {
       obj = CheckedUnwrapStatic(obj);
-      if (!obj) {
+      if (!obj) {MOZ_RELEASE_ASSERT(0);
         ReportAccessDenied(cx);
         return false;
       }
@@ -975,7 +975,7 @@ DEFINE_STATIC_GETTER(static_paren9_gette
 static bool static_input_setter(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
   RegExpStatics* res = GlobalObject::getRegExpStatics(cx, cx->global());
-  if (!res) {
+  if (!res) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1056,7 +1056,7 @@ static RegExpRunStatus ExecuteRegExp(JSC
   Handle<RegExpObject*> reobj = regexp.as<RegExpObject>();
 
   RootedRegExpShared re(cx, RegExpObject::getShared(cx, reobj));
-  if (!re) {
+  if (!re) {MOZ_RELEASE_ASSERT(0);
     return RegExpRunStatus_Error;
   }
 
@@ -1066,7 +1066,7 @@ static RegExpRunStatus ExecuteRegExp(JSC
   }
 
   RootedLinearString input(cx, string->ensureLinear(cx));
-  if (!input) {
+  if (!input) {MOZ_RELEASE_ASSERT(0);
     return RegExpRunStatus_Error;
   }
 
@@ -1416,7 +1416,7 @@ static bool InterpretDollar(JSLinearStri
     const CharT* nameEnd = js_strchr_limit(nameStart, '>', replacementEnd);
 
     // Step 2.c
-    if (!nameEnd) {
+    if (!nameEnd) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1598,7 +1598,7 @@ static bool CollectNames(JSContext* cx, 
       // Step 2.d.i
       size_t nameLength = nameEnd - nameStart;
       JSAtom* atom = AtomizeChars(cx, nameStart, nameLength);
-      if (!atom || !names.append(AtomToId(atom))) {
+      if (!atom || !names.append(AtomToId(atom))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       currentDollar = nameEnd + 1;
@@ -1630,11 +1630,11 @@ static bool InitNamedCaptures(JSContext*
                               MutableHandle<CapturesVector> namedCaptures) {
   Rooted<GCVector<jsid>> names(cx);
   if (replacement->hasLatin1Chars()) {
-    if (!CollectNames<Latin1Char>(cx, replacement, firstDollarIndex, &names)) {
+    if (!CollectNames<Latin1Char>(cx, replacement, firstDollarIndex, &names)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
-    if (!CollectNames<char16_t>(cx, replacement, firstDollarIndex, &names)) {
+    if (!CollectNames<char16_t>(cx, replacement, firstDollarIndex, &names)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1653,7 +1653,7 @@ static bool InitNamedCaptures(JSContext*
 
     // Step 2.d.iii
     if (capture.isUndefined()) {
-      if (!namedCaptures.append(capture)) {
+      if (!namedCaptures.append(capture)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -1663,7 +1663,7 @@ static bool InitNamedCaptures(JSContext*
         return false;
       }
       JSLinearString* linear = str->ensureLinear(cx);
-      if (!linear) {
+      if (!linear) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (!namedCaptures.append(StringValue(linear))) {
@@ -1729,7 +1729,7 @@ bool js::RegExpGetSubstitution(JSContext
 
   const Value& matchedValue = matchResult->getDenseElement(0);
   RootedLinearString matched(cx, matchedValue.toString()->ensureLinear(cx));
-  if (!matched) {
+  if (!matched) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1743,7 +1743,7 @@ bool js::RegExpGetSubstitution(JSContext
 
   uint32_t nCaptures = matchResultLength - 1;
   Rooted<CapturesVector> captures(cx, CapturesVector(cx));
-  if (!captures.reserve(nCaptures)) {
+  if (!captures.reserve(nCaptures)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1757,7 +1757,7 @@ bool js::RegExpGetSubstitution(JSContext
     }
 
     JSLinearString* captureLinear = capture.toString()->ensureLinear(cx);
-    if (!captureLinear) {
+    if (!captureLinear) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     captures.infallibleAppend(StringValue(captureLinear));
@@ -1780,7 +1780,7 @@ bool js::RegExpGetSubstitution(JSContext
   CheckedInt<uint32_t> checkedTailPos(0);
   checkedTailPos += position;
   checkedTailPos += matchLength;
-  if (!checkedTailPos.isValid()) {
+  if (!checkedTailPos.isValid()) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return false;
   }
@@ -1796,12 +1796,12 @@ bool js::RegExpGetSubstitution(JSContext
 
   JSStringBuilder result(cx);
   if (NeedTwoBytes(string, replacement, matched, captures, namedCaptures)) {
-    if (!result.ensureTwoByteChars()) {
+    if (!result.ensureTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!result.reserve(reserveLength)) {
+  if (!result.reserve(reserveLength)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1886,7 +1886,7 @@ bool js::RegExpPrototypeOptimizable(JSCo
 bool js::RegExpPrototypeOptimizableRaw(JSContext* cx, JSObject* proto) {
   AutoUnsafeCallWithABI unsafe;
   AutoAssertNoPendingException aanpe(cx);
-  if (!proto->is<NativeObject>()) {
+  if (!proto->is<NativeObject>()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1898,7 +1898,7 @@ bool js::RegExpPrototypeOptimizableRaw(J
   }
 
   JSFunction* flagsGetter;
-  if (!GetOwnGetterPure(cx, proto, NameToId(cx->names().flags), &flagsGetter)) {
+  if (!GetOwnGetterPure(cx, proto, NameToId(cx->names().flags), &flagsGetter)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1907,53 +1907,53 @@ bool js::RegExpPrototypeOptimizableRaw(J
   }
 
   if (!IsSelfHostedFunctionWithName(flagsGetter,
-                                    cx->names().RegExpFlagsGetter)) {
+                                    cx->names().RegExpFlagsGetter)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JSNative globalGetter;
   if (!GetOwnNativeGetterPure(cx, proto, NameToId(cx->names().global),
-                              &globalGetter)) {
+                              &globalGetter)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (globalGetter != regexp_global) {
+  if (globalGetter != regexp_global) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JSNative hasIndicesGetter;
   if (!GetOwnNativeGetterPure(cx, proto, NameToId(cx->names().hasIndices),
-                              &hasIndicesGetter)) {
+                              &hasIndicesGetter)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (hasIndicesGetter != regexp_hasIndices) {
+  if (hasIndicesGetter != regexp_hasIndices) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JSNative ignoreCaseGetter;
   if (!GetOwnNativeGetterPure(cx, proto, NameToId(cx->names().ignoreCase),
-                              &ignoreCaseGetter)) {
+                              &ignoreCaseGetter)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (ignoreCaseGetter != regexp_ignoreCase) {
+  if (ignoreCaseGetter != regexp_ignoreCase) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JSNative multilineGetter;
   if (!GetOwnNativeGetterPure(cx, proto, NameToId(cx->names().multiline),
-                              &multilineGetter)) {
+                              &multilineGetter)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (multilineGetter != regexp_multiline) {
+  if (multilineGetter != regexp_multiline) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JSNative stickyGetter;
   if (!GetOwnNativeGetterPure(cx, proto, NameToId(cx->names().sticky),
-                              &stickyGetter)) {
+                              &stickyGetter)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1963,7 +1963,7 @@ bool js::RegExpPrototypeOptimizableRaw(J
 
   JSNative unicodeGetter;
   if (!GetOwnNativeGetterPure(cx, proto, NameToId(cx->names().unicode),
-                              &unicodeGetter)) {
+                              &unicodeGetter)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1973,11 +1973,11 @@ bool js::RegExpPrototypeOptimizableRaw(J
 
   JSNative dotAllGetter;
   if (!GetOwnNativeGetterPure(cx, proto, NameToId(cx->names().dotAll),
-                              &dotAllGetter)) {
+                              &dotAllGetter)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (dotAllGetter != regexp_dotAll) {
+  if (dotAllGetter != regexp_dotAll) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1985,7 +1985,7 @@ bool js::RegExpPrototypeOptimizableRaw(J
   // those values should be tested in selfhosted JS.
   bool has = false;
   if (!HasOwnDataPropertyPure(
-          cx, proto, SYMBOL_TO_JSID(cx->wellKnownSymbols().match), &has)) {
+          cx, proto, SYMBOL_TO_JSID(cx->wellKnownSymbols().match), &has)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!has) {
@@ -1993,14 +1993,14 @@ bool js::RegExpPrototypeOptimizableRaw(J
   }
 
   if (!HasOwnDataPropertyPure(
-          cx, proto, SYMBOL_TO_JSID(cx->wellKnownSymbols().search), &has)) {
+          cx, proto, SYMBOL_TO_JSID(cx->wellKnownSymbols().search), &has)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!has) {
     return false;
   }
 
-  if (!HasOwnDataPropertyPure(cx, proto, NameToId(cx->names().exec), &has)) {
+  if (!HasOwnDataPropertyPure(cx, proto, NameToId(cx->names().exec), &has)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!has) {
@@ -2034,7 +2034,7 @@ bool js::RegExpInstanceOptimizableRaw(JS
     return true;
   }
 
-  if (!rx->hasStaticPrototype()) {
+  if (!rx->hasStaticPrototype()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2066,7 +2066,7 @@ bool js::intrinsic_GetElemBaseForLambda(
   JSObject& lambda = args[0].toObject();
   args.rval().setUndefined();
 
-  if (!lambda.is<JSFunction>()) {
+  if (!lambda.is<JSFunction>()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -2076,7 +2076,7 @@ bool js::intrinsic_GetElemBaseForLambda(
   }
 
   JSScript* script = JSFunction::getOrCreateScript(cx, fun);
-  if (!script) {
+  if (!script) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2092,7 +2092,7 @@ bool js::intrinsic_GetElemBaseForLambda(
   }
   EnvironmentCoordinate ec(pc);
   EnvironmentObject* env = &fun->environment()->as<EnvironmentObject>();
-  for (unsigned i = 0; i < ec.hops(); ++i) {
+  for (unsigned i = 0; i < ec.hops(); ++i) {MOZ_RELEASE_ASSERT(0);
     env = &env->enclosingEnvironment().as<EnvironmentObject>();
   }
   Value b = env->aliasedBinding(ec);
@@ -2105,18 +2105,18 @@ bool js::intrinsic_GetElemBaseForLambda(
   pc += JSOpLength_GetArg;
 
   /* 'b[a]' */
-  if (JSOp(*pc) != JSOp::GetElem) {
+  if (JSOp(*pc) != JSOp::GetElem) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
   pc += JSOpLength_GetElem;
 
   /* 'return b[a]' */
-  if (JSOp(*pc) != JSOp::Return) {
+  if (JSOp(*pc) != JSOp::Return) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   /* 'b' must behave like a normal object. */
-  if (!b.isObject()) {
+  if (!b.isObject()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -2151,7 +2151,7 @@ bool js::intrinsic_GetStringDataProperty
   }
 
   JSAtom* atom = AtomizeString(cx, args[1].toString());
-  if (!atom) {
+  if (!atom) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/builtin/Stream.cpp b/js/src/builtin/Stream.cpp
--- a/js/src/builtin/Stream.cpp
+++ b/js/src/builtin/Stream.cpp
@@ -260,7 +260,7 @@ class MOZ_RAII AutoClearUnderlyingSource
   // Done elsewhere in the standard: Create the controller object.
   Rooted<ReadableByteStreamController*> controller(
       cx, NewBuiltinClassInstance<ReadableByteStreamController>(cx));
-  if (!controller) {
+  if (!controller) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -309,7 +309,7 @@ class MOZ_RAII AutoClearUnderlyingSource
   // Step 12: Set this.[[pendingPullIntos]] to a new empty List.
   if (!StoreNewListInFixedSlot(
           cx, controller,
-          ReadableByteStreamController::Slot_PendingPullIntos)) {
+          ReadableByteStreamController::Slot_PendingPullIntos)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -320,7 +320,7 @@ class MOZ_RAII AutoClearUnderlyingSource
   // (For external sources, this algorithm does nothing and returns undefined.)
   // Step 15: Let startPromise be a promise resolved with startResult.
   Rooted<PromiseObject*> startPromise(cx, PromiseResolvedWithUndefined(cx));
-  if (!startPromise) {
+  if (!startPromise) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -328,13 +328,13 @@ class MOZ_RAII AutoClearUnderlyingSource
   // Step 17: Upon rejection of startPromise with reason r, [...]
   RootedObject onStartFulfilled(
       cx, NewHandler(cx, ReadableStreamControllerStartHandler, controller));
-  if (!onStartFulfilled) {
+  if (!onStartFulfilled) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedObject onStartRejected(
       cx,
       NewHandler(cx, ReadableStreamControllerStartFailedHandler, controller));
-  if (!onStartRejected) {
+  if (!onStartRejected) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!JS::AddPromiseReactions(cx, startPromise, onStartFulfilled,
@@ -357,7 +357,7 @@ static void ReadableByteStreamController
       obj->as<ReadableByteStreamController>();
 
   if (controller.getFixedSlot(ReadableStreamController::Slot_Flags)
-          .isUndefined()) {
+          .isUndefined()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -429,7 +429,7 @@ JS_STREAMS_CLASS_SPEC(ReadableByteStream
           unwrappedController->externalSource();
 
       view = JS_NewUint8Array(cx, queueTotalSize);
-      if (!view) {
+      if (!view) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -490,7 +490,7 @@ JS_STREAMS_CLASS_SPEC(ReadableByteStream
     // Step 3.e: Perform ! ReadableByteStreamControllerHandleQueueDrain(this).
     // (reordered)
     if (!ReadableByteStreamControllerHandleQueueDrain(cx,
-                                                      unwrappedController)) {
+                                                      unwrappedController)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -499,13 +499,13 @@ JS_STREAMS_CLASS_SPEC(ReadableByteStream
     val.setObject(*view);
     ReadableStreamReader* unwrappedReader =
         UnwrapReaderFromStream(cx, unwrappedStream);
-    if (!unwrappedReader) {
+    if (!unwrappedReader) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     Rooted<PlainObject*> readResult(
         cx, ReadableStreamCreateReadResult(cx, val, false,
                                            unwrappedReader->forAuthorCode()));
-    if (!readResult) {
+    if (!readResult) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     val.setObject(*readResult);
@@ -517,7 +517,7 @@ JS_STREAMS_CLASS_SPEC(ReadableByteStream
   val = unwrappedController->autoAllocateChunkSize();
 
   // Step 5: If autoAllocateChunkSize is not undefined,
-  if (!val.isUndefined()) {
+  if (!val.isUndefined()) {MOZ_RELEASE_ASSERT(0);
     double autoAllocateChunkSize = val.toNumber();
 
     // Step 5.a: Let buffer be
@@ -526,9 +526,9 @@ JS_STREAMS_CLASS_SPEC(ReadableByteStream
 
     // Step 5.b: If buffer is an abrupt completion,
     //           return a promise rejected with buffer.[[Value]].
-    if (!bufferObj) {
+    if (!bufferObj) {MOZ_RELEASE_ASSERT(0);
       return PromiseRejectedWithPendingError(cx);
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     RootedArrayBufferObject buffer(cx, &bufferObj->as<ArrayBufferObject>());
 
@@ -543,25 +543,25 @@ JS_STREAMS_CLASS_SPEC(ReadableByteStream
     RootedObject pullIntoDescriptor(
         cx, PullIntoDescriptor::create(cx, buffer, 0, autoAllocateChunkSize, 0,
                                        1, nullptr, ReaderType::Default));
-    if (!pullIntoDescriptor) {
+    if (!pullIntoDescriptor) {MOZ_RELEASE_ASSERT(0);
       return PromiseRejectedWithPendingError(cx);
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Step 5.d: Append pullIntoDescriptor as the last element of
     //           this.[[pendingPullIntos]].
     if (!AppendToListInFixedSlot(
             cx, unwrappedController,
             ReadableByteStreamController::Slot_PendingPullIntos,
-            pullIntoDescriptor)) {
+            pullIntoDescriptor)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   // Step 6: Let promise be ! ReadableStreamAddReadRequest(stream,
   //                                                       forAuthorCode).
   Rooted<PromiseObject*> promise(
       cx, ReadableStreamAddReadOrReadIntoRequest(cx, unwrappedStream));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -644,7 +644,7 @@ JS_STREAMS_CLASS_SPEC(ReadableByteStream
   MOZ_ASSERT(unwrappedStream->readable());
 
   // Step 4: If controller.[[queueTotalSize]] > 0,
-  if (unwrappedController->queueTotalSize() > 0) {
+  if (unwrappedController->queueTotalSize() > 0) {MOZ_RELEASE_ASSERT(0);
     // Step a: Set controller.[[closeRequested]] to true.
     unwrappedController->setCloseRequested();
 
@@ -655,18 +655,18 @@ JS_STREAMS_CLASS_SPEC(ReadableByteStream
   // Step 5: If controller.[[pendingPullIntos]] is not empty,
   Rooted<ListObject*> unwrappedPendingPullIntos(
       cx, unwrappedController->pendingPullIntos());
-  if (unwrappedPendingPullIntos->length() != 0) {
+  if (unwrappedPendingPullIntos->length() != 0) {MOZ_RELEASE_ASSERT(0);
     // Step a: Let firstPendingPullInto be the first element of
     //         controller.[[pendingPullIntos]].
     Rooted<PullIntoDescriptor*> unwrappedFirstPendingPullInto(
         cx, UnwrapAndDowncastObject<PullIntoDescriptor>(
                 cx, &unwrappedPendingPullIntos->get(0).toObject()));
-    if (!unwrappedFirstPendingPullInto) {
+    if (!unwrappedFirstPendingPullInto) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // Step b: If firstPendingPullInto.[[bytesFilled]] > 0,
-    if (unwrappedFirstPendingPullInto->bytesFilled() > 0) {
+    if (unwrappedFirstPendingPullInto->bytesFilled() > 0) {MOZ_RELEASE_ASSERT(0);
       // Step i: Let e be a new TypeError exception.
       JS_ReportErrorNumberASCII(
           cx, GetErrorMessage, nullptr,
@@ -674,7 +674,7 @@ JS_STREAMS_CLASS_SPEC(ReadableByteStream
       RootedValue e(cx);
       RootedSavedFrame stack(cx);
       if (!cx->isExceptionPending() ||
-          !GetAndClearExceptionAndStack(cx, &e, &stack)) {
+          !GetAndClearExceptionAndStack(cx, &e, &stack)) {MOZ_RELEASE_ASSERT(0);
         // Uncatchable error. Die immediately without erroring the
         // stream.
         return false;
@@ -752,7 +752,7 @@ enum BYOBRequestSlots {
   RootedValue unwrappedBYOBRequestVal(cx, unwrappedController->byobRequest());
   if (unwrappedBYOBRequestVal.isUndefined()) {
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedNativeObject unwrappedBYOBRequest(
       cx, UnwrapAndDowncastValue<NativeObject>(cx, unwrappedBYOBRequestVal));
diff --git a/js/src/builtin/String.cpp b/js/src/builtin/String.cpp
--- a/js/src/builtin/String.cpp
+++ b/js/src/builtin/String.cpp
@@ -159,7 +159,7 @@ static bool Escape(JSContext* cx, const 
     return true;
   }
 
-  if (!newChars.maybeAlloc(cx, newLength)) {
+  if (!newChars.maybeAlloc(cx, newLength)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -203,7 +203,7 @@ static bool str_escape(JSContext* cx, un
   if (str->hasLatin1Chars()) {
     AutoCheckCannotGC nogc;
     if (!Escape(cx, str->latin1Chars(nogc), str->length(), newChars,
-                &newLength)) {
+                &newLength)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -334,19 +334,19 @@ static bool str_unescape(JSContext* cx, 
 
   // Step 3.
   JSStringBuilder sb(cx);
-  if (str->hasTwoByteChars() && !sb.ensureTwoByteChars()) {
+  if (str->hasTwoByteChars() && !sb.ensureTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Steps 2, 4-5.
   if (str->hasLatin1Chars()) {
     AutoCheckCannotGC nogc;
-    if (!Unescape(sb, str->latin1Range(nogc))) {
+    if (!Unescape(sb, str->latin1Range(nogc))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
     AutoCheckCannotGC nogc;
-    if (!Unescape(sb, str->twoByteRange(nogc))) {
+    if (!Unescape(sb, str->twoByteRange(nogc))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -355,7 +355,7 @@ static bool str_unescape(JSContext* cx, 
   JSLinearString* result;
   if (!sb.empty()) {
     result = sb.finishString();
-    if (!result) {
+    if (!result) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -400,7 +400,7 @@ static bool str_enumerate(JSContext* cx,
   RootedValue value(cx);
   for (size_t i = 0, length = str->length(); i < length; i++) {
     JSString* str1 = staticStrings.getUnitStringForElement(cx, str, i);
-    if (!str1) {
+    if (!str1) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     value.setString(str1);
@@ -430,7 +430,7 @@ static bool str_resolve(JSContext* cx, H
   if ((size_t)slot < str->length()) {
     JSString* str1 =
         cx->staticStrings().getUnitStringForElement(cx, str, size_t(slot));
-    if (!str1) {
+    if (!str1) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     RootedValue value(cx, StringValue(str1));
@@ -506,18 +506,18 @@ MOZ_ALWAYS_INLINE bool str_toSource_impl
   MOZ_ASSERT(IsString(args.thisv()));
 
   JSString* str = ToString<CanGC>(cx, args.thisv());
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   UniqueChars quoted = QuoteString(cx, str, '"');
-  if (!quoted) {
+  if (!quoted) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JSStringBuilder sb(cx);
   if (!sb.append("(new String(") ||
-      !sb.append(quoted.get(), strlen(quoted.get())) || !sb.append("))")) {
+      !sb.append(quoted.get(), strlen(quoted.get())) || !sb.append("))")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -599,7 +599,7 @@ JSString* js::SubstringKernel(JSContext*
     Rooted<JSRope*> ropeRoot(cx, rope);
     RootedString lhs(
         cx, NewDependentString(cx, ropeRoot->leftChild(), begin, lhsLength));
-    if (!lhs) {
+    if (!lhs) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -829,7 +829,7 @@ static JSString* ToLowerCase(JSContext* 
     }
 
     resultLength = length;
-    if (!newChars.maybeAlloc(cx, resultLength)) {
+    if (!newChars.maybeAlloc(cx, resultLength)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -841,7 +841,7 @@ static JSString* ToLowerCase(JSContext* 
       if (readChars < length) {
         resultLength = ToLowerCaseLength(chars, readChars, length);
 
-        if (!newChars.maybeRealloc(cx, length, resultLength)) {
+        if (!newChars.maybeRealloc(cx, length, resultLength)) {MOZ_RELEASE_ASSERT(0);
           return nullptr;
         }
 
@@ -860,7 +860,7 @@ static JSString* ToLowerCase(JSContext* 
 
 JSString* js::StringToLowerCase(JSContext* cx, HandleString string) {
   JSLinearString* linear = string->ensureLinear(cx);
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -894,7 +894,7 @@ static bool str_toLowerCase(JSContext* c
 
 static const char* CaseMappingLocale(JSContext* cx, JSString* str) {
   JSLinearString* locale = str->ensureLinear(cx);
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -927,14 +927,14 @@ bool js::intl_toLocaleLowerCase(JSContex
   RootedString string(cx, args[0].toString());
 
   const char* locale = CaseMappingLocale(cx, args[1].toString());
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Call String.prototype.toLowerCase() for language independent casing.
   if (intl::StringsAreEqual(locale, "")) {
     JSString* str = StringToLowerCase(cx, string);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -943,7 +943,7 @@ bool js::intl_toLocaleLowerCase(JSContex
   }
 
   AutoStableStringChars inputChars(cx);
-  if (!inputChars.initTwoByte(cx, string)) {
+  if (!inputChars.initTwoByte(cx, string)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   mozilla::Range<const char16_t> input = inputChars.twoByteRange();
@@ -956,7 +956,7 @@ bool js::intl_toLocaleLowerCase(JSContex
   static const size_t INLINE_CAPACITY = js::intl::INITIAL_CHAR_BUFFER_SIZE;
 
   Vector<char16_t, INLINE_CAPACITY> chars(cx);
-  if (!chars.resize(std::max(INLINE_CAPACITY, input.length()))) {
+  if (!chars.resize(std::max(INLINE_CAPACITY, input.length()))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -967,7 +967,7 @@ bool js::intl_toLocaleLowerCase(JSContex
                             locale, status);
       },
       chars);
-  if (size < 0) {
+  if (size < 0) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1156,7 +1156,7 @@ static inline bool ToUpperCase(JSContext
   MOZ_ASSERT(startIndex < length);
 
   *resultLength = length;
-  if (!newChars.maybeAlloc(cx, length)) {
+  if (!newChars.maybeAlloc(cx, length)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1270,14 +1270,14 @@ static JSString* ToUpperCase(JSContext* 
         newChars.construct<Latin1Buffer>();
 
         if (!ToUpperCase(cx, newChars.ref<Latin1Buffer>(), chars, i, length,
-                         &resultLength)) {
+                         &resultLength)) {MOZ_RELEASE_ASSERT(0);
           return nullptr;
         }
       } else {
         newChars.construct<TwoByteBuffer>();
 
         if (!ToUpperCase(cx, newChars.ref<TwoByteBuffer>(), chars, i, length,
-                         &resultLength)) {
+                         &resultLength)) {MOZ_RELEASE_ASSERT(0);
           return nullptr;
         }
       }
@@ -1300,7 +1300,7 @@ static JSString* ToUpperCase(JSContext* 
 
 JSString* js::StringToUpperCase(JSContext* cx, HandleString string) {
   JSLinearString* linear = string->ensureLinear(cx);
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1341,14 +1341,14 @@ bool js::intl_toLocaleUpperCase(JSContex
   RootedString string(cx, args[0].toString());
 
   const char* locale = CaseMappingLocale(cx, args[1].toString());
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Call String.prototype.toUpperCase() for language independent casing.
   if (intl::StringsAreEqual(locale, "")) {
     JSString* str = js::StringToUpperCase(cx, string);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1357,7 +1357,7 @@ bool js::intl_toLocaleUpperCase(JSContex
   }
 
   AutoStableStringChars inputChars(cx);
-  if (!inputChars.initTwoByte(cx, string)) {
+  if (!inputChars.initTwoByte(cx, string)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   mozilla::Range<const char16_t> input = inputChars.twoByteRange();
@@ -1370,7 +1370,7 @@ bool js::intl_toLocaleUpperCase(JSContex
   static const size_t INLINE_CAPACITY = js::intl::INITIAL_CHAR_BUFFER_SIZE;
 
   Vector<char16_t, INLINE_CAPACITY> chars(cx);
-  if (!chars.resize(std::max(INLINE_CAPACITY, input.length()))) {
+  if (!chars.resize(std::max(INLINE_CAPACITY, input.length()))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1381,7 +1381,7 @@ bool js::intl_toLocaleUpperCase(JSContex
                             locale, status);
       },
       chars);
-  if (size < 0) {
+  if (size < 0) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1539,7 +1539,7 @@ static bool str_normalize(JSContext* cx,
 
   // Step 6.
   AutoStableStringChars stableChars(cx);
-  if (!stableChars.initTwoByte(cx, str)) {
+  if (!stableChars.initTwoByte(cx, str)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1559,7 +1559,7 @@ static bool str_normalize(JSContext* cx,
     MOZ_ASSERT(form == NFKD);
     normalizer = unorm2_getNFKDInstance(&status);
   }
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_INTERNAL_INTL_ERROR);
     return false;
@@ -1567,7 +1567,7 @@ static bool str_normalize(JSContext* cx,
 
   int32_t spanLengthInt = unorm2_spanQuickCheckYes(
       normalizer, srcChars.begin().get(), srcChars.length(), &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_INTERNAL_INTL_ERROR);
     return false;
@@ -1585,7 +1585,7 @@ static bool str_normalize(JSContext* cx,
   static const size_t INLINE_CAPACITY = js::intl::INITIAL_CHAR_BUFFER_SIZE;
 
   Vector<char16_t, INLINE_CAPACITY> chars(cx);
-  if (!chars.resize(std::max(INLINE_CAPACITY, srcChars.length()))) {
+  if (!chars.resize(std::max(INLINE_CAPACITY, srcChars.length()))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1607,7 +1607,7 @@ static bool str_normalize(JSContext* cx,
                                                remainingLength, status);
       },
       chars);
-  if (size < 0) {
+  if (size < 0) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2059,7 +2059,7 @@ static int RopeMatchImpl(const AutoCheck
       const TextChar* tt = t;
       for (const PatChar* pp = p1; pp != patend; ++pp, ++tt) {
         while (tt == ttend) {
-          if (++innerp == strings.end()) {
+          if (++innerp == strings.end()) {MOZ_RELEASE_ASSERT(0);
             return -1;
           }
 
@@ -2092,7 +2092,7 @@ static int RopeMatchImpl(const AutoCheck
 static bool RopeMatch(JSContext* cx, JSRope* text, JSLinearString* pat,
                       int* match) {
   uint32_t patLen = pat->length();
-  if (patLen == 0) {
+  if (patLen == 0) {MOZ_RELEASE_ASSERT(0);
     *match = 0;
     return true;
   }
@@ -2120,7 +2120,7 @@ static bool RopeMatch(JSContext* cx, JSR
   {
     size_t threshold = text->length() >> sRopeMatchThresholdRatioLog2;
     StringSegmentRange r(cx);
-    if (!r.init(text)) {
+    if (!r.init(text)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2129,14 +2129,14 @@ static bool RopeMatch(JSContext* cx, JSR
       if (threshold-- == 0 || r.front()->hasLatin1Chars() != textIsLatin1 ||
           !strings.append(r.front())) {
         JSLinearString* linear = text->ensureLinear(cx);
-        if (!linear) {
+        if (!linear) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         *match = StringMatch(linear, pat);
         return true;
       }
-      if (!r.popFront()) {
+      if (!r.popFront()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2147,7 +2147,7 @@ static bool RopeMatch(JSContext* cx, JSR
     if (pat->hasLatin1Chars()) {
       *match = RopeMatchImpl<Latin1Char>(nogc, strings, pat->latin1Chars(nogc),
                                          patLen);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       *match = RopeMatchImpl<Latin1Char>(nogc, strings, pat->twoByteChars(nogc),
                                          patLen);
     }
@@ -2389,7 +2389,7 @@ static bool str_lastIndexOf(JSContext* c
   MOZ_ASSERT(0 <= start && size_t(start) < len);
 
   JSLinearString* text = str->ensureLinear(cx);
-  if (!text) {
+  if (!text) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2577,7 +2577,7 @@ static bool TrimString(JSContext* cx, co
   }
 
   JSLinearString* linear = str->ensureLinear(cx);
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2662,12 +2662,12 @@ static JSString* BuildFlatReplacement(JS
   size_t matchEnd = matchStart + patternLength;
 
   RootedString resultStr(cx, NewDependentString(cx, textstr, 0, matchStart));
-  if (!resultStr) {
+  if (!resultStr) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   resultStr = ConcatStrings<CanGC>(cx, resultStr, repstr);
-  if (!resultStr) {
+  if (!resultStr) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2693,7 +2693,7 @@ static JSString* BuildFlatRopeReplacemen
    * through it, building a new rope.
    */
   StringSegmentRange r(cx);
-  if (!r.init(textstr)) {
+  if (!r.init(textstr)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2703,11 +2703,11 @@ static JSString* BuildFlatRopeReplacemen
    * Special case when the pattern string is '', which matches to the
    * head of the string and doesn't overlap with any component of the rope.
    */
-  if (patternLength == 0) {
+  if (patternLength == 0) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(match == 0);
-    if (!builder.append(repstr)) {
+    if (!builder.append(repstr)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   size_t pos = 0;
@@ -2728,7 +2728,7 @@ static JSString* BuildFlatRopeReplacemen
          * replacement string here.
          */
         RootedString leftSide(cx, NewDependentString(cx, str, 0, match - pos));
-        if (!leftSide || !builder.append(leftSide) || !builder.append(repstr)) {
+        if (!leftSide || !builder.append(leftSide) || !builder.append(repstr)) {MOZ_RELEASE_ASSERT(0);
           return nullptr;
         }
       }
@@ -2740,12 +2740,12 @@ static JSString* BuildFlatRopeReplacemen
       if (strEnd > matchEnd) {
         RootedString rightSide(
             cx, NewDependentString(cx, str, matchEnd - pos, strEnd - matchEnd));
-        if (!rightSide || !builder.append(rightSide)) {
+        if (!rightSide || !builder.append(rightSide)) {MOZ_RELEASE_ASSERT(0);
           return nullptr;
         }
       }
     } else {
-      if (!builder.append(str)) {
+      if (!builder.append(str)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -2768,7 +2768,7 @@ static bool AppendDollarReplacement(Stri
   MOZ_ASSERT(matchLimit <= text->length());
 
   // Move the pre-dollar chunk in bulk.
-  if (!newReplaceChars.append(repChars, firstDollarIndex)) {
+  if (!newReplaceChars.append(repChars, firstDollarIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2776,7 +2776,7 @@ static bool AppendDollarReplacement(Stri
   const CharT* repLimit = repChars + repLength;
   for (const CharT* it = repChars + firstDollarIndex; it < repLimit; ++it) {
     if (*it != '$' || it == repLimit - 1) {
-      if (!newReplaceChars.append(*it)) {
+      if (!newReplaceChars.append(*it)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       continue;
@@ -2827,7 +2827,7 @@ static JSLinearString* InterpretDollarRe
     JSContext* cx, HandleString textstrArg, HandleLinearString repstr,
     uint32_t firstDollarIndex, size_t matchStart, size_t patternLength) {
   RootedLinearString textstr(cx, textstrArg->ensureLinear(cx));
-  if (!textstr) {
+  if (!textstr) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2841,12 +2841,12 @@ static JSLinearString* InterpretDollarRe
    * Note that dollar vars _could_ make the resulting text smaller than this.
    */
   JSStringBuilder newReplaceChars(cx);
-  if (repstr->hasTwoByteChars() && !newReplaceChars.ensureTwoByteChars()) {
+  if (repstr->hasTwoByteChars() && !newReplaceChars.ensureTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   if (!newReplaceChars.reserve(textstr->length() - patternLength +
-                               repstr->length())) {
+                               repstr->length())) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2872,7 +2872,7 @@ static JSLinearString* InterpretDollarRe
 template <typename StrChar, typename RepChar>
 static bool StrFlatReplaceGlobal(JSContext* cx, JSLinearString* str,
                                  JSLinearString* pat, JSLinearString* rep,
-                                 StringBuffer& sb) {
+                                 StringBuffer& sb) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(str->length() > 0);
 
   AutoCheckCannotGC nogc;
@@ -2881,47 +2881,47 @@ static bool StrFlatReplaceGlobal(JSConte
 
   // The pattern is empty, so we interleave the replacement string in-between
   // each character.
-  if (!pat->length()) {
+  if (!pat->length()) {MOZ_RELEASE_ASSERT(0);
     CheckedInt<uint32_t> strLength(str->length());
     CheckedInt<uint32_t> repLength(rep->length());
     CheckedInt<uint32_t> length = repLength * (strLength - 1) + strLength;
-    if (!length.isValid()) {
+    if (!length.isValid()) {MOZ_RELEASE_ASSERT(0);
       ReportAllocationOverflow(cx);
       return false;
     }
 
-    if (!sb.reserve(length.value())) {
+    if (!sb.reserve(length.value())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    for (unsigned i = 0; i < str->length() - 1; ++i, ++strChars) {
+    for (unsigned i = 0; i < str->length() - 1; ++i, ++strChars) {MOZ_RELEASE_ASSERT(0);
       sb.infallibleAppend(*strChars);
       sb.infallibleAppend(repChars, rep->length());
-    }
+    }MOZ_RELEASE_ASSERT(0);
     sb.infallibleAppend(*strChars);
     return true;
   }
 
   // If it's true, we are sure that the result's length is, at least, the same
   // length as |str->length()|.
-  if (rep->length() >= pat->length()) {
-    if (!sb.reserve(str->length())) {
+  if (rep->length() >= pat->length()) {MOZ_RELEASE_ASSERT(0);
+    if (!sb.reserve(str->length())) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
-  }
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
 
   uint32_t start = 0;
-  for (;;) {
+  for (;;) {MOZ_RELEASE_ASSERT(0);
     int match = StringMatch(str, pat, start);
-    if (match < 0) {
+    if (match < 0) {MOZ_RELEASE_ASSERT(0);
       break;
     }
-    if (!sb.append(strChars + start, match - start)) {
+    if (!sb.append(strChars + start, match - start)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!sb.append(repChars, rep->length())) {
+    if (!sb.append(repChars, rep->length())) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     start = match + pat->length();
   }
 
@@ -2936,56 +2936,56 @@ static bool StrFlatReplaceGlobal(JSConte
 // do some deforestation optimization in Ion.
 JSString* js::StringFlatReplaceString(JSContext* cx, HandleString string,
                                       HandleString pattern,
-                                      HandleString replacement) {
+                                      HandleString replacement) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(string);
   MOZ_ASSERT(pattern);
   MOZ_ASSERT(replacement);
 
-  if (!string->length()) {
+  if (!string->length()) {MOZ_RELEASE_ASSERT(0);
     return string;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedLinearString linearRepl(cx, replacement->ensureLinear(cx));
-  if (!linearRepl) {
+  if (!linearRepl) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedLinearString linearPat(cx, pattern->ensureLinear(cx));
-  if (!linearPat) {
+  if (!linearPat) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedLinearString linearStr(cx, string->ensureLinear(cx));
-  if (!linearStr) {
+  if (!linearStr) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   JSStringBuilder sb(cx);
-  if (linearStr->hasTwoByteChars()) {
-    if (!sb.ensureTwoByteChars()) {
+  if (linearStr->hasTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
+    if (!sb.ensureTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (linearRepl->hasTwoByteChars()) {
+    if (linearRepl->hasTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
       if (!StrFlatReplaceGlobal<char16_t, char16_t>(cx, linearStr, linearPat,
-                                                    linearRepl, sb)) {
+                                                    linearRepl, sb)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       if (!StrFlatReplaceGlobal<char16_t, Latin1Char>(cx, linearStr, linearPat,
-                                                      linearRepl, sb)) {
+                                                      linearRepl, sb)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
   } else {
-    if (linearRepl->hasTwoByteChars()) {
-      if (!sb.ensureTwoByteChars()) {
+    if (linearRepl->hasTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
+      if (!sb.ensureTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
+        return nullptr;
+      }MOZ_RELEASE_ASSERT(0);
+      if (!StrFlatReplaceGlobal<Latin1Char, char16_t>(cx, linearStr, linearPat,
+                                                      linearRepl, sb)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
-      if (!StrFlatReplaceGlobal<Latin1Char, char16_t>(cx, linearStr, linearPat,
-                                                      linearRepl, sb)) {
-        return nullptr;
-      }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       if (!StrFlatReplaceGlobal<Latin1Char, Latin1Char>(
               cx, linearStr, linearPat, linearRepl, sb)) {
         return nullptr;
@@ -3000,12 +3000,12 @@ JSString* js::str_replace_string_raw(JSC
                                      HandleString pattern,
                                      HandleString replacement) {
   RootedLinearString repl(cx, replacement->ensureLinear(cx));
-  if (!repl) {
+  if (!repl) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedLinearString pat(cx, pattern->ensureLinear(cx));
-  if (!pat) {
+  if (!pat) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3026,7 +3026,7 @@ JSString* js::str_replace_string_raw(JSC
    * long as possible.
    */
   if (string->isRope()) {
-    if (!RopeMatch(cx, &string->asRope(), pat, &match)) {
+    if (!RopeMatch(cx, &string->asRope(), pat, &match)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
@@ -3040,7 +3040,7 @@ JSString* js::str_replace_string_raw(JSC
   if (dollarIndex != UINT32_MAX) {
     repl = InterpretDollarReplacement(cx, string, repl, dollarIndex, match,
                                       patternLength);
-    if (!repl) {
+    if (!repl) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else if (string->isRope()) {
@@ -3089,7 +3089,7 @@ static JSString* ReplaceAll(JSContext* c
   JSStringBuilder result(cx);
   if constexpr (std::is_same_v<StrChar, char16_t> ||
                 std::is_same_v<RepChar, char16_t>) {
-    if (!result.ensureTwoByteChars()) {
+    if (!result.ensureTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -3104,7 +3104,7 @@ static JSString* ReplaceAll(JSContext* c
     // If it's true, we are sure that the result's length is, at least, the same
     // length as |str->length()|.
     if (replaceLength >= searchLength) {
-      if (!result.reserve(stringLength)) {
+      if (!result.reserve(stringLength)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -3113,7 +3113,7 @@ static JSString* ReplaceAll(JSContext* c
       // Step 14.c.
       // Append the substring before the current match.
       if (!result.append(strChars + endOfLastMatch,
-                         position - endOfLastMatch)) {
+                         position - endOfLastMatch)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -3122,11 +3122,11 @@ static JSString* ReplaceAll(JSContext* c
       if (dollarIndex != UINT32_MAX) {
         size_t matchLimit = position + searchLength;
         if (!AppendDollarReplacement(result, dollarIndex, position, matchLimit,
-                                     string, repChars, replaceLength)) {
+                                     string, repChars, replaceLength)) {MOZ_RELEASE_ASSERT(0);
           return nullptr;
         }
       } else {
-        if (!result.append(repChars, replaceLength)) {
+        if (!result.append(repChars, replaceLength)) {MOZ_RELEASE_ASSERT(0);
           return nullptr;
         }
       }
@@ -3172,7 +3172,7 @@ static JSString* ReplaceAllInterleave(JS
   JSStringBuilder result(cx);
   if constexpr (std::is_same_v<StrChar, char16_t> ||
                 std::is_same_v<RepChar, char16_t>) {
-    if (!result.ensureTwoByteChars()) {
+    if (!result.ensureTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -3185,7 +3185,7 @@ static JSString* ReplaceAllInterleave(JS
     uint32_t dollarIndex = FindDollarIndex(repChars, replaceLength);
 
     if (dollarIndex != UINT32_MAX) {
-      if (!result.reserve(stringLength)) {
+      if (!result.reserve(stringLength)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     } else {
@@ -3193,12 +3193,12 @@ static JSString* ReplaceAllInterleave(JS
       CheckedInt<uint32_t> strLength(stringLength);
       CheckedInt<uint32_t> repLength(replaceLength);
       CheckedInt<uint32_t> length = strLength + (strLength + 1) * repLength;
-      if (!length.isValid()) {
+      if (!length.isValid()) {MOZ_RELEASE_ASSERT(0);
         ReportAllocationOverflow(cx);
         return nullptr;
       }
 
-      if (!result.reserve(length.value())) {
+      if (!result.reserve(length.value())) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -3214,12 +3214,12 @@ static JSString* ReplaceAllInterleave(JS
     for (size_t index = 0; index < stringLength; index++) {
       // Steps 11, 14.a-b and 14.d.
       // The empty string matches before each character.
-      if (!appendReplacement(index)) {
+      if (!appendReplacement(index)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
       // Step 14.c.
-      if (!result.append(strChars[index])) {
+      if (!result.append(strChars[index])) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -3255,17 +3255,17 @@ JSString* js::str_replaceAll_string_raw(
   }
 
   RootedLinearString str(cx, string->ensureLinear(cx));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedLinearString repl(cx, replaceString->ensureLinear(cx));
-  if (!repl) {
+  if (!repl) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedLinearString search(cx, searchString->ensureLinear(cx));
-  if (!search) {
+  if (!search) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3273,12 +3273,12 @@ JSString* js::str_replaceAll_string_raw(
   // each character.
   if (searchLength == 0) {
     if (str->hasTwoByteChars()) {
-      if (repl->hasTwoByteChars()) {
+      if (repl->hasTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
         return ReplaceAllInterleave<char16_t, char16_t>(cx, str, repl);
       }
       return ReplaceAllInterleave<char16_t, Latin1Char>(cx, str, repl);
     }
-    if (repl->hasTwoByteChars()) {
+    if (repl->hasTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
       return ReplaceAllInterleave<Latin1Char, char16_t>(cx, str, repl);
     }
     return ReplaceAllInterleave<Latin1Char, Latin1Char>(cx, str, repl);
@@ -3287,7 +3287,7 @@ JSString* js::str_replaceAll_string_raw(
   MOZ_ASSERT(stringLength > 0);
 
   if (str->hasTwoByteChars()) {
-    if (repl->hasTwoByteChars()) {
+    if (repl->hasTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
       return ReplaceAll<char16_t, char16_t>(cx, str, search, repl);
     }
     return ReplaceAll<char16_t, Latin1Char>(cx, str, search, repl);
@@ -3322,7 +3322,7 @@ static ArrayObject* SplitHelper(JSContex
     int match = StringMatch(str, sep, 0);
 
     // Step 12.b.
-    if (match != -1) {
+    if (match != -1) {MOZ_RELEASE_ASSERT(0);
       return NewDenseEmptyArray(cx);
     }
 
@@ -3365,7 +3365,7 @@ static ArrayObject* SplitHelper(JSContex
     size_t endIndex = match + sepLength;
 
     // Step 14.c.i.
-    if (endIndex == lastEndIndex) {
+    if (endIndex == lastEndIndex) {MOZ_RELEASE_ASSERT(0);
       index++;
       continue;
     }
@@ -3380,7 +3380,7 @@ static ArrayObject* SplitHelper(JSContex
     JSString* sub = NewDependentString(cx, str, lastEndIndex, subLength);
 
     // Steps 14.c.ii.2-4.
-    if (!sub || !splits.append(StringValue(sub))) {
+    if (!sub || !splits.append(StringValue(sub))) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -3424,7 +3424,7 @@ static ArrayObject* CharSplitHelper(JSCo
              "than zero.");
 
   RootedArrayObject splits(cx, NewDenseFullyAllocatedArray(cx, resultlen));
-  if (!splits) {
+  if (!splits) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3472,7 +3472,7 @@ static MOZ_ALWAYS_INLINE ArrayObject* Sp
 
   // Create the result array for the substring values.
   RootedArrayObject splits(cx, NewDenseFullyAllocatedArray(cx, count + 1));
-  if (!splits) {
+  if (!splits) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   splits->ensureDenseInitializedLength(0, count + 1);
@@ -3484,7 +3484,7 @@ static MOZ_ALWAYS_INLINE ArrayObject* Sp
     if (static_cast<char16_t>(text[index]) == patCh) {
       size_t subLength = size_t(index - lastEndIndex);
       JSString* sub = NewDependentString(cx, str, lastEndIndex, subLength);
-      if (!sub) {
+      if (!sub) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       splits->initDenseElement(splitsIndex++, StringValue(sub));
@@ -3510,7 +3510,7 @@ static ArrayObject* SplitSingleCharHelpe
   size_t strLength = str->length();
 
   AutoStableStringChars linearChars(cx);
-  if (!linearChars.init(cx, str)) {
+  if (!linearChars.init(cx, str)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3529,12 +3529,12 @@ ArrayObject* js::StringSplitString(JSCon
   MOZ_ASSERT(limit > 0, "Only called for strictly positive limit.");
 
   RootedLinearString linearStr(cx, str->ensureLinear(cx));
-  if (!linearStr) {
+  if (!linearStr) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedLinearString linearSep(cx, sep->ensureLinear(cx));
-  if (!linearSep) {
+  if (!linearSep) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3670,14 +3670,14 @@ bool js::str_fromCharCode(JSContext* cx,
   // JSFatInlineString::MAX_LENGTH_LATIN1 if we also checked if the chars are
   // all Latin-1, but it doesn't seem worth the effort.)
   InlineCharBuffer<char16_t> chars;
-  if (!chars.maybeAlloc(cx, args.length())) {
+  if (!chars.maybeAlloc(cx, args.length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   char16_t* rawChars = chars.get();
   for (unsigned i = 0; i < args.length(); i++) {
     uint16_t code;
-    if (!ToUint16(cx, args[i], &code)) {
+    if (!ToUint16(cx, args[i], &code)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3838,7 +3838,7 @@ bool js::str_fromCodePoint(JSContext* cx
       "|args.length() * 2| does not overflow");
   auto elements = cx->make_pod_arena_array<char16_t>(js::StringBufferArena,
                                                      args.length() * 2);
-  if (!elements) {
+  if (!elements) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3847,7 +3847,7 @@ bool js::str_fromCodePoint(JSContext* cx
   for (unsigned nextIndex = 0; nextIndex < args.length(); nextIndex++) {
     // Steps 5.a-d.
     uint32_t codePoint;
-    if (!ToCodePoint(cx, args[nextIndex], &codePoint)) {
+    if (!ToCodePoint(cx, args[nextIndex], &codePoint)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3886,7 +3886,7 @@ JSObject* StringObject::createPrototype(
   Rooted<JSString*> empty(cx, cx->runtime()->emptyString);
   Rooted<StringObject*> proto(
       cx, GlobalObject::createBlankPrototype<StringObject>(cx, cx->global()));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (!StringObject::init(cx, proto, empty)) {
@@ -3904,7 +3904,7 @@ static bool StringClassFinish(JSContext*
   RootedId trimId(cx, NameToId(cx->names().trimStart));
   RootedId trimAliasId(cx, NameToId(cx->names().trimLeft));
   if (!NativeGetProperty(cx, nativeProto, trimId, &trimFn) ||
-      !NativeDefineDataProperty(cx, nativeProto, trimAliasId, trimFn, 0)) {
+      !NativeDefineDataProperty(cx, nativeProto, trimAliasId, trimFn, 0)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3912,7 +3912,7 @@ static bool StringClassFinish(JSContext*
   trimId = NameToId(cx->names().trimEnd);
   trimAliasId = NameToId(cx->names().trimRight);
   if (!NativeGetProperty(cx, nativeProto, trimId, &trimFn) ||
-      !NativeDefineDataProperty(cx, nativeProto, trimAliasId, trimFn, 0)) {
+      !NativeDefineDataProperty(cx, nativeProto, trimAliasId, trimFn, 0)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4068,18 +4068,18 @@ static MOZ_NEVER_INLINE EncodeResult Enc
         (js_isUriUnescaped[c] || (unescapedSet && unescapedSet[c]))) {
       continue;
     } else {
-      if (!appendRange(startAppend, k)) {
+      if (!appendRange(startAppend, k)) {MOZ_RELEASE_ASSERT(0);
         return Encode_Failure;
       }
 
       if constexpr (std::is_same_v<CharT, Latin1Char>) {
         if (c < 0x80) {
-          if (!appendEncoded(c)) {
+          if (!appendEncoded(c)) {MOZ_RELEASE_ASSERT(0);
             return Encode_Failure;
           }
         } else {
           if (!appendEncoded(0xC0 | (c >> 6)) ||
-              !appendEncoded(0x80 | (c & 0x3F))) {
+              !appendEncoded(0x80 | (c & 0x3F))) {MOZ_RELEASE_ASSERT(0);
             return Encode_Failure;
           }
         }
@@ -4108,7 +4108,7 @@ static MOZ_NEVER_INLINE EncodeResult Enc
         uint8_t utf8buf[4];
         size_t L = OneUcs4ToUtf8Char(utf8buf, v);
         for (size_t j = 0; j < L; j++) {
-          if (!appendEncoded(utf8buf[j])) {
+          if (!appendEncoded(utf8buf[j])) {MOZ_RELEASE_ASSERT(0);
             return Encode_Failure;
           }
         }
@@ -4147,7 +4147,7 @@ static MOZ_ALWAYS_INLINE bool Encode(JSC
     res = Encode(sb, str->twoByteChars(nogc), str->length(), unescapedSet);
   }
 
-  if (res == Encode_Failure) {
+  if (res == Encode_Failure) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4196,10 +4196,10 @@ static DecodeResult Decode(StringBuffer&
           continue;
         }
 
-        if (!appendRange(startAppend, start)) {
+        if (!appendRange(startAppend, start)) {MOZ_RELEASE_ASSERT(0);
           return Decode_Failure;
         }
-        if (!sb.append(ch)) {
+        if (!sb.append(ch)) {MOZ_RELEASE_ASSERT(0);
           return Decode_Failure;
         }
       } else {
@@ -4239,7 +4239,7 @@ static DecodeResult Decode(StringBuffer&
           octets[j] = char(B);
         }
 
-        if (!appendRange(startAppend, start)) {
+        if (!appendRange(startAppend, start)) {MOZ_RELEASE_ASSERT(0);
           return Decode_Failure;
         }
 
@@ -4250,14 +4250,14 @@ static DecodeResult Decode(StringBuffer&
             return Decode_BadUri;
           }
 
-          if (!sb.append(unicode::LeadSurrogate(v))) {
+          if (!sb.append(unicode::LeadSurrogate(v))) {MOZ_RELEASE_ASSERT(0);
             return Decode_Failure;
           }
-          if (!sb.append(unicode::TrailSurrogate(v))) {
+          if (!sb.append(unicode::TrailSurrogate(v))) {MOZ_RELEASE_ASSERT(0);
             return Decode_Failure;
           }
         } else {
-          if (!sb.append(char16_t(v))) {
+          if (!sb.append(char16_t(v))) {MOZ_RELEASE_ASSERT(0);
             return Decode_Failure;
           }
         }
@@ -4295,7 +4295,7 @@ static bool Decode(JSContext* cx, Handle
     res = Decode(sb, str->twoByteChars(nogc), str->length(), reservedSet);
   }
 
-  if (res == Decode_Failure) {
+  if (res == Decode_Failure) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4352,10 +4352,10 @@ JSString* js::EncodeURI(JSContext* cx, c
   JSStringBuilder sb(cx);
   EncodeResult result = Encode(sb, reinterpret_cast<const Latin1Char*>(chars),
                                length, js_isUriReservedPlusPound);
-  if (result == EncodeResult::Encode_Failure) {
+  if (result == EncodeResult::Encode_Failure) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
-  if (result == EncodeResult::Encode_BadUri) {
+  if (result == EncodeResult::Encode_BadUri) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr, JSMSG_BAD_URI);
     return nullptr;
   }
@@ -4369,7 +4369,7 @@ static bool FlatStringMatchHelper(JSCont
                                   HandleString pattern, bool* isFlat,
                                   int32_t* match) {
   RootedLinearString linearPattern(cx, pattern->ensureLinear(cx));
-  if (!linearPattern) {
+  if (!linearPattern) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4382,7 +4382,7 @@ static bool FlatStringMatchHelper(JSCont
 
   *isFlat = true;
   if (str->isRope()) {
-    if (!RopeMatch(cx, &str->asRope(), linearPattern, match)) {
+    if (!RopeMatch(cx, &str->asRope(), linearPattern, match)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -4404,13 +4404,13 @@ static bool BuildFlatMatchArray(JSContex
   // object.
   ArrayObject* templateObject =
       cx->realm()->regExps.getOrCreateMatchResultTemplateObject(cx);
-  if (!templateObject) {
+  if (!templateObject) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedArrayObject arr(
       cx, NewDenseFullyAllocatedArrayWithTemplate(cx, 1, templateObject));
-  if (!arr) {
+  if (!arr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4476,7 +4476,7 @@ bool js::FlatStringMatch(JSContext* cx, 
 
   bool isFlat = false;
   int32_t match = 0;
-  if (!FlatStringMatchHelper(cx, str, pattern, &isFlat, &match)) {
+  if (!FlatStringMatchHelper(cx, str, pattern, &isFlat, &match)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4507,7 +4507,7 @@ bool js::FlatStringSearch(JSContext* cx,
 
   bool isFlat = false;
   int32_t match = 0;
-  if (!FlatStringMatchHelper(cx, str, pattern, &isFlat, &match)) {
+  if (!FlatStringMatchHelper(cx, str, pattern, &isFlat, &match)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/builtin/TestingFunctions.cpp b/js/src/builtin/TestingFunctions.cpp
--- a/js/src/builtin/TestingFunctions.cpp
+++ b/js/src/builtin/TestingFunctions.cpp
@@ -174,25 +174,25 @@ static bool EnvVarAsInt(const char* name
 static bool GetRealmConfiguration(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
   RootedObject info(cx, JS_NewPlainObject(cx));
-  if (!info) {
+  if (!info) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   bool privateFields = cx->options().privateClassFields();
   if (!JS_SetProperty(cx, info, "privateFields",
-                      privateFields ? TrueHandleValue : FalseHandleValue)) {
+                      privateFields ? TrueHandleValue : FalseHandleValue)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   bool privateMethods = cx->options().privateClassMethods();
   if (!JS_SetProperty(cx, info, "privateMethods",
                       privateFields && privateMethods ? TrueHandleValue
-                                                      : FalseHandleValue)) {
+                                                      : FalseHandleValue)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   bool topLevelAwait = cx->options().topLevelAwait();
   if (!JS_SetProperty(cx, info, "topLevelAwait",
-                      topLevelAwait ? TrueHandleValue : FalseHandleValue)) {
+                      topLevelAwait ? TrueHandleValue : FalseHandleValue)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -210,31 +210,31 @@ static bool GetRealmConfiguration(JSCont
 static bool GetBuildConfiguration(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
   RootedObject info(cx, JS_NewPlainObject(cx));
-  if (!info) {
-    return false;
-  }
-
-  if (!JS_SetProperty(cx, info, "rooting-analysis", FalseHandleValue)) {
-    return false;
-  }
-
-  if (!JS_SetProperty(cx, info, "exact-rooting", TrueHandleValue)) {
-    return false;
-  }
-
-  if (!JS_SetProperty(cx, info, "trace-jscalls-api", FalseHandleValue)) {
-    return false;
-  }
-
-  if (!JS_SetProperty(cx, info, "incremental-gc", TrueHandleValue)) {
-    return false;
-  }
-
-  if (!JS_SetProperty(cx, info, "generational-gc", TrueHandleValue)) {
-    return false;
-  }
-
-  if (!JS_SetProperty(cx, info, "oom-backtraces", FalseHandleValue)) {
+  if (!info) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!JS_SetProperty(cx, info, "rooting-analysis", FalseHandleValue)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!JS_SetProperty(cx, info, "exact-rooting", TrueHandleValue)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!JS_SetProperty(cx, info, "trace-jscalls-api", FalseHandleValue)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!JS_SetProperty(cx, info, "incremental-gc", TrueHandleValue)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!JS_SetProperty(cx, info, "generational-gc", TrueHandleValue)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!JS_SetProperty(cx, info, "oom-backtraces", FalseHandleValue)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -244,7 +244,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "debug", value)) {
+  if (!JS_SetProperty(cx, info, "debug", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -253,7 +253,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "release_or_beta", value)) {
+  if (!JS_SetProperty(cx, info, "release_or_beta", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -262,7 +262,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "early_beta_or_earlier", value)) {
+  if (!JS_SetProperty(cx, info, "early_beta_or_earlier", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -271,7 +271,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "coverage", value)) {
+  if (!JS_SetProperty(cx, info, "coverage", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -280,7 +280,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "has-ctypes", value)) {
+  if (!JS_SetProperty(cx, info, "has-ctypes", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -289,7 +289,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "x86", value)) {
+  if (!JS_SetProperty(cx, info, "x86", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -298,7 +298,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "x64", value)) {
+  if (!JS_SetProperty(cx, info, "x64", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -307,7 +307,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "arm", value)) {
+  if (!JS_SetProperty(cx, info, "arm", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -316,7 +316,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "arm-simulator", value)) {
+  if (!JS_SetProperty(cx, info, "arm-simulator", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -325,7 +325,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "android", value)) {
+  if (!JS_SetProperty(cx, info, "android", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -334,7 +334,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "windows", value)) {
+  if (!JS_SetProperty(cx, info, "windows", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -343,7 +343,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "arm64", value)) {
+  if (!JS_SetProperty(cx, info, "arm64", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -352,7 +352,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "arm64-simulator", value)) {
+  if (!JS_SetProperty(cx, info, "arm64-simulator", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -361,7 +361,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "mips32", value)) {
+  if (!JS_SetProperty(cx, info, "mips32", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -370,7 +370,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "mips64", value)) {
+  if (!JS_SetProperty(cx, info, "mips64", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -379,7 +379,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "mips32-simulator", value)) {
+  if (!JS_SetProperty(cx, info, "mips32-simulator", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -388,7 +388,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "mips64-simulator", value)) {
+  if (!JS_SetProperty(cx, info, "mips64-simulator", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -397,7 +397,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "asan", value)) {
+  if (!JS_SetProperty(cx, info, "asan", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -406,7 +406,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "tsan", value)) {
+  if (!JS_SetProperty(cx, info, "tsan", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -415,7 +415,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "ubsan", value)) {
+  if (!JS_SetProperty(cx, info, "ubsan", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -424,7 +424,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "has-gczeal", value)) {
+  if (!JS_SetProperty(cx, info, "has-gczeal", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -433,7 +433,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "profiling", value)) {
+  if (!JS_SetProperty(cx, info, "profiling", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -442,7 +442,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "dtrace", value)) {
+  if (!JS_SetProperty(cx, info, "dtrace", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -451,7 +451,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "valgrind", value)) {
+  if (!JS_SetProperty(cx, info, "valgrind", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -460,7 +460,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "intl-api", value)) {
+  if (!JS_SetProperty(cx, info, "intl-api", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -469,7 +469,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(true);
 #endif
-  if (!JS_SetProperty(cx, info, "mapped-array-buffer", value)) {
+  if (!JS_SetProperty(cx, info, "mapped-array-buffer", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -478,7 +478,7 @@ static bool GetBuildConfiguration(JSCont
 #else
   value = BooleanValue(false);
 #endif
-  if (!JS_SetProperty(cx, info, "moz-memory", value)) {
+  if (!JS_SetProperty(cx, info, "moz-memory", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -545,7 +545,7 @@ static bool GC(JSContext* cx, unsigned a
   if (args.length() >= 1) {
     Value arg = args[0];
     if (arg.isString()) {
-      if (!JS_StringEqualsLiteral(cx, arg.toString(), "zone", &zone)) {
+      if (!JS_StringEqualsLiteral(cx, arg.toString(), "zone", &zone)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (arg.isObject()) {
@@ -562,11 +562,11 @@ static bool GC(JSContext* cx, unsigned a
       bool shrinking = false;
       bool last_ditch = false;
       if (!JS_StringEqualsLiteral(cx, arg.toString(), "shrinking",
-                                  &shrinking)) {
+                                  &shrinking)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (!JS_StringEqualsLiteral(cx, arg.toString(), "last-ditch",
-                                  &last_ditch)) {
+                                  &last_ditch)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (shrinking) {
@@ -672,12 +672,12 @@ static bool GCParameter(JSContext* cx, u
   CallArgs args = CallArgsFromVp(argc, vp);
 
   JSString* str = ToString(cx, args.get(0));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JSLinearString* linearStr = JS_EnsureLinearString(cx, str);
-  if (!linearStr) {
+  if (!linearStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -701,13 +701,13 @@ static bool GCParameter(JSContext* cx, u
     return true;
   }
 
-  if (!info.writable) {
+  if (!info.writable) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Attempt to change read-only parameter %s",
                         info.name);
     return false;
   }
 
-  if (disableOOMFunctions) {
+  if (disableOOMFunctions) {MOZ_RELEASE_ASSERT(0);
     switch (param) {
       case JSGC_MAX_BYTES:
       case JSGC_MAX_NURSERY_BYTES:
@@ -719,7 +719,7 @@ static bool GCParameter(JSContext* cx, u
   }
 
   double d;
-  if (!ToNumber(cx, args[1], &d)) {
+  if (!ToNumber(cx, args[1], &d)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -729,7 +729,7 @@ static bool GCParameter(JSContext* cx, u
   }
 
   uint32_t value = floor(d);
-  if (param == JSGC_MARK_STACK_LIMIT && JS::IsIncrementalGCInProgress(cx)) {
+  if (param == JSGC_MARK_STACK_LIMIT && JS::IsIncrementalGCInProgress(cx)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(
         cx, "attempt to set markStackLimit while a GC is in progress");
     return false;
@@ -938,19 +938,19 @@ static bool WasmCompileMode(JSContext* c
   MOZ_ASSERT(!(ion && cranelift));
 
   JSStringBuilder result(cx);
-  if (none && !result.append("none", 4)) {
-    return false;
-  }
-  if (baseline && !result.append("baseline", 8)) {
-    return false;
-  }
-  if (tiered && !result.append("+", 1)) {
-    return false;
-  }
-  if (ion && !result.append("ion", 3)) {
-    return false;
-  }
-  if (cranelift && !result.append("cranelift", 9)) {
+  if (none && !result.append("none", 4)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (baseline && !result.append("baseline", 8)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (tiered && !result.append("+", 1)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (ion && !result.append("ion", 3)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (cranelift && !result.append("cranelift", 9)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (JSString* str = result.finishString()) {
@@ -965,12 +965,12 @@ static bool WasmCraneliftDisabledByFeatu
   CallArgs args = CallArgsFromVp(argc, vp);
   bool isDisabled = false;
   JSStringBuilder reason(cx);
-  if (!wasm::CraneliftDisabledByFeatures(cx, &isDisabled, &reason)) {
+  if (!wasm::CraneliftDisabledByFeatures(cx, &isDisabled, &reason)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (isDisabled) {
     JSString* result = reason.finishString();
-    if (!result) {
+    if (!result) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     args.rval().setString(result);
@@ -984,14 +984,14 @@ static bool WasmIonDisabledByFeatures(JS
   CallArgs args = CallArgsFromVp(argc, vp);
   bool isDisabled = false;
   JSStringBuilder reason(cx);
-  if (!wasm::IonDisabledByFeatures(cx, &isDisabled, &reason)) {
-    return false;
-  }
-  if (isDisabled) {
+  if (!wasm::IonDisabledByFeatures(cx, &isDisabled, &reason)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (isDisabled) {MOZ_RELEASE_ASSERT(0);
     JSString* result = reason.finishString();
-    if (!result) {
+    if (!result) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     args.rval().setString(result);
   } else {
     args.rval().setBoolean(false);
@@ -1035,7 +1035,7 @@ static bool ConvertToTier(JSContext* cx,
                           const wasm::Code& code, wasm::Tier* tier) {
   RootedString option(cx, JS::ToString(cx, value));
 
-  if (!option) {
+  if (!option) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1047,17 +1047,17 @@ static bool ConvertToTier(JSContext* cx,
   if (!JS_StringEqualsLiteral(cx, option, "stable", &stableTier) ||
       !JS_StringEqualsLiteral(cx, option, "best", &bestTier) ||
       !JS_StringEqualsLiteral(cx, option, "baseline", &baselineTier) ||
-      !JS_StringEqualsLiteral(cx, option, "ion", &ionTier)) {
+      !JS_StringEqualsLiteral(cx, option, "ion", &ionTier)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (stableTier) {
     *tier = code.stableTier();
-  } else if (bestTier) {
+  } else if (bestTier) {MOZ_RELEASE_ASSERT(0);
     *tier = code.bestTier();
-  } else if (baselineTier) {
+  } else if (baselineTier) {MOZ_RELEASE_ASSERT(0);
     *tier = wasm::Tier::Baseline;
-  } else if (ionTier) {
+  } else if (ionTier) {MOZ_RELEASE_ASSERT(0);
     *tier = wasm::Tier::Optimized;
   } else {
     // You can omit the argument but you can't pass just anything you like
@@ -1068,7 +1068,7 @@ static bool ConvertToTier(JSContext* cx,
 }
 
 static bool WasmExtractCode(JSContext* cx, unsigned argc, Value* vp) {
-  if (!cx->options().wasm()) {
+  if (!cx->options().wasm()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "wasm support unavailable");
     return false;
   }
@@ -1082,7 +1082,7 @@ static bool WasmExtractCode(JSContext* c
 
   Rooted<WasmModuleObject*> module(
       cx, args[0].toObject().maybeUnwrapIf<WasmModuleObject>());
-  if (!module) {
+  if (!module) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "argument is not a WebAssembly.Module");
     return false;
   }
@@ -1090,7 +1090,7 @@ static bool WasmExtractCode(JSContext* c
   wasm::Tier tier = module->module().code().stableTier();
   ;
   if (args.length() > 1 &&
-      !ConvertToTier(cx, args[1], module->module().code(), &tier)) {
+      !ConvertToTier(cx, args[1], module->module().code(), &tier)) {MOZ_RELEASE_ASSERT(0);
     args.rval().setNull();
     return false;
   }
@@ -1118,7 +1118,7 @@ static bool HasDisassembler(JSContext* c
 
 MOZ_THREAD_LOCAL(DisasmBuffer*) disasmBuf;
 
-static void captureDisasmText(const char* text) {
+static void captureDisasmText(const char* text) {MOZ_RELEASE_ASSERT(0);
   DisasmBuffer* buf = disasmBuf.get();
   if (!buf->builder.append(text, strlen(text)) || !buf->builder.append('\n')) {
     buf->oom = true;
@@ -1136,28 +1136,28 @@ static bool DisassembleNative(JSContext*
     return false;
   }
 
-  if (!args[0].isObject() || !args[0].toObject().is<JSFunction>()) {
+  if (!args[0].isObject() || !args[0].toObject().is<JSFunction>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "The first argument must be a function.");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   Sprinter sprinter(cx);
-  if (!sprinter.init()) {
-    return false;
-  }
+  if (!sprinter.init()) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedFunction fun(cx, &args[0].toObject().as<JSFunction>());
 
   uint8_t* jit_begin = nullptr;
   uint8_t* jit_end = nullptr;
 
-  if (fun->isAsmJSNative() || fun->isWasmWithJitEntry()) {
-    if (fun->isAsmJSNative() && !sprinter.jsprintf("; backend=asmjs\n")) {
+  if (fun->isAsmJSNative() || fun->isWasmWithJitEntry()) {MOZ_RELEASE_ASSERT(0);
+    if (fun->isAsmJSNative() && !sprinter.jsprintf("; backend=asmjs\n")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!sprinter.jsprintf("; backend=wasm\n")) {
+    if (!sprinter.jsprintf("; backend=wasm\n")) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     const Value& v2 =
         fun->getExtendedSlot(FunctionExtended::WASM_INSTANCE_SLOT);
@@ -1176,38 +1176,38 @@ static bool DisassembleNative(JSContext*
 
     jit_begin = segment.base() + codeRange.begin();
     jit_end = segment.base() + codeRange.end();
-  } else if (fun->hasJitScript()) {
+  } else if (fun->hasJitScript()) {MOZ_RELEASE_ASSERT(0);
     JSScript* script = fun->nonLazyScript();
-    if (script == nullptr) {
+    if (script == nullptr) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     js::jit::IonScript* ion =
         script->hasIonScript() ? script->ionScript() : nullptr;
     js::jit::BaselineScript* baseline =
         script->hasBaselineScript() ? script->baselineScript() : nullptr;
-    if (ion && ion->method()) {
-      if (!sprinter.jsprintf("; backend=ion\n")) {
+    if (ion && ion->method()) {MOZ_RELEASE_ASSERT(0);
+      if (!sprinter.jsprintf("; backend=ion\n")) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       jit_begin = ion->method()->raw();
       jit_end = ion->method()->rawEnd();
-    } else if (baseline) {
-      if (!sprinter.jsprintf("; backend=baseline\n")) {
+    } else if (baseline) {MOZ_RELEASE_ASSERT(0);
+      if (!sprinter.jsprintf("; backend=baseline\n")) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       jit_begin = baseline->method()->raw();
       jit_end = baseline->method()->rawEnd();
     }
-  } else {
-    return false;
-  }
-
-  if (jit_begin == nullptr || jit_end == nullptr) {
-    return false;
-  }
+  } else {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (jit_begin == nullptr || jit_end == nullptr) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
 
   DisasmBuffer buf(cx);
   disasmBuf.set(&buf);
@@ -1215,42 +1215,42 @@ static bool DisassembleNative(JSContext*
 
   jit::Disassemble(jit_begin, jit_end - jit_begin, &captureDisasmText);
 
-  if (buf.oom) {
+  if (buf.oom) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   JSString* sresult = buf.builder.finishString();
-  if (!sresult) {
+  if (!sresult) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   sprinter.putString(sresult);
 
-  if (args.length() > 1 && args[1].isString()) {
+  if (args.length() > 1 && args[1].isString()) {MOZ_RELEASE_ASSERT(0);
     RootedString str(cx, args[1].toString());
     JS::UniqueChars fileNameBytes = JS_EncodeStringToUTF8(cx, str);
 
     const char* fileName = fileNameBytes.get();
-    if (!fileName) {
+    if (!fileName) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     FILE* f = fopen(fileName, "w");
-    if (!f) {
+    if (!f) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "Could not open file for writing.");
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     uintptr_t expected_length = reinterpret_cast<uintptr_t>(jit_end) -
                                 reinterpret_cast<uintptr_t>(jit_begin);
-    if (expected_length != fwrite(jit_begin, jit_end - jit_begin, 1, f)) {
+    if (expected_length != fwrite(jit_begin, jit_end - jit_begin, 1, f)) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "Did not write all function bytes to the file.");
       fclose(f);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     fclose(f);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   JSString* str = JS_NewStringCopyZ(cx, sprinter.string());
   if (!str) {
@@ -1264,10 +1264,10 @@ static bool DisassembleNative(JSContext*
 }
 
 static bool ComputeTier(JSContext* cx, const wasm::Code& code,
-                        HandleValue tierSelection, wasm::Tier* tier) {
+                        HandleValue tierSelection, wasm::Tier* tier) {MOZ_RELEASE_ASSERT(0);
   *tier = code.stableTier();
   if (!tierSelection.isUndefined() &&
-      !ConvertToTier(cx, tierSelection, code, tier)) {
+      !ConvertToTier(cx, tierSelection, code, tier)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "invalid tier");
     return false;
   }
@@ -1283,20 +1283,20 @@ static bool ComputeTier(JSContext* cx, c
 template <typename DisasmFunction>
 static bool DisassembleIt(JSContext* cx, bool asString, MutableHandleValue rval,
                           DisasmFunction&& disassembleIt) {
-  if (asString) {
+  if (asString) {MOZ_RELEASE_ASSERT(0);
     DisasmBuffer buf(cx);
     disasmBuf.set(&buf);
     auto onFinish = mozilla::MakeScopeExit([&] { disasmBuf.set(nullptr); });
     disassembleIt(captureDisasmText);
-    if (buf.oom) {
+    if (buf.oom) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     JSString* sresult = buf.builder.finishString();
-    if (!sresult) {
+    if (!sresult) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     rval.setString(sresult);
     return true;
   }
@@ -1307,13 +1307,13 @@ static bool DisassembleIt(JSContext* cx,
 
 static bool WasmDisassembleFunction(JSContext* cx, const HandleFunction& func,
                                     HandleValue tierSelection, bool asString,
-                                    MutableHandleValue rval) {
+                                    MutableHandleValue rval) {MOZ_RELEASE_ASSERT(0);
   wasm::Instance& instance = wasm::ExportedFunctionToInstance(func);
   wasm::Tier tier;
 
-  if (!ComputeTier(cx, instance.code(), tierSelection, &tier)) {
-    return false;
-  }
+  if (!ComputeTier(cx, instance.code(), tierSelection, &tier)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
 
   uint32_t funcIndex = wasm::ExportedFunctionToFuncIndex(func);
   return DisassembleIt(
@@ -1324,11 +1324,11 @@ static bool WasmDisassembleFunction(JSCo
 
 static bool WasmDisassembleCode(JSContext* cx, const wasm::Code& code,
                                 HandleValue tierSelection, int kindSelection,
-                                bool asString, MutableHandleValue rval) {
+                                bool asString, MutableHandleValue rval) {MOZ_RELEASE_ASSERT(0);
   wasm::Tier tier;
-  if (!ComputeTier(cx, code, tierSelection, &tier)) {
-    return false;
-  }
+  if (!ComputeTier(cx, code, tierSelection, &tier)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
 
   return DisassembleIt(cx, asString, rval,
                        [&](void (*captureText)(const char*)) {
@@ -1337,7 +1337,7 @@ static bool WasmDisassembleCode(JSContex
 }
 
 static bool WasmDisassemble(JSContext* cx, unsigned argc, Value* vp) {
-  if (!cx->options().wasm()) {
+  if (!cx->options().wasm()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "wasm support unavailable");
     return false;
   }
@@ -1349,77 +1349,77 @@ static bool WasmDisassemble(JSContext* c
   if (!args.get(0).isObject()) {
     JS_ReportErrorASCII(cx, "argument is not an object");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   bool asString = false;
   RootedValue tierSelection(cx);
   int kindSelection = (1 << wasm::CodeRange::Function);
-  if (args.length() > 1 && args[1].isObject()) {
+  if (args.length() > 1 && args[1].isObject()) {MOZ_RELEASE_ASSERT(0);
     RootedObject options(cx, &args[1].toObject());
     RootedValue val(cx);
 
-    if (!JS_GetProperty(cx, options, "asString", &val)) {
+    if (!JS_GetProperty(cx, options, "asString", &val)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     asString = val.isBoolean() && val.toBoolean();
 
-    if (!JS_GetProperty(cx, options, "tier", &tierSelection)) {
+    if (!JS_GetProperty(cx, options, "tier", &tierSelection)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!JS_GetProperty(cx, options, "kinds", &val)) {
+    if (!JS_GetProperty(cx, options, "kinds", &val)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (val.isString() && val.toString()->hasLatin1Chars()) {
+    if (val.isString() && val.toString()->hasLatin1Chars()) {MOZ_RELEASE_ASSERT(0);
       AutoStableStringChars stable(cx);
-      if (!stable.init(cx, val.toString())) {
+      if (!stable.init(cx, val.toString())) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       const char* p = (const char*)(stable.latin1Chars());
       const char* end = p + val.toString()->length();
       int selection = 0;
-      for (;;) {
-        if (strncmp(p, "Function", 8) == 0) {
+      for (;;) {MOZ_RELEASE_ASSERT(0);
+        if (strncmp(p, "Function", 8) == 0) {MOZ_RELEASE_ASSERT(0);
           selection |= (1 << wasm::CodeRange::Function);
           p += 8;
-        } else if (strncmp(p, "InterpEntry", 11) == 0) {
+        } else if (strncmp(p, "InterpEntry", 11) == 0) {MOZ_RELEASE_ASSERT(0);
           selection |= (1 << wasm::CodeRange::InterpEntry);
           p += 11;
-        } else if (strncmp(p, "JitEntry", 8) == 0) {
+        } else if (strncmp(p, "JitEntry", 8) == 0) {MOZ_RELEASE_ASSERT(0);
           selection |= (1 << wasm::CodeRange::JitEntry);
           p += 8;
-        } else if (strncmp(p, "ImportInterpExit", 16) == 0) {
+        } else if (strncmp(p, "ImportInterpExit", 16) == 0) {MOZ_RELEASE_ASSERT(0);
           selection |= (1 << wasm::CodeRange::ImportInterpExit);
           p += 16;
-        } else if (strncmp(p, "ImportJitExit", 13) == 0) {
+        } else if (strncmp(p, "ImportJitExit", 13) == 0) {MOZ_RELEASE_ASSERT(0);
           selection |= (1 << wasm::CodeRange::ImportJitExit);
           p += 13;
-        } else if (strncmp(p, "all", 3) == 0) {
+        } else if (strncmp(p, "all", 3) == 0) {MOZ_RELEASE_ASSERT(0);
           selection = ~0;
           p += 3;
-        } else {
+        } else {MOZ_RELEASE_ASSERT(0);
           break;
         }
-        if (p == end || *p != ',') {
+        if (p == end || *p != ',') {MOZ_RELEASE_ASSERT(0);
           break;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         p++;
       }
-      if (p == end) {
+      if (p == end) {MOZ_RELEASE_ASSERT(0);
         kindSelection = selection;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorASCII(cx, "argument object has invalid `kinds`");
         return false;
-      }
-    }
-  }
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedFunction func(cx, args[0].toObject().maybeUnwrapIf<JSFunction>());
-  if (func && wasm::IsWasmExportedFunction(func)) {
+  if (func && wasm::IsWasmExportedFunction(func)) {MOZ_RELEASE_ASSERT(0);
     return WasmDisassembleFunction(cx, func, tierSelection, asString,
                                    args.rval());
   }
-  if (args[0].toObject().is<WasmModuleObject>()) {
+  if (args[0].toObject().is<WasmModuleObject>()) {MOZ_RELEASE_ASSERT(0);
     return WasmDisassembleCode(
         cx, args[0].toObject().as<WasmModuleObject>().module().code(),
         tierSelection, kindSelection, asString, args.rval());
@@ -1446,7 +1446,7 @@ static bool WasmReturnFlag(JSContext* cx
 
   Rooted<WasmModuleObject*> module(
       cx, args[0].toObject().maybeUnwrapIf<WasmModuleObject>());
-  if (!module) {
+  if (!module) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "argument is not a WebAssembly.Module");
     return false;
   }
@@ -1552,7 +1552,7 @@ static bool HasSameBytecodeData(JSContex
   //       the functions may be in different Zones.
 
   RefPtr<SharedImmutableScriptData> sharedData1 = GetSharedData(cx, args[0]);
-  if (!sharedData1) {
+  if (!sharedData1) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1573,11 +1573,11 @@ static bool InternalConst(JSContext* cx,
   }
 
   JSString* str = ToString(cx, args[0]);
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   JSLinearString* linear = JS_EnsureLinearString(cx, str);
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1846,7 +1846,7 @@ static bool DumpGCArenaInfo(JSContext* c
 static bool GCState(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() > 1) {
+  if (args.length() > 1) {MOZ_RELEASE_ASSERT(0);
     RootedObject callee(cx, &args.callee());
     ReportUsageErrorASCII(cx, callee, "Too many arguments");
     return false;
@@ -1855,7 +1855,7 @@ static bool GCState(JSContext* cx, unsig
   const char* state;
 
   if (args.length() == 1) {
-    if (!args[0].isObject()) {
+    if (!args[0].isObject()) {MOZ_RELEASE_ASSERT(0);
       RootedObject callee(cx, &args.callee());
       ReportUsageErrorASCII(cx, callee, "Expected object");
       return false;
@@ -1906,7 +1906,7 @@ static bool ScheduleZoneForGC(JSContext*
 static bool StartGC(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() > 2) {
+  if (args.length() > 2) {MOZ_RELEASE_ASSERT(0);
     RootedObject callee(cx, &args.callee());
     ReportUsageErrorASCII(cx, callee, "Wrong number of arguments");
     return false;
@@ -1915,7 +1915,7 @@ static bool StartGC(JSContext* cx, unsig
   auto budget = SliceBudget::unlimited();
   if (args.length() >= 1) {
     uint32_t work = 0;
-    if (!ToUint32(cx, args[0], &work)) {
+    if (!ToUint32(cx, args[0], &work)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     budget = SliceBudget(WorkBudget(work));
@@ -1926,7 +1926,7 @@ static bool StartGC(JSContext* cx, unsig
     Value arg = args[1];
     if (arg.isString()) {
       if (!JS_StringEqualsLiteral(cx, arg.toString(), "shrinking",
-                                  &shrinking)) {
+                                  &shrinking)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1949,7 +1949,7 @@ static bool StartGC(JSContext* cx, unsig
 static bool FinishGC(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() > 0) {
+  if (args.length() > 0) {MOZ_RELEASE_ASSERT(0);
     RootedObject callee(cx, &args.callee());
     ReportUsageErrorASCII(cx, callee, "Wrong number of arguments");
     return false;
@@ -1967,7 +1967,7 @@ static bool FinishGC(JSContext* cx, unsi
 static bool GCSlice(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() > 2) {
+  if (args.length() > 2) {MOZ_RELEASE_ASSERT(0);
     RootedObject callee(cx, &args.callee());
     ReportUsageErrorASCII(cx, callee, "Wrong number of arguments");
     return false;
@@ -1976,7 +1976,7 @@ static bool GCSlice(JSContext* cx, unsig
   auto budget = SliceBudget::unlimited();
   if (args.length() >= 1) {
     uint32_t work = 0;
-    if (!ToUint32(cx, args[0], &work)) {
+    if (!ToUint32(cx, args[0], &work)) {MOZ_RELEASE_ASSERT(0);
       RootedObject callee(cx, &args.callee());
       ReportUsageErrorASCII(cx, callee,
                             "The work budget parameter |n| must be an integer");
@@ -1989,7 +1989,7 @@ static bool GCSlice(JSContext* cx, unsig
   if (args.get(1).isObject()) {
     RootedObject options(cx, &args[1].toObject());
     RootedValue v(cx);
-    if (!JS_GetProperty(cx, options, "dontStart", &v)) {
+    if (!JS_GetProperty(cx, options, "dontStart", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     dontStart = ToBoolean(v);
@@ -2043,7 +2043,7 @@ static bool NondeterministicGetWeakMapKe
     ReportUsageErrorASCII(cx, callee, "Wrong number of arguments");
     return false;
   }
-  if (!args[0].isObject()) {
+  if (!args[0].isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_NOT_EXPECTED_TYPE,
                               "nondeterministicGetWeakMapKeys", "WeakMap",
@@ -2052,7 +2052,7 @@ static bool NondeterministicGetWeakMapKe
   }
   RootedObject arr(cx);
   RootedObject mapObj(cx, &args[0].toObject());
-  if (!JS_NondeterministicGetWeakMapKeys(cx, mapObj, &arr)) {
+  if (!JS_NondeterministicGetWeakMapKeys(cx, mapObj, &arr)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!arr) {
@@ -2070,7 +2070,7 @@ class HasChildTracer final : public JS::
   RootedValue child_;
   bool found_;
 
-  void onChild(const JS::GCCellPtr& thing) override {
+  void onChild(const JS::GCCellPtr& thing) override {MOZ_RELEASE_ASSERT(0);
     if (thing.asCell() == child_.toGCThing()) {
       found_ = true;
     }
@@ -2145,7 +2145,7 @@ static bool SaveStack(JSContext* cx, uns
   JS::StackCapture capture((JS::AllFrames()));
   if (args.length() >= 1) {
     double maxDouble;
-    if (!ToNumber(cx, args[0], &maxDouble)) {
+    if (!ToNumber(cx, args[0], &maxDouble)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (mozilla::IsNaN(maxDouble) || maxDouble < 0 || maxDouble > UINT32_MAX) {
@@ -2161,13 +2161,13 @@ static bool SaveStack(JSContext* cx, uns
 
   RootedObject compartmentObject(cx);
   if (args.length() >= 2) {
-    if (!args[1].isObject()) {
+    if (!args[1].isObject()) {MOZ_RELEASE_ASSERT(0);
       ReportValueError(cx, JSMSG_UNEXPECTED_TYPE, JSDVG_SEARCH_STACK, args[0],
                        nullptr, "not an object");
       return false;
     }
     compartmentObject = UncheckedUnwrap(&args[1].toObject());
-    if (!compartmentObject) {
+    if (!compartmentObject) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2178,7 +2178,7 @@ static bool SaveStack(JSContext* cx, uns
     if (compartmentObject) {
       ar.emplace(cx, compartmentObject);
     }
-    if (!JS::CaptureCurrentStack(cx, &stack, std::move(capture))) {
+    if (!JS::CaptureCurrentStack(cx, &stack, std::move(capture))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2198,14 +2198,14 @@ static bool CaptureFirstSubsumedFrame(JS
     return false;
   }
 
-  if (!args[0].isObject()) {
+  if (!args[0].isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "The argument must be an object");
     return false;
   }
 
   RootedObject obj(cx, &args[0].toObject());
   obj = CheckedUnwrapStatic(obj);
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Denied permission to object.");
     return false;
   }
@@ -2252,15 +2252,15 @@ static bool CallFunctionWithAsyncStack(J
     JS_ReportErrorASCII(cx, "The function takes exactly three arguments.");
     return false;
   }
-  if (!args[0].isObject() || !IsCallable(args[0])) {
+  if (!args[0].isObject() || !IsCallable(args[0])) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "The first argument should be a function.");
     return false;
   }
-  if (!args[1].isObject() || !args[1].toObject().is<SavedFrame>()) {
+  if (!args[1].isObject() || !args[1].toObject().is<SavedFrame>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "The second argument should be a SavedFrame.");
     return false;
   }
-  if (!args[2].isString() || args[2].toString()->empty()) {
+  if (!args[2].isString() || args[2].toString()->empty()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "The third argument should be a non-empty string.");
     return false;
   }
@@ -2326,7 +2326,7 @@ static bool NewString(JSContext* cx, uns
   CallArgs args = CallArgsFromVp(argc, vp);
 
   RootedString src(cx, ToString(cx, args.get(0)));
-  if (!src) {
+  if (!src) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2347,7 +2347,7 @@ static bool NewString(JSContext* cx, uns
          {Setting{"tenured", &requestTenured}, Setting{"twoByte", &wantTwoByte},
           Setting{"external", &forceExternal},
           Setting{"maybeExternal", &maybeExternal}}) {
-      if (!JS_GetProperty(cx, options, name, &v)) {
+      if (!JS_GetProperty(cx, options, name, &v)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       *setting = ToBoolean(v);  // false if not given (or otherwise undefined)
@@ -2364,12 +2364,12 @@ static bool NewString(JSContext* cx, uns
 
   if (forceExternal || maybeExternal) {
     auto buf = cx->make_pod_array<char16_t>(len);
-    if (!buf) {
+    if (!buf) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (!JS_CopyStringChars(cx, mozilla::Range<char16_t>(buf.get(), len),
-                            src)) {
+                            src)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2387,11 +2387,11 @@ static bool NewString(JSContext* cx, uns
   } else {
     AutoStableStringChars stable(cx);
     if (!wantTwoByte && src->hasLatin1Chars()) {
-      if (!stable.init(cx, src)) {
+      if (!stable.init(cx, src)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
-      if (!stable.initTwoByte(cx, src)) {
+      if (!stable.initTwoByte(cx, src)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2400,7 +2400,7 @@ static bool NewString(JSContext* cx, uns
                                               heap);
     } else if (stable.isLatin1()) {
       dest = NewStringCopyN<CanGC>(cx, stable.latin1Chars(), len, heap);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       // Normal behavior: auto-deflate to latin1 if possible.
       dest = NewStringCopyN<CanGC>(cx, stable.twoByteChars(), len, heap);
     }
@@ -2432,7 +2432,7 @@ static bool NewRope(JSContext* cx, unsig
   if (args.get(2).isObject()) {
     RootedObject options(cx, &args[2].toObject());
     RootedValue v(cx);
-    if (!JS_GetProperty(cx, options, "nursery", &v)) {
+    if (!JS_GetProperty(cx, options, "nursery", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!v.isUndefined() && !ToBoolean(v)) {
@@ -2443,7 +2443,7 @@ static bool NewRope(JSContext* cx, unsig
   RootedString left(cx, args[0].toString());
   RootedString right(cx, args[1].toString());
   size_t length = JS_GetStringLength(left) + JS_GetStringLength(right);
-  if (length > JSString::MAX_LENGTH) {
+  if (length > JSString::MAX_LENGTH) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "rope length exceeds maximum string length");
     return false;
   }
@@ -2492,7 +2492,7 @@ static bool RepresentativeStringArray(JS
   CallArgs args = CallArgsFromVp(argc, vp);
 
   RootedObject array(cx, JS::NewArrayObject(cx, 0));
-  if (!array) {
+  if (!array) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2953,7 +2953,7 @@ static bool SettlePromiseNow(JSContext* 
   if (!args.requireAtLeast(cx, "settlePromiseNow", 1)) {
     return false;
   }
-  if (!args[0].isObject() || !args[0].toObject().is<PromiseObject>()) {
+  if (!args[0].isObject() || !args[0].toObject().is<PromiseObject>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "first argument must be a Promise object");
     return false;
   }
@@ -2994,7 +2994,7 @@ static bool GetWaitForAllPromise(JSConte
   RootedNativeObject list(cx, &args[0].toObject().as<NativeObject>());
   RootedObjectVector promises(cx);
   uint32_t count = list->getDenseInitializedLength();
-  if (!promises.resize(count)) {
+  if (!promises.resize(count)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3023,7 +3023,7 @@ static bool ResolvePromise(JSContext* cx
     return false;
   }
   if (!args[0].isObject() ||
-      !UncheckedUnwrap(&args[0].toObject())->is<PromiseObject>()) {
+      !UncheckedUnwrap(&args[0].toObject())->is<PromiseObject>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(
         cx, "first argument must be a maybe-wrapped Promise object");
     return false;
@@ -3035,12 +3035,12 @@ static bool ResolvePromise(JSContext* cx
   if (IsWrapper(promise)) {
     promise = UncheckedUnwrap(promise);
     ar.emplace(cx, promise);
-    if (!cx->compartment()->wrap(cx, &resolution)) {
+    if (!cx->compartment()->wrap(cx, &resolution)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (IsPromiseForAsyncFunctionOrGenerator(promise)) {
+  if (IsPromiseForAsyncFunctionOrGenerator(promise)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(
         cx,
         "async function/generator's promise shouldn't be manually resolved");
@@ -3060,7 +3060,7 @@ static bool RejectPromise(JSContext* cx,
     return false;
   }
   if (!args[0].isObject() ||
-      !UncheckedUnwrap(&args[0].toObject())->is<PromiseObject>()) {
+      !UncheckedUnwrap(&args[0].toObject())->is<PromiseObject>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(
         cx, "first argument must be a maybe-wrapped Promise object");
     return false;
@@ -3072,12 +3072,12 @@ static bool RejectPromise(JSContext* cx,
   if (IsWrapper(promise)) {
     promise = UncheckedUnwrap(promise);
     ar.emplace(cx, promise);
-    if (!cx->compartment()->wrap(cx, &reason)) {
+    if (!cx->compartment()->wrap(cx, &reason)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (IsPromiseForAsyncFunctionOrGenerator(promise)) {
+  if (IsPromiseForAsyncFunctionOrGenerator(promise)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(
         cx,
         "async function/generator's promise shouldn't be manually rejected");
@@ -3151,32 +3151,32 @@ static bool DumpHeap(JSContext* cx, unsi
 
   FILE* dumpFile = stdout;
 
-  if (args.length() > 1) {
+  if (args.length() > 1) {MOZ_RELEASE_ASSERT(0);
     RootedObject callee(cx, &args.callee());
     ReportUsageErrorASCII(cx, callee, "Too many arguments");
     return false;
   }
 
-  if (!args.get(0).isUndefined()) {
+  if (!args.get(0).isUndefined()) {MOZ_RELEASE_ASSERT(0);
     RootedString str(cx, ToString(cx, args[0]));
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!fuzzingSafe) {
+    if (!fuzzingSafe) {MOZ_RELEASE_ASSERT(0);
       UniqueChars fileNameBytes = JS_EncodeStringToLatin1(cx, str);
-      if (!fileNameBytes) {
+      if (!fileNameBytes) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       dumpFile = fopen(fileNameBytes.get(), "w");
-      if (!dumpFile) {
+      if (!dumpFile) {MOZ_RELEASE_ASSERT(0);
         fileNameBytes = JS_EncodeStringToLatin1(cx, str);
-        if (!fileNameBytes) {
+        if (!fileNameBytes) {MOZ_RELEASE_ASSERT(0);
           return false;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorLatin1(cx, "can't open %s", fileNameBytes.get());
         return false;
-      }
-    }
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   js::DumpHeap(cx, dumpFile, js::IgnoreNurseryObjects);
@@ -3212,13 +3212,13 @@ static bool ReadGeckoProfilingStack(JSCo
 
   // Array holding physical jit stack frames.
   RootedObject stack(cx, NewDenseEmptyArray(cx));
-  if (!stack) {
+  if (!stack) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // If profiler sampling has been suppressed, return an empty
   // stack.
-  if (!cx->isProfilerSamplingEnabled()) {
+  if (!cx->isProfilerSamplingEnabled()) {MOZ_RELEASE_ASSERT(0);
     args.rval().setObject(*stack);
     return true;
   }
@@ -3237,7 +3237,7 @@ static bool ReadGeckoProfilingStack(JSCo
   for (JS::ProfilingFrameIterator i(cx, state); !i.done(); ++i) {
     MOZ_ASSERT(i.stackAddress() != nullptr);
 
-    if (!frameInfo.emplaceBack(cx)) {
+    if (!frameInfo.emplaceBack(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3266,11 +3266,11 @@ static bool ReadGeckoProfilingStack(JSCo
 
       UniqueChars label =
           DuplicateStringToArena(js::StringBufferArena, cx, frames[i].label);
-      if (!label) {
+      if (!label) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
-      if (!frameInfo.back().emplaceBack(frameKindStr, std::move(label))) {
+      if (!frameInfo.back().emplaceBack(frameKindStr, std::move(label))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -3287,7 +3287,7 @@ static bool ReadGeckoProfilingStack(JSCo
   for (auto& frame : frameInfo) {
     // Array holding all inline frames in a single physical jit stack frame.
     RootedObject inlineStack(cx, NewDenseEmptyArray(cx));
-    if (!inlineStack) {
+    if (!inlineStack) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3296,32 +3296,32 @@ static bool ReadGeckoProfilingStack(JSCo
       // Object holding frame info.
       RootedObject inlineFrameInfo(cx,
                                    NewBuiltinClassInstance<PlainObject>(cx));
-      if (!inlineFrameInfo) {
+      if (!inlineFrameInfo) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       frameKind = NewStringCopyZ<CanGC>(cx, inlineFrame.kind);
-      if (!frameKind) {
+      if (!frameKind) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       if (!JS_DefineProperty(cx, inlineFrameInfo, "kind", frameKind,
-                             propAttrs)) {
+                             propAttrs)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       frameLabel = NewLatin1StringZ(cx, std::move(inlineFrame.label));
-      if (!frameLabel) {
+      if (!frameLabel) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       if (!JS_DefineProperty(cx, inlineFrameInfo, "label", frameLabel,
-                             propAttrs)) {
+                             propAttrs)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       idx = INT_TO_JSID(inlineFrameNo);
-      if (!JS_DefinePropertyById(cx, inlineStack, idx, inlineFrameInfo, 0)) {
+      if (!JS_DefinePropertyById(cx, inlineStack, idx, inlineFrameInfo, 0)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -3377,23 +3377,23 @@ class ShellAllocationMetadataBuilder : p
 JSObject* ShellAllocationMetadataBuilder::build(
     JSContext* cx, HandleObject, AutoEnterOOMUnsafeRegion& oomUnsafe) const {
   RootedObject obj(cx, NewBuiltinClassInstance<PlainObject>(cx));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     oomUnsafe.crash("ShellAllocationMetadataBuilder::build");
   }
 
   RootedObject stack(cx, NewDenseEmptyArray(cx));
-  if (!stack) {
+  if (!stack) {MOZ_RELEASE_ASSERT(0);
     oomUnsafe.crash("ShellAllocationMetadataBuilder::build");
   }
 
   static int createdIndex = 0;
   createdIndex++;
 
-  if (!JS_DefineProperty(cx, obj, "index", createdIndex, 0)) {
+  if (!JS_DefineProperty(cx, obj, "index", createdIndex, 0)) {MOZ_RELEASE_ASSERT(0);
     oomUnsafe.crash("ShellAllocationMetadataBuilder::build");
   }
 
-  if (!JS_DefineProperty(cx, obj, "stack", stack, 0)) {
+  if (!JS_DefineProperty(cx, obj, "stack", stack, 0)) {MOZ_RELEASE_ASSERT(0);
     oomUnsafe.crash("ShellAllocationMetadataBuilder::build");
   }
 
@@ -3478,7 +3478,7 @@ static bool testingFunc_invalidate(JSCon
   // If the topmost frame is Ion/Warp, find the IonScript and invalidate it.
   FrameIter iter(cx);
   if (!iter.done() && iter.isIon()) {
-    while (!iter.isPhysicalJitFrame()) {
+    while (!iter.isPhysicalJitFrame()) {MOZ_RELEASE_ASSERT(0);
       ++iter;
     }
     if (iter.script()->hasIonScript()) {
@@ -3643,7 +3643,7 @@ class CloneBufferObject : public NativeO
 
   static CloneBufferObject* Create(JSContext* cx) {
     RootedObject obj(cx, JS_NewObject(cx, &class_));
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     obj->as<CloneBufferObject>().setReservedSlot(DATA_SLOT,
@@ -3661,7 +3661,7 @@ class CloneBufferObject : public NativeO
   static CloneBufferObject* Create(JSContext* cx,
                                    JSAutoStructuredCloneBuffer* buffer) {
     Rooted<CloneBufferObject*> obj(cx, Create(cx));
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     auto data = js::MakeUnique<JSStructuredCloneData>(buffer->scope());
@@ -3713,18 +3713,18 @@ class CloneBufferObject : public NativeO
       data = reinterpret_cast<char*>(dataBytes);
     } else {
       JSString* str = JS::ToString(cx, args.get(0));
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       dataOwner = JS_EncodeStringToLatin1(cx, str);
-      if (!dataOwner) {
+      if (!dataOwner) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       data = dataOwner.get();
       nbytes = JS_GetStringLength(str);
     }
 
-    if (nbytes == 0 || (nbytes % sizeof(uint64_t) != 0)) {
+    if (nbytes == 0 || (nbytes % sizeof(uint64_t) != 0)) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "Invalid length for clonebuffer data");
       return false;
     }
@@ -3755,13 +3755,13 @@ class CloneBufferObject : public NativeO
 
   static bool getData(JSContext* cx, Handle<CloneBufferObject*> obj,
                       JSStructuredCloneData** data) {
-    if (!obj->data()) {
+    if (!obj->data()) {MOZ_RELEASE_ASSERT(0);
       *data = nullptr;
       return true;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     bool hasTransferable;
-    if (!JS_StructuredCloneHasTransferables(*obj->data(), &hasTransferable)) {
+    if (!JS_StructuredCloneHasTransferables(*obj->data(), &hasTransferable)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3775,27 +3775,27 @@ class CloneBufferObject : public NativeO
     return true;
   }
 
-  static bool getCloneBuffer_impl(JSContext* cx, const CallArgs& args) {
+  static bool getCloneBuffer_impl(JSContext* cx, const CallArgs& args) {MOZ_RELEASE_ASSERT(0);
     Rooted<CloneBufferObject*> obj(
         cx, &args.thisv().toObject().as<CloneBufferObject>());
     MOZ_ASSERT(args.length() == 0);
 
     JSStructuredCloneData* data;
-    if (!getData(cx, obj, &data)) {
+    if (!getData(cx, obj, &data)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     size_t size = data->Size();
     UniqueChars buffer(js_pod_malloc<char>(size));
-    if (!buffer) {
+    if (!buffer) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     auto iter = data->Start();
-    if (!data->ReadBytes(iter, buffer.get(), size)) {
+    if (!data->ReadBytes(iter, buffer.get(), size)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     JSString* str = JS_NewStringCopyN(cx, buffer.get(), size);
     if (!str) {
       return false;
@@ -3810,27 +3810,27 @@ class CloneBufferObject : public NativeO
   }
 
   static bool getCloneBufferAsArrayBuffer_impl(JSContext* cx,
-                                               const CallArgs& args) {
+                                               const CallArgs& args) {MOZ_RELEASE_ASSERT(0);
     Rooted<CloneBufferObject*> obj(
         cx, &args.thisv().toObject().as<CloneBufferObject>());
     MOZ_ASSERT(args.length() == 0);
 
     JSStructuredCloneData* data;
-    if (!getData(cx, obj, &data)) {
+    if (!getData(cx, obj, &data)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     size_t size = data->Size();
     UniqueChars buffer(js_pod_malloc<char>(size));
-    if (!buffer) {
+    if (!buffer) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     auto iter = data->Start();
-    if (!data->ReadBytes(iter, buffer.get(), size)) {
+    if (!data->ReadBytes(iter, buffer.get(), size)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     auto* rawBuffer = buffer.release();
     JSObject* arrayBuffer = JS::NewArrayBufferWithContents(cx, size, rawBuffer);
@@ -3884,7 +3884,7 @@ static mozilla::Maybe<JS::StructuredClon
   mozilla::Maybe<JS::StructuredCloneScope> scope;
 
   JSLinearString* scopeStr = str->ensureLinear(cx);
-  if (!scopeStr) {
+  if (!scopeStr) {MOZ_RELEASE_ASSERT(0);
     return scope;
   }
 
@@ -3907,22 +3907,22 @@ bool js::testingFunc_serialize(JSContext
 
   if (!args.get(2).isUndefined()) {
     RootedObject opts(cx, ToObject(cx, args.get(2)));
-    if (!opts) {
+    if (!opts) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedValue v(cx);
-    if (!JS_GetProperty(cx, opts, "SharedArrayBuffer", &v)) {
+    if (!JS_GetProperty(cx, opts, "SharedArrayBuffer", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (!v.isUndefined()) {
       JSString* str = JS::ToString(cx, v);
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       JSLinearString* poli = str->ensureLinear(cx);
-      if (!poli) {
+      if (!poli) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -3931,23 +3931,23 @@ bool js::testingFunc_serialize(JSContext
         policy.allowIntraClusterClonableSharedObjects();
       } else if (StringEqualsLiteral(poli, "deny")) {
         // default
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorASCII(cx, "Invalid policy value for 'SharedArrayBuffer'");
         return false;
       }
     }
 
-    if (!JS_GetProperty(cx, opts, "scope", &v)) {
+    if (!JS_GetProperty(cx, opts, "scope", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (!v.isUndefined()) {
       RootedString str(cx, JS::ToString(cx, v));
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       auto scope = ParseCloneScope(cx, str);
-      if (!scope) {
+      if (!scope) {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorASCII(cx, "Invalid structured clone scope");
         return false;
       }
@@ -3988,22 +3988,22 @@ static bool Deserialize(JSContext* cx, u
                          : JS::StructuredCloneScope::SameProcess;
   if (args.get(1).isObject()) {
     RootedObject opts(cx, &args[1].toObject());
-    if (!opts) {
+    if (!opts) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedValue v(cx);
-    if (!JS_GetProperty(cx, opts, "SharedArrayBuffer", &v)) {
+    if (!JS_GetProperty(cx, opts, "SharedArrayBuffer", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (!v.isUndefined()) {
       JSString* str = JS::ToString(cx, v);
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       JSLinearString* poli = str->ensureLinear(cx);
-      if (!poli) {
+      if (!poli) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -4012,40 +4012,40 @@ static bool Deserialize(JSContext* cx, u
         policy.allowIntraClusterClonableSharedObjects();
       } else if (StringEqualsLiteral(poli, "deny")) {
         // default
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorASCII(cx, "Invalid policy value for 'SharedArrayBuffer'");
         return false;
       }
     }
 
-    if (!JS_GetProperty(cx, opts, "scope", &v)) {
+    if (!JS_GetProperty(cx, opts, "scope", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!v.isUndefined()) {
+    if (!v.isUndefined()) {MOZ_RELEASE_ASSERT(0);
       RootedString str(cx, JS::ToString(cx, v));
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       auto maybeScope = ParseCloneScope(cx, str);
-      if (!maybeScope) {
+      if (!maybeScope) {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorASCII(cx, "Invalid structured clone scope");
         return false;
       }
 
-      if (*maybeScope < scope) {
+      if (*maybeScope < scope) {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorASCII(cx,
                             "Cannot use less restrictive scope "
                             "than the deserialized clone buffer's scope");
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       scope = *maybeScope;
     }
   }
 
   // Clone buffer was already consumed?
-  if (!obj->data()) {
+  if (!obj->data()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx,
                         "deserialize given invalid clone buffer "
                         "(transferables already consumed?)");
@@ -4053,7 +4053,7 @@ static bool Deserialize(JSContext* cx, u
   }
 
   bool hasTransferable;
-  if (!JS_StructuredCloneHasTransferables(*obj->data(), &hasTransferable)) {
+  if (!JS_StructuredCloneHasTransferables(*obj->data(), &hasTransferable)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4081,7 +4081,7 @@ static bool DetachArrayBuffer(JSContext*
     return false;
   }
 
-  if (!args[0].isObject()) {
+  if (!args[0].isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "detachArrayBuffer must be passed an object");
     return false;
   }
@@ -4098,7 +4098,7 @@ static bool DetachArrayBuffer(JSContext*
 static bool HelperThreadCount(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (js::SupportDifferentialTesting()) {
+  if (js::SupportDifferentialTesting()) {MOZ_RELEASE_ASSERT(0);
     // Always return 0 to get consistent output with and without --no-threads.
     args.rval().setInt32(0);
     return true;
@@ -4177,7 +4177,7 @@ static bool SharedArrayRawBufferRefcount
   if (args.length() != 1 || !args[0].isObject()) {
     JS_ReportErrorASCII(cx, "Expected SharedArrayBuffer object");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   RootedObject obj(cx, &args[0].toObject());
   if (!obj->is<SharedArrayBufferObject>()) {
     JS_ReportErrorASCII(cx, "Expected SharedArrayBuffer object");
@@ -4192,7 +4192,7 @@ static bool SharedArrayRawBufferRefcount
 static bool ObjectAddress(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (js::SupportDifferentialTesting()) {
+  if (js::SupportDifferentialTesting()) {MOZ_RELEASE_ASSERT(0);
     RootedObject callee(cx, &args.callee());
     ReportUsageErrorASCII(cx, callee,
                           "Function unavailable in differential testing mode.");
@@ -4220,7 +4220,7 @@ static bool ObjectAddress(JSContext* cx,
 static bool SharedAddress(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (js::SupportDifferentialTesting()) {
+  if (js::SupportDifferentialTesting()) {MOZ_RELEASE_ASSERT(0);
     RootedObject callee(cx, &args.callee());
     ReportUsageErrorASCII(cx, callee,
                           "Function unavailable in differential testing mode.");
@@ -4232,21 +4232,21 @@ static bool SharedAddress(JSContext* cx,
     ReportUsageErrorASCII(cx, callee, "Wrong number of arguments");
     return false;
   }
-  if (!args[0].isObject()) {
+  if (!args[0].isObject()) {MOZ_RELEASE_ASSERT(0);
     RootedObject callee(cx, &args.callee());
     ReportUsageErrorASCII(cx, callee, "Expected object");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedObject obj(cx, CheckedUnwrapStatic(&args[0].toObject()));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     ReportAccessDenied(cx);
     return false;
   }
-  if (!obj->is<SharedArrayBufferObject>()) {
+  if (!obj->is<SharedArrayBufferObject>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Argument must be a SharedArrayBuffer");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   char buffer[64];
   uint32_t nchar = SprintfLiteral(
       buffer, "%p",
@@ -4278,7 +4278,7 @@ static bool GetBacktrace(JSContext* cx, 
   bool showLocals = false;
   bool showThisProps = false;
 
-  if (args.length() > 1) {
+  if (args.length() > 1) {MOZ_RELEASE_ASSERT(0);
     RootedObject callee(cx, &args.callee());
     ReportUsageErrorASCII(cx, callee, "Too many arguments");
     return false;
@@ -4286,22 +4286,22 @@ static bool GetBacktrace(JSContext* cx, 
 
   if (args.length() == 1) {
     RootedObject cfg(cx, ToObject(cx, args[0]));
-    if (!cfg) {
+    if (!cfg) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     RootedValue v(cx);
 
-    if (!JS_GetProperty(cx, cfg, "args", &v)) {
+    if (!JS_GetProperty(cx, cfg, "args", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     showArgs = ToBoolean(v);
 
-    if (!JS_GetProperty(cx, cfg, "locals", &v)) {
+    if (!JS_GetProperty(cx, cfg, "locals", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     showLocals = ToBoolean(v);
 
-    if (!JS_GetProperty(cx, cfg, "thisprops", &v)) {
+    if (!JS_GetProperty(cx, cfg, "thisprops", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     showThisProps = ToBoolean(v);
@@ -4309,7 +4309,7 @@ static bool GetBacktrace(JSContext* cx, 
 
   JS::UniqueChars buf =
       JS::FormatStackDump(cx, showArgs, showLocals, showThisProps);
-  if (!buf) {
+  if (!buf) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4497,13 +4497,13 @@ static bool FindPath(JSContext* cx, unsi
   // We don't ToString non-objects given as 'start' or 'target', because this
   // test is all about object identity, and ToString doesn't preserve that.
   // Non-GCThing endpoints don't make much sense.
-  if (!args[0].isObject() && !args[0].isString() && !args[0].isSymbol()) {
+  if (!args[0].isObject() && !args[0].isString() && !args[0].isSymbol()) {MOZ_RELEASE_ASSERT(0);
     ReportValueError(cx, JSMSG_UNEXPECTED_TYPE, JSDVG_SEARCH_STACK, args[0],
                      nullptr, "not an object, string, or symbol");
     return false;
   }
 
-  if (!args[1].isObject() && !args[1].isString() && !args[1].isSymbol()) {
+  if (!args[1].isObject() && !args[1].isString() && !args[1].isSymbol()) {MOZ_RELEASE_ASSERT(0);
     ReportValueError(cx, JSMSG_UNEXPECTED_TYPE, JSDVG_SEARCH_STACK, args[0],
                      nullptr, "not an object, string, or symbol");
     return false;
@@ -4521,19 +4521,19 @@ static bool FindPath(JSContext* cx, unsi
 
     heaptools::FindPathHandler handler(cx, start, target, &nodes, edges);
     heaptools::FindPathHandler::Traversal traversal(cx, handler, autoCannotGC);
-    if (!traversal.addStart(start)) {
+    if (!traversal.addStart(start)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
 
     if (!traversal.traverse()) {
-      if (!cx->isExceptionPending()) {
+      if (!cx->isExceptionPending()) {MOZ_RELEASE_ASSERT(0);
         ReportOutOfMemory(cx);
-      }
+      }MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!handler.foundPath) {
+    if (!handler.foundPath) {MOZ_RELEASE_ASSERT(0);
       // We didn't find any paths from the start to the target.
       args.rval().setUndefined();
       return true;
@@ -4555,7 +4555,7 @@ static bool FindPath(JSContext* cx, unsi
   //   { node: undefined, edge: <string> }
   size_t length = nodes.length();
   RootedArrayObject result(cx, NewDenseFullyAllocatedArray(cx, length));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   result->ensureDenseInitializedLength(0, length);
@@ -4565,16 +4565,16 @@ static bool FindPath(JSContext* cx, unsi
   for (size_t i = 0; i < length; i++) {
     // Build an object describing the node and edge.
     RootedObject obj(cx, NewBuiltinClassInstance<PlainObject>(cx));
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedValue wrapped(cx, nodes[i]);
-    if (!cx->compartment()->wrap(cx, &wrapped)) {
+    if (!cx->compartment()->wrap(cx, &wrapped)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!JS_DefineProperty(cx, obj, "node", wrapped, JSPROP_ENUMERATE)) {
+    if (!JS_DefineProperty(cx, obj, "node", wrapped, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -4583,7 +4583,7 @@ static bool FindPath(JSContext* cx, unsi
     size_t edgeNameLength = js_strlen(edgeName.get());
     RootedString edgeStr(
         cx, NewString<CanGC>(cx, std::move(edgeName), edgeNameLength));
-    if (!edgeStr) {
+    if (!edgeStr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -4612,7 +4612,7 @@ static bool ShortestPaths(JSContext* cx,
 
   RootedArrayObject objs(cx, &args[0].toObject().as<ArrayObject>());
   size_t length = objs->getDenseInitializedLength();
-  if (length == 0) {
+  if (length == 0) {MOZ_RELEASE_ASSERT(0);
     ReportValueError(cx, JSMSG_UNEXPECTED_TYPE, JSDVG_SEARCH_STACK, args[0],
                      nullptr,
                      "not a dense array object with one or more elements");
@@ -4632,7 +4632,7 @@ static bool ShortestPaths(JSContext* cx,
   int32_t maxNumPaths = 3;
 
   if (!args.get(1).isUndefined()) {
-    if (!args[1].isObject()) {
+    if (!args[1].isObject()) {MOZ_RELEASE_ASSERT(0);
       ReportValueError(cx, JSMSG_UNEXPECTED_TYPE, JSDVG_SEARCH_STACK, args[1],
                        nullptr, "not an options object");
       return false;
@@ -4640,11 +4640,11 @@ static bool ShortestPaths(JSContext* cx,
 
     RootedObject options(cx, &args[1].toObject());
     bool exists;
-    if (!JS_HasProperty(cx, options, "start", &exists)) {
+    if (!JS_HasProperty(cx, options, "start", &exists)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (exists) {
-      if (!JS_GetProperty(cx, options, "start", &start)) {
+      if (!JS_GetProperty(cx, options, "start", &start)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -4657,18 +4657,18 @@ static bool ShortestPaths(JSContext* cx,
     }
 
     RootedValue v(cx, Int32Value(maxNumPaths));
-    if (!JS_HasProperty(cx, options, "maxNumPaths", &exists)) {
+    if (!JS_HasProperty(cx, options, "maxNumPaths", &exists)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (exists) {
-      if (!JS_GetProperty(cx, options, "maxNumPaths", &v)) {
+      if (!JS_GetProperty(cx, options, "maxNumPaths", &v)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
-      if (!JS::ToInt32(cx, v, &maxNumPaths)) {
+      if (!JS::ToInt32(cx, v, &maxNumPaths)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
-    if (maxNumPaths <= 0) {
+    if (maxNumPaths <= 0) {MOZ_RELEASE_ASSERT(0);
       ReportValueError(cx, JSMSG_UNEXPECTED_TYPE, JSDVG_SEARCH_STACK, v,
                        nullptr, "not greater than 0");
       return false;
@@ -4688,7 +4688,7 @@ static bool ShortestPaths(JSContext* cx,
 
     JS::ubi::RootList rootList(cx, maybeNoGC, true);
     if (start.isNull()) {
-      if (!rootList.init()) {
+      if (!rootList.init()) {MOZ_RELEASE_ASSERT(0);
         ReportOutOfMemory(cx);
         return false;
       }
@@ -4704,7 +4704,7 @@ static bool ShortestPaths(JSContext* cx,
     for (size_t i = 0; i < length; i++) {
       RootedValue val(cx, objs->getDenseElement(i));
       JS::ubi::Node node(val);
-      if (!targets.put(node)) {
+      if (!targets.put(node)) {MOZ_RELEASE_ASSERT(0);
         ReportOutOfMemory(cx);
         return false;
       }
@@ -4712,7 +4712,7 @@ static bool ShortestPaths(JSContext* cx,
 
     auto maybeShortestPaths = JS::ubi::ShortestPaths::Create(
         cx, noGC, maxNumPaths, root, std::move(targets));
-    if (maybeShortestPaths.isNothing()) {
+    if (maybeShortestPaths.isNothing()) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
@@ -4720,7 +4720,7 @@ static bool ShortestPaths(JSContext* cx,
 
     for (size_t i = 0; i < length; i++) {
       if (!values.append(GCVector<GCVector<Value>>(cx)) ||
-          !names.append(Vector<Vector<JS::ubi::EdgeName>>(cx))) {
+          !names.append(Vector<Vector<JS::ubi::EdgeName>>(cx))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -4742,7 +4742,7 @@ static bool ShortestPaths(JSContext* cx,
                names.back().append(std::move(pathNames));
       });
 
-      if (!ok) {
+      if (!ok) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -4752,7 +4752,7 @@ static bool ShortestPaths(JSContext* cx,
   MOZ_ASSERT(values.length() == length);
 
   RootedArrayObject results(cx, NewDenseFullyAllocatedArray(cx, length));
-  if (!results) {
+  if (!results) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   results->ensureDenseInitializedLength(0, length);
@@ -4762,7 +4762,7 @@ static bool ShortestPaths(JSContext* cx,
     MOZ_ASSERT(names[i].length() == numPaths);
 
     RootedArrayObject pathsArray(cx, NewDenseFullyAllocatedArray(cx, numPaths));
-    if (!pathsArray) {
+    if (!pathsArray) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     pathsArray->ensureDenseInitializedLength(0, numPaths);
@@ -4772,21 +4772,21 @@ static bool ShortestPaths(JSContext* cx,
       MOZ_ASSERT(names[i][j].length() == pathLength);
 
       RootedArrayObject path(cx, NewDenseFullyAllocatedArray(cx, pathLength));
-      if (!path) {
+      if (!path) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       path->ensureDenseInitializedLength(0, pathLength);
 
       for (size_t k = 0; k < pathLength; k++) {
         RootedPlainObject part(cx, NewBuiltinClassInstance<PlainObject>(cx));
-        if (!part) {
+        if (!part) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         RootedValue predecessor(cx, values[i][j][k]);
         if (!cx->compartment()->wrap(cx, &predecessor) ||
             !JS_DefineProperty(cx, part, "predecessor", predecessor,
-                               JSPROP_ENUMERATE)) {
+                               JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -4819,20 +4819,20 @@ static bool EvalReturningScope(JSContext
   }
 
   RootedString str(cx, ToString(cx, args[0]));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject global(cx);
   if (args.hasDefined(1)) {
     global = ToObject(cx, args[1]);
-    if (!global) {
+    if (!global) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   AutoStableStringChars strChars(cx);
-  if (!strChars.initTwoByte(cx, str)) {
+  if (!strChars.initTwoByte(cx, str)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4851,22 +4851,22 @@ static bool EvalReturningScope(JSContext
   options.setNonSyntacticScope(true);
 
   JS::SourceText<char16_t> srcBuf;
-  if (!srcBuf.init(cx, src, srclen, SourceOwnership::Borrowed)) {
+  if (!srcBuf.init(cx, src, srclen, SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedScript script(cx, JS::Compile(cx, options, srcBuf));
-  if (!script) {
+  if (!script) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (global) {
     global = CheckedUnwrapDynamic(global, cx, /* stopAtWindowProxy = */ false);
-    if (!global) {
+    if (!global) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "Permission denied to access global");
       return false;
     }
-    if (!global->is<GlobalObject>()) {
+    if (!global->is<GlobalObject>()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "Argument must be a global object");
       return false;
     }
@@ -4882,7 +4882,7 @@ static bool EvalReturningScope(JSContext
     // executing it.
     AutoRealm ar(cx, global);
     JS::RootedObject obj(cx, JS_NewPlainObject(cx));
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -4912,17 +4912,17 @@ static bool ShellCloneAndExecuteScript(J
   }
 
   RootedString str(cx, ToString(cx, args[0]));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject global(cx, ToObject(cx, args[1]));
-  if (!global) {
+  if (!global) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   AutoStableStringChars strChars(cx);
-  if (!strChars.initTwoByte(cx, str)) {
+  if (!strChars.initTwoByte(cx, str)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4939,21 +4939,21 @@ static bool ShellCloneAndExecuteScript(J
   options.setFileAndLine(filename.get(), lineno);
 
   JS::SourceText<char16_t> srcBuf;
-  if (!srcBuf.init(cx, src, srclen, SourceOwnership::Borrowed)) {
+  if (!srcBuf.init(cx, src, srclen, SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedScript script(cx, JS::Compile(cx, options, srcBuf));
-  if (!script) {
+  if (!script) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   global = CheckedUnwrapDynamic(global, cx, /* stopAtWindowProxy = */ false);
-  if (!global) {
+  if (!global) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Permission denied to access global");
     return false;
   }
-  if (!global->is<GlobalObject>()) {
+  if (!global->is<GlobalObject>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Argument must be a global object");
     return false;
   }
@@ -4998,7 +4998,7 @@ static bool ByteSizeOfScript(JSContext* 
   if (!args.requireAtLeast(cx, "byteSizeOfScript", 1)) {
     return false;
   }
-  if (!args[0].isObject() || !args[0].toObject().is<JSFunction>()) {
+  if (!args[0].isObject() || !args[0].toObject().is<JSFunction>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Argument must be a Function object");
     return false;
   }
@@ -5010,7 +5010,7 @@ static bool ByteSizeOfScript(JSContext* 
   }
 
   RootedScript script(cx, JSFunction::getOrCreateScript(cx, fun));
-  if (!script) {
+  if (!script) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5102,7 +5102,7 @@ static bool CompileStencilXDR(JSContext*
   }
 
   RootedString src(cx, ToString<CanGC>(cx, args[0]));
-  if (!src) {
+  if (!src) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5112,12 +5112,12 @@ static bool CompileStencilXDR(JSContext*
 
   /* Linearize the string to obtain a char16_t* range. */
   AutoStableStringChars linearChars(cx);
-  if (!linearChars.initTwoByte(cx, src)) {
+  if (!linearChars.initTwoByte(cx, src)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   JS::SourceText<char16_t> srcBuf;
   if (!srcBuf.init(cx, linearChars.twoByteChars(), src->length(),
-                   JS::SourceOwnership::Borrowed)) {
+                   JS::SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5132,7 +5132,7 @@ static bool CompileStencilXDR(JSContext*
                                            frontend::CompilationInput(options));
   auto stencil = frontend::CompileGlobalScriptToExtensibleStencil(
       cx, input.get(), srcBuf, ScopeKind::Global);
-  if (!stencil) {
+  if (!stencil) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5140,14 +5140,14 @@ static bool CompileStencilXDR(JSContext*
   JS::TranscodeBuffer xdrBytes;
   {
     frontend::BorrowingCompilationStencil borrowingStencil(*stencil);
-    if (!borrowingStencil.serializeStencils(cx, input.get(), xdrBytes)) {
+    if (!borrowingStencil.serializeStencils(cx, input.get(), xdrBytes)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   /* Dump the bytes into a javascript ArrayBuffer and return a UInt8Array. */
   RootedObject arrayBuf(cx, JS::NewArrayBuffer(cx, xdrBytes.length()));
-  if (!arrayBuf) {
+  if (!arrayBuf) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5170,7 +5170,7 @@ static bool EvalStencilXDR(JSContext* cx
   }
 
   /* Prepare the input byte array. */
-  if (!args[0].isObject() || !args[0].toObject().is<ArrayBufferObject>()) {
+  if (!args[0].isObject() || !args[0].toObject().is<ArrayBufferObject>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "evalStencilXDR: ArrayBuffer expected");
     return false;
   }
@@ -5186,7 +5186,7 @@ static bool EvalStencilXDR(JSContext* cx
 
   Rooted<frontend::CompilationInput> input(cx,
                                            frontend::CompilationInput(options));
-  if (!input.get().initForGlobal(cx)) {
+  if (!input.get().initForGlobal(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   frontend::CompilationStencil stencil(nullptr);
@@ -5194,10 +5194,10 @@ static bool EvalStencilXDR(JSContext* cx
   /* Deserialize the stencil from XDR. */
   JS::TranscodeRange xdrRange(src->dataPointer(), src->byteLength().get());
   bool succeeded = false;
-  if (!stencil.deserializeStencils(cx, input.get(), xdrRange, &succeeded)) {
-    return false;
-  }
-  if (!succeeded) {
+  if (!stencil.deserializeStencils(cx, input.get(), xdrRange, &succeeded)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!succeeded) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Decoding failure");
     return false;
   }
@@ -5205,7 +5205,7 @@ static bool EvalStencilXDR(JSContext* cx
   /* Instantiate the stencil. */
   Rooted<frontend::CompilationGCOutput> output(cx);
   if (!frontend::CompilationStencil::instantiateStencils(
-          cx, input.get(), stencil, output.get())) {
+          cx, input.get(), stencil, output.get())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5235,7 +5235,7 @@ static bool AllocationMarker(JSContext* 
     RootedObject options(cx, &args[0].toObject());
 
     RootedValue nurseryVal(cx);
-    if (!JS_GetProperty(cx, options, "nursery", &nurseryVal)) {
+    if (!JS_GetProperty(cx, options, "nursery", &nurseryVal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     allocateInsideNursery = ToBoolean(nurseryVal);
@@ -5281,13 +5281,13 @@ struct MinorGC {
 };
 
 static void minorGC(JSContext* cx, JSGCStatus status, JS::GCReason reason,
-                    void* data) {
+                    void* data) {MOZ_RELEASE_ASSERT(0);
   auto info = static_cast<MinorGC*>(data);
-  if (!(info->phases & (1 << status))) {
+  if (!(info->phases & (1 << status))) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
-  if (info->active) {
+  if (info->active) {MOZ_RELEASE_ASSERT(0);
     info->active = false;
     if (cx->zone() && !cx->zone()->isAtomsZone()) {
       cx->runtime()->gc.evictNursery(JS::GCReason::DEBUG_GC);
@@ -5316,75 +5316,75 @@ static bool SetGCCallback(JSContext* cx,
   }
 
   RootedObject opts(cx, ToObject(cx, args[0]));
-  if (!opts) {
+  if (!opts) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedValue v(cx);
-  if (!JS_GetProperty(cx, opts, "action", &v)) {
+  if (!JS_GetProperty(cx, opts, "action", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JSString* str = JS::ToString(cx, v);
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedLinearString action(cx, str->ensureLinear(cx));
-  if (!action) {
+  if (!action) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   int32_t phases = 0;
   if (StringEqualsLiteral(action, "minorGC") ||
       StringEqualsLiteral(action, "majorGC")) {
-    if (!JS_GetProperty(cx, opts, "phases", &v)) {
+    if (!JS_GetProperty(cx, opts, "phases", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (v.isUndefined()) {
       phases = (1 << JSGC_END);
     } else {
       JSString* str = JS::ToString(cx, v);
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       JSLinearString* phasesStr = str->ensureLinear(cx);
-      if (!phasesStr) {
+      if (!phasesStr) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       if (StringEqualsLiteral(phasesStr, "begin")) {
         phases = (1 << JSGC_BEGIN);
-      } else if (StringEqualsLiteral(phasesStr, "end")) {
+      } else if (StringEqualsLiteral(phasesStr, "end")) {MOZ_RELEASE_ASSERT(0);
         phases = (1 << JSGC_END);
       } else if (StringEqualsLiteral(phasesStr, "both")) {
         phases = (1 << JSGC_BEGIN) | (1 << JSGC_END);
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorASCII(cx, "Invalid callback phase");
         return false;
       }
     }
   }
 
-  if (StringEqualsLiteral(action, "minorGC")) {
+  if (StringEqualsLiteral(action, "minorGC")) {MOZ_RELEASE_ASSERT(0);
     gcCallback::minorGCInfo.phases = phases;
     gcCallback::minorGCInfo.active = true;
     JS_SetGCCallback(cx, gcCallback::minorGC, &gcCallback::minorGCInfo);
   } else if (StringEqualsLiteral(action, "majorGC")) {
-    if (!JS_GetProperty(cx, opts, "depth", &v)) {
+    if (!JS_GetProperty(cx, opts, "depth", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     int32_t depth = 1;
     if (!v.isUndefined()) {
-      if (!ToInt32(cx, v, &depth)) {
+      if (!ToInt32(cx, v, &depth)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
-    }
-    if (depth < 0) {
+      }MOZ_RELEASE_ASSERT(0);
+    }
+    if (depth < 0) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "Nesting depth cannot be negative");
       return false;
     }
     if (depth + gcstats::MAX_PHASE_NESTING >
-        gcstats::Statistics::MAX_SUSPENDED_PHASES) {
+        gcstats::Statistics::MAX_SUSPENDED_PHASES) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "Nesting depth too large, would overflow");
       return false;
     }
@@ -5485,12 +5485,12 @@ static bool IsNurseryAllocated(JSContext
 static bool GetLcovInfo(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() > 1) {
+  if (args.length() > 1) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Wrong number of arguments");
     return false;
   }
 
-  if (!coverage::IsLCovEnabled()) {
+  if (!coverage::IsLCovEnabled()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Coverage not enabled for process.");
     return false;
   }
@@ -5498,16 +5498,16 @@ static bool GetLcovInfo(JSContext* cx, u
   RootedObject global(cx);
   if (args.hasDefined(0)) {
     global = ToObject(cx, args[0]);
-    if (!global) {
+    if (!global) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "Permission denied to access global");
       return false;
     }
     global = CheckedUnwrapDynamic(global, cx, /* stopAtWindowProxy = */ false);
-    if (!global) {
+    if (!global) {MOZ_RELEASE_ASSERT(0);
       ReportAccessDenied(cx);
       return false;
     }
-    if (!global->is<GlobalObject>()) {
+    if (!global->is<GlobalObject>()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "Argument must be a global object");
       return false;
     }
@@ -5522,7 +5522,7 @@ static bool GetLcovInfo(JSContext* cx, u
     content = js::GetCodeCoverageSummary(cx, &length);
   }
 
-  if (!content) {
+  if (!content) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5583,20 +5583,20 @@ static bool GetModuleEnvironmentNames(JS
     return false;
   }
 
-  if (!args[0].isObject() || !args[0].toObject().is<ModuleObject>()) {
+  if (!args[0].isObject() || !args[0].toObject().is<ModuleObject>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "First argument should be a ModuleObject");
     return false;
   }
 
   RootedModuleObject module(cx, &args[0].toObject().as<ModuleObject>());
-  if (module->hadEvaluationError()) {
+  if (module->hadEvaluationError()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Module environment unavailable");
     return false;
   }
 
   RootedModuleEnvironmentObject env(cx, GetModuleEnvironment(cx, module));
   Rooted<IdVector> ids(cx, IdVector(cx));
-  if (!JS_Enumerate(cx, env, &ids)) {
+  if (!JS_Enumerate(cx, env, &ids)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5606,7 +5606,7 @@ static bool GetModuleEnvironmentNames(JS
 
   uint32_t length = ids.length();
   RootedArrayObject array(cx, NewDenseFullyAllocatedArray(cx, length));
-  if (!array) {
+  if (!array) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5626,12 +5626,12 @@ static bool GetModuleEnvironmentValue(JS
     return false;
   }
 
-  if (!args[0].isObject() || !args[0].toObject().is<ModuleObject>()) {
+  if (!args[0].isObject() || !args[0].toObject().is<ModuleObject>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "First argument should be a ModuleObject");
     return false;
   }
 
-  if (!args[1].isString()) {
+  if (!args[1].isString()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Second argument should be a string");
     return false;
   }
@@ -5645,11 +5645,11 @@ static bool GetModuleEnvironmentValue(JS
   RootedModuleEnvironmentObject env(cx, GetModuleEnvironment(cx, module));
   RootedString name(cx, args[1].toString());
   RootedId id(cx);
-  if (!JS_StringToId(cx, name, &id)) {
-    return false;
-  }
-
-  if (!GetProperty(cx, env, env, id, args.rval())) {
+  if (!JS_StringToId(cx, name, &id)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!GetProperty(cx, env, env, id, args.rval())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5717,7 +5717,7 @@ static bool SetTimeZone(JSContext* cx, u
     return false;
   }
 
-  if (!args[0].isString() && !args[0].isUndefined()) {
+  if (!args[0].isString() && !args[0].isUndefined()) {MOZ_RELEASE_ASSERT(0);
     ReportUsageErrorASCII(cx, callee,
                           "First argument should be a string or undefined");
     return false;
@@ -5741,22 +5741,22 @@ static bool SetTimeZone(JSContext* cx, u
 
   if (args[0].isString() && !args[0].toString()->empty()) {
     RootedLinearString str(cx, args[0].toString()->ensureLinear(cx));
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!StringIsAscii(str)) {
+    if (!StringIsAscii(str)) {MOZ_RELEASE_ASSERT(0);
       ReportUsageErrorASCII(cx, callee,
                             "First argument contains non-ASCII characters");
       return false;
     }
 
     UniqueChars timeZone = JS_EncodeStringToASCII(cx, str);
-    if (!timeZone) {
+    if (!timeZone) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!setTimeZone(timeZone.get())) {
+    if (!setTimeZone(timeZone.get())) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "Failed to set 'TZ' environment variable");
       return false;
     }
@@ -5796,7 +5796,7 @@ static bool GetDefaultLocale(JSContext* 
   CallArgs args = CallArgsFromVp(argc, vp);
   RootedObject callee(cx, &args.callee());
 
-  if (args.length() != 0) {
+  if (args.length() != 0) {MOZ_RELEASE_ASSERT(0);
     ReportUsageErrorASCII(cx, callee, "Wrong number of arguments");
     return false;
   }
@@ -5820,7 +5820,7 @@ static bool SetDefaultLocale(JSContext* 
     return false;
   }
 
-  if (!args[0].isString() && !args[0].isUndefined()) {
+  if (!args[0].isString() && !args[0].isUndefined()) {MOZ_RELEASE_ASSERT(0);
     ReportUsageErrorASCII(cx, callee,
                           "First argument should be a string or undefined");
     return false;
@@ -5828,18 +5828,18 @@ static bool SetDefaultLocale(JSContext* 
 
   if (args[0].isString() && !args[0].toString()->empty()) {
     RootedLinearString str(cx, args[0].toString()->ensureLinear(cx));
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!StringIsAscii(str)) {
+    if (!StringIsAscii(str)) {MOZ_RELEASE_ASSERT(0);
       ReportUsageErrorASCII(cx, callee,
                             "First argument contains non-ASCII characters");
       return false;
     }
 
     UniqueChars locale = JS_EncodeStringToASCII(cx, str);
-    if (!locale) {
+    if (!locale) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5849,13 +5849,13 @@ static bool SetDefaultLocale(JSContext* 
           return mozilla::IsAsciiAlphanumeric(c) || c == '-';
         });
 
-    if (!containsOnlyValidBCP47Characters) {
+    if (!containsOnlyValidBCP47Characters) {MOZ_RELEASE_ASSERT(0);
       ReportUsageErrorASCII(cx, callee,
                             "First argument should be a BCP47 language tag");
       return false;
     }
 
-    if (!JS_SetDefaultLocale(cx->runtime(), locale.get())) {
+    if (!JS_SetDefaultLocale(cx->runtime(), locale.get())) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
@@ -5898,11 +5898,11 @@ static bool MonotonicNow(JSContext* cx, 
     now = ComputeNow(ts);
   } else {
     // Use a realtime clock as fallback.
-    if (clock_gettime(CLOCK_REALTIME, &ts) != 0) {
+    if (clock_gettime(CLOCK_REALTIME, &ts) != 0) {MOZ_RELEASE_ASSERT(0);
       // Fail if no clock is available.
       JS_ReportErrorASCII(cx, "can't retrieve system clock");
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     now = ComputeNow(ts);
 
@@ -5946,13 +5946,13 @@ static bool GetErrorNotes(JSContext* cx,
     return false;
   }
 
-  if (!args[0].isObject() || !args[0].toObject().is<ErrorObject>()) {
+  if (!args[0].isObject() || !args[0].toObject().is<ErrorObject>()) {MOZ_RELEASE_ASSERT(0);
     args.rval().setNull();
     return true;
   }
 
   JSErrorReport* report = args[0].toObject().as<ErrorObject>().getErrorReport();
-  if (!report) {
+  if (!report) {MOZ_RELEASE_ASSERT(0);
     args.rval().setNull();
     return true;
   }
@@ -5984,10 +5984,10 @@ static bool SetTimeResolution(JSContext*
     return false;
   }
 
-  if (!args[0].isInt32()) {
+  if (!args[0].isInt32()) {MOZ_RELEASE_ASSERT(0);
     ReportUsageErrorASCII(cx, callee, "First argument must be an Int32.");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   int32_t resolution = args[0].toInt32();
 
   if (!args[1].isBoolean()) {
@@ -6006,7 +6006,7 @@ static bool ScriptedCallerGlobal(JSConte
   CallArgs args = CallArgsFromVp(argc, vp);
 
   RootedObject obj(cx, JS::GetScriptedCallerGlobal(cx));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     args.rval().setNull();
     return true;
   }
@@ -6092,19 +6092,19 @@ static bool GlobalLexicals(JSContext* cx
       cx, &cx->global()->lexicalEnvironment());
 
   RootedIdVector props(cx);
-  if (!GetPropertyKeys(cx, globalLexical, JSITER_HIDDEN, &props)) {
+  if (!GetPropertyKeys(cx, globalLexical, JSITER_HIDDEN, &props)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject res(cx, JS_NewPlainObject(cx));
-  if (!res) {
+  if (!res) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedValue val(cx);
   for (size_t i = 0; i < props.length(); i++) {
     HandleId id = props[i];
-    if (!JS_GetPropertyById(cx, globalLexical, id, &val)) {
+    if (!JS_GetPropertyById(cx, globalLexical, id, &val)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (val.isMagic(JS_UNINITIALIZED_LEXICAL)) {
@@ -6123,21 +6123,21 @@ static bool EncodeAsUtf8InBuffer(JSConte
   CallArgs args = CallArgsFromVp(argc, vp);
   if (!args.requireAtLeast(cx, "encodeAsUtf8InBuffer", 2)) {
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedObject callee(cx, &args.callee());
 
-  if (!args[0].isString()) {
+  if (!args[0].isString()) {MOZ_RELEASE_ASSERT(0);
     ReportUsageErrorASCII(cx, callee, "First argument must be a String");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Create the amounts array early so that the raw pointer into Uint8Array
   // data has as short a lifetime as possible
   RootedArrayObject array(cx, NewDenseFullyAllocatedArray(cx, 2));
-  if (!array) {
-    return false;
-  }
+  if (!array) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
   array->ensureDenseInitializedLength(0, 2);
 
   size_t length;
@@ -6147,10 +6147,10 @@ static bool EncodeAsUtf8InBuffer(JSConte
       !JS_GetObjectAsUint8Array(&args[1].toObject(), &length, &isSharedMemory,
                                 &data) ||
       isSharedMemory ||  // excluded views of SharedArrayBuffers
-      !data) {           // exclude views of detached ArrayBuffers
+      !data) {MOZ_RELEASE_ASSERT(0);           // exclude views of detached ArrayBuffers
     ReportUsageErrorASCII(cx, callee, "Second argument must be a Uint8Array");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   Maybe<Tuple<size_t, size_t>> amounts = JS_EncodeStringToUTF8BufferPartial(
       cx, args[0].toString(), AsWritableChars(Span(data, length)));
@@ -6171,24 +6171,24 @@ static bool EncodeAsUtf8InBuffer(JSConte
 
 JSScript* js::TestingFunctionArgumentToScript(
     JSContext* cx, HandleValue v, JSFunction** funp /* = nullptr */) {
-  if (v.isString()) {
+  if (v.isString()) {MOZ_RELEASE_ASSERT(0);
     // To convert a string to a script, compile it. Parse it as an ES6 Program.
     RootedLinearString linearStr(cx,
                                  JS::StringToLinearString(cx, v.toString()));
-    if (!linearStr) {
+    if (!linearStr) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     size_t len = JS::GetLinearStringLength(linearStr);
     AutoStableStringChars linearChars(cx);
-    if (!linearChars.initTwoByte(cx, linearStr)) {
+    if (!linearChars.initTwoByte(cx, linearStr)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     const char16_t* chars = linearChars.twoByteRange().begin().get();
 
     SourceText<char16_t> source;
-    if (!source.init(cx, chars, len, SourceOwnership::Borrowed)) {
+    if (!source.init(cx, chars, len, SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     CompileOptions options(cx);
     return JS::Compile(cx, options, source);
@@ -6200,23 +6200,23 @@ JSScript* js::TestingFunctionArgumentToS
   }
 
   // Unwrap bound functions.
-  while (fun->isBoundFunction()) {
+  while (fun->isBoundFunction()) {MOZ_RELEASE_ASSERT(0);
     JSObject* target = fun->getBoundFunctionTarget();
-    if (target && target->is<JSFunction>()) {
+    if (target && target->is<JSFunction>()) {MOZ_RELEASE_ASSERT(0);
       fun = &target->as<JSFunction>();
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       break;
-    }
-  }
-
-  if (!fun->isInterpreted()) {
+    }MOZ_RELEASE_ASSERT(0);
+  }
+
+  if (!fun->isInterpreted()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_TESTING_SCRIPTS_ONLY);
     return nullptr;
   }
 
   JSScript* script = JSFunction::getOrCreateScript(cx, fun);
-  if (!script) {
+  if (!script) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -6234,30 +6234,30 @@ static bool BaselineCompile(JSContext* c
   RootedScript script(cx);
   if (args.length() == 0) {
     NonBuiltinScriptFrameIter iter(cx);
-    if (iter.done()) {
+    if (iter.done()) {MOZ_RELEASE_ASSERT(0);
       ReportUsageErrorASCII(cx, callee,
                             "no script argument and no script caller");
       return false;
     }
     script = iter.script();
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     script = TestingFunctionArgumentToScript(cx, args[0]);
-    if (!script) {
+    if (!script) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   bool forceDebug = false;
   if (args.length() > 1) {
-    if (args.length() > 2) {
+    if (args.length() > 2) {MOZ_RELEASE_ASSERT(0);
       ReportUsageErrorASCII(cx, callee, "too many arguments");
       return false;
     }
-    if (!args[1].isBoolean() && !args[1].isUndefined()) {
+    if (!args[1].isBoolean() && !args[1].isUndefined()) {MOZ_RELEASE_ASSERT(0);
       ReportUsageErrorASCII(
           cx, callee, "forceDebugInstrumentation argument should be boolean");
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     forceDebug = ToBoolean(args[1]);
   }
 
@@ -6265,14 +6265,14 @@ static bool BaselineCompile(JSContext* c
   do {
     // In order to check for differential behaviour, baselineCompile should have
     // the same output whether --no-baseline is used or not.
-    if (js::SupportDifferentialTesting()) {
+    if (js::SupportDifferentialTesting()) {MOZ_RELEASE_ASSERT(0);
       returnedStr = "skipped (differential testing)";
       break;
     }
 
     AutoRealm ar(cx, script);
     if (script->hasBaselineScript()) {
-      if (forceDebug && !script->baselineScript()->hasDebugInstrumentation()) {
+      if (forceDebug && !script->baselineScript()->hasDebugInstrumentation()) {MOZ_RELEASE_ASSERT(0);
         // There isn't an easy way to do this for a script that might be on
         // stack right now. See
         // js::jit::RecompileOnStackBaselineScriptsForDebugMode.
@@ -6289,11 +6289,11 @@ static bool BaselineCompile(JSContext* c
       returnedStr = "baseline disabled";
       break;
     }
-    if (!script->canBaselineCompile()) {
+    if (!script->canBaselineCompile()) {MOZ_RELEASE_ASSERT(0);
       returnedStr = "can't compile";
       break;
     }
-    if (!cx->realm()->ensureJitRealmExists(cx)) {
+    if (!cx->realm()->ensureJitRealmExists(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -6346,7 +6346,7 @@ static bool GetICUOptions(JSContext* cx,
   CallArgs args = CallArgsFromVp(argc, vp);
 
   RootedObject info(cx, JS_NewPlainObject(cx));
-  if (!info) {
+  if (!info) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6354,34 +6354,34 @@ static bool GetICUOptions(JSContext* cx,
   RootedString str(cx);
 
   str = NewStringCopyZ<CanGC>(cx, U_ICU_VERSION);
-  if (!str || !JS_DefineProperty(cx, info, "version", str, JSPROP_ENUMERATE)) {
+  if (!str || !JS_DefineProperty(cx, info, "version", str, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   str = NewStringCopyZ<CanGC>(cx, U_UNICODE_VERSION);
-  if (!str || !JS_DefineProperty(cx, info, "unicode", str, JSPROP_ENUMERATE)) {
+  if (!str || !JS_DefineProperty(cx, info, "unicode", str, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   str = NewStringCopyZ<CanGC>(cx, uloc_getDefault());
-  if (!str || !JS_DefineProperty(cx, info, "locale", str, JSPROP_ENUMERATE)) {
+  if (!str || !JS_DefineProperty(cx, info, "locale", str, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   UErrorCode status = U_ZERO_ERROR;
   const char* tzdataVersion = ucal_getTZDataVersion(&status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
 
   str = NewStringCopyZ<CanGC>(cx, tzdataVersion);
-  if (!str || !JS_DefineProperty(cx, info, "tzdata", str, JSPROP_ENUMERATE)) {
+  if (!str || !JS_DefineProperty(cx, info, "tzdata", str, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   str = intl::CallICU(cx, ucal_getDefaultTimeZone);
-  if (!str || !JS_DefineProperty(cx, info, "timezone", str, JSPROP_ENUMERATE)) {
+  if (!str || !JS_DefineProperty(cx, info, "timezone", str, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6407,13 +6407,13 @@ static bool IsSmallFunction(JSContext* c
   }
 
   HandleValue arg = args[0];
-  if (!arg.isObject() || !arg.toObject().is<JSFunction>()) {
+  if (!arg.isObject() || !arg.toObject().is<JSFunction>()) {MOZ_RELEASE_ASSERT(0);
     ReportUsageErrorASCII(cx, callee, "First argument must be a function");
     return false;
   }
 
   RootedFunction fun(cx, &args[0].toObject().as<JSFunction>());
-  if (!fun->isInterpreted()) {
+  if (!fun->isInterpreted()) {MOZ_RELEASE_ASSERT(0);
     ReportUsageErrorASCII(cx, callee,
                           "First argument must be an interpreted function");
     return false;
@@ -6468,12 +6468,12 @@ static bool PCCountProfiling_ScriptCount
 static bool PCCountProfiling_ScriptSummary(JSContext* cx, unsigned argc,
                                            Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (!args.requireAtLeast(cx, "summary", 1)) {
+  if (!args.requireAtLeast(cx, "summary", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   uint32_t index;
-  if (!JS::ToUint32(cx, args[0], &index)) {
+  if (!JS::ToUint32(cx, args[0], &index)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6489,12 +6489,12 @@ static bool PCCountProfiling_ScriptSumma
 static bool PCCountProfiling_ScriptContents(JSContext* cx, unsigned argc,
                                             Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (!args.requireAtLeast(cx, "contents", 1)) {
+  if (!args.requireAtLeast(cx, "contents", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   uint32_t index;
-  if (!JS::ToUint32(cx, args[0], &index)) {
+  if (!JS::ToUint32(cx, args[0], &index)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -7512,23 +7512,23 @@ bool js::InitTestingFunctions() { return
 bool js::DefineTestingFunctions(JSContext* cx, HandleObject obj,
                                 bool fuzzingSafe_, bool disableOOMFunctions_) {
   fuzzingSafe = fuzzingSafe_;
-  if (EnvVarIsDefined("MOZ_FUZZING_SAFE")) {
+  if (EnvVarIsDefined("MOZ_FUZZING_SAFE")) {MOZ_RELEASE_ASSERT(0);
     fuzzingSafe = true;
   }
 
   disableOOMFunctions = disableOOMFunctions_;
 
   if (!fuzzingSafe) {
-    if (!JS_DefineFunctionsWithHelp(cx, obj, FuzzingUnsafeTestingFunctions)) {
+    if (!JS_DefineFunctionsWithHelp(cx, obj, FuzzingUnsafeTestingFunctions)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedObject pccount(cx, JS_NewPlainObject(cx));
-    if (!pccount) {
+    if (!pccount) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!JS_DefineProperty(cx, obj, "pccount", pccount, 0)) {
+    if (!JS_DefineProperty(cx, obj, "pccount", pccount, 0)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
diff --git a/js/src/builtin/WeakMapObject.cpp b/js/src/builtin/WeakMapObject.cpp
--- a/js/src/builtin/WeakMapObject.cpp
+++ b/js/src/builtin/WeakMapObject.cpp
@@ -143,7 +143,7 @@ bool WeakMapObject::set(JSContext* cx, u
 bool WeakCollectionObject::nondeterministicGetKeys(
     JSContext* cx, Handle<WeakCollectionObject*> obj, MutableHandleObject ret) {
   RootedObject arr(cx, NewDenseEmptyArray(cx));
-  if (!arr) {
+  if (!arr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (ObjectValueWeakMap* map = obj->getMap()) {
@@ -153,7 +153,7 @@ bool WeakCollectionObject::nondeterminis
          r.popFront()) {
       JS::ExposeObjectToActiveJS(r.front().key());
       RootedObject key(cx, r.front().key());
-      if (!cx->compartment()->wrap(cx, &key)) {
+      if (!cx->compartment()->wrap(cx, &key)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (!NewbornArrayPush(cx, arr, ObjectValue(*key))) {
@@ -240,7 +240,7 @@ bool WeakMapObject::construct(JSContext*
   }
 
   RootedObject obj(cx, NewObjectWithClassProto<WeakMapObject>(cx, proto));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/builtin/WeakRefObject.cpp b/js/src/builtin/WeakRefObject.cpp
--- a/js/src/builtin/WeakRefObject.cpp
+++ b/js/src/builtin/WeakRefObject.cpp
@@ -48,26 +48,26 @@ bool WeakRefObject::construct(JSContext*
 
   Rooted<WeakRefObject*> weakRef(
       cx, NewObjectWithClassProto<WeakRefObject>(cx, proto));
-  if (!weakRef) {
+  if (!weakRef) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject target(cx);
   target = CheckedUnwrapDynamic(&args[0].toObject(), cx);
-  if (!target) {
+  if (!target) {MOZ_RELEASE_ASSERT(0);
     ReportAccessDenied(cx);
     return false;
   }
 
   // If the target is a DOM wrapper, preserve it.
-  if (!preserveDOMWrapper(cx, target)) {
+  if (!preserveDOMWrapper(cx, target)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Wrap the weakRef into the target's compartment.
   RootedObject wrappedWeakRef(cx, weakRef);
   AutoRealm ar(cx, target);
-  if (!JS_WrapObject(cx, &wrappedWeakRef)) {
+  if (!JS_WrapObject(cx, &wrappedWeakRef)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -77,7 +77,7 @@ bool WeakRefObject::construct(JSContext*
   }
 
   // 4. Perfom ! KeepDuringJob(target).
-  if (!target->zone()->keepDuringJob(target)) {
+  if (!target->zone()->keepDuringJob(target)) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   };
@@ -207,7 +207,7 @@ bool WeakRefObject::deref(JSContext* cx,
   }
 
   RootedObject target(cx, weakRef->target());
-  if (!target->zone()->keepDuringJob(target)) {
+  if (!target->zone()->keepDuringJob(target)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/builtin/WeakSetObject.cpp b/js/src/builtin/WeakSetObject.cpp
--- a/js/src/builtin/WeakSetObject.cpp
+++ b/js/src/builtin/WeakSetObject.cpp
@@ -180,7 +180,7 @@ bool WeakSetObject::construct(JSContext*
   }
 
   Rooted<WeakSetObject*> obj(cx, WeakSetObject::create(cx, proto));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -188,7 +188,7 @@ bool WeakSetObject::construct(JSContext*
     RootedValue iterable(cx, args[0]);
     bool optimized = false;
     if (!IsOptimizableInitForSet<GlobalObject::getOrCreateWeakSetPrototype,
-                                 isBuiltinAdd>(cx, obj, iterable, &optimized)) {
+                                 isBuiltinAdd>(cx, obj, iterable, &optimized)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -201,14 +201,14 @@ bool WeakSetObject::construct(JSContext*
         keyVal.set(array->getDenseElement(index));
         MOZ_ASSERT(!keyVal.isMagic(JS_ELEMENTS_HOLE));
 
-        if (keyVal.isPrimitive()) {
+        if (keyVal.isPrimitive()) {MOZ_RELEASE_ASSERT(0);
           ReportNotObject(cx, JSMSG_OBJECT_REQUIRED_WEAKSET_VAL, keyVal);
           return false;
         }
 
         keyObject = &keyVal.toObject();
         if (!WeakCollectionPutEntryInternal(cx, obj, keyObject,
-                                            TrueHandleValue)) {
+                                            TrueHandleValue)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
diff --git a/js/src/builtin/intl/Collator.cpp b/js/src/builtin/intl/Collator.cpp
--- a/js/src/builtin/intl/Collator.cpp
+++ b/js/src/builtin/intl/Collator.cpp
@@ -115,7 +115,7 @@ static bool Collator(JSContext* cx, cons
 
   Rooted<CollatorObject*> collator(
       cx, NewObjectWithClassProto<CollatorObject>(cx, proto));
-  if (!collator) {
+  if (!collator) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -161,38 +161,38 @@ bool js::intl_availableCollations(JSCont
   MOZ_ASSERT(args[0].isString());
 
   UniqueChars locale = intl::EncodeLocale(cx, args[0].toString());
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   UErrorCode status = U_ZERO_ERROR;
   UEnumeration* values =
       ucol_getKeywordValuesForLocale("co", locale.get(), false, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     ReportInternalError(cx);
     return false;
   }
   ScopedICUObject<UEnumeration, uenum_close> toClose(values);
 
   uint32_t count = uenum_count(values, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     ReportInternalError(cx);
     return false;
   }
 
   RootedObject collations(cx, NewDenseEmptyArray(cx));
-  if (!collations) {
+  if (!collations) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // The first element of the collations array must be |null| per
   // ES2017 Intl, 10.2.3 Internal Slots.
-  if (!NewbornArrayPush(cx, collations, NullValue())) {
+  if (!NewbornArrayPush(cx, collations, NullValue())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   for (uint32_t i = 0; i < count; i++) {
     const char* collation = uenum_next(values, nullptr, &status);
-    if (U_FAILURE(status)) {
+    if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
       ReportInternalError(cx);
       return false;
     }
@@ -208,13 +208,13 @@ bool js::intl_availableCollations(JSCont
 
     // ICU returns old-style keyword values; map them to BCP 47 equivalents.
     collation = uloc_toUnicodeLocaleType("co", collation);
-    if (!collation) {
+    if (!collation) {MOZ_RELEASE_ASSERT(0);
       ReportInternalError(cx);
       return false;
     }
 
     JSString* jscollation = NewStringCopyZ<CanGC>(cx, collation);
-    if (!jscollation) {
+    if (!jscollation) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!NewbornArrayPush(cx, collations, StringValue(jscollation))) {
@@ -235,15 +235,15 @@ static UCollator* NewUCollator(JSContext
   RootedValue value(cx);
 
   RootedObject internals(cx, intl::GetInternalsObject(cx, collator));
-  if (!internals) {
+  if (!internals) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!GetProperty(cx, internals, internals, cx->names().locale, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().locale, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   UniqueChars locale = intl::EncodeLocale(cx, value.toString());
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -256,26 +256,26 @@ static UCollator* NewUCollator(JSContext
   UColAttributeValue uNormalization = UCOL_ON;
   UColAttributeValue uCaseFirst = UCOL_DEFAULT;
 
-  if (!GetProperty(cx, internals, internals, cx->names().usage, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().usage, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   {
     JSLinearString* usage = value.toString()->ensureLinear(cx);
-    if (!usage) {
+    if (!usage) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (StringEqualsLiteral(usage, "search")) {
       // ICU expects search as a Unicode locale extension on locale.
       intl::LanguageTag tag(cx);
       if (!intl::LanguageTagParser::parse(
-              cx, mozilla::MakeStringSpan(locale.get()), tag)) {
+              cx, mozilla::MakeStringSpan(locale.get()), tag)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
       JS::RootedVector<intl::UnicodeExtensionKeyword> keywords(cx);
 
-      if (!keywords.emplaceBack("co", cx->names().search)) {
+      if (!keywords.emplaceBack("co", cx->names().search)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -283,12 +283,12 @@ static UCollator* NewUCollator(JSContext
       // the Unicode extension subtag. We're then relying on ICU to follow RFC
       // 6067, which states that any trailing keywords using the same key
       // should be ignored.
-      if (!intl::ApplyUnicodeExtensionToTag(cx, tag, keywords)) {
+      if (!intl::ApplyUnicodeExtensionToTag(cx, tag, keywords)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
       locale = tag.toStringZ(cx);
-      if (!locale) {
+      if (!locale) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     } else {
@@ -300,13 +300,13 @@ static UCollator* NewUCollator(JSContext
   // via the Unicode locale extension and is therefore already set on
   // locale.
 
-  if (!GetProperty(cx, internals, internals, cx->names().sensitivity, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().sensitivity, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   {
     JSLinearString* sensitivity = value.toString()->ensureLinear(cx);
-    if (!sensitivity) {
+    if (!sensitivity) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (StringEqualsLiteral(sensitivity, "base")) {
@@ -323,7 +323,7 @@ static UCollator* NewUCollator(JSContext
   }
 
   if (!GetProperty(cx, internals, internals, cx->names().ignorePunctuation,
-                   &value)) {
+                   &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   // According to the ICU team, UCOL_SHIFTED causes punctuation to be
@@ -335,19 +335,19 @@ static UCollator* NewUCollator(JSContext
     uAlternate = UCOL_SHIFTED;
   }
 
-  if (!GetProperty(cx, internals, internals, cx->names().numeric, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().numeric, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (!value.isUndefined() && value.toBoolean()) {
     uNumeric = UCOL_ON;
   }
 
-  if (!GetProperty(cx, internals, internals, cx->names().caseFirst, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().caseFirst, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (!value.isUndefined()) {
     JSLinearString* caseFirst = value.toString()->ensureLinear(cx);
-    if (!caseFirst) {
+    if (!caseFirst) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (StringEqualsLiteral(caseFirst, "upper")) {
@@ -362,7 +362,7 @@ static UCollator* NewUCollator(JSContext
 
   UErrorCode status = U_ZERO_ERROR;
   UCollator* coll = ucol_open(IcuLocale(locale.get()), &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     ReportInternalError(cx);
     return nullptr;
   }
@@ -394,12 +394,12 @@ static bool intl_CompareStrings(JSContex
   }
 
   AutoStableStringChars stableChars1(cx);
-  if (!stableChars1.initTwoByte(cx, str1)) {
+  if (!stableChars1.initTwoByte(cx, str1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   AutoStableStringChars stableChars2(cx);
-  if (!stableChars2.initTwoByte(cx, str2)) {
+  if (!stableChars2.initTwoByte(cx, str2)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/builtin/intl/DateTimeFormat.cpp b/js/src/builtin/intl/DateTimeFormat.cpp
--- a/js/src/builtin/intl/DateTimeFormat.cpp
+++ b/js/src/builtin/intl/DateTimeFormat.cpp
@@ -217,27 +217,27 @@ bool JS::AddMozDateTimeFormatConstructor
   RootedObject ctor(
       cx, GlobalObject::createConstructor(cx, MozDateTimeFormat,
                                           cx->names().DateTimeFormat, 0));
-  if (!ctor) {
+  if (!ctor) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject proto(
       cx, GlobalObject::createBlankPrototype<PlainObject>(cx, cx->global()));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!LinkConstructorAndPrototype(cx, ctor, proto)) {
+  if (!LinkConstructorAndPrototype(cx, ctor, proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // 12.3.2
-  if (!JS_DefineFunctions(cx, ctor, dateTimeFormat_static_methods)) {
+  if (!JS_DefineFunctions(cx, ctor, dateTimeFormat_static_methods)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // 12.4.4 and 12.4.5
-  if (!JS_DefineFunctions(cx, proto, dateTimeFormat_methods)) {
+  if (!JS_DefineFunctions(cx, proto, dateTimeFormat_methods)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -259,14 +259,14 @@ static bool DefaultCalendar(JSContext* c
   ScopedICUObject<UCalendar, ucal_close> closeCalendar(cal);
 
   const char* calendar = ucal_getType(cal, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
 
   // ICU returns old-style keyword values; map them to BCP 47 equivalents
   calendar = uloc_toUnicodeLocaleType("ca", calendar);
-  if (!calendar) {
+  if (!calendar) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -294,22 +294,22 @@ bool js::intl_availableCalendars(JSConte
   MOZ_ASSERT(args[0].isString());
 
   UniqueChars locale = intl::EncodeLocale(cx, args[0].toString());
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject calendars(cx, NewDenseEmptyArray(cx));
-  if (!calendars) {
+  if (!calendars) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // We need the default calendar for the locale as the first result.
   RootedValue defaultCalendar(cx);
-  if (!DefaultCalendar(cx, locale, &defaultCalendar)) {
+  if (!DefaultCalendar(cx, locale, &defaultCalendar)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!NewbornArrayPush(cx, calendars, defaultCalendar)) {
+  if (!NewbornArrayPush(cx, calendars, defaultCalendar)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -318,37 +318,37 @@ bool js::intl_availableCalendars(JSConte
   UErrorCode status = U_ZERO_ERROR;
   UEnumeration* values =
       ucal_getKeywordValuesForLocale("ca", locale.get(), false, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
   ScopedICUObject<UEnumeration, uenum_close> toClose(values);
 
   uint32_t count = uenum_count(values, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
 
   for (; count > 0; count--) {
     const char* calendar = uenum_next(values, nullptr, &status);
-    if (U_FAILURE(status)) {
+    if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
       intl::ReportInternalError(cx);
       return false;
     }
 
     // ICU returns old-style keyword values; map them to BCP 47 equivalents
     calendar = uloc_toUnicodeLocaleType("ca", calendar);
-    if (!calendar) {
+    if (!calendar) {MOZ_RELEASE_ASSERT(0);
       intl::ReportInternalError(cx);
       return false;
     }
 
     JSString* jscalendar = NewStringCopyZ<CanGC>(cx, calendar);
-    if (!jscalendar) {
+    if (!jscalendar) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!NewbornArrayPush(cx, calendars, StringValue(jscalendar))) {
+    if (!NewbornArrayPush(cx, calendars, StringValue(jscalendar))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -356,7 +356,7 @@ bool js::intl_availableCalendars(JSConte
     for (const auto& calendarAlias : calendarAliases) {
       if (StringsAreEqual(calendar, calendarAlias.calendar)) {
         JSString* jscalendar = NewStringCopyZ<CanGC>(cx, calendarAlias.alias);
-        if (!jscalendar) {
+        if (!jscalendar) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         if (!NewbornArrayPush(cx, calendars, StringValue(jscalendar))) {
@@ -392,7 +392,7 @@ bool js::intl_IsValidTimeZoneName(JSCont
 
   RootedString timeZone(cx, args[0].toString());
   RootedAtom validatedTimeZone(cx);
-  if (!sharedIntlData.validateTimeZoneName(cx, timeZone, &validatedTimeZone)) {
+  if (!sharedIntlData.validateTimeZoneName(cx, timeZone, &validatedTimeZone)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -418,7 +418,7 @@ bool js::intl_canonicalizeTimeZone(JSCon
   RootedString timeZone(cx, args[0].toString());
   RootedAtom ianaTimeZone(cx);
   if (!sharedIntlData.tryCanonicalizeTimeZoneConsistentWithIANA(
-          cx, timeZone, &ianaTimeZone)) {
+          cx, timeZone, &ianaTimeZone)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -429,7 +429,7 @@ bool js::intl_canonicalizeTimeZone(JSCon
   }
 
   AutoStableStringChars stableChars(cx);
-  if (!stableChars.initTwoByte(cx, timeZone)) {
+  if (!stableChars.initTwoByte(cx, timeZone)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -466,7 +466,7 @@ bool js::intl_defaultTimeZone(JSContext*
   return true;
 }
 
-bool js::intl_defaultTimeZoneOffset(JSContext* cx, unsigned argc, Value* vp) {
+bool js::intl_defaultTimeZoneOffset(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
   MOZ_ASSERT(args.length() == 0);
 
@@ -476,10 +476,10 @@ bool js::intl_defaultTimeZoneOffset(JSCo
   const char* rootLocale = "";
   UCalendar* cal =
       ucal_open(uTimeZone, uTimeZoneLength, rootLocale, UCAL_DEFAULT, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   ScopedICUObject<UCalendar, ucal_close> toClose(cal);
 
   int32_t offset = ucal_get(cal, UCAL_ZONE_OFFSET, &status);
@@ -513,17 +513,17 @@ bool js::intl_isDefaultTimeZone(JSContex
   MOZ_ALWAYS_TRUE(chars.resize(INITIAL_CHAR_BUFFER_SIZE));
 
   int32_t size = CallICU(cx, ucal_getDefaultTimeZone, chars);
-  if (size < 0) {
+  if (size < 0) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JSLinearString* str = args[0].toString()->ensureLinear(cx);
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   bool equals;
-  if (str->length() == size_t(size)) {
+  if (str->length() == size_t(size)) {MOZ_RELEASE_ASSERT(0);
     JS::AutoCheckCannotGC nogc;
     equals =
         str->hasLatin1Chars()
@@ -663,19 +663,19 @@ bool js::intl_patternForSkeleton(JSConte
   MOZ_ASSERT(args[2].isString() || args[2].isUndefined());
 
   UniqueChars locale = intl::EncodeLocale(cx, args[0].toString());
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   AutoStableStringChars skeleton(cx);
-  if (!skeleton.initTwoByte(cx, args[1].toString())) {
+  if (!skeleton.initTwoByte(cx, args[1].toString())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   mozilla::Maybe<HourCycle> hourCycle;
   if (args[2].isString()) {
     JSLinearString* hourCycleStr = args[2].toString()->ensureLinear(cx);
-    if (!hourCycleStr) {
+    if (!hourCycleStr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -687,7 +687,7 @@ bool js::intl_patternForSkeleton(JSConte
   SharedIntlData& sharedIntlData = cx->runtime()->sharedIntlData.ref();
   UDateTimePatternGenerator* gen =
       sharedIntlData.getDateTimePatternGenerator(cx, locale.get());
-  if (!gen) {
+  if (!gen) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -701,7 +701,7 @@ bool js::intl_patternForSkeleton(JSConte
                                      skelChars.length(), chars, size, status);
       },
       pattern);
-  if (patternSize < 0) {
+  if (patternSize < 0) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   pattern.shrinkTo(size_t(patternSize));
@@ -752,7 +752,7 @@ static bool FindPatternWithHourCycle(JSC
   SharedIntlData& sharedIntlData = cx->runtime()->sharedIntlData.ref();
   UDateTimePatternGenerator* gen =
       sharedIntlData.getDateTimePatternGenerator(cx, locale);
-  if (!gen) {
+  if (!gen) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -766,7 +766,7 @@ static bool FindPatternWithHourCycle(JSC
                                   chars, size, status);
       },
       skeleton);
-  if (skeletonSize < 0) {
+  if (skeletonSize < 0) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   skeleton.shrinkTo(size_t(skeletonSize));
@@ -802,7 +802,7 @@ bool js::intl_patternForStyle(JSContext*
   MOZ_ASSERT(args[5].isString() || args[5].isUndefined());
 
   UniqueChars locale = intl::EncodeLocale(cx, args[0].toString());
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -823,7 +823,7 @@ bool js::intl_patternForStyle(JSContext*
   UDateFormatStyle dateStyle = UDAT_NONE;
   if (args[1].isString()) {
     JSLinearString* dateStyleStr = args[1].toString()->ensureLinear(cx);
-    if (!dateStyleStr) {
+    if (!dateStyleStr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -833,7 +833,7 @@ bool js::intl_patternForStyle(JSContext*
   UDateFormatStyle timeStyle = UDAT_NONE;
   if (args[2].isString()) {
     JSLinearString* timeStyleStr = args[2].toString()->ensureLinear(cx);
-    if (!timeStyleStr) {
+    if (!timeStyleStr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -841,7 +841,7 @@ bool js::intl_patternForStyle(JSContext*
   }
 
   AutoStableStringChars timeZone(cx);
-  if (!timeZone.initTwoByte(cx, args[3].toString())) {
+  if (!timeZone.initTwoByte(cx, args[3].toString())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -853,7 +853,7 @@ bool js::intl_patternForStyle(JSContext*
   mozilla::Maybe<HourCycle> hourCycle;
   if (args[5].isString()) {
     JSLinearString* hourCycleStr = args[5].toString()->ensureLinear(cx);
-    if (!hourCycleStr) {
+    if (!hourCycleStr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -866,7 +866,7 @@ bool js::intl_patternForStyle(JSContext*
   UDateFormat* df = udat_open(timeStyle, dateStyle, IcuLocale(locale.get()),
                               timeZoneChars.begin().get(),
                               timeZoneChars.length(), nullptr, -1, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -881,7 +881,7 @@ bool js::intl_patternForStyle(JSContext*
         return udat_toPattern(df, false, chars, size, status);
       },
       pattern);
-  if (patternSize < 0) {
+  if (patternSize < 0) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   pattern.shrinkTo(size_t(patternSize));
@@ -893,7 +893,7 @@ bool js::intl_patternForStyle(JSContext*
     if (auto hcPattern = HourCycleFromPattern<char16_t>(pattern)) {
       bool wantHour12 = hour12 ? hour12.value() : IsHour12(hourCycle.value());
       if (wantHour12 != IsHour12(hcPattern.value())) {
-        if (!FindPatternWithHourCycle(cx, locale.get(), pattern, wantHour12)) {
+        if (!FindPatternWithHourCycle(cx, locale.get(), pattern, wantHour12)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -920,7 +920,7 @@ bool js::intl_skeletonForPattern(JSConte
   MOZ_ASSERT(args[0].isString());
 
   AutoStableStringChars pattern(cx);
-  if (!pattern.initTwoByte(cx, args[0].toString())) {
+  if (!pattern.initTwoByte(cx, args[0].toString())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   mozilla::Range<const char16_t> patternChars = pattern.twoByteRange();
@@ -942,7 +942,7 @@ static UniqueChars DateTimeFormatLocale(
     JSContext* cx, HandleObject internals,
     mozilla::Maybe<HourCycle> hourCycle = mozilla::Nothing()) {
   RootedValue value(cx);
-  if (!GetProperty(cx, internals, internals, cx->names().locale, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().locale, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -952,44 +952,44 @@ static UniqueChars DateTimeFormatLocale(
   intl::LanguageTag tag(cx);
   {
     JSLinearString* locale = value.toString()->ensureLinear(cx);
-    if (!locale) {
+    if (!locale) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (!intl::LanguageTagParser::parse(cx, locale, tag)) {
+    if (!intl::LanguageTagParser::parse(cx, locale, tag)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
 
   JS::RootedVector<intl::UnicodeExtensionKeyword> keywords(cx);
 
-  if (!GetProperty(cx, internals, internals, cx->names().calendar, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().calendar, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   {
     JSLinearString* calendar = value.toString()->ensureLinear(cx);
-    if (!calendar) {
+    if (!calendar) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (!keywords.emplaceBack("ca", calendar)) {
+    if (!keywords.emplaceBack("ca", calendar)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
 
   if (!GetProperty(cx, internals, internals, cx->names().numberingSystem,
-                   &value)) {
+                   &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   {
     JSLinearString* numberingSystem = value.toString()->ensureLinear(cx);
-    if (!numberingSystem) {
+    if (!numberingSystem) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (!keywords.emplaceBack("nu", numberingSystem)) {
+    if (!keywords.emplaceBack("nu", numberingSystem)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -1011,7 +1011,7 @@ static UniqueChars DateTimeFormatLocale(
         break;
     }
 
-    if (!keywords.emplaceBack("hc", hourCycleStr)) {
+    if (!keywords.emplaceBack("hc", hourCycleStr)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -1041,27 +1041,27 @@ static UDateFormat* NewUDateFormat(
   }
 
   UniqueChars locale = DateTimeFormatLocale(cx, internals);
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!GetProperty(cx, internals, internals, cx->names().timeZone, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().timeZone, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   AutoStableStringChars timeZone(cx);
-  if (!timeZone.initTwoByte(cx, value.toString())) {
+  if (!timeZone.initTwoByte(cx, value.toString())) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   mozilla::Range<const char16_t> timeZoneChars = timeZone.twoByteRange();
 
-  if (!GetProperty(cx, internals, internals, cx->names().pattern, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().pattern, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   AutoStableStringChars pattern(cx);
-  if (!pattern.initTwoByte(cx, value.toString())) {
+  if (!pattern.initTwoByte(cx, value.toString())) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1212,7 +1212,7 @@ static bool intl_FormatToPartsDateTime(J
 
   UErrorCode status = U_ZERO_ERROR;
   UFieldPositionIterator* fpositer = ufieldpositer_open(&status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -1225,16 +1225,16 @@ static bool intl_FormatToPartsDateTime(J
         return udat_formatForFields(df, x.toDouble(), chars, size, fpositer,
                                     status);
       });
-  if (!overallResult) {
+  if (!overallResult) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedArrayObject partsArray(cx, NewDenseEmptyArray(cx));
-  if (!partsArray) {
+  if (!partsArray) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (overallResult->length() == 0) {
+  if (overallResult->length() == 0) {MOZ_RELEASE_ASSERT(0);
     // An empty string contains no parts, so avoid extra work below.
     result.setObject(*partsArray);
     return true;
@@ -1303,12 +1303,12 @@ static bool intl_FormatToPartsDateTime(J
     if (FieldType type = GetFieldTypeForFormatField(
             static_cast<UDateFormatField>(fieldInt))) {
       if (lastEndIndex < beginIndex) {
-        if (!AppendPart(&JSAtomState::literal, lastEndIndex, beginIndex)) {
+        if (!AppendPart(&JSAtomState::literal, lastEndIndex, beginIndex)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
 
-      if (!AppendPart(type, beginIndex, endIndex)) {
+      if (!AppendPart(type, beginIndex, endIndex)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1376,11 +1376,11 @@ static UDateIntervalFormat* NewUDateInte
   RootedValue value(cx);
 
   RootedObject internals(cx, intl::GetInternalsObject(cx, dateTimeFormat));
-  if (!internals) {
+  if (!internals) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!GetProperty(cx, internals, internals, cx->names().pattern, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().pattern, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1390,7 +1390,7 @@ static UDateIntervalFormat* NewUDateInte
   mozilla::Maybe<HourCycle> hcPattern;
   {
     JSLinearString* pattern = value.toString()->ensureLinear(cx);
-    if (!pattern) {
+    if (!pattern) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1403,33 +1403,33 @@ static UDateIntervalFormat* NewUDateInte
   }
 
   UniqueChars locale = DateTimeFormatLocale(cx, internals, hcPattern);
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!GetProperty(cx, internals, internals, cx->names().timeZone, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().timeZone, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   AutoStableStringChars timeZone(cx);
-  if (!timeZone.initTwoByte(cx, value.toString())) {
+  if (!timeZone.initTwoByte(cx, value.toString())) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   mozilla::Span<const char16_t> timeZoneChars = timeZone.twoByteRange();
 
-  if (!GetProperty(cx, internals, internals, cx->names().skeleton, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().skeleton, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   AutoStableStringChars skeleton(cx);
-  if (!skeleton.initTwoByte(cx, value.toString())) {
+  if (!skeleton.initTwoByte(cx, value.toString())) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   mozilla::Span<const char16_t> skeletonChars = skeleton.twoByteRange();
 
   Vector<char16_t, INITIAL_CHAR_BUFFER_SIZE> newSkeleton(cx);
   if (hcPattern) {
-    if (!newSkeleton.append(skeletonChars.data(), skeletonChars.size())) {
+    if (!newSkeleton.append(skeletonChars.data(), skeletonChars.size())) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1453,7 +1453,7 @@ static UCalendar* CreateCalendar(JSConte
                                  ClippedTime t) {
   UErrorCode status = U_ZERO_ERROR;
   UCalendar* clone = ucal_clone(cal, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return nullptr;
   }
@@ -1499,13 +1499,13 @@ static const UFormattedValue* PartitionD
     const UCalendar* cal = udat_getCalendar(df);
 
     UCalendar* startCal = CreateCalendar(cx, cal, x);
-    if (!startCal) {
+    if (!startCal) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     ScopedICUObject<UCalendar, ucal_close> toCloseStart(startCal);
 
     UCalendar* endCal = CreateCalendar(cx, cal, y);
-    if (!endCal) {
+    if (!endCal) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     ScopedICUObject<UCalendar, ucal_close> toCloseEnd(endCal);
@@ -1516,7 +1516,7 @@ static const UFormattedValue* PartitionD
     udtitvfmt_formatToResult(dif, x.toDouble(), y.toDouble(), formatted,
                              &status);
   }
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return nullptr;
   }
@@ -1541,7 +1541,7 @@ static bool DateFieldsPracticallyEqual(J
                                        bool* equal) {
   UErrorCode status = U_ZERO_ERROR;
   UConstrainedFieldPosition* fpos = ucfpos_open(&status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -1549,7 +1549,7 @@ static bool DateFieldsPracticallyEqual(J
 
   // We're only interested in UFIELD_CATEGORY_DATE_INTERVAL_SPAN fields.
   ucfpos_constrainCategory(fpos, UFIELD_CATEGORY_DATE_INTERVAL_SPAN, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -1574,7 +1574,7 @@ static bool FormatDateTimeRange(JSContex
                                 ClippedTime y, MutableHandleValue result) {
   UErrorCode status = U_ZERO_ERROR;
   UFormattedDateInterval* formatted = udtitvfmt_openResult(&status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -1583,13 +1583,13 @@ static bool FormatDateTimeRange(JSContex
 
   const UFormattedValue* formattedValue =
       PartitionDateTimeRangePattern(cx, df, dif, formatted, x, y);
-  if (!formattedValue) {
+  if (!formattedValue) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // PartitionDateTimeRangePattern, steps 9-11.
   bool equal;
-  if (!DateFieldsPracticallyEqual(cx, formattedValue, &equal)) {
+  if (!DateFieldsPracticallyEqual(cx, formattedValue, &equal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1616,7 +1616,7 @@ static bool FormatDateTimeRangeToParts(J
                                        MutableHandleValue result) {
   UErrorCode status = U_ZERO_ERROR;
   UFormattedDateInterval* formatted = udtitvfmt_openResult(&status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -1625,13 +1625,13 @@ static bool FormatDateTimeRangeToParts(J
 
   const UFormattedValue* formattedValue =
       PartitionDateTimeRangePattern(cx, df, dif, formatted, x, y);
-  if (!formattedValue) {
+  if (!formattedValue) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // PartitionDateTimeRangePattern, steps 9-11.
   bool equal;
-  if (!DateFieldsPracticallyEqual(cx, formattedValue, &equal)) {
+  if (!DateFieldsPracticallyEqual(cx, formattedValue, &equal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1643,12 +1643,12 @@ static bool FormatDateTimeRangeToParts(J
 
   RootedString overallResult(cx,
                              intl::FormattedValueToString(cx, formattedValue));
-  if (!overallResult) {
+  if (!overallResult) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedArrayObject partsArray(cx, NewDenseEmptyArray(cx));
-  if (!partsArray) {
+  if (!partsArray) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1693,7 +1693,7 @@ static bool FormatDateTimeRangeToParts(J
   };
 
   UConstrainedFieldPosition* fpos = ucfpos_open(&status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -1704,7 +1704,7 @@ static bool FormatDateTimeRangeToParts(J
 
   while (true) {
     bool hasMore = ufmtval_nextPosition(formattedValue, fpos, &status);
-    if (U_FAILURE(status)) {
+    if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
       intl::ReportInternalError(cx);
       return false;
     }
@@ -1713,20 +1713,20 @@ static bool FormatDateTimeRangeToParts(J
     }
 
     int32_t category = ucfpos_getCategory(fpos, &status);
-    if (U_FAILURE(status)) {
+    if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
       intl::ReportInternalError(cx);
       return false;
     }
 
     int32_t field = ucfpos_getField(fpos, &status);
-    if (U_FAILURE(status)) {
+    if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
       intl::ReportInternalError(cx);
       return false;
     }
 
     int32_t beginIndexInt, endIndexInt;
     ucfpos_getIndexes(fpos, &beginIndexInt, &endIndexInt, &status);
-    if (U_FAILURE(status)) {
+    if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
       intl::ReportInternalError(cx);
       return false;
     }
@@ -1748,7 +1748,7 @@ static bool FormatDateTimeRangeToParts(J
       // Append any remaining literal parts before changing the source kind.
       if (lastEndIndex < beginIndex) {
         if (!AppendPart(&JSAtomState::literal, lastEndIndex, beginIndex,
-                        source)) {
+                        source)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -1765,7 +1765,7 @@ static bool FormatDateTimeRangeToParts(J
     }
 
     // Ignore categories other than UFIELD_CATEGORY_DATE.
-    if (category != UFIELD_CATEGORY_DATE) {
+    if (category != UFIELD_CATEGORY_DATE) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
@@ -1775,23 +1775,23 @@ static bool FormatDateTimeRangeToParts(J
             GetFieldTypeForFormatField(static_cast<UDateFormatField>(field))) {
       if (lastEndIndex < beginIndex) {
         if (!AppendPart(&JSAtomState::literal, lastEndIndex, beginIndex,
-                        source)) {
+                        source)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
 
-      if (!AppendPart(type, beginIndex, endIndex, source)) {
+      if (!AppendPart(type, beginIndex, endIndex, source)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
 
     if (endIndex == categoryEndIndex) {
       // Append any remaining literal parts before changing the source kind.
-      if (lastEndIndex < endIndex) {
+      if (lastEndIndex < endIndex) {MOZ_RELEASE_ASSERT(0);
         if (!AppendPart(&JSAtomState::literal, lastEndIndex, endIndex,
-                        source)) {
+                        source)) {MOZ_RELEASE_ASSERT(0);
           return false;
-        }
+        }MOZ_RELEASE_ASSERT(0);
       }
 
       source = &JSAtomState::shared;
@@ -1799,7 +1799,7 @@ static bool FormatDateTimeRangeToParts(J
   }
 
   // Append any final literal.
-  if (lastEndIndex < overallResult->length()) {
+  if (lastEndIndex < overallResult->length()) {MOZ_RELEASE_ASSERT(0);
     if (!AppendPart(&JSAtomState::literal, lastEndIndex,
                     overallResult->length(), source)) {
       return false;
@@ -1849,7 +1849,7 @@ bool js::intl_FormatDateTimeRange(JSCont
   UDateFormat* df = dateTimeFormat->getDateFormat();
   if (!df) {
     df = NewUDateFormat(cx, dateTimeFormat);
-    if (!df) {
+    if (!df) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     dateTimeFormat->setDateFormat(df);
diff --git a/js/src/builtin/intl/DisplayNames.cpp b/js/src/builtin/intl/DisplayNames.cpp
--- a/js/src/builtin/intl/DisplayNames.cpp
+++ b/js/src/builtin/intl/DisplayNames.cpp
@@ -172,11 +172,11 @@ static bool DisplayNames(JSContext* cx, 
                                             &proto)) {
       return false;
     }
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     RootedObject newTarget(cx, &args.newTarget().toObject());
-    if (!GetPrototypeFromConstructor(cx, newTarget, JSProto_Null, &proto)) {
+    if (!GetPrototypeFromConstructor(cx, newTarget, JSProto_Null, &proto)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   // TypeError anyway, but this gives a better error message.
@@ -186,7 +186,7 @@ static bool DisplayNames(JSContext* cx, 
 
   Rooted<DisplayNamesObject*> displayNames(cx);
   displayNames = NewObjectWithClassProto<DisplayNamesObject>(cx, proto);
-  if (!displayNames) {
+  if (!displayNames) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -229,25 +229,25 @@ void js::DisplayNamesObject::finalize(JS
 bool JS::AddMozDisplayNamesConstructor(JSContext* cx, HandleObject intl) {
   RootedObject ctor(cx, GlobalObject::createConstructor(
                             cx, MozDisplayNames, cx->names().DisplayNames, 2));
-  if (!ctor) {
+  if (!ctor) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject proto(
       cx, GlobalObject::createBlankPrototype<PlainObject>(cx, cx->global()));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!LinkConstructorAndPrototype(cx, ctor, proto)) {
+  if (!LinkConstructorAndPrototype(cx, ctor, proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!JS_DefineFunctions(cx, ctor, displayNames_static_methods)) {
+  if (!JS_DefineFunctions(cx, ctor, displayNames_static_methods)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!JS_DefineFunctions(cx, proto, displayNames_methods)) {
+  if (!JS_DefineFunctions(cx, proto, displayNames_methods)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -320,7 +320,7 @@ static void ReportInvalidOptionError(JSC
 }
 
 static void ReportInvalidOptionError(JSContext* cx, const char* type,
-                                     double option) {
+                                     double option) {MOZ_RELEASE_ASSERT(0);
   ToCStringBuf cbuf;
   if (const char* str = NumberToCString(cx, &cbuf, option)) {
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
@@ -344,18 +344,18 @@ static JSString* GetLanguageDisplayName(
   // ICU always canonicalizes the input locale, but since we know that ICU's
   // canonicalization is incomplete, we need to perform our own canonicalization
   // to ensure consistent result.
-  if (!tag.canonicalizeBaseName(cx)) {
+  if (!tag.canonicalizeBaseName(cx)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   UniqueChars languageChars = tag.toStringZ(cx);
-  if (!languageChars) {
+  if (!languageChars) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   ULocaleDisplayNames* ldn =
       GetOrCreateLocaleDisplayNames(cx, displayNames, locale, displayStyle);
-  if (!ldn) {
+  if (!ldn) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -372,7 +372,7 @@ static JSString* GetLanguageDisplayName(
     }
     return res;
   });
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -408,7 +408,7 @@ static JSString* GetScriptDisplayName(JS
   // ICU always canonicalizes the input locale, but since we know that ICU's
   // canonicalization is incomplete, we need to perform our own canonicalization
   // to ensure consistent result.
-  if (!tag.canonicalizeBaseName(cx)) {
+  if (!tag.canonicalizeBaseName(cx)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   MOZ_ASSERT(tag.script().present());
@@ -421,7 +421,7 @@ static JSString* GetScriptDisplayName(JS
   if (displayStyle == DisplayNamesStyle::Long) {
     // |uloc_getDisplayScript| expects a full locale identifier as its input.
     UniqueChars scriptChars = tag.toStringZ(cx);
-    if (!scriptChars) {
+    if (!scriptChars) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -439,7 +439,7 @@ static JSString* GetScriptDisplayName(JS
           }
           return res;
         });
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -461,7 +461,7 @@ static JSString* GetScriptDisplayName(JS
 
   ULocaleDisplayNames* ldn =
       GetOrCreateLocaleDisplayNames(cx, displayNames, locale, displayStyle);
-  if (!ldn) {
+  if (!ldn) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -477,7 +477,7 @@ static JSString* GetScriptDisplayName(JS
     }
     return res;
   });
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -509,7 +509,7 @@ static JSString* GetRegionDisplayName(JS
   // ICU always canonicalizes the input locale, but since we know that ICU's
   // canonicalization is incomplete, we need to perform our own canonicalization
   // to ensure consistent result.
-  if (!tag.canonicalizeBaseName(cx)) {
+  if (!tag.canonicalizeBaseName(cx)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   MOZ_ASSERT(tag.region().present());
@@ -523,7 +523,7 @@ static JSString* GetRegionDisplayName(JS
 
   ULocaleDisplayNames* ldn =
       GetOrCreateLocaleDisplayNames(cx, displayNames, locale, displayStyle);
-  if (!ldn) {
+  if (!ldn) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -539,7 +539,7 @@ static JSString* GetRegionDisplayName(JS
     }
     return res;
   });
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -568,7 +568,7 @@ static JSString* GetCurrencyDisplayName(
 
   if (!mozilla::IsAsciiAlpha(currency[0]) ||
       !mozilla::IsAsciiAlpha(currency[1]) ||
-      !mozilla::IsAsciiAlpha(currency[2])) {
+      !mozilla::IsAsciiAlpha(currency[2])) {MOZ_RELEASE_ASSERT(0);
     ReportInvalidOptionError(cx, "currency", currencyStr);
     return nullptr;
   }
@@ -590,7 +590,7 @@ static JSString* GetCurrencyDisplayName(
   UErrorCode status = U_ZERO_ERROR;
   const char16_t* name =
       ucurr_getName(currency, locale, currencyStyle, nullptr, &length, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return nullptr;
   }
@@ -653,29 +653,29 @@ static ListObject* GetDateTimeDisplayNam
     JSContext* cx, Handle<DisplayNamesObject*> displayNames, const char* locale,
     HandleLinearString calendar, UDateFormatSymbolType symbolType,
     mozilla::Span<const int32_t> indices) {
-  if (auto* names = displayNames->getDateTimeNames()) {
+  if (auto* names = displayNames->getDateTimeNames()) {MOZ_RELEASE_ASSERT(0);
     return names;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   intl::LanguageTag tag(cx);
   if (!intl::LanguageTagParser::parse(cx, mozilla::MakeStringSpan(locale),
-                                      tag)) {
+                                      tag)) {MOZ_RELEASE_ASSERT(0);
+    return nullptr;
+  }MOZ_RELEASE_ASSERT(0);
+
+  JS::RootedVector<intl::UnicodeExtensionKeyword> keywords(cx);
+  if (!keywords.emplaceBack("ca", calendar)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  JS::RootedVector<intl::UnicodeExtensionKeyword> keywords(cx);
-  if (!keywords.emplaceBack("ca", calendar)) {
+  if (!intl::ApplyUnicodeExtensionToTag(cx, tag, keywords)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
-
-  if (!intl::ApplyUnicodeExtensionToTag(cx, tag, keywords)) {
-    return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   UniqueChars localeWithCalendar = tag.toStringZ(cx);
-  if (!localeWithCalendar) {
+  if (!localeWithCalendar) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   constexpr char16_t* timeZone = nullptr;
   constexpr int32_t timeZoneLength = 0;
@@ -687,28 +687,28 @@ static ListObject* GetDateTimeDisplayNam
   UDateFormat* fmt =
       udat_open(UDAT_DEFAULT, UDAT_DEFAULT, IcuLocale(localeWithCalendar.get()),
                 timeZone, timeZoneLength, pattern, patternLength, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   ScopedICUObject<UDateFormat, udat_close> datToClose(fmt);
 
   Rooted<ListObject*> names(cx, ListObject::create(cx));
-  if (!names) {
+  if (!names) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedValue value(cx);
-  for (uint32_t i = 0; i < indices.size(); i++) {
+  for (uint32_t i = 0; i < indices.size(); i++) {MOZ_RELEASE_ASSERT(0);
     int32_t index = indices[i];
     JSString* name =
         CallICU(cx, [fmt, symbolType, index](UChar* chars, int32_t size,
                                              UErrorCode* status) {
           return udat_getSymbols(fmt, symbolType, index, chars, size, status);
         });
-    if (!name) {
+    if (!name) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Everything except Undecimber should always have a non-empty name.
     MOZ_ASSERT_IF(!IsStandaloneMonth(symbolType) || index != UCAL_UNDECIMBER,
@@ -729,22 +729,22 @@ static JSString* GetWeekdayDisplayName(J
                                        const char* locale,
                                        HandleLinearString calendar,
                                        DisplayNamesStyle displayStyle,
-                                       HandleLinearString code) {
+                                       HandleLinearString code) {MOZ_RELEASE_ASSERT(0);
   uint8_t weekday;
-  {
+  {MOZ_RELEASE_ASSERT(0);
     double d;
-    if (!StringToNumber(cx, code, &d)) {
+    if (!StringToNumber(cx, code, &d)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     // Inlined implementation of `IsValidWeekdayCode ( weekday )`.
-    if (!IsInteger(d) || d < 1 || d > 7) {
+    if (!IsInteger(d) || d < 1 || d > 7) {MOZ_RELEASE_ASSERT(0);
       ReportInvalidOptionError(cx, "weekday", d);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     weekday = uint8_t(d);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   UDateFormatSymbolType symbolType;
   switch (displayStyle) {
@@ -779,22 +779,22 @@ static JSString* GetWeekdayDisplayName(J
 static JSString* GetMonthDisplayName(
     JSContext* cx, Handle<DisplayNamesObject*> displayNames, const char* locale,
     HandleLinearString calendar, DisplayNamesStyle displayStyle,
-    DisplayNamesFallback fallback, HandleLinearString code) {
+    DisplayNamesFallback fallback, HandleLinearString code) {MOZ_RELEASE_ASSERT(0);
   uint8_t month;
-  {
+  {MOZ_RELEASE_ASSERT(0);
     double d;
-    if (!StringToNumber(cx, code, &d)) {
+    if (!StringToNumber(cx, code, &d)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     // Inlined implementation of `IsValidMonthCode ( month )`.
-    if (!IsInteger(d) || d < 1 || d > 13) {
+    if (!IsInteger(d) || d < 1 || d > 13) {MOZ_RELEASE_ASSERT(0);
       ReportInvalidOptionError(cx, "month", d);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     month = uint8_t(d);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   UDateFormatSymbolType symbolType;
   switch (displayStyle) {
@@ -819,9 +819,9 @@ static JSString* GetMonthDisplayName(
 
   ListObject* names = GetDateTimeDisplayNames(
       cx, displayNames, locale, calendar, symbolType, mozilla::Span(indices));
-  if (!names) {
+  if (!names) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(names->length() == std::size(indices));
 
   JSString* str = names->get(month - 1).toString();
@@ -836,22 +836,22 @@ static JSString* GetQuarterDisplayName(J
                                        const char* locale,
                                        HandleLinearString calendar,
                                        DisplayNamesStyle displayStyle,
-                                       HandleLinearString code) {
+                                       HandleLinearString code) {MOZ_RELEASE_ASSERT(0);
   uint8_t quarter;
-  {
+  {MOZ_RELEASE_ASSERT(0);
     double d;
-    if (!StringToNumber(cx, code, &d)) {
+    if (!StringToNumber(cx, code, &d)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     // Inlined implementation of `IsValidQuarterCode ( quarter )`.
-    if (!IsInteger(d) || d < 1 || d > 4) {
+    if (!IsInteger(d) || d < 1 || d > 4) {MOZ_RELEASE_ASSERT(0);
       ReportInvalidOptionError(cx, "quarter", d);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     quarter = uint8_t(d);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   UDateFormatSymbolType symbolType;
   switch (displayStyle) {
@@ -881,17 +881,17 @@ static JSString* GetQuarterDisplayName(J
 
 static JSString* GetDayPeriodDisplayName(
     JSContext* cx, Handle<DisplayNamesObject*> displayNames, const char* locale,
-    HandleLinearString calendar, HandleLinearString dayPeriod) {
+    HandleLinearString calendar, HandleLinearString dayPeriod) {MOZ_RELEASE_ASSERT(0);
   // Inlined implementation of `IsValidDayPeriodCode ( dayperiod )`.
   uint32_t index;
-  if (StringEqualsLiteral(dayPeriod, "am")) {
+  if (StringEqualsLiteral(dayPeriod, "am")) {MOZ_RELEASE_ASSERT(0);
     index = 0;
-  } else if (StringEqualsLiteral(dayPeriod, "pm")) {
+  } else if (StringEqualsLiteral(dayPeriod, "pm")) {MOZ_RELEASE_ASSERT(0);
     index = 1;
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     ReportInvalidOptionError(cx, "dayPeriod", dayPeriod);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   UDateFormatSymbolType symbolType = UDAT_AM_PMS;
 
@@ -909,37 +909,37 @@ static JSString* GetDayPeriodDisplayName
 
 static JSString* GetDateTimeFieldDisplayName(JSContext* cx, const char* locale,
                                              DisplayNamesStyle displayStyle,
-                                             HandleLinearString dateTimeField) {
+                                             HandleLinearString dateTimeField) {MOZ_RELEASE_ASSERT(0);
   // Inlined implementation of `IsValidDateTimeFieldCode ( field )`.
   UDateTimePatternField field;
-  if (StringEqualsLiteral(dateTimeField, "era")) {
+  if (StringEqualsLiteral(dateTimeField, "era")) {MOZ_RELEASE_ASSERT(0);
     field = UDATPG_ERA_FIELD;
-  } else if (StringEqualsLiteral(dateTimeField, "year")) {
+  } else if (StringEqualsLiteral(dateTimeField, "year")) {MOZ_RELEASE_ASSERT(0);
     field = UDATPG_YEAR_FIELD;
-  } else if (StringEqualsLiteral(dateTimeField, "quarter")) {
+  } else if (StringEqualsLiteral(dateTimeField, "quarter")) {MOZ_RELEASE_ASSERT(0);
     field = UDATPG_QUARTER_FIELD;
-  } else if (StringEqualsLiteral(dateTimeField, "month")) {
+  } else if (StringEqualsLiteral(dateTimeField, "month")) {MOZ_RELEASE_ASSERT(0);
     field = UDATPG_MONTH_FIELD;
-  } else if (StringEqualsLiteral(dateTimeField, "weekOfYear")) {
+  } else if (StringEqualsLiteral(dateTimeField, "weekOfYear")) {MOZ_RELEASE_ASSERT(0);
     field = UDATPG_WEEK_OF_YEAR_FIELD;
-  } else if (StringEqualsLiteral(dateTimeField, "weekday")) {
+  } else if (StringEqualsLiteral(dateTimeField, "weekday")) {MOZ_RELEASE_ASSERT(0);
     field = UDATPG_WEEKDAY_FIELD;
-  } else if (StringEqualsLiteral(dateTimeField, "day")) {
+  } else if (StringEqualsLiteral(dateTimeField, "day")) {MOZ_RELEASE_ASSERT(0);
     field = UDATPG_DAY_FIELD;
-  } else if (StringEqualsLiteral(dateTimeField, "dayPeriod")) {
+  } else if (StringEqualsLiteral(dateTimeField, "dayPeriod")) {MOZ_RELEASE_ASSERT(0);
     field = UDATPG_DAYPERIOD_FIELD;
-  } else if (StringEqualsLiteral(dateTimeField, "hour")) {
+  } else if (StringEqualsLiteral(dateTimeField, "hour")) {MOZ_RELEASE_ASSERT(0);
     field = UDATPG_HOUR_FIELD;
-  } else if (StringEqualsLiteral(dateTimeField, "minute")) {
+  } else if (StringEqualsLiteral(dateTimeField, "minute")) {MOZ_RELEASE_ASSERT(0);
     field = UDATPG_MINUTE_FIELD;
-  } else if (StringEqualsLiteral(dateTimeField, "second")) {
+  } else if (StringEqualsLiteral(dateTimeField, "second")) {MOZ_RELEASE_ASSERT(0);
     field = UDATPG_SECOND_FIELD;
-  } else if (StringEqualsLiteral(dateTimeField, "timeZoneName")) {
+  } else if (StringEqualsLiteral(dateTimeField, "timeZoneName")) {MOZ_RELEASE_ASSERT(0);
     field = UDATPG_ZONE_FIELD;
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     ReportInvalidOptionError(cx, "dateTimeField", dateTimeField);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   UDateTimePGDisplayWidth width;
   switch (displayStyle) {
@@ -957,9 +957,9 @@ static JSString* GetDateTimeFieldDisplay
   intl::SharedIntlData& sharedIntlData = cx->runtime()->sharedIntlData.ref();
   UDateTimePatternGenerator* dtpg =
       sharedIntlData.getDateTimePatternGenerator(cx, locale);
-  if (!dtpg) {
+  if (!dtpg) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   JSString* str = intl::CallICU(cx, [dtpg, field, width](UChar* chars,
                                                          uint32_t size,
@@ -982,24 +982,24 @@ bool js::intl_ComputeDisplayName(JSConte
       cx, &args[0].toObject().as<DisplayNamesObject>());
 
   UniqueChars locale = intl::EncodeLocale(cx, args[1].toString());
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedLinearString calendar(cx, args[2].toString()->ensureLinear(cx));
-  if (!calendar) {
+  if (!calendar) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedLinearString code(cx, args[6].toString()->ensureLinear(cx));
-  if (!code) {
+  if (!code) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   DisplayNamesStyle displayStyle;
   {
     JSLinearString* style = args[3].toString()->ensureLinear(cx);
-    if (!style) {
+    if (!style) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1016,7 +1016,7 @@ bool js::intl_ComputeDisplayName(JSConte
   DisplayNamesFallback displayFallback;
   {
     JSLinearString* fallback = args[4].toString()->ensureLinear(cx);
-    if (!fallback) {
+    if (!fallback) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1029,7 +1029,7 @@ bool js::intl_ComputeDisplayName(JSConte
   }
 
   JSLinearString* type = args[5].toString()->ensureLinear(cx);
-  if (!type) {
+  if (!type) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1046,19 +1046,19 @@ bool js::intl_ComputeDisplayName(JSConte
   } else if (StringEqualsLiteral(type, "currency")) {
     result = GetCurrencyDisplayName(cx, locale.get(), displayStyle,
                                     displayFallback, code);
-  } else if (StringEqualsLiteral(type, "weekday")) {
+  } else if (StringEqualsLiteral(type, "weekday")) {MOZ_RELEASE_ASSERT(0);
     result = GetWeekdayDisplayName(cx, displayNames, locale.get(), calendar,
                                    displayStyle, code);
-  } else if (StringEqualsLiteral(type, "month")) {
+  } else if (StringEqualsLiteral(type, "month")) {MOZ_RELEASE_ASSERT(0);
     result = GetMonthDisplayName(cx, displayNames, locale.get(), calendar,
                                  displayStyle, displayFallback, code);
-  } else if (StringEqualsLiteral(type, "quarter")) {
+  } else if (StringEqualsLiteral(type, "quarter")) {MOZ_RELEASE_ASSERT(0);
     result = GetQuarterDisplayName(cx, displayNames, locale.get(), calendar,
                                    displayStyle, code);
-  } else if (StringEqualsLiteral(type, "dayPeriod")) {
+  } else if (StringEqualsLiteral(type, "dayPeriod")) {MOZ_RELEASE_ASSERT(0);
     result =
         GetDayPeriodDisplayName(cx, displayNames, locale.get(), calendar, code);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(StringEqualsLiteral(type, "dateTimeField"));
     result = GetDateTimeFieldDisplayName(cx, locale.get(), displayStyle, code);
   }
@@ -1068,7 +1068,7 @@ bool js::intl_ComputeDisplayName(JSConte
 
   if (!result->empty()) {
     args.rval().setString(result);
-  } else if (displayFallback == DisplayNamesFallback::Code) {
+  } else if (displayFallback == DisplayNamesFallback::Code) {MOZ_RELEASE_ASSERT(0);
     args.rval().setString(code);
   } else {
     args.rval().setUndefined();
diff --git a/js/src/builtin/intl/IntlObject.cpp b/js/src/builtin/intl/IntlObject.cpp
--- a/js/src/builtin/intl/IntlObject.cpp
+++ b/js/src/builtin/intl/IntlObject.cpp
@@ -67,7 +67,7 @@ bool js::intl_GetCalendarInfo(JSContext*
   MOZ_ASSERT(args.length() == 1);
 
   UniqueChars locale = intl::EncodeLocale(cx, args[0].toString());
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -76,14 +76,14 @@ bool js::intl_GetCalendarInfo(JSContext*
   int32_t uTimeZoneLength = 0;
   UCalendar* cal = ucal_open(uTimeZone, uTimeZoneLength, locale.get(),
                              UCAL_DEFAULT, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
   ScopedICUObject<UCalendar, ucal_close> toClose(cal);
 
   RootedObject info(cx, NewBuiltinClassInstance<PlainObject>(cx));
-  if (!info) {
+  if (!info) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -91,19 +91,19 @@ bool js::intl_GetCalendarInfo(JSContext*
   int32_t firstDayOfWeek = ucal_getAttribute(cal, UCAL_FIRST_DAY_OF_WEEK);
   v.setInt32(firstDayOfWeek);
 
-  if (!DefineDataProperty(cx, info, cx->names().firstDayOfWeek, v)) {
+  if (!DefineDataProperty(cx, info, cx->names().firstDayOfWeek, v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   int32_t minDays = ucal_getAttribute(cal, UCAL_MINIMAL_DAYS_IN_FIRST_WEEK);
   v.setInt32(minDays);
-  if (!DefineDataProperty(cx, info, cx->names().minDays, v)) {
+  if (!DefineDataProperty(cx, info, cx->names().minDays, v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   UCalendarWeekdayType prevDayType =
       ucal_getDayOfWeekType(cal, UCAL_SATURDAY, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -113,7 +113,7 @@ bool js::intl_GetCalendarInfo(JSContext*
   for (int i = UCAL_SUNDAY; i <= UCAL_SATURDAY; i++) {
     UCalendarDaysOfWeek dayOfWeek = static_cast<UCalendarDaysOfWeek>(i);
     UCalendarWeekdayType type = ucal_getDayOfWeekType(cal, dayOfWeek, &status);
-    if (U_FAILURE(status)) {
+    if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
       intl::ReportInternalError(cx);
       return false;
     }
@@ -147,7 +147,7 @@ bool js::intl_GetCalendarInfo(JSContext*
   MOZ_ASSERT(weekendStart.isInt32());
   MOZ_ASSERT(weekendEnd.isInt32());
 
-  if (!DefineDataProperty(cx, info, cx->names().weekendStart, weekendStart)) {
+  if (!DefineDataProperty(cx, info, cx->names().weekendStart, weekendStart)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -219,12 +219,12 @@ static JSString* ComputeSingleDisplayNam
     return nullptr;
   }
 
-  if (!MatchSlash()) {
+  if (!MatchSlash()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   if (MatchPart(&iter, end, "fields")) {
-    if (!MatchSlash()) {
+    if (!MatchSlash()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -234,17 +234,17 @@ static JSString* ComputeSingleDisplayNam
       fieldType = UDATPG_YEAR_FIELD;
     } else if (MatchPart(&iter, end, "month")) {
       fieldType = UDATPG_MONTH_FIELD;
-    } else if (MatchPart(&iter, end, "week")) {
+    } else if (MatchPart(&iter, end, "week")) {MOZ_RELEASE_ASSERT(0);
       fieldType = UDATPG_WEEK_OF_YEAR_FIELD;
     } else if (MatchPart(&iter, end, "day")) {
       fieldType = UDATPG_DAY_FIELD;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       ReportBadKey(cx, patternString);
       return nullptr;
     }
 
     // This part must be the final part with no trailing data.
-    if (iter != end) {
+    if (iter != end) {MOZ_RELEASE_ASSERT(0);
       ReportBadKey(cx, patternString);
       return nullptr;
     }
@@ -257,7 +257,7 @@ static JSString* ComputeSingleDisplayNam
   }
 
   if (MatchPart(&iter, end, "gregorian")) {
-    if (!MatchSlash()) {
+    if (!MatchSlash()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -265,7 +265,7 @@ static JSString* ComputeSingleDisplayNam
     int32_t index;
 
     if (MatchPart(&iter, end, "months")) {
-      if (!MatchSlash()) {
+      if (!MatchSlash()) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -307,12 +307,12 @@ static JSString* ComputeSingleDisplayNam
         index = UCAL_NOVEMBER;
       } else if (MatchPart(&iter, end, "december")) {
         index = UCAL_DECEMBER;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         ReportBadKey(cx, patternString);
         return nullptr;
       }
     } else if (MatchPart(&iter, end, "weekdays")) {
-      if (!MatchSlash()) {
+      if (!MatchSlash()) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -344,12 +344,12 @@ static JSString* ComputeSingleDisplayNam
         index = UCAL_SATURDAY;
       } else if (MatchPart(&iter, end, "sunday")) {
         index = UCAL_SUNDAY;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         ReportBadKey(cx, patternString);
         return nullptr;
       }
     } else if (MatchPart(&iter, end, "dayperiods")) {
-      if (!MatchSlash()) {
+      if (!MatchSlash()) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -359,17 +359,17 @@ static JSString* ComputeSingleDisplayNam
         index = UCAL_AM;
       } else if (MatchPart(&iter, end, "pm")) {
         index = UCAL_PM;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         ReportBadKey(cx, patternString);
         return nullptr;
       }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       ReportBadKey(cx, patternString);
       return nullptr;
     }
 
     // This part must be the final part with no trailing data.
-    if (iter != end) {
+    if (iter != end) {MOZ_RELEASE_ASSERT(0);
       ReportBadKey(cx, patternString);
       return nullptr;
     }
@@ -390,7 +390,7 @@ bool js::intl_ComputeDisplayNames(JSCont
 
   // 1. Assert: locale is a string.
   UniqueChars locale = intl::EncodeLocale(cx, args[0].toString());
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -398,7 +398,7 @@ bool js::intl_ComputeDisplayNames(JSCont
   DisplayNameStyle dnStyle;
   {
     JSLinearString* style = args[1].toString()->ensureLinear(cx);
-    if (!style) {
+    if (!style) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -414,13 +414,13 @@ bool js::intl_ComputeDisplayNames(JSCont
 
   // 3. Assert: keys is an Array.
   RootedArrayObject keys(cx, &args[2].toObject().as<ArrayObject>());
-  if (!keys) {
+  if (!keys) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // 4. Let result be ArrayCreate(0).
   RootedArrayObject result(cx, NewDenseFullyAllocatedArray(cx, keys->length()));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   result->ensureDenseInitializedLength(0, keys->length());
@@ -430,7 +430,7 @@ bool js::intl_ComputeDisplayNames(JSCont
   UDateFormat* fmt =
       udat_open(UDAT_DEFAULT, UDAT_DEFAULT, IcuLocale(locale.get()), nullptr, 0,
                 nullptr, 0, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -440,7 +440,7 @@ bool js::intl_ComputeDisplayNames(JSCont
   // time fields like "month", "week", "day" etc.
   UDateTimePatternGenerator* dtpg =
       udatpg_open(IcuLocale(locale.get()), &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -450,14 +450,14 @@ bool js::intl_ComputeDisplayNames(JSCont
   RootedString keyValStr(cx);
   RootedValue v(cx);
   for (uint32_t i = 0; i < keys->length(); i++) {
-    if (!GetElement(cx, keys, keys, i, &v)) {
+    if (!GetElement(cx, keys, keys, i, &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     keyValStr = v.toString();
 
     AutoStableStringChars stablePatternChars(cx);
-    if (!stablePatternChars.init(cx, keyValStr)) {
+    if (!stablePatternChars.init(cx, keyValStr)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -489,16 +489,16 @@ bool js::intl_GetLocaleInfo(JSContext* c
   MOZ_ASSERT(args.length() == 1);
 
   UniqueChars locale = intl::EncodeLocale(cx, args[0].toString());
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject info(cx, NewBuiltinClassInstance<PlainObject>(cx));
-  if (!info) {
+  if (!info) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!DefineDataProperty(cx, info, cx->names().locale, args[0])) {
+  if (!DefineDataProperty(cx, info, cx->names().locale, args[0])) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -556,7 +556,7 @@ static JS::Result<JSString*> BestAvailab
   while (true) {
     // Step 2.a.
     bool supported = false;
-    if (!sharedIntlData.isSupportedLocale(cx, kind, candidate, &supported)) {
+    if (!sharedIntlData.isSupportedLocale(cx, kind, candidate, &supported)) {MOZ_RELEASE_ASSERT(0);
       return cx->alreadyReportedError();
     }
     if (supported) {
@@ -580,7 +580,7 @@ static JS::Result<JSString*> BestAvailab
     if (candidate->hasLatin1Chars()) {
       JS::AutoCheckCannotGC nogc;
       pos = findLast(candidate->latin1Chars(nogc), candidate->length());
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       JS::AutoCheckCannotGC nogc;
       pos = findLast(candidate->twoByteChars(nogc), candidate->length());
     }
@@ -614,7 +614,7 @@ bool js::intl_BestAvailableLocale(JSCont
   SupportedLocaleKind kind;
   {
     JSLinearString* typeStr = args[0].toString()->ensureLinear(cx);
-    if (!typeStr) {
+    if (!typeStr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -637,7 +637,7 @@ bool js::intl_BestAvailableLocale(JSCont
   }
 
   RootedLinearString locale(cx, args[1].toString()->ensureLinear(cx));
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -674,7 +674,7 @@ bool js::intl_BestAvailableLocale(JSCont
   RootedLinearString defaultLocale(cx);
   if (args[2].isString()) {
     defaultLocale = args[2].toString()->ensureLinear(cx);
-    if (!defaultLocale) {
+    if (!defaultLocale) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -697,7 +697,7 @@ bool js::intl_supportedLocaleOrFallback(
   MOZ_ASSERT(args.length() == 1);
 
   RootedLinearString locale(cx, args[0].toString()->ensureLinear(cx));
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -709,11 +709,11 @@ bool js::intl_supportedLocaleOrFallback(
   RootedLinearString candidate(cx);
   if (!ok) {
     candidate = NewStringCopyZ<CanGC>(cx, intl::LastDitchLocale());
-    if (!candidate) {
+    if (!candidate) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
-    if (!tag.canonicalize(cx)) {
+    if (!tag.canonicalize(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -723,12 +723,12 @@ bool js::intl_supportedLocaleOrFallback(
     tag.clearUnicodeExtension();
 
     JSString* canonical = tag.toString(cx);
-    if (!canonical) {
+    if (!canonical) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     candidate = canonical->ensureLinear(cx);
-    if (!candidate) {
+    if (!candidate) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -736,11 +736,11 @@ bool js::intl_supportedLocaleOrFallback(
       const char* oldStyle = mapping.oldStyle;
       const char* modernStyle = mapping.modernStyle;
 
-      if (StringEqualsAscii(candidate, oldStyle)) {
+      if (StringEqualsAscii(candidate, oldStyle)) {MOZ_RELEASE_ASSERT(0);
         candidate = NewStringCopyZ<CanGC>(cx, modernStyle);
-        if (!candidate) {
+        if (!candidate) {MOZ_RELEASE_ASSERT(0);
           return false;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         break;
       }
     }
@@ -768,13 +768,13 @@ bool js::intl_supportedLocaleOrFallback(
     JS_TRY_VAR_OR_RETURN_FALSE(
         cx, supported, BestAvailableLocale(cx, kind, candidate, nullptr));
 
-    if (!supported) {
+    if (!supported) {MOZ_RELEASE_ASSERT(0);
       isSupported = false;
       break;
     }
   }
 
-  if (!isSupported) {
+  if (!isSupported) {MOZ_RELEASE_ASSERT(0);
     candidate = NewStringCopyZ<CanGC>(cx, intl::LastDitchLocale());
     if (!candidate) {
       return false;
@@ -825,7 +825,7 @@ static bool IntlClassFinish(JSContext* c
         JSProto_ListFormat, JSProto_Locale, JSProto_NumberFormat,
         JSProto_PluralRules, JSProto_RelativeTimeFormat}) {
     JSObject* ctor = GlobalObject::getOrCreateConstructor(cx, protoKey);
-    if (!ctor) {
+    if (!ctor) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
diff --git a/js/src/builtin/intl/LanguageTag.cpp b/js/src/builtin/intl/LanguageTag.cpp
--- a/js/src/builtin/intl/LanguageTag.cpp
+++ b/js/src/builtin/intl/LanguageTag.cpp
@@ -243,7 +243,7 @@ static bool SortAlphabetically(JSContext
   }
 
   Vector<char*, 8> scratch(cx);
-  if (!scratch.resizeUninitialized(length * 2)) {
+  if (!scratch.resizeUninitialized(length * 2)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (size_t i = 0; i < length; i++) {
@@ -299,7 +299,7 @@ bool LanguageTag::canonicalizeBaseName(J
 
   if (variants_.length() > 1) {
     // 1. Any variants are in alphabetical order.
-    if (!SortAlphabetically(cx, variants_)) {
+    if (!SortAlphabetically(cx, variants_)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -337,7 +337,7 @@ bool LanguageTag::canonicalizeBaseName(J
   // Replace deprecated language, region, and variant subtags with their
   // preferred mappings.
 
-  if (!updateGrandfatheredMappings(cx)) {
+  if (!updateGrandfatheredMappings(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -395,13 +395,13 @@ bool LanguageTag::canonicalizeExtensions
 
   // Any extensions are in alphabetical order by their singleton.
   // "u-ca-chinese-t-zh-latn" -> "t-zh-latn-u-ca-chinese"
-  if (!SortAlphabetically(cx, extensions_)) {
+  if (!SortAlphabetically(cx, extensions_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   for (UniqueChars& extension : extensions_) {
     if (extension[0] == 'u') {
-      if (!canonicalizeUnicodeExtension(cx, extension)) {
+      if (!canonicalizeUnicodeExtension(cx, extension)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (extension[0] == 't') {
@@ -481,7 +481,7 @@ bool LanguageTag::canonicalizeUnicodeExt
   // All attributes are sorted in alphabetical order.
   size_t attributesLength = attributes.length();
   if (attributesLength > 1) {
-    if (!attributes.growByUninitialized(attributesLength)) {
+    if (!attributes.growByUninitialized(attributesLength)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -508,7 +508,7 @@ bool LanguageTag::canonicalizeUnicodeExt
   // All keywords are sorted by alphabetical order of keys.
   size_t keywordsLength = keywords.length();
   if (keywordsLength > 1) {
-    if (!keywords.growByUninitialized(keywordsLength)) {
+    if (!keywords.growByUninitialized(keywordsLength)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -530,7 +530,7 @@ bool LanguageTag::canonicalizeUnicodeExt
   }
 
   Vector<char, 32> sb(cx);
-  if (!sb.append('u')) {
+  if (!sb.append('u')) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -550,10 +550,10 @@ bool LanguageTag::canonicalizeUnicodeExt
       MOZ_ASSERT(!attributesLessOrEqual(attribute, lastAttribute));
     }
 
-    if (!sb.append('-')) {
+    if (!sb.append('-')) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!sb.append(attribute.begin(extension), attribute.length())) {
+    if (!sb.append(attribute.begin(extension), attribute.length())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -615,13 +615,13 @@ bool LanguageTag::canonicalizeUnicodeExt
       MOZ_ASSERT(!keywordsLessOrEqual(keyword, lastKeyword));
     }
 
-    if (!sb.append('-')) {
+    if (!sb.append('-')) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (keyword.length() == UnicodeKeyLength) {
       // Keyword without type value.
-      if (!appendKey(keyword)) {
+      if (!appendKey(keyword)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -631,11 +631,11 @@ bool LanguageTag::canonicalizeUnicodeExt
 
       // Search if there's a replacement for the current Unicode keyword.
       if (const char* replacement = replaceUnicodeExtensionType(key, type)) {
-        if (!appendReplacement(keyword, mozilla::MakeStringSpan(replacement))) {
+        if (!appendReplacement(keyword, mozilla::MakeStringSpan(replacement))) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
-        if (!appendKeyword(keyword, type)) {
+        if (!appendKeyword(keyword, type)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -646,7 +646,7 @@ bool LanguageTag::canonicalizeUnicodeExt
   if (sb.length() != length ||
       std::char_traits<char>::compare(sb.begin(), extension, length) != 0) {
     // Null-terminate the new string and replace the previous extension.
-    if (!sb.append('\0')) {
+    if (!sb.append('\0')) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     UniqueChars canonical(sb.extractOrCopyRawBuffer());
@@ -683,31 +683,31 @@ static bool LanguageTagToString(JSContex
   };
 
   // Append the language subtag.
-  if (!appendSubtag(tag.language())) {
+  if (!appendSubtag(tag.language())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Append the script subtag if present.
   if (tag.script().present()) {
-    if (!sb.append('-') || !appendSubtag(tag.script())) {
+    if (!sb.append('-') || !appendSubtag(tag.script())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // Append the region subtag if present.
   if (tag.region().present()) {
-    if (!sb.append('-') || !appendSubtag(tag.region())) {
+    if (!sb.append('-') || !appendSubtag(tag.region())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // Append the variant subtags if present.
-  if (!appendSubtagsZ(tag.variants())) {
+  if (!appendSubtagsZ(tag.variants())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Append the extensions subtags if present.
-  if (!appendSubtagsZ(tag.extensions())) {
+  if (!appendSubtagsZ(tag.extensions())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -767,7 +767,7 @@ bool LanguageTag::canonicalizeTransformE
 
   // All tfields are sorted by alphabetical order of their keys.
   if (size_t fieldsLength = fields.length(); fieldsLength > 1) {
-    if (!fields.growByUninitialized(fieldsLength)) {
+    if (!fields.growByUninitialized(fieldsLength)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -782,7 +782,7 @@ bool LanguageTag::canonicalizeTransformE
   }
 
   Vector<char, 32> sb(cx);
-  if (!sb.append('t')) {
+  if (!sb.append('t')) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -791,7 +791,7 @@ bool LanguageTag::canonicalizeTransformE
   // Replace aliases in tlang per
   // <https://unicode.org/reports/tr35/#Canonical_Unicode_Locale_Identifiers>.
   if (tag.language().present()) {
-    if (!sb.append('-')) {
+    if (!sb.append('-')) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -805,7 +805,7 @@ bool LanguageTag::canonicalizeTransformE
     tag.script_.toLowerCase();
     tag.region_.toLowerCase();
 
-    if (!LanguageTagToString(cx, tag, sb)) {
+    if (!LanguageTagToString(cx, tag, sb)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -823,7 +823,7 @@ bool LanguageTag::canonicalizeTransformE
   // this apparently invalid part of the UTS 35 specification and simply
   // append all `tfield` subtags.
   for (const auto& field : fields) {
-    if (!sb.append('-')) {
+    if (!sb.append('-')) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -833,14 +833,14 @@ bool LanguageTag::canonicalizeTransformE
 
     // Search if there's a replacement for the current transform keyword.
     if (const char* replacement = replaceTransformExtensionType(key, value)) {
-      if (!sb.append(field.begin(extension), TransformKeyWithSepLength)) {
+      if (!sb.append(field.begin(extension), TransformKeyWithSepLength)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
-      if (!sb.append(replacement, strlen(replacement))) {
+      if (!sb.append(replacement, strlen(replacement))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
-      if (!sb.append(field.begin(extension), field.length())) {
+      if (!sb.append(field.begin(extension), field.length())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -850,7 +850,7 @@ bool LanguageTag::canonicalizeTransformE
   if (sb.length() != length ||
       std::char_traits<char>::compare(sb.begin(), extension, length) != 0) {
     // Null-terminate the new string and replace the previous extension.
-    if (!sb.append('\0')) {
+    if (!sb.append('\0')) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     UniqueChars canonical(sb.extractOrCopyRawBuffer());
@@ -874,7 +874,7 @@ JSString* LanguageTag::toString(JSContex
 
 UniqueChars LanguageTag::toStringZ(JSContext* cx) const {
   Vector<char, 16> sb(cx);
-  if (!LanguageTagToString(cx, *this, sb)) {
+  if (!LanguageTagToString(cx, *this, sb)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (!sb.append('\0')) {
@@ -920,13 +920,13 @@ static bool CreateLocaleForLikelySubtags
   };
 
   // Append the language subtag.
-  if (!appendSubtag(tag.language())) {
+  if (!appendSubtag(tag.language())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Append the script subtag if present.
   if (tag.script().present()) {
-    if (!locale.append('_') || !appendSubtag(tag.script())) {
+    if (!locale.append('_') || !appendSubtag(tag.script())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -962,7 +962,7 @@ static bool AssignFromLocaleId(JSContext
     size_t length = strlen(und);
 
     // Insert "und" in front of the locale ID.
-    if (!localeId.growBy(length)) {
+    if (!localeId.growBy(length)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     memmove(localeId.begin() + length, localeId.begin(), localeId.length());
@@ -1041,7 +1041,7 @@ static bool LikelySubtags(JSContext* cx,
 
   // Create the locale ID for the input argument.
   LocaleId locale(cx);
-  if (!CreateLocaleForLikelySubtags(tag, locale)) {
+  if (!CreateLocaleForLikelySubtags(tag, locale)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1060,7 +1060,7 @@ static bool LikelySubtags(JSContext* cx,
 
   if (addLikelySubtags) {
     if (!CallLikelySubtags<uloc_addLikelySubtags>(cx, locale,
-                                                  localeLikelySubtags)) {
+                                                  localeLikelySubtags)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1075,7 +1075,7 @@ static bool LikelySubtags(JSContext* cx,
 
     // Remove likely subtags from the locale ID.
     if (!CallLikelySubtags<uloc_minimizeSubtags>(cx, locale,
-                                                 localeLikelySubtags)) {
+                                                 localeLikelySubtags)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1190,7 +1190,7 @@ JS::Result<bool> LanguageTagParser::inte
   MOZ_ASSERT(variants.length() == 0);
   while (ts.isVariant(tok)) {
     auto variant = ts.chars(cx, tok);
-    if (!variant) {
+    if (!variant) {MOZ_RELEASE_ASSERT(0);
       return cx->alreadyReportedOOM();
     }
     if (!variants.append(std::move(variant))) {
@@ -1329,10 +1329,10 @@ JS::Result<bool> LanguageTagParser::tryP
     }
 
     UniqueChars extension = ts.extension(cx, start, tok);
-    if (!extension) {
+    if (!extension) {MOZ_RELEASE_ASSERT(0);
       return cx->alreadyReportedOOM();
     }
-    if (!extensions.append(std::move(extension))) {
+    if (!extensions.append(std::move(extension))) {MOZ_RELEASE_ASSERT(0);
       return cx->alreadyReportedOOM();
     }
   }
@@ -1383,7 +1383,7 @@ bool LanguageTagParser::parse(JSContext*
   JS_TRY_VAR_OR_RETURN_FALSE(cx, ok, tryParse(cx, locale, tag));
   if (ok) {
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   if (UniqueChars localeChars =
           DuplicateString(cx, locale.data(), locale.size())) {
     JS_ReportErrorNumberUTF8(cx, GetErrorMessage, nullptr,
@@ -1404,7 +1404,7 @@ bool LanguageTagParser::parseBaseName(JS
   JS_TRY_VAR_OR_RETURN_FALSE(cx, ok, parseBaseName(cx, ts, tag, tok));
   if (ok) {
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   if (UniqueChars localeChars =
           DuplicateString(cx, locale.data(), locale.size())) {
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
@@ -1436,13 +1436,13 @@ JS::Result<bool> LanguageTagParser::pars
   LanguageTagParser ts(extensionChars, extension.size());
   Token tok = ts.nextToken();
 
-  if (!ts.isExtensionStart(tok) || ts.singletonKey(tok) != 't') {
+  if (!ts.isExtensionStart(tok) || ts.singletonKey(tok) != 't') {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   tok = ts.nextToken();
 
-  if (tok.isNone()) {
+  if (tok.isNone()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1472,7 +1472,7 @@ JS::Result<bool> LanguageTagParser::pars
     }
 
     // `tfield` requires at least one `tvalue`.
-    if (tok.index() <= startTValue) {
+    if (tok.index() <= startTValue) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1499,18 +1499,18 @@ JS::Result<bool> LanguageTagParser::pars
   // unicode_locale_extensions = sep [uU] ((sep keyword)+ |
   //                                       (sep attribute)+ (sep keyword)*) ;
 
-  if (!ts.isExtensionStart(tok) || ts.singletonKey(tok) != 'u') {
+  if (!ts.isExtensionStart(tok) || ts.singletonKey(tok) != 'u') {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   tok = ts.nextToken();
 
-  if (tok.isNone()) {
+  if (tok.isNone()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   while (ts.isUnicodeExtensionAttribute(tok)) {
-    if (!attributes.emplaceBack(tok.index(), tok.length())) {
+    if (!attributes.emplaceBack(tok.index(), tok.length())) {MOZ_RELEASE_ASSERT(0);
       return cx->alreadyReportedOOM();
     }
 
@@ -1526,7 +1526,7 @@ JS::Result<bool> LanguageTagParser::pars
       tok = ts.nextToken();
     }
 
-    if (tok.isError()) {
+    if (tok.isError()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1541,7 +1541,7 @@ JS::Result<bool> LanguageTagParser::pars
 }
 
 bool LanguageTagParser::canParseUnicodeExtension(
-    mozilla::Span<const char> extension) {
+    mozilla::Span<const char> extension) {MOZ_RELEASE_ASSERT(0);
   LocaleChars extensionChars = StringChars(extension.data());
   LanguageTagParser ts(extensionChars, extension.size());
   Token tok = ts.nextToken();
@@ -1549,25 +1549,25 @@ bool LanguageTagParser::canParseUnicodeE
   // unicode_locale_extensions = sep [uU] ((sep keyword)+ |
   //                                       (sep attribute)+ (sep keyword)*) ;
 
-  if (!ts.isExtensionStart(tok) || ts.singletonKey(tok) != 'u') {
+  if (!ts.isExtensionStart(tok) || ts.singletonKey(tok) != 'u') {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   tok = ts.nextToken();
 
-  if (tok.isNone()) {
+  if (tok.isNone()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  while (ts.isUnicodeExtensionAttribute(tok)) {
+  while (ts.isUnicodeExtensionAttribute(tok)) {MOZ_RELEASE_ASSERT(0);
     tok = ts.nextToken();
   }
 
   // keyword = key (sep type)? ;
-  while (ts.isUnicodeExtensionKey(tok)) {
+  while (ts.isUnicodeExtensionKey(tok)) {MOZ_RELEASE_ASSERT(0);
     tok = ts.nextToken();
 
-    while (ts.isUnicodeExtensionType(tok)) {
+    while (ts.isUnicodeExtensionType(tok)) {MOZ_RELEASE_ASSERT(0);
       tok = ts.nextToken();
     }
 
@@ -1704,7 +1704,7 @@ JS::Result<JSString*> ParseStandaloneISO
   if (str->hasLatin1Chars()) {
     JS::AutoCheckCannotGC nogc;
     languageTag.set<Latin1Char>(str->latin1Range(nogc));
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     JS::AutoCheckCannotGC nogc;
     languageTag.set<char16_t>(str->twoByteRange(nogc));
   }
diff --git a/js/src/builtin/intl/LanguageTagGenerated.cpp b/js/src/builtin/intl/LanguageTagGenerated.cpp
--- a/js/src/builtin/intl/LanguageTagGenerated.cpp
+++ b/js/src/builtin/intl/LanguageTagGenerated.cpp
@@ -368,11 +368,11 @@ void js::intl::LanguageTag::performCompl
   }
   else if (language().equalTo("drw") ||
            language().equalTo("prs") ||
-           language().equalTo("tnf")) {
+           language().equalTo("tnf")) {MOZ_RELEASE_ASSERT(0);
     setLanguage("fa");
-    if (region().missing()) {
+    if (region().missing()) {MOZ_RELEASE_ASSERT(0);
       setRegion("AF");
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
   else if (language().equalTo("hbs") ||
            language().equalTo("sh")) {
@@ -400,16 +400,16 @@ void js::intl::LanguageTag::performCompl
 
   if (region().equalTo("172")) {
     if (language().equalTo("hy") ||
-        (language().equalTo("und") && script().equalTo("Armn"))) {
+        (language().equalTo("und") && script().equalTo("Armn"))) {MOZ_RELEASE_ASSERT(0);
       setRegion("AM");
     }
     else if (language().equalTo("az") ||
              language().equalTo("tkr") ||
              language().equalTo("tly") ||
-             language().equalTo("ttt")) {
+             language().equalTo("ttt")) {MOZ_RELEASE_ASSERT(0);
       setRegion("AZ");
     }
-    else if (language().equalTo("be")) {
+    else if (language().equalTo("be")) {MOZ_RELEASE_ASSERT(0);
       setRegion("BY");
     }
     else if (language().equalTo("ab") ||
@@ -418,23 +418,23 @@ void js::intl::LanguageTag::performCompl
              language().equalTo("os") ||
              (language().equalTo("und") && script().equalTo("Geor")) ||
              (language().equalTo("und") && script().equalTo("Yezi")) ||
-             language().equalTo("xmf")) {
+             language().equalTo("xmf")) {MOZ_RELEASE_ASSERT(0);
       setRegion("GE");
     }
-    else if (language().equalTo("ky")) {
+    else if (language().equalTo("ky")) {MOZ_RELEASE_ASSERT(0);
       setRegion("KG");
     }
     else if (language().equalTo("kk") ||
-             (language().equalTo("ug") && script().equalTo("Cyrl"))) {
+             (language().equalTo("ug") && script().equalTo("Cyrl"))) {MOZ_RELEASE_ASSERT(0);
       setRegion("KZ");
     }
-    else if (language().equalTo("gag")) {
+    else if (language().equalTo("gag")) {MOZ_RELEASE_ASSERT(0);
       setRegion("MD");
     }
-    else if (language().equalTo("tg")) {
+    else if (language().equalTo("tg")) {MOZ_RELEASE_ASSERT(0);
       setRegion("TJ");
     }
-    else if (language().equalTo("tk")) {
+    else if (language().equalTo("tk")) {MOZ_RELEASE_ASSERT(0);
       setRegion("TM");
     }
     else if (language().equalTo("crh") ||
@@ -442,7 +442,7 @@ void js::intl::LanguageTag::performCompl
              language().equalTo("ji") ||
              language().equalTo("rue") ||
              language().equalTo("uk") ||
-             (language().equalTo("und") && script().equalTo("Goth"))) {
+             (language().equalTo("und") && script().equalTo("Goth"))) {MOZ_RELEASE_ASSERT(0);
       setRegion("UA");
     }
     else if (language().equalTo("kaa") ||
@@ -451,7 +451,7 @@ void js::intl::LanguageTag::performCompl
              (language().equalTo("und") && script().equalTo("Sogd")) ||
              (language().equalTo("und") && script().equalTo("Sogo")) ||
              language().equalTo("uz") ||
-             language().equalTo("xco")) {
+             language().equalTo("xco")) {MOZ_RELEASE_ASSERT(0);
       setRegion("UZ");
     }
     else {
@@ -459,22 +459,22 @@ void js::intl::LanguageTag::performCompl
     }
   }
   else if (region().equalTo("200")) {
-    if (language().equalTo("sk")) {
+    if (language().equalTo("sk")) {MOZ_RELEASE_ASSERT(0);
       setRegion("SK");
     }
-    else {
+    else {MOZ_RELEASE_ASSERT(0);
       setRegion("CZ");
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
   else if (region().equalTo("530") ||
            region().equalTo("532") ||
            region().equalTo("AN")) {
-    if (language().equalTo("vic")) {
+    if (language().equalTo("vic")) {MOZ_RELEASE_ASSERT(0);
       setRegion("SX");
     }
-    else {
+    else {MOZ_RELEASE_ASSERT(0);
       setRegion("CW");
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
   else if (region().equalTo("536") ||
            region().equalTo("NT")) {
@@ -485,7 +485,7 @@ void js::intl::LanguageTag::performCompl
         language().equalTo("syr") ||
         (language().equalTo("und") && script().equalTo("Hatr")) ||
         (language().equalTo("und") && script().equalTo("Syrc")) ||
-        (language().equalTo("und") && script().equalTo("Xsux"))) {
+        (language().equalTo("und") && script().equalTo("Xsux"))) {MOZ_RELEASE_ASSERT(0);
       setRegion("IQ");
     }
     else {
@@ -494,15 +494,15 @@ void js::intl::LanguageTag::performCompl
   }
   else if (region().equalTo("582") ||
            region().equalTo("PC")) {
-    if (language().equalTo("mh")) {
+    if (language().equalTo("mh")) {MOZ_RELEASE_ASSERT(0);
       setRegion("MH");
     }
-    else if (language().equalTo("pau")) {
+    else if (language().equalTo("pau")) {MOZ_RELEASE_ASSERT(0);
       setRegion("PW");
     }
-    else {
+    else {MOZ_RELEASE_ASSERT(0);
       setRegion("FM");
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
   else if (region().equalTo("810") ||
            region().equalTo("SU")) {
@@ -513,14 +513,14 @@ void js::intl::LanguageTag::performCompl
     else if (language().equalTo("az") ||
              language().equalTo("tkr") ||
              language().equalTo("tly") ||
-             language().equalTo("ttt")) {
+             language().equalTo("ttt")) {MOZ_RELEASE_ASSERT(0);
       setRegion("AZ");
     }
-    else if (language().equalTo("be")) {
+    else if (language().equalTo("be")) {MOZ_RELEASE_ASSERT(0);
       setRegion("BY");
     }
     else if (language().equalTo("et") ||
-             language().equalTo("vro")) {
+             language().equalTo("vro")) {MOZ_RELEASE_ASSERT(0);
       setRegion("EE");
     }
     else if (language().equalTo("ab") ||
@@ -529,31 +529,31 @@ void js::intl::LanguageTag::performCompl
              language().equalTo("os") ||
              (language().equalTo("und") && script().equalTo("Geor")) ||
              (language().equalTo("und") && script().equalTo("Yezi")) ||
-             language().equalTo("xmf")) {
+             language().equalTo("xmf")) {MOZ_RELEASE_ASSERT(0);
       setRegion("GE");
     }
-    else if (language().equalTo("ky")) {
+    else if (language().equalTo("ky")) {MOZ_RELEASE_ASSERT(0);
       setRegion("KG");
     }
     else if (language().equalTo("kk") ||
-             (language().equalTo("ug") && script().equalTo("Cyrl"))) {
+             (language().equalTo("ug") && script().equalTo("Cyrl"))) {MOZ_RELEASE_ASSERT(0);
       setRegion("KZ");
     }
     else if (language().equalTo("lt") ||
-             language().equalTo("sgs")) {
+             language().equalTo("sgs")) {MOZ_RELEASE_ASSERT(0);
       setRegion("LT");
     }
     else if (language().equalTo("ltg") ||
-             language().equalTo("lv")) {
+             language().equalTo("lv")) {MOZ_RELEASE_ASSERT(0);
       setRegion("LV");
     }
-    else if (language().equalTo("gag")) {
+    else if (language().equalTo("gag")) {MOZ_RELEASE_ASSERT(0);
       setRegion("MD");
     }
-    else if (language().equalTo("tg")) {
+    else if (language().equalTo("tg")) {MOZ_RELEASE_ASSERT(0);
       setRegion("TJ");
     }
-    else if (language().equalTo("tk")) {
+    else if (language().equalTo("tk")) {MOZ_RELEASE_ASSERT(0);
       setRegion("TM");
     }
     else if (language().equalTo("crh") ||
@@ -561,7 +561,7 @@ void js::intl::LanguageTag::performCompl
              language().equalTo("ji") ||
              language().equalTo("rue") ||
              language().equalTo("uk") ||
-             (language().equalTo("und") && script().equalTo("Goth"))) {
+             (language().equalTo("und") && script().equalTo("Goth"))) {MOZ_RELEASE_ASSERT(0);
       setRegion("UA");
     }
     else if (language().equalTo("kaa") ||
@@ -570,24 +570,24 @@ void js::intl::LanguageTag::performCompl
              (language().equalTo("und") && script().equalTo("Sogd")) ||
              (language().equalTo("und") && script().equalTo("Sogo")) ||
              language().equalTo("uz") ||
-             language().equalTo("xco")) {
+             language().equalTo("xco")) {MOZ_RELEASE_ASSERT(0);
       setRegion("UZ");
     }
     else {
       setRegion("RU");
     }
   }
-  else if (region().equalTo("890")) {
-    if (language().equalTo("bs")) {
+  else if (region().equalTo("890")) {MOZ_RELEASE_ASSERT(0);
+    if (language().equalTo("bs")) {MOZ_RELEASE_ASSERT(0);
       setRegion("BA");
     }
-    else if (language().equalTo("hr")) {
+    else if (language().equalTo("hr")) {MOZ_RELEASE_ASSERT(0);
       setRegion("HR");
     }
-    else if (language().equalTo("mk")) {
+    else if (language().equalTo("mk")) {MOZ_RELEASE_ASSERT(0);
       setRegion("MK");
     }
-    else if (language().equalTo("sl")) {
+    else if (language().equalTo("sl")) {MOZ_RELEASE_ASSERT(0);
       setRegion("SI");
     }
     else {
@@ -653,13 +653,13 @@ bool js::intl::LanguageTag::performVaria
     }
     else if (strcmp(variant.get(), "heploc") == 0) {
       variants_.erase(variants_.begin() + i);
-      if (!insertVariantSortedIfNotPresent("alalc97")) {
+      if (!insertVariantSortedIfNotPresent("alalc97")) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
     else if (strcmp(variant.get(), "polytoni") == 0) {
       variants_.erase(variants_.begin() + i);
-      if (!insertVariantSortedIfNotPresent("polyton")) {
+      if (!insertVariantSortedIfNotPresent("polyton")) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -728,7 +728,7 @@ bool js::intl::LanguageTag::updateGrandf
     clearVariants();
 
     auto privateuse = DuplicateString(cx, "x-cel-gaulish");
-    if (!privateuse) {
+    if (!privateuse) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     setPrivateuse(std::move(privateuse));
@@ -946,7 +946,7 @@ const char* js::intl::LanguageTag::repla
   MOZ_ASSERT(IsCanonicallyCasedTransformType(type));
 
   if (IsTransformKey(key, "d0")) {
-    if (IsTransformType(type, "name")) {
+    if (IsTransformType(type, "name")) {MOZ_RELEASE_ASSERT(0);
       return "charname";
     }
   }
diff --git a/js/src/builtin/intl/ListFormat.cpp b/js/src/builtin/intl/ListFormat.cpp
--- a/js/src/builtin/intl/ListFormat.cpp
+++ b/js/src/builtin/intl/ListFormat.cpp
@@ -142,13 +142,13 @@ static bool ListFormat(JSContext* cx, un
   // Step 2 (Inlined 9.1.14, OrdinaryCreateFromConstructor).
   RootedObject proto(cx);
   if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_ListFormat,
-                                          &proto)) {
+                                          &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Rooted<ListFormatObject*> listFormat(
       cx, NewObjectWithClassProto<ListFormatObject>(cx, proto));
-  if (!listFormat) {
+  if (!listFormat) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -191,29 +191,29 @@ void js::ListFormatObject::finalize(JSFr
 static UListFormatter* NewUListFormatter(JSContext* cx,
                                          Handle<ListFormatObject*> listFormat) {
   RootedObject internals(cx, intl::GetInternalsObject(cx, listFormat));
-  if (!internals) {
+  if (!internals) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedValue value(cx);
 
-  if (!GetProperty(cx, internals, internals, cx->names().locale, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().locale, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   UniqueChars locale = intl::EncodeLocale(cx, value.toString());
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   enum class ListFormatType { Conjunction, Disjunction, Unit };
 
   ListFormatType type;
-  if (!GetProperty(cx, internals, internals, cx->names().type, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().type, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   {
     JSLinearString* strType = value.toString()->ensureLinear(cx);
-    if (!strType) {
+    if (!strType) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -230,12 +230,12 @@ static UListFormatter* NewUListFormatter
   enum class ListFormatStyle { Long, Short, Narrow };
 
   ListFormatStyle style;
-  if (!GetProperty(cx, internals, internals, cx->names().style, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().style, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   {
     JSLinearString* strStyle = value.toString()->ensureLinear(cx);
-    if (!strStyle) {
+    if (!strStyle) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -343,7 +343,7 @@ static bool FormatListToParts(JSContext*
 
   UErrorCode status = U_ZERO_ERROR;
   UFormattedList* formatted = ulistfmt_openResult(&status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -352,26 +352,26 @@ static bool FormatListToParts(JSContext*
   ulistfmt_formatStringsToResult(
       lf, reinterpret_cast<char16_t* const*>(strings.begin()),
       stringLengths.begin(), int32_t(strings.length()), formatted, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
 
   const UFormattedValue* formattedValue =
       ulistfmt_resultAsValue(formatted, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
 
   RootedString overallResult(cx,
                              intl::FormattedValueToString(cx, formattedValue));
-  if (!overallResult) {
+  if (!overallResult) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedArrayObject partsArray(cx, NewDenseEmptyArray(cx));
-  if (!partsArray) {
+  if (!partsArray) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -412,7 +412,7 @@ static bool FormatListToParts(JSContext*
   };
 
   UConstrainedFieldPosition* fpos = ucfpos_open(&status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -421,14 +421,14 @@ static bool FormatListToParts(JSContext*
   // We're only interested in ULISTFMT_ELEMENT_FIELD fields.
   ucfpos_constrainField(fpos, UFIELD_CATEGORY_LIST, ULISTFMT_ELEMENT_FIELD,
                         &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
 
   while (true) {
     bool hasMore = ufmtval_nextPosition(formattedValue, fpos, &status);
-    if (U_FAILURE(status)) {
+    if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
       intl::ReportInternalError(cx);
       return false;
     }
@@ -438,7 +438,7 @@ static bool FormatListToParts(JSContext*
 
     int32_t beginIndexInt, endIndexInt;
     ucfpos_getIndexes(fpos, &beginIndexInt, &endIndexInt, &status);
-    if (U_FAILURE(status)) {
+    if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
       intl::ReportInternalError(cx);
       return false;
     }
@@ -457,18 +457,18 @@ static bool FormatListToParts(JSContext*
                "finish as expected");
 
     if (lastEndIndex < beginIndex) {
-      if (!AppendPart(&JSAtomState::literal, lastEndIndex, beginIndex)) {
+      if (!AppendPart(&JSAtomState::literal, lastEndIndex, beginIndex)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
 
-    if (!AppendPart(&JSAtomState::element, beginIndex, endIndex)) {
+    if (!AppendPart(&JSAtomState::element, beginIndex, endIndex)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // Append any final literal.
-  if (lastEndIndex < overallResult->length()) {
+  if (lastEndIndex < overallResult->length()) {MOZ_RELEASE_ASSERT(0);
     if (!AppendPart(&JSAtomState::literal, lastEndIndex,
                     overallResult->length())) {
       return false;
@@ -492,7 +492,7 @@ bool js::intl_FormatList(JSContext* cx, 
   UListFormatter* lf = listFormat->getListFormatter();
   if (!lf) {
     lf = NewUListFormatter(cx, listFormat);
-    if (!lf) {
+    if (!lf) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     listFormat->setListFormatter(lf);
@@ -511,28 +511,28 @@ bool js::intl_FormatList(JSContext* cx, 
   RootedValue value(cx);
   uint32_t listLen = list->length();
   for (uint32_t i = 0; i < listLen; i++) {
-    if (!GetElement(cx, list, list, i, &value)) {
+    if (!GetElement(cx, list, list, i, &value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     JSLinearString* linear = value.toString()->ensureLinear(cx);
-    if (!linear) {
+    if (!linear) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     size_t linearLength = linear->length();
-    if (!stringLengths.append(linearLength)) {
+    if (!stringLengths.append(linearLength)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     stringLengthTotal += linearLength;
 
     UniqueTwoByteChars chars = cx->make_pod_array<char16_t>(linearLength);
-    if (!chars) {
+    if (!chars) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     CopyChars(chars.get(), *linear);
 
-    if (!strings.append(std::move(chars))) {
+    if (!strings.append(std::move(chars))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -542,7 +542,7 @@ bool js::intl_FormatList(JSContext* cx, 
   stringLengthTotal += CheckedInt<int32_t>(listLen) * MaxConjunctionLen;
 
   // If the overestimate exceeds ICU length limits, don't try to format.
-  if (!stringLengthTotal.isValid()) {
+  if (!stringLengthTotal.isValid()) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return false;
   }
diff --git a/js/src/builtin/intl/Locale.cpp b/js/src/builtin/intl/Locale.cpp
--- a/js/src/builtin/intl/Locale.cpp
+++ b/js/src/builtin/intl/Locale.cpp
@@ -111,14 +111,14 @@ static mozilla::Maybe<IndexAndLength> Un
 static LocaleObject* CreateLocaleObject(JSContext* cx, HandleObject prototype,
                                         const LanguageTag& tag) {
   RootedString tagStr(cx, tag.toString(cx));
-  if (!tagStr) {
+  if (!tagStr) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   size_t baseNameLength = BaseNameLength(tag);
 
   RootedString baseName(cx, NewDependentString(cx, tagStr, 0, baseNameLength));
-  if (!baseName) {
+  if (!baseName) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -126,7 +126,7 @@ static LocaleObject* CreateLocaleObject(
   if (auto result = UnicodeExtensionPosition(tag)) {
     JSString* str = NewDependentString(
         cx, tagStr, baseNameLength + 1 + result->index, result->length);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -231,7 +231,7 @@ static bool GetStringOption(JSContext* c
 
     // Steps 2.c, 2.e.
     JSString* str = ToString(cx, option);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     linear = str->ensureLinear(cx);
@@ -374,7 +374,7 @@ bool js::intl::ApplyUnicodeExtensionToTa
   }
 
   Vector<char, 32> newExtension(cx);
-  if (!newExtension.append('u')) {
+  if (!newExtension.append('u')) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -382,7 +382,7 @@ bool js::intl::ApplyUnicodeExtensionToTa
 
   const char* unicodeExtensionEnd = nullptr;
   const char* unicodeExtensionKeywords = nullptr;
-  if (const char* unicodeExtension = tag.unicodeExtension()) {
+  if (const char* unicodeExtension = tag.unicodeExtension()) {MOZ_RELEASE_ASSERT(0);
     unicodeExtensionEnd = unicodeExtension + strlen(unicodeExtension);
 
     SepKeywordIterator<char> iter(unicodeExtension, unicodeExtensionEnd);
@@ -394,7 +394,7 @@ bool js::intl::ApplyUnicodeExtensionToTa
     const char* attributesEnd = unicodeExtensionKeywords
                                     ? unicodeExtensionKeywords
                                     : unicodeExtensionEnd;
-    if (!newExtension.append(unicodeExtension + 1, attributesEnd)) {
+    if (!newExtension.append(unicodeExtension + 1, attributesEnd)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -405,24 +405,24 @@ bool js::intl::ApplyUnicodeExtensionToTa
 
   for (const auto& keyword : keywords) {
     UnicodeExtensionKeyword::UnicodeKeySpan key = keyword.key();
-    if (!newExtension.append('-')) {
+    if (!newExtension.append('-')) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!newExtension.append(key.data(), key.size())) {
+    if (!newExtension.append(key.data(), key.size())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!newExtension.append('-')) {
+    if (!newExtension.append('-')) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     JS::AutoCheckCannotGC nogc;
     JSLinearString* type = keyword.type();
     if (type->hasLatin1Chars()) {
-      if (!newExtension.append(type->latin1Chars(nogc), type->length())) {
+      if (!newExtension.append(type->latin1Chars(nogc), type->length())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
-      if (!newExtension.append(type->twoByteChars(nogc), type->length())) {
+      if (!newExtension.append(type->twoByteChars(nogc), type->length())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -430,13 +430,13 @@ bool js::intl::ApplyUnicodeExtensionToTa
 
   // Append the remaining keywords from the previous Unicode extension subtag.
   if (unicodeExtensionKeywords) {
-    if (!newExtension.append(unicodeExtensionKeywords, unicodeExtensionEnd)) {
+    if (!newExtension.append(unicodeExtensionKeywords, unicodeExtensionEnd)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // Null-terminate the new Unicode extension string.
-  if (!newExtension.append('\0')) {
+  if (!newExtension.append('\0')) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -455,14 +455,14 @@ static JS::Result<JSString*> LanguageTag
   }
 
   JSObject* unwrapped = CheckedUnwrapStatic(obj);
-  if (!unwrapped) {
+  if (!unwrapped) {MOZ_RELEASE_ASSERT(0);
     ReportAccessDenied(cx);
     return cx->alreadyReportedError();
   }
 
   if (!unwrapped->is<LocaleObject>()) {
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedString tagStr(cx, unwrapped->as<LocaleObject>().languageTag());
   if (!cx->compartment()->wrap(cx, &tagStr)) {
@@ -484,7 +484,7 @@ static bool Locale(JSContext* cx, unsign
 
   // Steps 2-6 (Inlined 9.1.14, OrdinaryCreateFromConstructor).
   RootedObject proto(cx);
-  if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_Locale, &proto)) {
+  if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_Locale, &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -510,7 +510,7 @@ static bool Locale(JSContext* cx, unsign
   }
 
   RootedLinearString tagLinearStr(cx, tagStr->ensureLinear(cx));
-  if (!tagLinearStr) {
+  if (!tagLinearStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -559,7 +559,7 @@ static bool Locale(JSContext* cx, unsign
         return false;
       }
 
-      if (!keywords.emplaceBack("ca", calendar)) {
+      if (!keywords.emplaceBack("ca", calendar)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -581,7 +581,7 @@ static bool Locale(JSContext* cx, unsign
         return false;
       }
 
-      if (!keywords.emplaceBack("co", collation)) {
+      if (!keywords.emplaceBack("co", collation)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -606,7 +606,7 @@ static bool Locale(JSContext* cx, unsign
         return false;
       }
 
-      if (!keywords.emplaceBack("hc", hourCycle)) {
+      if (!keywords.emplaceBack("hc", hourCycle)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -630,7 +630,7 @@ static bool Locale(JSContext* cx, unsign
         return false;
       }
 
-      if (!keywords.emplaceBack("kf", caseFirst)) {
+      if (!keywords.emplaceBack("kf", caseFirst)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -643,7 +643,7 @@ static bool Locale(JSContext* cx, unsign
 
     // Step 26.
     if (numeric) {
-      if (!keywords.emplaceBack("kn", numeric)) {
+      if (!keywords.emplaceBack("kn", numeric)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -666,13 +666,13 @@ static bool Locale(JSContext* cx, unsign
         return false;
       }
 
-      if (!keywords.emplaceBack("nu", numberingSystem)) {
+      if (!keywords.emplaceBack("nu", numberingSystem)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
 
     // Step 30.
-    if (!ApplyUnicodeExtensionToTag(cx, tag, keywords)) {
+    if (!ApplyUnicodeExtensionToTag(cx, tag, keywords)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -764,14 +764,14 @@ static bool GetUnicodeExtension(JSContex
                                 UnicodeKey key, MutableHandleValue value) {
   // Return undefined when no Unicode extension subtag is present.
   const Value& unicodeExtensionValue = locale->unicodeExtension();
-  if (unicodeExtensionValue.isUndefined()) {
+  if (unicodeExtensionValue.isUndefined()) {MOZ_RELEASE_ASSERT(0);
     value.setUndefined();
     return true;
   }
 
   JSLinearString* unicodeExtension =
       unicodeExtensionValue.toString()->ensureLinear(cx);
-  if (!unicodeExtension) {
+  if (!unicodeExtension) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -875,16 +875,16 @@ static bool Locale_maximize(JSContext* c
   // Step 3.
   auto* locale = &args.thisv().toObject().as<LocaleObject>();
   RootedLinearString tagStr(cx, locale->languageTag()->ensureLinear(cx));
-  if (!tagStr) {
+  if (!tagStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   LanguageTag tag(cx);
-  if (!LanguageTagParser::parse(cx, tagStr, tag)) {
+  if (!LanguageTagParser::parse(cx, tagStr, tag)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!tag.addLikelySubtags(cx)) {
+  if (!tag.addLikelySubtags(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -911,16 +911,16 @@ static bool Locale_minimize(JSContext* c
   // Step 3.
   auto* locale = &args.thisv().toObject().as<LocaleObject>();
   RootedLinearString tagStr(cx, locale->languageTag()->ensureLinear(cx));
-  if (!tagStr) {
+  if (!tagStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   LanguageTag tag(cx);
-  if (!LanguageTagParser::parse(cx, tagStr, tag)) {
+  if (!LanguageTagParser::parse(cx, tagStr, tag)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!tag.removeLikelySubtags(cx)) {
+  if (!tag.removeLikelySubtags(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1090,7 +1090,7 @@ static bool Locale_language(JSContext* c
   // Step 3.
   auto* locale = &args.thisv().toObject().as<LocaleObject>();
   JSLinearString* baseName = locale->baseName()->ensureLinear(cx);
-  if (!baseName) {
+  if (!baseName) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1125,7 +1125,7 @@ static bool Locale_script(JSContext* cx,
   // Step 3.
   auto* locale = &args.thisv().toObject().as<LocaleObject>();
   JSLinearString* baseName = locale->baseName()->ensureLinear(cx);
-  if (!baseName) {
+  if (!baseName) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1166,7 +1166,7 @@ static bool Locale_region(JSContext* cx,
   // Step 3.
   auto* locale = &args.thisv().toObject().as<LocaleObject>();
   JSLinearString* baseName = locale->baseName()->ensureLinear(cx);
-  if (!baseName) {
+  if (!baseName) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1261,12 +1261,12 @@ bool js::intl_ValidateAndCanonicalizeLan
   }
 
   JSString* tagStr = ToString(cx, tagValue);
-  if (!tagStr) {
+  if (!tagStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedLinearString tagLinearStr(cx, tagStr->ensureLinear(cx));
-  if (!tagLinearStr) {
+  if (!tagLinearStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1301,14 +1301,14 @@ bool js::intl_ValidateAndCanonicalizeLan
 }
 
 bool js::intl_TryValidateAndCanonicalizeLanguageTag(JSContext* cx,
-                                                    unsigned argc, Value* vp) {
+                                                    unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
   MOZ_ASSERT(args.length() == 1);
 
   RootedLinearString linear(cx, args[0].toString()->ensureLinear(cx));
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   LanguageTag tag(cx);
   bool ok;
@@ -1316,14 +1316,14 @@ bool js::intl_TryValidateAndCanonicalize
                              LanguageTagParser::tryParse(cx, linear, tag));
 
   // The caller handles invalid inputs.
-  if (!ok) {
+  if (!ok) {MOZ_RELEASE_ASSERT(0);
     args.rval().setNull();
     return true;
   }
 
-  if (!tag.canonicalize(cx)) {
+  if (!tag.canonicalize(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   JSString* resultStr = tag.toString(cx);
   if (!resultStr) {
@@ -1349,18 +1349,18 @@ bool js::intl_ValidateAndCanonicalizeUni
   MOZ_ASSERT(keyArg.isString(), "key must be a string");
 
   RootedLinearString unicodeType(cx, typeArg.toString()->ensureLinear(cx));
-  if (!unicodeType) {
+  if (!unicodeType) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (!IsValidUnicodeExtensionValue(unicodeType)) {
     UniqueChars optionChars = EncodeAscii(cx, optionArg.toString());
-    if (!optionChars) {
+    if (!optionChars) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     UniqueChars unicodeTypeChars = QuoteString(cx, unicodeType, '"');
-    if (!unicodeTypeChars) {
+    if (!unicodeTypeChars) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1373,7 +1373,7 @@ bool js::intl_ValidateAndCanonicalizeUni
   char unicodeKey[UnicodeKeyLength];
   {
     JSLinearString* str = keyArg.toString()->ensureLinear(cx);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     MOZ_ASSERT(str->length() == UnicodeKeyLength);
@@ -1386,7 +1386,7 @@ bool js::intl_ValidateAndCanonicalizeUni
   }
 
   UniqueChars unicodeTypeChars = EncodeAscii(cx, unicodeType);
-  if (!unicodeTypeChars) {
+  if (!unicodeTypeChars) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/builtin/intl/NumberFormat.cpp b/js/src/builtin/intl/NumberFormat.cpp
--- a/js/src/builtin/intl/NumberFormat.cpp
+++ b/js/src/builtin/intl/NumberFormat.cpp
@@ -195,13 +195,13 @@ bool js::intl_numberingSystem(JSContext*
   MOZ_ASSERT(args[0].isString());
 
   UniqueChars locale = intl::EncodeLocale(cx, args[0].toString());
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   UErrorCode status = U_ZERO_ERROR;
   UNumberingSystem* numbers = unumsys_open(IcuLocale(locale.get()), &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -209,7 +209,7 @@ bool js::intl_numberingSystem(JSContext*
   ScopedICUObject<UNumberingSystem, unumsys_close> toClose(numbers);
 
   const char* name = unumsys_getName(numbers);
-  if (!name) {
+  if (!name) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -372,13 +372,13 @@ bool js::intl::NumberFormatterSkeleton::
     p[0] = '\0';
 
     auto& numerator = FindSimpleMeasureUnit(unitChars);
-    if (!append(u"measure-unit/") || !appendUnit(numerator) || !append(' ')) {
+    if (!append(u"measure-unit/") || !appendUnit(numerator) || !append(' ')) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     auto& denominator = FindSimpleMeasureUnit(p + strlen(separator));
     if (!append(u"per-measure-unit/") || !appendUnit(denominator) ||
-        !append(' ')) {
+        !append(' ')) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -493,11 +493,11 @@ static UNumberFormatter* NewUNumberForma
   RootedValue value(cx);
 
   RootedObject internals(cx, intl::GetInternalsObject(cx, numberFormat));
-  if (!internals) {
+  if (!internals) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!GetProperty(cx, internals, internals, cx->names().locale, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().locale, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -506,11 +506,11 @@ static UNumberFormatter* NewUNumberForma
   intl::LanguageTag tag(cx);
   {
     JSLinearString* locale = value.toString()->ensureLinear(cx);
-    if (!locale) {
+    if (!locale) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (!intl::LanguageTagParser::parse(cx, locale, tag)) {
+    if (!intl::LanguageTagParser::parse(cx, locale, tag)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -518,17 +518,17 @@ static UNumberFormatter* NewUNumberForma
   JS::RootedVector<intl::UnicodeExtensionKeyword> keywords(cx);
 
   if (!GetProperty(cx, internals, internals, cx->names().numberingSystem,
-                   &value)) {
+                   &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   {
     JSLinearString* numberingSystem = value.toString()->ensureLinear(cx);
-    if (!numberingSystem) {
+    if (!numberingSystem) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (!keywords.emplaceBack("nu", numberingSystem)) {
+    if (!keywords.emplaceBack("nu", numberingSystem)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -537,48 +537,48 @@ static UNumberFormatter* NewUNumberForma
   // the Unicode extension subtag. We're then relying on ICU to follow RFC
   // 6067, which states that any trailing keywords using the same key
   // should be ignored.
-  if (!intl::ApplyUnicodeExtensionToTag(cx, tag, keywords)) {
+  if (!intl::ApplyUnicodeExtensionToTag(cx, tag, keywords)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   UniqueChars locale = tag.toStringZ(cx);
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   intl::NumberFormatterSkeleton skeleton(cx);
 
-  if (!GetProperty(cx, internals, internals, cx->names().style, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().style, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   bool accountingSign = false;
   {
     JSLinearString* style = value.toString()->ensureLinear(cx);
-    if (!style) {
+    if (!style) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     if (StringEqualsLiteral(style, "currency")) {
       if (!GetProperty(cx, internals, internals, cx->names().currency,
-                       &value)) {
+                       &value)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       JSLinearString* currency = value.toString()->ensureLinear(cx);
-      if (!currency) {
+      if (!currency) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
-      if (!skeleton.currency(currency)) {
+      if (!skeleton.currency(currency)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
       if (!GetProperty(cx, internals, internals, cx->names().currencyDisplay,
-                       &value)) {
+                       &value)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       JSLinearString* currencyDisplay = value.toString()->ensureLinear(cx);
-      if (!currencyDisplay) {
+      if (!currencyDisplay) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -596,16 +596,16 @@ static UNumberFormatter* NewUNumberForma
         display = CurrencyDisplay::Name;
       }
 
-      if (!skeleton.currencyDisplay(display)) {
+      if (!skeleton.currencyDisplay(display)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
       if (!GetProperty(cx, internals, internals, cx->names().currencySign,
-                       &value)) {
+                       &value)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       JSLinearString* currencySign = value.toString()->ensureLinear(cx);
-      if (!currencySign) {
+      if (!currencySign) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -615,28 +615,28 @@ static UNumberFormatter* NewUNumberForma
         MOZ_ASSERT(StringEqualsLiteral(currencySign, "standard"));
       }
     } else if (StringEqualsLiteral(style, "percent")) {
-      if (!skeleton.percent()) {
+      if (!skeleton.percent()) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     } else if (StringEqualsLiteral(style, "unit")) {
-      if (!GetProperty(cx, internals, internals, cx->names().unit, &value)) {
+      if (!GetProperty(cx, internals, internals, cx->names().unit, &value)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       JSLinearString* unit = value.toString()->ensureLinear(cx);
-      if (!unit) {
+      if (!unit) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
-      if (!skeleton.unit(unit)) {
+      if (!skeleton.unit(unit)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
       if (!GetProperty(cx, internals, internals, cx->names().unitDisplay,
-                       &value)) {
+                       &value)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       JSLinearString* unitDisplay = value.toString()->ensureLinear(cx);
-      if (!unitDisplay) {
+      if (!unitDisplay) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -652,7 +652,7 @@ static UNumberFormatter* NewUNumberForma
         display = UnitDisplay::Long;
       }
 
-      if (!skeleton.unitDisplay(display)) {
+      if (!skeleton.unitDisplay(display)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     } else {
@@ -662,78 +662,78 @@ static UNumberFormatter* NewUNumberForma
 
   bool hasMinimumSignificantDigits;
   if (!HasProperty(cx, internals, cx->names().minimumSignificantDigits,
-                   &hasMinimumSignificantDigits)) {
+                   &hasMinimumSignificantDigits)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   if (hasMinimumSignificantDigits) {
     if (!GetProperty(cx, internals, internals,
-                     cx->names().minimumSignificantDigits, &value)) {
+                     cx->names().minimumSignificantDigits, &value)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     uint32_t minimumSignificantDigits = AssertedCast<uint32_t>(value.toInt32());
 
     if (!GetProperty(cx, internals, internals,
-                     cx->names().maximumSignificantDigits, &value)) {
+                     cx->names().maximumSignificantDigits, &value)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     uint32_t maximumSignificantDigits = AssertedCast<uint32_t>(value.toInt32());
 
     if (!skeleton.significantDigits(minimumSignificantDigits,
-                                    maximumSignificantDigits)) {
+                                    maximumSignificantDigits)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
 
   bool hasMinimumFractionDigits;
   if (!HasProperty(cx, internals, cx->names().minimumFractionDigits,
-                   &hasMinimumFractionDigits)) {
+                   &hasMinimumFractionDigits)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   if (hasMinimumFractionDigits) {
     if (!GetProperty(cx, internals, internals,
-                     cx->names().minimumFractionDigits, &value)) {
+                     cx->names().minimumFractionDigits, &value)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     uint32_t minimumFractionDigits = AssertedCast<uint32_t>(value.toInt32());
 
     if (!GetProperty(cx, internals, internals,
-                     cx->names().maximumFractionDigits, &value)) {
+                     cx->names().maximumFractionDigits, &value)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     uint32_t maximumFractionDigits = AssertedCast<uint32_t>(value.toInt32());
 
     if (!skeleton.fractionDigits(minimumFractionDigits,
-                                 maximumFractionDigits)) {
+                                 maximumFractionDigits)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
 
   if (!GetProperty(cx, internals, internals, cx->names().minimumIntegerDigits,
-                   &value)) {
+                   &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   uint32_t minimumIntegerDigits = AssertedCast<uint32_t>(value.toInt32());
 
-  if (!skeleton.integerWidth(minimumIntegerDigits)) {
+  if (!skeleton.integerWidth(minimumIntegerDigits)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!GetProperty(cx, internals, internals, cx->names().useGrouping, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().useGrouping, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
-  if (!skeleton.useGrouping(value.toBoolean())) {
+  if (!skeleton.useGrouping(value.toBoolean())) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!GetProperty(cx, internals, internals, cx->names().notation, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().notation, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   {
     JSLinearString* notation = value.toString()->ensureLinear(cx);
-    if (!notation) {
+    if (!notation) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -750,12 +750,12 @@ static UNumberFormatter* NewUNumberForma
       MOZ_ASSERT(StringEqualsLiteral(notation, "compact"));
 
       if (!GetProperty(cx, internals, internals, cx->names().compactDisplay,
-                       &value)) {
+                       &value)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
       JSLinearString* compactDisplay = value.toString()->ensureLinear(cx);
-      if (!compactDisplay) {
+      if (!compactDisplay) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -767,18 +767,18 @@ static UNumberFormatter* NewUNumberForma
       }
     }
 
-    if (!skeleton.notation(style)) {
+    if (!skeleton.notation(style)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
 
-  if (!GetProperty(cx, internals, internals, cx->names().signDisplay, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().signDisplay, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   {
     JSLinearString* signDisplay = value.toString()->ensureLinear(cx);
-    if (!signDisplay) {
+    if (!signDisplay) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -808,7 +808,7 @@ static UNumberFormatter* NewUNumberForma
       }
     }
 
-    if (!skeleton.signDisplay(display)) {
+    if (!skeleton.signDisplay(display)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -853,7 +853,7 @@ static const UFormattedValue* PartitionN
       unumf_formatInt(nf, num, formatted, &status);
     } else {
       JSLinearString* str = BigInt::toString<CanGC>(cx, bi, 10);
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       MOZ_ASSERT(str->hasLatin1Chars());
@@ -865,7 +865,7 @@ static const UFormattedValue* PartitionN
       unumf_formatDecimal(nf, chars, str->length(), formatted, &status);
     }
   }
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return nullptr;
   }
@@ -897,7 +897,7 @@ static bool FormatNumeric(JSContext* cx,
                           MutableHandleValue result) {
   const UFormattedValue* formattedValue =
       PartitionNumberPattern(cx, nf, formatted, x);
-  if (!formattedValue) {
+  if (!formattedValue) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1038,7 +1038,7 @@ ArrayObject* NumberFormatFields::toArray
   // Merge sort the fields vector.  Expand the vector to have scratch space for
   // performing the sort.
   size_t fieldsLen = fields_.length();
-  if (!fields_.growByUninitialized(fieldsLen)) {
+  if (!fields_.growByUninitialized(fieldsLen)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1206,7 +1206,7 @@ ArrayObject* NumberFormatFields::toArray
         // enclosing field.  (If there are no nested fields, don't
         // bother pushing a field that'd be immediately popped.)
         if (current->end > next->begin) {
-          if (!enclosingFields.append(index - 1)) {
+          if (!enclosingFields.append(index - 1)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -1246,7 +1246,7 @@ ArrayObject* NumberFormatFields::toArray
         return true;
       }
 
-      if (!nextPartInternal(part)) {
+      if (!nextPartInternal(part)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -1262,7 +1262,7 @@ ArrayObject* NumberFormatFields::toArray
   RootedValue propVal(cx);
 
   RootedArrayObject partsArray(cx, NewDenseEmptyArray(cx));
-  if (!partsArray) {
+  if (!partsArray) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1270,7 +1270,7 @@ ArrayObject* NumberFormatFields::toArray
   do {
     bool hasPart;
     Part part;
-    if (!gen.nextPart(&hasPart, &part)) {
+    if (!gen.nextPart(&hasPart, &part)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1284,29 +1284,29 @@ ArrayObject* NumberFormatFields::toArray
     MOZ_ASSERT(lastEndIndex < endIndex);
 
     singlePart = NewBuiltinClassInstance<PlainObject>(cx);
-    if (!singlePart) {
+    if (!singlePart) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     propVal.setString(cx->names().*type);
-    if (!DefineDataProperty(cx, singlePart, cx->names().type, propVal)) {
+    if (!DefineDataProperty(cx, singlePart, cx->names().type, propVal)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     JSLinearString* partSubstr = NewDependentString(
         cx, overallResult, lastEndIndex, endIndex - lastEndIndex);
-    if (!partSubstr) {
+    if (!partSubstr) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     propVal.setString(partSubstr);
-    if (!DefineDataProperty(cx, singlePart, cx->names().value, propVal)) {
+    if (!DefineDataProperty(cx, singlePart, cx->names().value, propVal)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     if (unitType != nullptr && type != &JSAtomState::literal) {
       propVal.setString(cx->names().*unitType);
-      if (!DefineDataProperty(cx, singlePart, cx->names().unit, propVal)) {
+      if (!DefineDataProperty(cx, singlePart, cx->names().unit, propVal)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -1333,13 +1333,13 @@ static bool FormattedNumberToParts(JSCon
   MOZ_ASSERT(number.isNumeric());
 
   RootedString overallResult(cx, FormattedNumberToString(cx, formattedValue));
-  if (!overallResult) {
+  if (!overallResult) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   UErrorCode status = U_ZERO_ERROR;
   UConstrainedFieldPosition* fpos = ucfpos_open(&status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -1347,7 +1347,7 @@ static bool FormattedNumberToParts(JSCon
 
   // We're only interested in UFIELD_CATEGORY_NUMBER fields.
   ucfpos_constrainCategory(fpos, UFIELD_CATEGORY_NUMBER, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -1358,7 +1358,7 @@ static bool FormattedNumberToParts(JSCon
 
   while (true) {
     bool hasMore = ufmtval_nextPosition(formattedValue, fpos, &status);
-    if (U_FAILURE(status)) {
+    if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
       intl::ReportInternalError(cx);
       return false;
     }
@@ -1367,14 +1367,14 @@ static bool FormattedNumberToParts(JSCon
     }
 
     int32_t field = ucfpos_getField(fpos, &status);
-    if (U_FAILURE(status)) {
+    if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
       intl::ReportInternalError(cx);
       return false;
     }
 
     int32_t beginIndex, endIndex;
     ucfpos_getIndexes(fpos, &beginIndex, &endIndex, &status);
-    if (U_FAILURE(status)) {
+    if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
       intl::ReportInternalError(cx);
       return false;
     }
@@ -1382,7 +1382,7 @@ static bool FormattedNumberToParts(JSCon
     FieldType type = GetFieldTypeForNumberField(UNumberFormatFields(field),
                                                 number, formattingType);
 
-    if (!fields.append(type, beginIndex, endIndex)) {
+    if (!fields.append(type, beginIndex, endIndex)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1434,7 +1434,7 @@ bool js::intl_FormatNumber(JSContext* cx
   UNumberFormatter* nf = numberFormat->getNumberFormatter();
   if (!nf) {
     nf = NewUNumberFormatter(cx, numberFormat);
-    if (!nf) {
+    if (!nf) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     numberFormat->setNumberFormatter(nf);
@@ -1447,7 +1447,7 @@ bool js::intl_FormatNumber(JSContext* cx
   UFormattedNumber* formatted = numberFormat->getFormattedNumber();
   if (!formatted) {
     formatted = NewUFormattedNumber(cx);
-    if (!formatted) {
+    if (!formatted) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     numberFormat->setFormattedNumber(formatted);
diff --git a/js/src/builtin/intl/PluralRules.cpp b/js/src/builtin/intl/PluralRules.cpp
--- a/js/src/builtin/intl/PluralRules.cpp
+++ b/js/src/builtin/intl/PluralRules.cpp
@@ -116,7 +116,7 @@ static bool PluralRules(JSContext* cx, u
 
   Rooted<PluralRulesObject*> pluralRules(cx);
   pluralRules = NewObjectWithClassProto<PluralRulesObject>(cx, proto);
-  if (!pluralRules) {
+  if (!pluralRules) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -174,17 +174,17 @@ void js::PluralRulesObject::finalize(JSF
 static UNumberFormatter* NewUNumberFormatterForPluralRules(
     JSContext* cx, Handle<PluralRulesObject*> pluralRules) {
   RootedObject internals(cx, intl::GetInternalsObject(cx, pluralRules));
-  if (!internals) {
+  if (!internals) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedValue value(cx);
 
-  if (!GetProperty(cx, internals, internals, cx->names().locale, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().locale, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   UniqueChars locale = intl::EncodeLocale(cx, value.toString());
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -192,53 +192,53 @@ static UNumberFormatter* NewUNumberForma
 
   bool hasMinimumSignificantDigits;
   if (!HasProperty(cx, internals, cx->names().minimumSignificantDigits,
-                   &hasMinimumSignificantDigits)) {
+                   &hasMinimumSignificantDigits)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (hasMinimumSignificantDigits) {
+  if (hasMinimumSignificantDigits) {MOZ_RELEASE_ASSERT(0);
     if (!GetProperty(cx, internals, internals,
-                     cx->names().minimumSignificantDigits, &value)) {
+                     cx->names().minimumSignificantDigits, &value)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     uint32_t minimumSignificantDigits = AssertedCast<uint32_t>(value.toInt32());
 
     if (!GetProperty(cx, internals, internals,
-                     cx->names().maximumSignificantDigits, &value)) {
+                     cx->names().maximumSignificantDigits, &value)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     uint32_t maximumSignificantDigits = AssertedCast<uint32_t>(value.toInt32());
 
     if (!skeleton.significantDigits(minimumSignificantDigits,
-                                    maximumSignificantDigits)) {
+                                    maximumSignificantDigits)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
     if (!GetProperty(cx, internals, internals,
-                     cx->names().minimumFractionDigits, &value)) {
+                     cx->names().minimumFractionDigits, &value)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     uint32_t minimumFractionDigits = AssertedCast<uint32_t>(value.toInt32());
 
     if (!GetProperty(cx, internals, internals,
-                     cx->names().maximumFractionDigits, &value)) {
+                     cx->names().maximumFractionDigits, &value)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     uint32_t maximumFractionDigits = AssertedCast<uint32_t>(value.toInt32());
 
     if (!skeleton.fractionDigits(minimumFractionDigits,
-                                 maximumFractionDigits)) {
+                                 maximumFractionDigits)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
 
   if (!GetProperty(cx, internals, internals, cx->names().minimumIntegerDigits,
-                   &value)) {
+                   &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   uint32_t minimumIntegerDigits = AssertedCast<uint32_t>(value.toInt32());
 
-  if (!skeleton.integerWidth(minimumIntegerDigits)) {
+  if (!skeleton.integerWidth(minimumIntegerDigits)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -266,28 +266,28 @@ static UFormattedNumber* NewUFormattedNu
 static UPluralRules* NewUPluralRules(JSContext* cx,
                                      Handle<PluralRulesObject*> pluralRules) {
   RootedObject internals(cx, intl::GetInternalsObject(cx, pluralRules));
-  if (!internals) {
+  if (!internals) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedValue value(cx);
 
-  if (!GetProperty(cx, internals, internals, cx->names().locale, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().locale, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   UniqueChars locale = intl::EncodeLocale(cx, value.toString());
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!GetProperty(cx, internals, internals, cx->names().type, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().type, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   UPluralType category;
   {
     JSLinearString* type = value.toString()->ensureLinear(cx);
-    if (!type) {
+    if (!type) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -322,7 +322,7 @@ bool js::intl_SelectPluralRule(JSContext
   UPluralRules* pr = pluralRules->getPluralRules();
   if (!pr) {
     pr = NewUPluralRules(cx, pluralRules);
-    if (!pr) {
+    if (!pr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     pluralRules->setPluralRules(pr);
@@ -335,7 +335,7 @@ bool js::intl_SelectPluralRule(JSContext
   UNumberFormatter* nf = pluralRules->getNumberFormatter();
   if (!nf) {
     nf = NewUNumberFormatterForPluralRules(cx, pluralRules);
-    if (!nf) {
+    if (!nf) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     pluralRules->setNumberFormatter(nf);
@@ -348,7 +348,7 @@ bool js::intl_SelectPluralRule(JSContext
   UFormattedNumber* formatted = pluralRules->getFormattedNumber();
   if (!formatted) {
     formatted = NewUFormattedNumberForPluralRules(cx);
-    if (!formatted) {
+    if (!formatted) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     pluralRules->setFormattedNumber(formatted);
@@ -358,7 +358,7 @@ bool js::intl_SelectPluralRule(JSContext
 
   UErrorCode status = U_ZERO_ERROR;
   unumf_formatDouble(nf, x, formatted, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -386,7 +386,7 @@ bool js::intl_GetPluralCategories(JSCont
   UPluralRules* pr = pluralRules->getPluralRules();
   if (!pr) {
     pr = NewUPluralRules(cx, pluralRules);
-    if (!pr) {
+    if (!pr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     pluralRules->setPluralRules(pr);
@@ -397,21 +397,21 @@ bool js::intl_GetPluralCategories(JSCont
 
   UErrorCode status = U_ZERO_ERROR;
   UEnumeration* ue = uplrules_getKeywords(pr, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
   ScopedICUObject<UEnumeration, uenum_close> closeEnum(ue);
 
   RootedObject res(cx, NewDenseEmptyArray(cx));
-  if (!res) {
+  if (!res) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   do {
     int32_t catSize;
     const char* cat = uenum_next(ue, &catSize, &status);
-    if (U_FAILURE(status)) {
+    if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
       intl::ReportInternalError(cx);
       return false;
     }
@@ -422,7 +422,7 @@ bool js::intl_GetPluralCategories(JSCont
 
     MOZ_ASSERT(catSize >= 0);
     JSString* str = NewStringCopyN<CanGC>(cx, cat, catSize);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
diff --git a/js/src/builtin/intl/RelativeTimeFormat.cpp b/js/src/builtin/intl/RelativeTimeFormat.cpp
--- a/js/src/builtin/intl/RelativeTimeFormat.cpp
+++ b/js/src/builtin/intl/RelativeTimeFormat.cpp
@@ -121,7 +121,7 @@ static bool RelativeTimeFormat(JSContext
   Rooted<RelativeTimeFormatObject*> relativeTimeFormat(cx);
   relativeTimeFormat =
       NewObjectWithClassProto<RelativeTimeFormatObject>(cx, proto);
-  if (!relativeTimeFormat) {
+  if (!relativeTimeFormat) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -158,13 +158,13 @@ void js::RelativeTimeFormatObject::final
 static URelativeDateTimeFormatter* NewURelativeDateTimeFormatter(
     JSContext* cx, Handle<RelativeTimeFormatObject*> relativeTimeFormat) {
   RootedObject internals(cx, intl::GetInternalsObject(cx, relativeTimeFormat));
-  if (!internals) {
+  if (!internals) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedValue value(cx);
 
-  if (!GetProperty(cx, internals, internals, cx->names().locale, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().locale, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -173,11 +173,11 @@ static URelativeDateTimeFormatter* NewUR
   intl::LanguageTag tag(cx);
   {
     JSLinearString* locale = value.toString()->ensureLinear(cx);
-    if (!locale) {
+    if (!locale) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (!intl::LanguageTagParser::parse(cx, locale, tag)) {
+    if (!intl::LanguageTagParser::parse(cx, locale, tag)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -185,17 +185,17 @@ static URelativeDateTimeFormatter* NewUR
   JS::RootedVector<intl::UnicodeExtensionKeyword> keywords(cx);
 
   if (!GetProperty(cx, internals, internals, cx->names().numberingSystem,
-                   &value)) {
+                   &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   {
     JSLinearString* numberingSystem = value.toString()->ensureLinear(cx);
-    if (!numberingSystem) {
+    if (!numberingSystem) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (!keywords.emplaceBack("nu", numberingSystem)) {
+    if (!keywords.emplaceBack("nu", numberingSystem)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -204,23 +204,23 @@ static URelativeDateTimeFormatter* NewUR
   // Unicode extension subtag. We're then relying on ICU to follow RFC 6067,
   // which states that any trailing keywords using the same key should be
   // ignored.
-  if (!intl::ApplyUnicodeExtensionToTag(cx, tag, keywords)) {
+  if (!intl::ApplyUnicodeExtensionToTag(cx, tag, keywords)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   UniqueChars locale = tag.toStringZ(cx);
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!GetProperty(cx, internals, internals, cx->names().style, &value)) {
+  if (!GetProperty(cx, internals, internals, cx->names().style, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   UDateRelativeDateTimeFormatterStyle relDateTimeStyle;
   {
     JSLinearString* style = value.toString()->ensureLinear(cx);
-    if (!style) {
+    if (!style) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -237,7 +237,7 @@ static URelativeDateTimeFormatter* NewUR
   UErrorCode status = U_ZERO_ERROR;
   UNumberFormat* nf = unum_open(UNUM_DECIMAL, nullptr, 0,
                                 IcuLocale(locale.get()), nullptr, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return nullptr;
   }
@@ -314,7 +314,7 @@ static bool intl_FormatToPartsRelativeTi
                                            MutableHandleValue result) {
   UErrorCode status = U_ZERO_ERROR;
   UFormattedRelativeDateTime* formatted = ureldatefmt_openResult(&status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -326,14 +326,14 @@ static bool intl_FormatToPartsRelativeTi
   } else {
     ureldatefmt_formatNumericToResult(rtf, t, unit, formatted, &status);
   }
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
 
   const UFormattedValue* formattedValue =
       ureldatefmt_resultAsValue(formatted, &status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return false;
   }
@@ -395,7 +395,7 @@ bool js::intl_FormatRelativeTime(JSConte
       relativeTimeFormat->getRelativeDateTimeFormatter();
   if (!rtf) {
     rtf = NewURelativeDateTimeFormatter(cx, relativeTimeFormat);
-    if (!rtf) {
+    if (!rtf) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     relativeTimeFormat->setRelativeDateTimeFormatter(rtf);
@@ -407,7 +407,7 @@ bool js::intl_FormatRelativeTime(JSConte
   URelativeDateTimeUnit relDateTimeUnit;
   {
     JSLinearString* unit = args[2].toString()->ensureLinear(cx);
-    if (!unit) {
+    if (!unit) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -449,7 +449,7 @@ bool js::intl_FormatRelativeTime(JSConte
   RelativeTimeNumeric relDateTimeNumeric;
   {
     JSLinearString* numeric = args[3].toString()->ensureLinear(cx);
-    if (!numeric) {
+    if (!numeric) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
diff --git a/js/src/builtin/intl/SharedIntlData.cpp b/js/src/builtin/intl/SharedIntlData.cpp
--- a/js/src/builtin/intl/SharedIntlData.cpp
+++ b/js/src/builtin/intl/SharedIntlData.cpp
@@ -83,7 +83,7 @@ static bool EqualCharsIgnoreCaseASCII(co
 
 bool js::intl::SharedIntlData::TimeZoneHasher::match(TimeZoneName key,
                                                      const Lookup& lookup) {
-  if (key->length() != lookup.length) {
+  if (key->length() != lookup.length) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -93,10 +93,10 @@ bool js::intl::SharedIntlData::TimeZoneH
     if (lookup.isLatin1) {
       return EqualCharsIgnoreCaseASCII(keyChars, lookup.latin1Chars,
                                        lookup.length);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return EqualCharsIgnoreCaseASCII(keyChars, lookup.twoByteChars,
                                      lookup.length);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   const char16_t* keyChars = key->twoByteChars(lookup.nogc);
   if (lookup.isLatin1) {
@@ -127,7 +127,7 @@ bool js::intl::SharedIntlData::ensureTim
 
   UErrorCode status = U_ZERO_ERROR;
   UEnumeration* values = ucal_openTimeZones(&status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     ReportInternalError(cx);
     return false;
   }
@@ -137,7 +137,7 @@ bool js::intl::SharedIntlData::ensureTim
   while (true) {
     int32_t size;
     const char* rawTimeZone = uenum_next(values, &size, &status);
-    if (U_FAILURE(status)) {
+    if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
       ReportInternalError(cx);
       return false;
     }
@@ -153,7 +153,7 @@ bool js::intl::SharedIntlData::ensureTim
 
     MOZ_ASSERT(size >= 0);
     timeZone = Atomize(cx, rawTimeZone, size_t(size));
-    if (!timeZone) {
+    if (!timeZone) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -162,7 +162,7 @@ bool js::intl::SharedIntlData::ensureTim
 
     // ICU shouldn't report any duplicate time zone names, but if it does,
     // just ignore the duplicate name.
-    if (!p && !availableTimeZones.add(p, timeZone)) {
+    if (!p && !availableTimeZones.add(p, timeZone)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
@@ -173,7 +173,7 @@ bool js::intl::SharedIntlData::ensureTim
   for (const char* rawTimeZone : timezone::ianaZonesTreatedAsLinksByICU) {
     MOZ_ASSERT(rawTimeZone != nullptr);
     timeZone = Atomize(cx, rawTimeZone, strlen(rawTimeZone));
-    if (!timeZone) {
+    if (!timeZone) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -181,7 +181,7 @@ bool js::intl::SharedIntlData::ensureTim
     TimeZoneSet::AddPtr p = ianaZonesTreatedAsLinksByICU.lookupForAdd(lookup);
     MOZ_ASSERT(!p, "Duplicate entry in timezone::ianaZonesTreatedAsLinksByICU");
 
-    if (!ianaZonesTreatedAsLinksByICU.add(p, timeZone)) {
+    if (!ianaZonesTreatedAsLinksByICU.add(p, timeZone)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
@@ -198,13 +198,13 @@ bool js::intl::SharedIntlData::ensureTim
 
     MOZ_ASSERT(rawLinkName != nullptr);
     linkName = Atomize(cx, rawLinkName, strlen(rawLinkName));
-    if (!linkName) {
+    if (!linkName) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     MOZ_ASSERT(rawTarget != nullptr);
     target = Atomize(cx, rawTarget, strlen(rawTarget));
-    if (!target) {
+    if (!target) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -231,12 +231,12 @@ bool js::intl::SharedIntlData::ensureTim
 bool js::intl::SharedIntlData::validateTimeZoneName(JSContext* cx,
                                                     HandleString timeZone,
                                                     MutableHandleAtom result) {
-  if (!ensureTimeZones(cx)) {
+  if (!ensureTimeZones(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedLinearString timeZoneLinear(cx, timeZone->ensureLinear(cx));
-  if (!timeZoneLinear) {
+  if (!timeZoneLinear) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -250,12 +250,12 @@ bool js::intl::SharedIntlData::validateT
 
 bool js::intl::SharedIntlData::tryCanonicalizeTimeZoneConsistentWithIANA(
     JSContext* cx, HandleString timeZone, MutableHandleAtom result) {
-  if (!ensureTimeZones(cx)) {
+  if (!ensureTimeZones(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedLinearString timeZoneLinear(cx, timeZone->ensureLinear(cx));
-  if (!timeZoneLinear) {
+  if (!timeZoneLinear) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -300,7 +300,7 @@ js::intl::SharedIntlData::LocaleHasher::
 
 bool js::intl::SharedIntlData::LocaleHasher::match(Locale key,
                                                    const Lookup& lookup) {
-  if (key->length() != lookup.length) {
+  if (key->length() != lookup.length) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -308,9 +308,9 @@ bool js::intl::SharedIntlData::LocaleHas
     const Latin1Char* keyChars = key->latin1Chars(lookup.nogc);
     if (lookup.isLatin1) {
       return EqualChars(keyChars, lookup.latin1Chars, lookup.length);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return EqualChars(keyChars, lookup.twoByteChars, lookup.length);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   const char16_t* keyChars = key->twoByteChars(lookup.nogc);
   if (lookup.isLatin1) {
@@ -349,13 +349,13 @@ bool js::intl::SharedIntlData::getAvaila
     size_t length = strlen(locale);
 
     lang.clear();
-    if (!lang.append(locale, length)) {
+    if (!lang.append(locale, length)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     std::replace(lang.begin(), lang.end(), '_', '-');
 
-    if (!addLocale(lang.begin(), length)) {
+    if (!addLocale(lang.begin(), length)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -373,7 +373,7 @@ bool js::intl::SharedIntlData::getAvaila
 
     LocaleHasher::Lookup lookup(modernStyle, strlen(modernStyle));
     if (locales.has(lookup)) {
-      if (!addLocale(oldStyle, strlen(oldStyle))) {
+      if (!addLocale(oldStyle, strlen(oldStyle))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -431,7 +431,7 @@ bool js::intl::SharedIntlData::ensureSup
   collatorSupportedLocales.clearAndCompact();
 
   if (!getAvailableLocales(cx, supportedLocales, uloc_countAvailable,
-                           uloc_getAvailable)) {
+                           uloc_getAvailable)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!getAvailableLocales(cx, collatorSupportedLocales, ucol_countAvailable,
@@ -456,12 +456,12 @@ bool js::intl::SharedIntlData::isSupport
                                                  SupportedLocaleKind kind,
                                                  HandleString locale,
                                                  bool* supported) {
-  if (!ensureSupportedLocales(cx)) {
+  if (!ensureSupportedLocales(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedLinearString localeLinear(cx, locale->ensureLinear(cx));
-  if (!localeLinear) {
+  if (!localeLinear) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -614,7 +614,7 @@ js::intl::SharedIntlData::getDateTimePat
 
   UErrorCode status = U_ZERO_ERROR;
   UniqueUDateTimePatternGenerator gen(udatpg_open(IcuLocale(locale), &status));
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     intl::ReportInternalError(cx);
     return nullptr;
   }
diff --git a/js/src/builtin/streams/MiscellaneousOperations.cpp b/js/src/builtin/streams/MiscellaneousOperations.cpp
--- a/js/src/builtin/streams/MiscellaneousOperations.cpp
+++ b/js/src/builtin/streams/MiscellaneousOperations.cpp
@@ -142,7 +142,7 @@ using JS::Value;
 [[nodiscard]] bool js::ValidateAndNormalizeHighWaterMark(
     JSContext* cx, Handle<Value> highWaterMarkVal, double* highWaterMark) {
   // Step 1: Set highWaterMark to ? ToNumber(highWaterMark).
-  if (!ToNumber(cx, highWaterMarkVal, highWaterMark)) {
+  if (!ToNumber(cx, highWaterMarkVal, highWaterMark)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/builtin/streams/PipeToState.cpp b/js/src/builtin/streams/PipeToState.cpp
--- a/js/src/builtin/streams/PipeToState.cpp
+++ b/js/src/builtin/streams/PipeToState.cpp
@@ -96,23 +96,23 @@ static bool WritableAndNotClosing(const 
 }
 
 [[nodiscard]] static bool Finalize(JSContext* cx, Handle<PipeToState*> state,
-                                   Handle<Maybe<Value>> error) {
+                                   Handle<Maybe<Value>> error) {MOZ_RELEASE_ASSERT(0);
   cx->check(state);
   cx->check(error);
 
   // Step 1: Perform ! WritableStreamDefaultWriterRelease(writer).
   Rooted<WritableStreamDefaultWriter*> writer(cx, state->writer());
   cx->check(writer);
-  if (!WritableStreamDefaultWriterRelease(cx, writer)) {
+  if (!WritableStreamDefaultWriterRelease(cx, writer)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Step 2: Perform ! ReadableStreamReaderGenericRelease(reader).
   Rooted<ReadableStreamDefaultReader*> reader(cx, state->reader());
   cx->check(reader);
-  if (!ReadableStreamReaderGenericRelease(cx, reader)) {
+  if (!ReadableStreamReaderGenericRelease(cx, reader)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Step 3: If signal is not undefined, remove abortAlgorithm from signal.
   // XXX
@@ -130,7 +130,7 @@ static bool WritableAndNotClosing(const 
   return PromiseObject::resolve(cx, promise, UndefinedHandleValue);
 }
 
-[[nodiscard]] static bool Finalize(JSContext* cx, unsigned argc, Value* vp) {
+[[nodiscard]] static bool Finalize(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
   Rooted<PipeToState*> state(cx, TargetFromHandler<PipeToState>(args));
@@ -138,9 +138,9 @@ static bool WritableAndNotClosing(const 
 
   Rooted<Maybe<Value>> optionalError(cx, Nothing());
   if (Value maybeError = ExtraValueFromHandler(args);
-      !maybeError.isMagic(JS_READABLESTREAM_PIPETO_FINALIZE_WITHOUT_ERROR)) {
+      !maybeError.isMagic(JS_READABLESTREAM_PIPETO_FINALIZE_WITHOUT_ERROR)) {MOZ_RELEASE_ASSERT(0);
     optionalError = Some(maybeError);
-  }
+  }MOZ_RELEASE_ASSERT(0);
   cx->check(optionalError);
 
   if (!Finalize(cx, state, optionalError)) {
@@ -158,7 +158,7 @@ static bool WritableAndNotClosing(const 
 //   f. Upon rejection of p with reason newError, finalize with newError.
 [[nodiscard]] static bool ActAndFinalize(JSContext* cx,
                                          Handle<PipeToState*> state,
-                                         Handle<Maybe<Value>> error) {
+                                         Handle<Maybe<Value>> error) {MOZ_RELEASE_ASSERT(0);
   // Step d: Let p be the result of performing action.
   Rooted<JSObject*> p(cx);
   switch (state->shutdownAction()) {
@@ -246,22 +246,22 @@ static bool WritableAndNotClosing(const 
       break;
     }
   }
-  if (!p) {
+  if (!p) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Step e: Upon fulfillment of p, finalize, passing along originalError if it
   //         was given.
   Rooted<JSFunction*> onFulfilled(cx);
-  {
+  {MOZ_RELEASE_ASSERT(0);
     Rooted<Value> optionalError(
         cx, error.isSome()
                 ? *error.get()
                 : MagicValue(JS_READABLESTREAM_PIPETO_FINALIZE_WITHOUT_ERROR));
     onFulfilled = NewHandlerWithExtraValue(cx, Finalize, state, optionalError);
-    if (!onFulfilled) {
+    if (!onFulfilled) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   // Step f: Upon rejection of p with reason newError, finalize with newError.
@@ -290,7 +290,7 @@ static bool WritableAndNotClosing(const 
 }
 
 [[nodiscard]] static bool ActAndFinalize(JSContext* cx, unsigned argc,
-                                         Value* vp) {
+                                         Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
   Rooted<PipeToState*> state(cx, TargetFromHandler<PipeToState>(args));
@@ -298,9 +298,9 @@ static bool WritableAndNotClosing(const 
 
   Rooted<Maybe<Value>> optionalError(cx, Nothing());
   if (Value maybeError = ExtraValueFromHandler(args);
-      !maybeError.isMagic(JS_READABLESTREAM_PIPETO_FINALIZE_WITHOUT_ERROR)) {
+      !maybeError.isMagic(JS_READABLESTREAM_PIPETO_FINALIZE_WITHOUT_ERROR)) {MOZ_RELEASE_ASSERT(0);
     optionalError = Some(maybeError);
-  }
+  }MOZ_RELEASE_ASSERT(0);
   cx->check(optionalError);
 
   if (!ActAndFinalize(cx, state, optionalError)) {
@@ -315,14 +315,14 @@ static bool WritableAndNotClosing(const 
 // with an action action, optionally with an error originalError, then:
 [[nodiscard]] static bool ShutdownWithAction(
     JSContext* cx, Handle<PipeToState*> state,
-    PipeToState::ShutdownAction action, Handle<Maybe<Value>> originalError) {
+    PipeToState::ShutdownAction action, Handle<Maybe<Value>> originalError) {MOZ_RELEASE_ASSERT(0);
   cx->check(state);
   cx->check(originalError);
 
   // Step a: If shuttingDown is true, abort these substeps.
-  if (state->shuttingDown()) {
+  if (state->shuttingDown()) {MOZ_RELEASE_ASSERT(0);
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Step b: Set shuttingDown to true.
   state->setShuttingDown();
@@ -333,10 +333,10 @@ static bool WritableAndNotClosing(const 
   // Step c: If dest.[[state]] is "writable" and
   //         ! WritableStreamCloseQueuedOrInFlight(dest) is false,
   WritableStream* unwrappedDest = GetUnwrappedDest(cx, state);
-  if (!unwrappedDest) {
+  if (!unwrappedDest) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (WritableAndNotClosing(unwrappedDest)) {
+  if (WritableAndNotClosing(unwrappedDest)) {MOZ_RELEASE_ASSERT(0);
     // Step c.i:  If any chunks have been read but not yet written, write them
     //            to dest.
     //
@@ -348,7 +348,7 @@ static bool WritableAndNotClosing(const 
 
     // Step c.ii: Wait until every chunk that has been read has been written
     //            (i.e. the corresponding promises have settled).
-    if (PromiseObject* p = state->lastWriteRequest()) {
+    if (PromiseObject* p = state->lastWriteRequest()) {MOZ_RELEASE_ASSERT(0);
       Rooted<PromiseObject*> lastWriteRequest(cx, p);
 
       Rooted<Value> extra(
@@ -381,14 +381,14 @@ static bool WritableAndNotClosing(const 
 // Shutdown: if any of the above requirements or steps ask to shutdown,
 // optionally with an error error, then:
 [[nodiscard]] static bool Shutdown(JSContext* cx, Handle<PipeToState*> state,
-                                   Handle<Maybe<Value>> error) {
+                                   Handle<Maybe<Value>> error) {MOZ_RELEASE_ASSERT(0);
   cx->check(state);
   cx->check(error);
 
   // Step a: If shuttingDown is true, abort these substeps.
-  if (state->shuttingDown()) {
+  if (state->shuttingDown()) {MOZ_RELEASE_ASSERT(0);
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Step b: Set shuttingDown to true.
   state->setShuttingDown();
@@ -396,10 +396,10 @@ static bool WritableAndNotClosing(const 
   // Step c: If dest.[[state]] is "writable" and
   //         ! WritableStreamCloseQueuedOrInFlight(dest) is false,
   WritableStream* unwrappedDest = GetUnwrappedDest(cx, state);
-  if (!unwrappedDest) {
+  if (!unwrappedDest) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (WritableAndNotClosing(unwrappedDest)) {
+  if (WritableAndNotClosing(unwrappedDest)) {MOZ_RELEASE_ASSERT(0);
     // Step 1: If any chunks have been read but not yet written, write them to
     //         dest.
     //
@@ -411,7 +411,7 @@ static bool WritableAndNotClosing(const 
 
     // Step 2: Wait until every chunk that has been read has been written
     //         (i.e. the corresponding promises have settled).
-    if (PromiseObject* p = state->lastWriteRequest()) {
+    if (PromiseObject* p = state->lastWriteRequest()) {MOZ_RELEASE_ASSERT(0);
       Rooted<PromiseObject*> lastWriteRequest(cx, p);
 
       Rooted<Value> extra(
@@ -444,11 +444,11 @@ static bool WritableAndNotClosing(const 
  */
 [[nodiscard]] static bool OnSourceErrored(
     JSContext* cx, Handle<PipeToState*> state,
-    Handle<ReadableStream*> unwrappedSource) {
+    Handle<ReadableStream*> unwrappedSource) {MOZ_RELEASE_ASSERT(0);
   cx->check(state);
 
   Rooted<Maybe<Value>> storedError(cx, Some(unwrappedSource->storedError()));
-  if (!cx->compartment()->wrap(cx, &storedError)) {
+  if (!cx->compartment()->wrap(cx, &storedError)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -485,15 +485,15 @@ static bool WritableAndNotClosing(const 
 
   // ii. Otherwise (if preventAbort is true), shutdown with
   //     source.[[storedError]].
-  if (state->preventAbort()) {
-    if (!Shutdown(cx, state, storedError)) {
+  if (state->preventAbort()) {MOZ_RELEASE_ASSERT(0);
+    if (!Shutdown(cx, state, storedError)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
   // i. (If preventAbort is false,) shutdown with an action of
   //    ! WritableStreamAbort(dest, source.[[storedError]]) and with
   //    source.[[storedError]].
-  else {
+  else {MOZ_RELEASE_ASSERT(0);
     if (!ShutdownWithAction(cx, state,
                             PipeToState::ShutdownAction::AbortDestStream,
                             storedError)) {
@@ -511,11 +511,11 @@ static bool WritableAndNotClosing(const 
  */
 [[nodiscard]] static bool OnDestErrored(JSContext* cx,
                                         Handle<PipeToState*> state,
-                                        Handle<WritableStream*> unwrappedDest) {
+                                        Handle<WritableStream*> unwrappedDest) {MOZ_RELEASE_ASSERT(0);
   cx->check(state);
 
   Rooted<Maybe<Value>> storedError(cx, Some(unwrappedDest->storedError()));
-  if (!cx->compartment()->wrap(cx, &storedError)) {
+  if (!cx->compartment()->wrap(cx, &storedError)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -529,15 +529,15 @@ static bool WritableAndNotClosing(const 
 
   // ii. Otherwise (if preventCancel is true), shutdown with
   //     dest.[[storedError]].
-  if (state->preventCancel()) {
-    if (!Shutdown(cx, state, storedError)) {
+  if (state->preventCancel()) {MOZ_RELEASE_ASSERT(0);
+    if (!Shutdown(cx, state, storedError)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
   // i. If preventCancel is false, shutdown with an action of
   //    ! ReadableStreamCancel(source, dest.[[storedError]]) and with
   //    dest.[[storedError]].
-  else {
+  else {MOZ_RELEASE_ASSERT(0);
     if (!ShutdownWithAction(cx, state,
                             PipeToState::ShutdownAction::CancelSource,
                             storedError)) {
@@ -554,7 +554,7 @@ static bool WritableAndNotClosing(const 
  * 'closed', then..."
  */
 [[nodiscard]] static bool OnSourceClosed(JSContext* cx,
-                                         Handle<PipeToState*> state) {
+                                         Handle<PipeToState*> state) {MOZ_RELEASE_ASSERT(0);
   cx->check(state);
 
   Rooted<Maybe<Value>> noError(cx, Nothing());
@@ -567,14 +567,14 @@ static bool WritableAndNotClosing(const 
   // read is in progress.
 
   // ii. Otherwise (if preventClose is true), shutdown.
-  if (state->preventClose()) {
-    if (!Shutdown(cx, state, noError)) {
+  if (state->preventClose()) {MOZ_RELEASE_ASSERT(0);
+    if (!Shutdown(cx, state, noError)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
   // i. If preventClose is false, shutdown with an action of
   //    ! WritableStreamDefaultWriterCloseWithErrorPropagation(writer).
-  else {
+  else {MOZ_RELEASE_ASSERT(0);
     if (!ShutdownWithAction(
             cx, state,
             PipeToState::ShutdownAction::CloseWriterWithErrorPropagation,
@@ -593,7 +593,7 @@ static bool WritableAndNotClosing(const 
  * 'closed', then..."
  */
 [[nodiscard]] static bool OnDestClosed(JSContext* cx,
-                                       Handle<PipeToState*> state) {
+                                       Handle<PipeToState*> state) {MOZ_RELEASE_ASSERT(0);
   cx->check(state);
 
   // i. Assert: no chunks have been read or written.
@@ -610,13 +610,13 @@ static bool WritableAndNotClosing(const 
 
   // ii. Let destClosed be a new TypeError.
   Rooted<Maybe<Value>> destClosed(cx, Nothing());
-  {
+  {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_WRITABLESTREAM_WRITE_CLOSING_OR_CLOSED);
     Rooted<Value> v(cx);
-    if (!cx->isExceptionPending() || !GetAndClearException(cx, &v)) {
+    if (!cx->isExceptionPending() || !GetAndClearException(cx, &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     destClosed = Some(v.get());
   }
@@ -634,14 +634,14 @@ static bool WritableAndNotClosing(const 
   // ensure shutdown only occurs once, so we need not do anything special here.
 
   // iv. Otherwise (if preventCancel is true), shutdown with destClosed.
-  if (state->preventCancel()) {
-    if (!Shutdown(cx, state, destClosed)) {
+  if (state->preventCancel()) {MOZ_RELEASE_ASSERT(0);
+    if (!Shutdown(cx, state, destClosed)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
   // iii. If preventCancel is false, shutdown with an action of
   //      ! ReadableStreamCancel(source, destClosed) and with destClosed.
-  else {
+  else {MOZ_RELEASE_ASSERT(0);
     if (!ShutdownWithAction(
             cx, state, PipeToState::ShutdownAction::CancelSource, destClosed)) {
       return false;
@@ -660,28 +660,28 @@ static bool WritableAndNotClosing(const 
 [[nodiscard]] static bool SourceOrDestErroredOrClosed(
     JSContext* cx, Handle<PipeToState*> state,
     Handle<ReadableStream*> unwrappedSource,
-    Handle<WritableStream*> unwrappedDest, bool* erroredOrClosed) {
+    Handle<WritableStream*> unwrappedDest, bool* erroredOrClosed) {MOZ_RELEASE_ASSERT(0);
   cx->check(state);
 
   *erroredOrClosed = true;
 
   // a. Errors must be propagated forward: if source.[[state]] is or becomes
   //    "errored", then
-  if (unwrappedSource->errored()) {
+  if (unwrappedSource->errored()) {MOZ_RELEASE_ASSERT(0);
     return OnSourceErrored(cx, state, unwrappedSource);
   }
 
   // b. Errors must be propagated backward: if dest.[[state]] is or becomes
   //    "errored", then
-  if (unwrappedDest->errored()) {
+  if (unwrappedDest->errored()) {MOZ_RELEASE_ASSERT(0);
     return OnDestErrored(cx, state, unwrappedDest);
   }
 
   // c. Closing must be propagated forward: if source.[[state]] is or becomes
   //    "closed", then
-  if (unwrappedSource->closed()) {
+  if (unwrappedSource->closed()) {MOZ_RELEASE_ASSERT(0);
     return OnSourceClosed(cx, state);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // d. Closing must be propagated backward: if
   //    ! WritableStreamCloseQueuedOrInFlight(dest) is true or dest.[[state]] is
@@ -696,7 +696,7 @@ static bool WritableAndNotClosing(const 
 }
 
 [[nodiscard]] static bool OnSourceClosed(JSContext* cx, unsigned argc,
-                                         Value* vp) {
+                                         Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
   Rooted<PipeToState*> state(cx, TargetFromHandler<PipeToState>(args));
@@ -711,14 +711,14 @@ static bool WritableAndNotClosing(const 
 }
 
 [[nodiscard]] static bool OnSourceErrored(JSContext* cx, unsigned argc,
-                                          Value* vp) {
+                                          Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
   Rooted<PipeToState*> state(cx, TargetFromHandler<PipeToState>(args));
   cx->check(state);
 
   Rooted<ReadableStream*> unwrappedSource(cx, GetUnwrappedSource(cx, state));
-  if (!unwrappedSource) {
+  if (!unwrappedSource) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -731,7 +731,7 @@ static bool WritableAndNotClosing(const 
 }
 
 [[nodiscard]] static bool OnDestClosed(JSContext* cx, unsigned argc,
-                                       Value* vp) {
+                                       Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
   Rooted<PipeToState*> state(cx, TargetFromHandler<PipeToState>(args));
@@ -746,14 +746,14 @@ static bool WritableAndNotClosing(const 
 }
 
 [[nodiscard]] static bool OnDestErrored(JSContext* cx, unsigned argc,
-                                        Value* vp) {
+                                        Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
   Rooted<PipeToState*> state(cx, TargetFromHandler<PipeToState>(args));
   cx->check(state);
 
   Rooted<WritableStream*> unwrappedDest(cx, GetUnwrappedDest(cx, state));
-  if (!unwrappedDest) {
+  if (!unwrappedDest) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -768,7 +768,7 @@ static bool WritableAndNotClosing(const 
 template <class StreamAccessor, class Stream>
 static inline JSObject* GetClosedPromise(
     JSContext* cx, Handle<Stream*> unwrappedStream,
-    StreamAccessor* (&unwrapAccessorFromStream)(JSContext*, Handle<Stream*>)) {
+    StreamAccessor* (&unwrapAccessorFromStream)(JSContext*, Handle<Stream*>)) {MOZ_RELEASE_ASSERT(0);
   StreamAccessor* unwrappedAccessor =
       unwrapAccessorFromStream(cx, unwrappedStream);
   if (!unwrappedAccessor) {
@@ -782,7 +782,7 @@ static inline JSObject* GetClosedPromise
                                          Handle<PipeToState*> state);
 
 static bool ReadFulfilled(JSContext* cx, Handle<PipeToState*> state,
-                          Handle<JSObject*> result) {
+                          Handle<JSObject*> result) {MOZ_RELEASE_ASSERT(0);
   cx->check(state);
   cx->check(result);
 
@@ -805,38 +805,38 @@ static bool ReadFulfilled(JSContext* cx,
   // shutdown algorithm has already been invoked.  So we check for shutdown here
   // in case of asynchronous closure/error and abort if shutdown has already
   // started (and possibly finished).
-  if (state->shuttingDown()) {
+  if (state->shuttingDown()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
-  {
+  {MOZ_RELEASE_ASSERT(0);
     bool done;
-    {
+    {MOZ_RELEASE_ASSERT(0);
       Rooted<Value> doneVal(cx);
-      if (!GetProperty(cx, result, result, cx->names().done, &doneVal)) {
+      if (!GetProperty(cx, result, result, cx->names().done, &doneVal)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       done = doneVal.toBoolean();
     }
 
-    if (done) {
+    if (done) {MOZ_RELEASE_ASSERT(0);
       // All chunks have been read from |reader| and written to |writer| (but
       // not necessarily fulfilled yet, in the latter case).  Proceed as if
       // |source| is now closed.  (This will asynchronously wait until any
       // pending writes have fulfilled.)
       return OnSourceClosed(cx, state);
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   // A chunk was read, and *at the time the read was requested*, |dest| was
   // ready to accept a write.  (Only one read is processed at a time per
   // |state->hasPendingRead()|, so this condition remains true now.)  Write the
   // chunk to |dest|.
-  {
+  {MOZ_RELEASE_ASSERT(0);
     Rooted<Value> chunk(cx);
-    if (!GetProperty(cx, result, result, cx->names().value, &chunk)) {
+    if (!GetProperty(cx, result, result, cx->names().value, &chunk)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     Rooted<WritableStreamDefaultWriter*> writer(cx, state->writer());
     cx->check(writer);
@@ -860,7 +860,7 @@ static bool ReadFulfilled(JSContext* cx,
   return ReadFromSource(cx, state);
 }
 
-static bool ReadFulfilled(JSContext* cx, unsigned argc, Value* vp) {
+static bool ReadFulfilled(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
   MOZ_ASSERT(args.length() == 1);
 
@@ -881,7 +881,7 @@ static bool ReadFulfilled(JSContext* cx,
 static bool ReadFromSource(JSContext* cx, unsigned argc, Value* vp);
 
 [[nodiscard]] static bool ReadFromSource(JSContext* cx,
-                                         Handle<PipeToState*> state) {
+                                         Handle<PipeToState*> state) {MOZ_RELEASE_ASSERT(0);
   cx->check(state);
 
   MOZ_ASSERT(!state->hasPendingRead(),
@@ -891,9 +891,9 @@ static bool ReadFromSource(JSContext* cx
 
   // "Shutdown must stop activity: if shuttingDown becomes true, the user agent
   // must not initiate further reads from reader..."
-  if (state->shuttingDown()) {
+  if (state->shuttingDown()) {MOZ_RELEASE_ASSERT(0);
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   Rooted<WritableStreamDefaultWriter*> writer(cx, state->writer());
   cx->check(writer);
@@ -901,14 +901,14 @@ static bool ReadFromSource(JSContext* cx
   // "While WritableStreamDefaultWriterGetDesiredSize(writer) is ≤ 0 or is null,
   // the user agent must not read from reader."
   Rooted<Value> desiredSize(cx);
-  if (!WritableStreamDefaultWriterGetDesiredSize(cx, writer, &desiredSize)) {
+  if (!WritableStreamDefaultWriterGetDesiredSize(cx, writer, &desiredSize)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // If we're in the middle of erroring or are fully errored, either way the
   // |dest|-closed reaction queued up in |StartPiping| will do the right
   // thing, so do nothing here.
-  if (desiredSize.isNull()) {
+  if (desiredSize.isNull()) {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
     {
       WritableStream* unwrappedDest = GetUnwrappedDest(cx, state);
@@ -917,24 +917,24 @@ static bool ReadFromSource(JSContext* cx
       }
 
       MOZ_ASSERT(unwrappedDest->erroring() || unwrappedDest->errored());
-    }
+    }MOZ_RELEASE_ASSERT(0);
 #endif
 
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // If |dest| isn't ready to receive writes yet (i.e. backpressure applies),
   // resume when it is.
   MOZ_ASSERT(desiredSize.isNumber());
-  if (desiredSize.toNumber() <= 0) {
+  if (desiredSize.toNumber() <= 0) {MOZ_RELEASE_ASSERT(0);
     Rooted<JSObject*> readyPromise(cx, writer->readyPromise());
     cx->check(readyPromise);
 
     Rooted<JSFunction*> readFromSource(cx,
                                        NewHandler(cx, ReadFromSource, state));
-    if (!readFromSource) {
+    if (!readFromSource) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Resume when there's writable capacity.  Don't bother handling rejection:
     // if this happens, the stream is going to be errored shortly anyway, and
@@ -945,7 +945,7 @@ static bool ReadFromSource(JSContext* cx
     //     rejection of [[closedPromise]].
     return JS::AddPromiseReactionsIgnoringUnhandledRejection(
         cx, readyPromise, readFromSource, nullptr);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // |dest| is ready to receive at least one write.  Read one chunk from the
   // reader now that we're not subject to backpressure.
@@ -954,12 +954,12 @@ static bool ReadFromSource(JSContext* cx
 
   Rooted<PromiseObject*> readRequest(
       cx, js::ReadableStreamDefaultReaderRead(cx, reader));
-  if (!readRequest) {
+  if (!readRequest) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   Rooted<JSFunction*> readFulfilled(cx, NewHandler(cx, ReadFulfilled, state));
-  if (!readFulfilled) {
+  if (!readFulfilled) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -992,7 +992,7 @@ static bool ReadFromSource(JSContext* cx
   Rooted<JSFunction*> readRejected(cx, NewHandler(cx, ReadRejected, state));
   if (!readRejected) {
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 #else
   auto readRejected = nullptr;
 #endif
@@ -1020,7 +1020,7 @@ static bool ReadFromSource(JSContext* cx
   return true;
 }
 
-static bool ReadFromSource(JSContext* cx, unsigned argc, Value* vp) {
+static bool ReadFromSource(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
   Rooted<PipeToState*> state(cx, TargetFromHandler<PipeToState>(args));
@@ -1036,7 +1036,7 @@ static bool ReadFromSource(JSContext* cx
 
 [[nodiscard]] static bool StartPiping(JSContext* cx, Handle<PipeToState*> state,
                                       Handle<ReadableStream*> unwrappedSource,
-                                      Handle<WritableStream*> unwrappedDest) {
+                                      Handle<WritableStream*> unwrappedDest) {MOZ_RELEASE_ASSERT(0);
   cx->check(state);
 
   // "Shutdown must stop activity: if shuttingDown becomes true, the user agent
@@ -1050,16 +1050,16 @@ static bool ReadFromSource(JSContext* cx
   // or closed manually.
   bool erroredOrClosed;
   if (!SourceOrDestErroredOrClosed(cx, state, unwrappedSource, unwrappedDest,
-                                   &erroredOrClosed)) {
+                                   &erroredOrClosed)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (erroredOrClosed) {
+  if (erroredOrClosed) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   // *After* piping has started, add reactions to respond to source/dest
   // becoming errored or closed.
-  {
+  {MOZ_RELEASE_ASSERT(0);
     Rooted<JSObject*> unwrappedClosedPromise(cx);
     Rooted<JSObject*> onClosed(cx);
     Rooted<JSObject*> onErrored(cx);
@@ -1083,17 +1083,17 @@ static bool ReadFromSource(JSContext* cx
 
     unwrappedClosedPromise =
         GetClosedPromise(cx, unwrappedSource, UnwrapReaderFromStream);
-    if (!unwrappedClosedPromise) {
+    if (!unwrappedClosedPromise) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!ReactWhenClosedOrErrored(cx, OnSourceClosed, OnSourceErrored)) {
+    if (!ReactWhenClosedOrErrored(cx, OnSourceClosed, OnSourceErrored)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     unwrappedClosedPromise =
         GetClosedPromise(cx, unwrappedDest, UnwrapWriterFromStream);
-    if (!unwrappedClosedPromise) {
+    if (!unwrappedClosedPromise) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1147,23 +1147,23 @@ static bool ReadFromSource(JSContext* cx
     JSContext* cx, Handle<PromiseObject*> promise,
     Handle<ReadableStream*> unwrappedSource,
     Handle<WritableStream*> unwrappedDest, bool preventClose, bool preventAbort,
-    bool preventCancel, Handle<JSObject*> signal) {
+    bool preventCancel, Handle<JSObject*> signal) {MOZ_RELEASE_ASSERT(0);
   cx->check(promise);
   cx->check(signal);
 
   Rooted<PipeToState*> state(cx,
                              NewTenuredBuiltinClassInstance<PipeToState>(cx));
-  if (!state) {
+  if (!state) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Step 4. Assert: signal is undefined or signal is an instance of the
   //         AbortSignal interface.
   MOZ_ASSERT(state->getFixedSlot(Slot_Signal).isUndefined());
-  if (signal) {
+  if (signal) {MOZ_RELEASE_ASSERT(0);
     // |signal| is double-checked to be an |AbortSignal| further down.
     state->initFixedSlot(Slot_Signal, ObjectValue(*signal));
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Step 5: Assert: ! IsReadableStreamLocked(source) is false.
   MOZ_ASSERT(!unwrappedSource->locked());
@@ -1182,28 +1182,28 @@ static bool ReadFromSource(JSContext* cx
   // Step 8: Otherwise, let reader be
   //         ! AcquireReadableStreamDefaultReader(source).
   // We don't implement byte streams, so we always acquire a default reader.
-  {
+  {MOZ_RELEASE_ASSERT(0);
     ReadableStreamDefaultReader* reader = CreateReadableStreamDefaultReader(
         cx, unwrappedSource, ForAuthorCodeBool::No);
-    if (!reader) {
+    if (!reader) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     MOZ_ASSERT(state->getFixedSlot(Slot_Reader).isUndefined());
     state->initFixedSlot(Slot_Reader, ObjectValue(*reader));
   }
 
   // Step 9: Let writer be ! AcquireWritableStreamDefaultWriter(dest).
-  {
+  {MOZ_RELEASE_ASSERT(0);
     WritableStreamDefaultWriter* writer =
         CreateWritableStreamDefaultWriter(cx, unwrappedDest);
-    if (!writer) {
+    if (!writer) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     MOZ_ASSERT(state->getFixedSlot(Slot_Writer).isUndefined());
     state->initFixedSlot(Slot_Writer, ObjectValue(*writer));
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Step 10: Set source.[[disturbed]] to true.
   unwrappedSource->setDisturbed();
@@ -1222,17 +1222,17 @@ static bool ReadFromSource(JSContext* cx
   // XXX This used to be step 13 but is now step 14, all the step-comments of
   //     the overall algorithm need renumbering.
   // Step 13: If signal is not undefined,
-  if (signal) {
+  if (signal) {MOZ_RELEASE_ASSERT(0);
     // Step 14.2: If signal’s aborted flag is set, perform abortAlgorithm and
     //         return promise.
     bool aborted;
-    {
+    {MOZ_RELEASE_ASSERT(0);
       // Sadly, we can't assert |signal| is an |AbortSignal| here because it
       // could have become a nuked CCW since it was type-checked.
       JSObject* unwrappedSignal = UnwrapSignalFromPipeToState(cx, state);
-      if (!unwrappedSignal) {
+      if (!unwrappedSignal) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       JSRuntime* rt = cx->runtime();
       MOZ_ASSERT(unwrappedSignal->hasClass(rt->maybeAbortSignalClass()));
@@ -1240,15 +1240,15 @@ static bool ReadFromSource(JSContext* cx
       AutoRealm ar(cx, unwrappedSignal);
       aborted = rt->abortSignalIsAborted(unwrappedSignal);
     }
-    if (aborted) {
-      if (!PerformAbortAlgorithm(cx, state)) {
+    if (aborted) {MOZ_RELEASE_ASSERT(0);
+      if (!PerformAbortAlgorithm(cx, state)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       // Returning |state| here will cause |promise| to be returned by the
       // overall algorithm.
       return state;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Step 14.3: Add abortAlgorithm to signal.
     // XXX jwalden need JSAPI to add an algorithm/steps to an AbortSignal
diff --git a/js/src/builtin/streams/PullIntoDescriptor.cpp b/js/src/builtin/streams/PullIntoDescriptor.cpp
--- a/js/src/builtin/streams/PullIntoDescriptor.cpp
+++ b/js/src/builtin/streams/PullIntoDescriptor.cpp
@@ -26,7 +26,7 @@ using JS::Rooted;
 /* static */ PullIntoDescriptor* PullIntoDescriptor::create(
     JSContext* cx, Handle<ArrayBufferObject*> buffer, uint32_t byteOffset,
     uint32_t byteLength, uint32_t bytesFilled, uint32_t elementSize,
-    Handle<JSObject*> ctor, ReaderType readerType) {
+    Handle<JSObject*> ctor, ReaderType readerType) {MOZ_RELEASE_ASSERT(0);
   Rooted<PullIntoDescriptor*> descriptor(
       cx, NewBuiltinClassInstance<PullIntoDescriptor>(cx));
   if (!descriptor) {
diff --git a/js/src/builtin/streams/QueueWithSizes.cpp b/js/src/builtin/streams/QueueWithSizes.cpp
--- a/js/src/builtin/streams/QueueWithSizes.cpp
+++ b/js/src/builtin/streams/QueueWithSizes.cpp
@@ -116,7 +116,7 @@ void js::DequeueValue(StreamController* 
   //         slots (implicit).
   // Step 2: Let size be ? ToNumber(size).
   double size;
-  if (!ToNumber(cx, sizeVal, &size)) {
+  if (!ToNumber(cx, sizeVal, &size)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -134,7 +134,7 @@ void js::DequeueValue(StreamController* 
     AutoRealm ar(cx, unwrappedContainer);
     Rooted<ListObject*> unwrappedQueue(cx, unwrappedContainer->queue());
     Rooted<Value> wrappedVal(cx, value);
-    if (!cx->compartment()->wrap(cx, &wrappedVal)) {
+    if (!cx->compartment()->wrap(cx, &wrappedVal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
diff --git a/js/src/builtin/streams/QueueingStrategies.cpp b/js/src/builtin/streams/QueueingStrategies.cpp
--- a/js/src/builtin/streams/QueueingStrategies.cpp
+++ b/js/src/builtin/streams/QueueingStrategies.cpp
@@ -45,19 +45,19 @@ bool js::ByteLengthQueuingStrategy::cons
                                                 Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (!ThrowIfNotConstructing(cx, args, "ByteLengthQueuingStrategy")) {
+  if (!ThrowIfNotConstructing(cx, args, "ByteLengthQueuingStrategy")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Implicit in the spec: Create the new strategy object.
   Rooted<JSObject*> proto(cx);
   if (!GetPrototypeFromBuiltinConstructor(
-          cx, args, JSProto_ByteLengthQueuingStrategy, &proto)) {
+          cx, args, JSProto_ByteLengthQueuingStrategy, &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   Rooted<ByteLengthQueuingStrategy*> strategy(
       cx, NewObjectWithClassProto<ByteLengthQueuingStrategy>(cx, proto));
-  if (!strategy) {
+  if (!strategy) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -140,19 +140,19 @@ bool js::CountQueuingStrategy::construct
                                            Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (!ThrowIfNotConstructing(cx, args, "CountQueuingStrategy")) {
+  if (!ThrowIfNotConstructing(cx, args, "CountQueuingStrategy")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Implicit in the spec: Create the new strategy object.
   RootedObject proto(cx);
   if (!GetPrototypeFromBuiltinConstructor(
-          cx, args, JSProto_CountQueuingStrategy, &proto)) {
+          cx, args, JSProto_CountQueuingStrategy, &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   Rooted<CountQueuingStrategy*> strategy(
       cx, NewObjectWithClassProto<CountQueuingStrategy>(cx, proto));
-  if (!strategy) {
+  if (!strategy) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/builtin/streams/ReadableStream.cpp b/js/src/builtin/streams/ReadableStream.cpp
--- a/js/src/builtin/streams/ReadableStream.cpp
+++ b/js/src/builtin/streams/ReadableStream.cpp
@@ -84,7 +84,7 @@ ReadableStream* ReadableStream::createEx
     Handle<JSObject*> proto /* = nullptr */) {
   Rooted<ReadableStream*> stream(
       cx, create(cx, nsISupportsObject_alreadyAddreffed, proto));
-  if (!stream) {
+  if (!stream) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -101,7 +101,7 @@ ReadableStream* ReadableStream::createEx
 bool ReadableStream::constructor(JSContext* cx, unsigned argc, JS::Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (!ThrowIfNotConstructing(cx, args, "ReadableStream")) {
+  if (!ThrowIfNotConstructing(cx, args, "ReadableStream")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -109,7 +109,7 @@ bool ReadableStream::constructor(JSConte
   Rooted<Value> underlyingSource(cx, args.get(0));
   if (underlyingSource.isUndefined()) {
     JSObject* emptyObj = NewBuiltinClassInstance<PlainObject>(cx);
-    if (!emptyObj) {
+    if (!emptyObj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     underlyingSource = ObjectValue(*emptyObj);
@@ -118,7 +118,7 @@ bool ReadableStream::constructor(JSConte
   Rooted<Value> strategy(cx, args.get(1));
   if (strategy.isUndefined()) {
     JSObject* emptyObj = NewBuiltinClassInstance<PlainObject>(cx);
-    if (!emptyObj) {
+    if (!emptyObj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     strategy = ObjectValue(*emptyObj);
@@ -129,12 +129,12 @@ bool ReadableStream::constructor(JSConte
   // Step 1: Perform ! InitializeReadableStream(this).
   Rooted<JSObject*> proto(cx);
   if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_ReadableStream,
-                                          &proto)) {
+                                          &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   Rooted<ReadableStream*> stream(cx,
                                  ReadableStream::create(cx, nullptr, proto));
-  if (!stream) {
+  if (!stream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -159,13 +159,13 @@ bool ReadableStream::constructor(JSConte
 
   // Step 5: Let typeString be ? ToString(type).
   Rooted<JSString*> typeString(cx, ToString<CanGC>(cx, type));
-  if (!typeString) {
+  if (!typeString) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Step 6: If typeString is "bytes",
   bool equal;
-  if (!EqualStrings(cx, typeString, cx->names().bytes, &equal)) {
+  if (!EqualStrings(cx, typeString, cx->names().bytes, &equal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (equal) {
@@ -179,7 +179,7 @@ bool ReadableStream::constructor(JSConte
   // Step 7: Otherwise, if type is undefined,
   if (type.isUndefined()) {
     // Step 7.a: Let sizeAlgorithm be ? MakeSizeAlgorithmFromSizeFunction(size).
-    if (!MakeSizeAlgorithmFromSizeFunction(cx, size)) {
+    if (!MakeSizeAlgorithmFromSizeFunction(cx, size)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -282,7 +282,7 @@ bool ReadableStream::constructor(JSConte
   Rooted<Value> optionsVal(cx, args.get(0));
   if (optionsVal.isUndefined()) {
     JSObject* emptyObj = NewBuiltinClassInstance<PlainObject>(cx);
-    if (!emptyObj) {
+    if (!emptyObj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     optionsVal.setObject(*emptyObj);
@@ -295,7 +295,7 @@ bool ReadableStream::constructor(JSConte
   // Step 1: If ! IsReadableStream(this) is false, throw a TypeError exception.
   Rooted<ReadableStream*> unwrappedStream(
       cx, UnwrapAndTypeCheckThis<ReadableStream>(cx, args, "getReader"));
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -308,20 +308,20 @@ bool ReadableStream::constructor(JSConte
   } else {
     // Step 3: Set mode to ? ToString(mode) (implicit).
     Rooted<JSString*> mode(cx, ToString<CanGC>(cx, modeVal));
-    if (!mode) {
+    if (!mode) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // Step 5: (If mode is not "byob",) Throw a RangeError exception.
     bool equal;
-    if (!EqualStrings(cx, mode, cx->names().byob, &equal)) {
+    if (!EqualStrings(cx, mode, cx->names().byob, &equal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!equal) {
       JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                 JSMSG_READABLESTREAM_INVALID_READER_MODE);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Step 4: If mode is "byob",
     //         return ? AcquireReadableStreamBYOBReader(this, true).
@@ -347,62 +347,62 @@ bool ReadableStream::constructor(JSConte
  * Streams spec, 3.2.5.6.
  *      pipeTo(dest, { preventClose, preventAbort, preventCancel, signal } = {})
  */
-static bool ReadableStream_pipeTo(JSContext* cx, unsigned argc, Value* vp) {
+static bool ReadableStream_pipeTo(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
   // Implicit in the spec: argument default values.
   Rooted<Value> options(cx, args.get(1));
-  if (options.isUndefined()) {
+  if (options.isUndefined()) {MOZ_RELEASE_ASSERT(0);
     JSObject* emptyObj = NewBuiltinClassInstance<PlainObject>(cx);
-    if (!emptyObj) {
+    if (!emptyObj) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     options.setObject(*emptyObj);
-  }
+  }MOZ_RELEASE_ASSERT(0);
   // Step 3 (reordered).
   // Implicit in the spec: get the values of the named parameters inside the
   // second argument destructuring pattern.  But as |ToBoolean| is infallible
   // and has no observable side effects, we may as well do step 3 here too.
   bool preventClose, preventAbort, preventCancel;
   Rooted<Value> signalVal(cx);
-  {
+  {MOZ_RELEASE_ASSERT(0);
     // (P)(Re)use the |signal| root.
     auto& v = signalVal;
 
-    if (!GetProperty(cx, options, cx->names().preventClose, &v)) {
+    if (!GetProperty(cx, options, cx->names().preventClose, &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     preventClose = JS::ToBoolean(v);
 
-    if (!GetProperty(cx, options, cx->names().preventAbort, &v)) {
+    if (!GetProperty(cx, options, cx->names().preventAbort, &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     preventAbort = JS::ToBoolean(v);
 
-    if (!GetProperty(cx, options, cx->names().preventCancel, &v)) {
+    if (!GetProperty(cx, options, cx->names().preventCancel, &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     preventCancel = JS::ToBoolean(v);
   }
-  if (!GetProperty(cx, options, cx->names().signal, &signalVal)) {
+  if (!GetProperty(cx, options, cx->names().signal, &signalVal)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Step 1: If ! IsReadableStream(this) is false, return a promise rejected
   //         with a TypeError exception.
   Rooted<ReadableStream*> unwrappedThis(
       cx, UnwrapAndTypeCheckThis<ReadableStream>(cx, args, "pipeTo"));
-  if (!unwrappedThis) {
+  if (!unwrappedThis) {MOZ_RELEASE_ASSERT(0);
     return ReturnPromiseRejectedWithPendingError(cx, args);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Step 2: If ! IsWritableStream(dest) is false, return a promise rejected
   //         with a TypeError exception.
   Rooted<WritableStream*> unwrappedDest(
       cx, UnwrapAndTypeCheckArgument<WritableStream>(cx, args, "pipeTo", 0));
-  if (!unwrappedDest) {
+  if (!unwrappedDest) {MOZ_RELEASE_ASSERT(0);
     return ReturnPromiseRejectedWithPendingError(cx, args);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Step 3: Set preventClose to ! ToBoolean(preventClose), set preventAbort to
   //         ! ToBoolean(preventAbort), and set preventCancel to
@@ -413,14 +413,14 @@ static bool ReadableStream_pipeTo(JSCont
   //         AbortSignal interface, return a promise rejected with a TypeError
   //         exception.
   Rooted<JSObject*> signal(cx, nullptr);
-  if (!signalVal.isUndefined()) {
+  if (!signalVal.isUndefined()) {MOZ_RELEASE_ASSERT(0);
     if (!UnwrapAndTypeCheckValue(
-            cx, signalVal, cx->runtime()->maybeAbortSignalClass(), [cx] {
+            cx, signalVal, cx->runtime()->maybeAbortSignalClass(), [cx] {MOZ_RELEASE_ASSERT(0);
               JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                         JSMSG_READABLESTREAM_PIPETO_BAD_SIGNAL);
-            })) {
+            })) {MOZ_RELEASE_ASSERT(0);
       return ReturnPromiseRejectedWithPendingError(cx, args);
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Note: |signal| can be a wrapper.
     signal = &signalVal.toObject();
@@ -428,7 +428,7 @@ static bool ReadableStream_pipeTo(JSCont
 
   // Step 5: If ! IsReadableStreamLocked(this) is true, return a promise
   //         rejected with a TypeError exception.
-  if (unwrappedThis->locked()) {
+  if (unwrappedThis->locked()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_READABLESTREAM_LOCKED_METHOD, "pipeTo");
     return ReturnPromiseRejectedWithPendingError(cx, args);
@@ -436,11 +436,11 @@ static bool ReadableStream_pipeTo(JSCont
 
   // Step 6: If ! IsWritableStreamLocked(dest) is true, return a promise
   //         rejected with a TypeError exception.
-  if (unwrappedDest->isLocked()) {
+  if (unwrappedDest->isLocked()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_WRITABLESTREAM_ALREADY_LOCKED);
     return ReturnPromiseRejectedWithPendingError(cx, args);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Step 7: Return
   //         ! ReadableStreamPipeTo(this, dest, preventClose, preventAbort,
@@ -472,7 +472,7 @@ static bool ReadableStream_tee(JSContext
   // Step 2: Let branches be ? ReadableStreamTee(this, false).
   Rooted<ReadableStream*> branch1(cx);
   Rooted<ReadableStream*> branch2(cx);
-  if (!ReadableStreamTee(cx, unwrappedStream, false, &branch1, &branch2)) {
+  if (!ReadableStreamTee(cx, unwrappedStream, false, &branch1, &branch2)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -517,7 +517,7 @@ static bool FinishReadableStreamClassIni
   // when "pipeTo" is always enabled.
   const auto& rco = cx->realm()->creationOptions();
   if (rco.getStreamsEnabled() && rco.getWritableStreamsEnabled() &&
-      rco.getReadableStreamPipeToEnabled()) {
+      rco.getReadableStreamPipeToEnabled()) {MOZ_RELEASE_ASSERT(0);
     Rooted<jsid> pipeTo(cx, NameToId(cx->names().pipeTo));
     if (!DefineFunction(cx, proto, pipeTo, ReadableStream_pipeTo, 2,
                         JSPROP_RESOLVING | JSPROP_ENUMERATE)) {
diff --git a/js/src/builtin/streams/ReadableStreamDefaultController.cpp b/js/src/builtin/streams/ReadableStreamDefaultController.cpp
--- a/js/src/builtin/streams/ReadableStreamDefaultController.cpp
+++ b/js/src/builtin/streams/ReadableStreamDefaultController.cpp
@@ -143,7 +143,7 @@ static bool ReadableStreamDefaultControl
   Rooted<ReadableStreamController*> unwrappedController(
       cx, UnwrapAndTypeCheckThis<ReadableStreamDefaultController>(
               cx, args, "get desiredSize"));
-  if (!unwrappedController) {
+  if (!unwrappedController) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -219,7 +219,7 @@ static bool ReadableStreamDefaultControl
   Rooted<ReadableStreamDefaultController*> unwrappedController(
       cx, UnwrapAndTypeCheckThis<ReadableStreamDefaultController>(cx, args,
                                                                   "close"));
-  if (!unwrappedController) {
+  if (!unwrappedController) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -250,7 +250,7 @@ static bool ReadableStreamDefaultControl
   Rooted<ReadableStreamDefaultController*> unwrappedController(
       cx, UnwrapAndTypeCheckThis<ReadableStreamDefaultController>(cx, args,
                                                                   "enqueue"));
-  if (!unwrappedController) {
+  if (!unwrappedController) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -281,7 +281,7 @@ static bool ReadableStreamDefaultControl
   Rooted<ReadableStreamDefaultController*> unwrappedController(
       cx, UnwrapAndTypeCheckThis<ReadableStreamDefaultController>(cx, args,
                                                                   "enqueue"));
-  if (!unwrappedController) {
+  if (!unwrappedController) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -324,15 +324,15 @@ JS_STREAMS_CLASS_SPEC(ReadableStreamDefa
         cx, unwrappedController->as<ReadableByteStreamController>()
                 .pendingPullIntos());
 
-    if (unwrappedPendingPullIntos->length() != 0) {
+    if (unwrappedPendingPullIntos->length() != 0) {MOZ_RELEASE_ASSERT(0);
       // Step a: Let firstDescriptor be the first element of
       //         this.[[pendingPullIntos]].
       PullIntoDescriptor* unwrappedDescriptor =
           UnwrapAndDowncastObject<PullIntoDescriptor>(
               cx, &unwrappedPendingPullIntos->get(0).toObject());
-      if (!unwrappedDescriptor) {
+      if (!unwrappedDescriptor) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       // Step b: Set firstDescriptor.[[bytesFilled]] to 0.
       unwrappedDescriptor->setBytesFilled(0);
@@ -343,7 +343,7 @@ JS_STREAMS_CLASS_SPEC(ReadableStreamDefa
       cx, unwrappedController->underlyingSource());
 
   // Step 1 of 3.9.5.1, step 2 of 3.11.5.1: Perform ! ResetQueue(this).
-  if (!ResetQueue(cx, unwrappedController)) {
+  if (!ResetQueue(cx, unwrappedController)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -373,7 +373,7 @@ JS_STREAMS_CLASS_SPEC(ReadableStreamDefa
           unwrappedController->externalSource();
       Rooted<ReadableStream*> stream(cx, unwrappedController->stream());
       Rooted<Value> wrappedReason(cx, reason);
-      if (!cx->compartment()->wrap(cx, &wrappedReason)) {
+      if (!cx->compartment()->wrap(cx, &wrappedReason)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -383,7 +383,7 @@ JS_STREAMS_CLASS_SPEC(ReadableStreamDefa
 
     // Make sure the ReadableStreamControllerClearAlgorithms call below is
     // reached, even on error.
-    if (!cx->compartment()->wrap(cx, &rval)) {
+    if (!cx->compartment()->wrap(cx, &rval)) {MOZ_RELEASE_ASSERT(0);
       result = nullptr;
     } else {
       result = PromiseObject::unforgeableResolve(cx, rval);
@@ -407,7 +407,7 @@ JS_STREAMS_CLASS_SPEC(ReadableStreamDefa
         cx->check(unwrappedUnderlyingSource);
 
         Rooted<Value> wrappedReason(cx, reason);
-        if (!cx->compartment()->wrap(cx, &wrappedReason)) {
+        if (!cx->compartment()->wrap(cx, &wrappedReason)) {MOZ_RELEASE_ASSERT(0);
           return nullptr;
         }
 
@@ -452,7 +452,7 @@ PromiseObject* js::ReadableStreamDefault
   if (unwrappedQueue && unwrappedQueue->length() != 0) {
     // Step a: Let chunk be ! DequeueValue(this).
     Rooted<Value> chunk(cx);
-    if (!DequeueValue(cx, unwrappedController, &chunk)) {
+    if (!DequeueValue(cx, unwrappedController, &chunk)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -471,7 +471,7 @@ PromiseObject* js::ReadableStreamDefault
     // Step c: Otherwise, perform
     //         ! ReadableStreamDefaultControllerCallPullIfNeeded(this).
     else {
-      if (!ReadableStreamControllerCallPullIfNeeded(cx, unwrappedController)) {
+      if (!ReadableStreamControllerCallPullIfNeeded(cx, unwrappedController)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -481,13 +481,13 @@ PromiseObject* js::ReadableStreamDefault
     cx->check(chunk);
     ReadableStreamReader* unwrappedReader =
         UnwrapReaderFromStream(cx, unwrappedStream);
-    if (!unwrappedReader) {
+    if (!unwrappedReader) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     PlainObject* readResultObj = ReadableStreamCreateReadResult(
         cx, chunk, false, unwrappedReader->forAuthorCode());
-    if (!readResultObj) {
+    if (!readResultObj) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -499,7 +499,7 @@ PromiseObject* js::ReadableStreamDefault
   //         ! ReadableStreamAddReadRequest(stream, forAuthorCode).
   Rooted<PromiseObject*> pendingPromise(
       cx, ReadableStreamAddReadOrReadIntoRequest(cx, unwrappedStream));
-  if (!pendingPromise) {
+  if (!pendingPromise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/builtin/streams/ReadableStreamDefaultControllerOperations.cpp b/js/src/builtin/streams/ReadableStreamDefaultControllerOperations.cpp
--- a/js/src/builtin/streams/ReadableStreamDefaultControllerOperations.cpp
+++ b/js/src/builtin/streams/ReadableStreamDefaultControllerOperations.cpp
@@ -69,7 +69,7 @@ static bool ControllerPullHandler(JSCont
 
   Rooted<ReadableStreamController*> unwrappedController(
       cx, UnwrapCalleeSlot<ReadableStreamController>(cx, args, 0));
-  if (!unwrappedController) {
+  if (!unwrappedController) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -104,7 +104,7 @@ static bool ControllerPullFailedHandler(
 
   Rooted<ReadableStreamController*> controller(
       cx, UnwrapCalleeSlot<ReadableStreamController>(cx, args, 0));
-  if (!controller) {
+  if (!controller) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -157,7 +157,7 @@ static bool ReadableStreamControllerShou
   // We use this variable in step 7. For ease of error-handling, we wrap it
   // early.
   Rooted<JSObject*> wrappedController(cx, unwrappedController);
-  if (!cx->compartment()->wrap(cx, &wrappedController)) {
+  if (!cx->compartment()->wrap(cx, &wrappedController)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -215,12 +215,12 @@ static bool ReadableStreamControllerShou
           return false;
         }
       }
-      if (!cx->compartment()->wrap(cx, &pullPromise)) {
+      if (!cx->compartment()->wrap(cx, &pullPromise)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
   }
-  if (!pullPromise) {
+  if (!pullPromise) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -228,7 +228,7 @@ static bool ReadableStreamControllerShou
   // Step 8. Upon rejection of pullPromise with reason e, [...]
   Rooted<JSObject*> onPullFulfilled(
       cx, NewHandler(cx, ControllerPullHandler, wrappedController));
-  if (!onPullFulfilled) {
+  if (!onPullFulfilled) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   Rooted<JSObject*> onPullRejected(
@@ -382,7 +382,7 @@ void js::ReadableStreamControllerClearAl
   if (unwrappedStream->locked() &&
       ReadableStreamGetNumReadRequests(unwrappedStream) > 0) {
     if (!ReadableStreamFulfillReadOrReadIntoRequest(cx, unwrappedStream, chunk,
-                                                    false)) {
+                                                    false)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -395,7 +395,7 @@ void js::ReadableStreamControllerClearAl
     bool success = true;
     Rooted<Value> strategySize(cx, unwrappedController->strategySize());
     if (!strategySize.isUndefined()) {
-      if (!cx->compartment()->wrap(cx, &strategySize)) {
+      if (!cx->compartment()->wrap(cx, &strategySize)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       success = Call(cx, strategySize, UndefinedHandleValue, chunk, &chunkSize);
@@ -466,7 +466,7 @@ void js::ReadableStreamControllerClearAl
     Rooted<ReadableByteStreamController*> unwrappedByteStreamController(
         cx, &unwrappedController->as<ReadableByteStreamController>());
     if (!ReadableByteStreamControllerClearPendingPullIntos(
-            cx, unwrappedByteStreamController)) {
+            cx, unwrappedByteStreamController)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -556,7 +556,7 @@ void js::ReadableStreamControllerClearAl
   // Done elsewhere in the standard: Create the new controller.
   Rooted<ReadableStreamDefaultController*> controller(
       cx, NewBuiltinClassInstance<ReadableStreamDefaultController>(cx));
-  if (!controller) {
+  if (!controller) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -568,7 +568,7 @@ void js::ReadableStreamControllerClearAl
 
   // Step 3: Set controller.[[queue]] and controller.[[queueTotalSize]] to
   //         undefined (implicit), then perform ! ResetQueue(controller).
-  if (!ResetQueue(cx, controller)) {
+  if (!ResetQueue(cx, controller)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -606,7 +606,7 @@ void js::ReadableStreamControllerClearAl
   // Step 10: Let startPromise be a promise resolved with startResult.
   Rooted<JSObject*> startPromise(
       cx, PromiseObject::unforgeableResolve(cx, startResult));
-  if (!startPromise) {
+  if (!startPromise) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -614,13 +614,13 @@ void js::ReadableStreamControllerClearAl
   // Step 12: Upon rejection of startPromise with reason r, [...]
   Rooted<JSObject*> onStartFulfilled(
       cx, NewHandler(cx, ReadableStreamControllerStartHandler, controller));
-  if (!onStartFulfilled) {
+  if (!onStartFulfilled) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   Rooted<JSObject*> onStartRejected(
       cx,
       NewHandler(cx, ReadableStreamControllerStartFailedHandler, controller));
-  if (!onStartRejected) {
+  if (!onStartRejected) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!JS::AddPromiseReactions(cx, startPromise, onStartFulfilled,
diff --git a/js/src/builtin/streams/ReadableStreamDefaultReader.cpp b/js/src/builtin/streams/ReadableStreamDefaultReader.cpp
--- a/js/src/builtin/streams/ReadableStreamDefaultReader.cpp
+++ b/js/src/builtin/streams/ReadableStreamDefaultReader.cpp
@@ -51,7 +51,7 @@ js::CreateReadableStreamDefaultReader(JS
                                       Handle<JSObject*> proto /* = nullptr */) {
   Rooted<ReadableStreamDefaultReader*> reader(
       cx, NewObjectWithClassProto<ReadableStreamDefaultReader>(cx, proto));
-  if (!reader) {
+  if (!reader) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -80,13 +80,13 @@ bool ReadableStreamDefaultReader::constr
                                               Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (!ThrowIfNotConstructing(cx, args, "ReadableStreamDefaultReader")) {
+  if (!ThrowIfNotConstructing(cx, args, "ReadableStreamDefaultReader")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Implicit in the spec: Find the prototype object to use.
   Rooted<JSObject*> proto(cx);
-  if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_Null, &proto)) {
+  if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_Null, &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -95,7 +95,7 @@ bool ReadableStreamDefaultReader::constr
   Rooted<ReadableStream*> unwrappedStream(
       cx, UnwrapAndTypeCheckArgument<ReadableStream>(
               cx, args, "ReadableStreamDefaultReader constructor", 0));
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -123,7 +123,7 @@ bool ReadableStreamDefaultReader::constr
   Rooted<ReadableStreamDefaultReader*> unwrappedReader(
       cx, UnwrapAndTypeCheckThis<ReadableStreamDefaultReader>(cx, args,
                                                               "get closed"));
-  if (!unwrappedReader) {
+  if (!unwrappedReader) {MOZ_RELEASE_ASSERT(0);
     return ReturnPromiseRejectedWithPendingError(cx, args);
   }
 
@@ -150,7 +150,7 @@ bool ReadableStreamDefaultReader::constr
   Rooted<ReadableStreamDefaultReader*> unwrappedReader(
       cx,
       UnwrapAndTypeCheckThis<ReadableStreamDefaultReader>(cx, args, "cancel"));
-  if (!unwrappedReader) {
+  if (!unwrappedReader) {MOZ_RELEASE_ASSERT(0);
     return ReturnPromiseRejectedWithPendingError(cx, args);
   }
 
@@ -185,7 +185,7 @@ bool ReadableStreamDefaultReader::constr
   Rooted<ReadableStreamDefaultReader*> unwrappedReader(
       cx,
       UnwrapAndTypeCheckThis<ReadableStreamDefaultReader>(cx, args, "read"));
-  if (!unwrappedReader) {
+  if (!unwrappedReader) {MOZ_RELEASE_ASSERT(0);
     return ReturnPromiseRejectedWithPendingError(cx, args);
   }
 
@@ -218,7 +218,7 @@ static bool ReadableStreamDefaultReader_
   Rooted<ReadableStreamDefaultReader*> reader(
       cx, UnwrapAndTypeCheckThis<ReadableStreamDefaultReader>(cx, args,
                                                               "releaseLock"));
-  if (!reader) {
+  if (!reader) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/builtin/streams/ReadableStreamInternals.cpp b/js/src/builtin/streams/ReadableStreamInternals.cpp
--- a/js/src/builtin/streams/ReadableStreamInternals.cpp
+++ b/js/src/builtin/streams/ReadableStreamInternals.cpp
@@ -73,7 +73,7 @@ using js::ReadableStream;
   // (Only default readers exist so far.)
   Rooted<ReadableStreamReader*> unwrappedReader(
       cx, UnwrapReaderFromStream(cx, unwrappedStream));
-  if (!unwrappedReader) {
+  if (!unwrappedReader) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   MOZ_ASSERT(unwrappedReader->is<ReadableStreamDefaultReader>());
@@ -86,7 +86,7 @@ using js::ReadableStream;
 
   // Step 3: Let promise be a new promise.
   Rooted<PromiseObject*> promise(cx, PromiseObject::createSkippingExecutor(cx));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -136,14 +136,14 @@ static bool ReturnUndefined(JSContext* c
   //         stream.[[storedError]].
   if (unwrappedStream->errored()) {
     Rooted<Value> storedError(cx, unwrappedStream->storedError());
-    if (!cx->compartment()->wrap(cx, &storedError)) {
+    if (!cx->compartment()->wrap(cx, &storedError)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     return PromiseObject::unforgeableReject(cx, storedError);
   }
 
   // Step 4: Perform ! ReadableStreamClose(stream).
-  if (!ReadableStreamCloseInternal(cx, unwrappedStream)) {
+  if (!ReadableStreamCloseInternal(cx, unwrappedStream)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -153,7 +153,7 @@ static bool ReturnUndefined(JSContext* c
       cx, unwrappedStream->controller());
   Rooted<JSObject*> sourceCancelPromise(
       cx, ReadableStreamControllerCancelSteps(cx, unwrappedController, reason));
-  if (!sourceCancelPromise) {
+  if (!sourceCancelPromise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -209,17 +209,17 @@ static bool ReturnUndefined(JSContext* c
       //         ! ReadableStreamCreateReadResult(undefined, true,
       //                                          readRequest.[[forAuthorCode]]).
       readRequest = &unwrappedReadRequests->getAs<JSObject>(i);
-      if (!cx->compartment()->wrap(cx, &readRequest)) {
+      if (!cx->compartment()->wrap(cx, &readRequest)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       resultObj = js::ReadableStreamCreateReadResult(cx, UndefinedHandleValue,
                                                      true, forAuthorCode);
-      if (!resultObj) {
+      if (!resultObj) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       resultVal = ObjectValue(*resultObj);
-      if (!ResolvePromise(cx, readRequest, resultVal)) {
+      if (!ResolvePromise(cx, readRequest, resultVal)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -230,7 +230,7 @@ static bool ReturnUndefined(JSContext* c
 
   // Step 6: Resolve reader.[[closedPromise]] with undefined.
   if (!ResolveUnwrappedPromiseWithUndefined(cx,
-                                            unwrappedReader->closedPromise())) {
+                                            unwrappedReader->closedPromise())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -298,7 +298,7 @@ static bool ReturnUndefined(JSContext* c
   {
     AutoRealm ar(cx, unwrappedStream);
     Rooted<Value> wrappedError(cx, e);
-    if (!cx->compartment()->wrap(cx, &wrappedError)) {
+    if (!cx->compartment()->wrap(cx, &wrappedError)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     unwrappedStream->setStoredError(wrappedError);
@@ -312,7 +312,7 @@ static bool ReturnUndefined(JSContext* c
   // Step 5: Let reader be stream.[[reader]].
   Rooted<ReadableStreamReader*> unwrappedReader(
       cx, UnwrapReaderFromStream(cx, unwrappedStream));
-  if (!unwrappedReader) {
+  if (!unwrappedReader) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -329,7 +329,7 @@ static bool ReturnUndefined(JSContext* c
       // was triggered, which might not be the same as the one the request was
       // created in, so we have to wrap requests here.
       readRequest = &unwrappedReadRequests->get(i).toObject();
-      if (!RejectUnwrappedPromiseWithError(cx, &readRequest, e)) {
+      if (!RejectUnwrappedPromiseWithError(cx, &readRequest, e)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -337,13 +337,13 @@ static bool ReturnUndefined(JSContext* c
 
   // Step 7.b/8.c: Set reader.[[read{Into}Requests]] to a new empty List.
   if (!StoreNewListInFixedSlot(cx, unwrappedReader,
-                               ReadableStreamReader::Slot_Requests)) {
+                               ReadableStreamReader::Slot_Requests)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Step 9: Reject reader.[[closedPromise]] with e.
   if (!RejectUnwrappedPromiseWithError(cx, unwrappedReader->closedPromise(),
-                                       e)) {
+                                       e)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -357,7 +357,7 @@ static bool ReturnUndefined(JSContext* c
   Rooted<JSObject*> closedPromise(cx, unwrappedReader->closedPromise());
   js::SetSettledPromiseIsHandled(cx, closedPromise.as<PromiseObject>());
 
-  if (unwrappedStream->mode() == JS::ReadableStreamMode::ExternalSource) {
+  if (unwrappedStream->mode() == JS::ReadableStreamMode::ExternalSource) {MOZ_RELEASE_ASSERT(0);
     // Make sure we're in the stream's compartment.
     AutoRealm ar(cx, unwrappedStream);
     JS::ReadableStreamUnderlyingSource* source =
@@ -390,7 +390,7 @@ static bool ReturnUndefined(JSContext* c
   // Step 1: Let reader be stream.[[reader]].
   Rooted<ReadableStreamReader*> unwrappedReader(
       cx, UnwrapReaderFromStream(cx, unwrappedStream));
-  if (!unwrappedReader) {
+  if (!unwrappedReader) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -404,7 +404,7 @@ static bool ReturnUndefined(JSContext* c
   Rooted<JSObject*> readIntoRequest(
       cx, &unwrappedReadIntoRequests->popFirstAs<JSObject>(cx));
   MOZ_ASSERT(readIntoRequest);
-  if (!cx->compartment()->wrap(cx, &readIntoRequest)) {
+  if (!cx->compartment()->wrap(cx, &readIntoRequest)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -455,7 +455,7 @@ uint32_t js::ReadableStreamGetNumReadReq
     JSContext* cx, Handle<ReadableStream*> unwrappedStream, bool* result) {
   // Step 1: Let reader be stream.[[reader]].
   // Step 2: If reader is undefined, return false.
-  if (!unwrappedStream->hasReader()) {
+  if (!unwrappedStream->hasReader()) {MOZ_RELEASE_ASSERT(0);
     *result = false;
     return true;
   }
diff --git a/js/src/builtin/streams/ReadableStreamOperations.cpp b/js/src/builtin/streams/ReadableStreamOperations.cpp
--- a/js/src/builtin/streams/ReadableStreamOperations.cpp
+++ b/js/src/builtin/streams/ReadableStreamOperations.cpp
@@ -97,7 +97,7 @@ using JS::Value;
   // Step 5: Perform ! InitializeReadableStream(stream).
   Rooted<ReadableStream*> stream(cx,
                                  ReadableStream::create(cx, nullptr, proto));
-  if (!stream) {
+  if (!stream) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -188,7 +188,7 @@ static bool TeeReaderReadHandler(JSConte
 
   Rooted<TeeState*> unwrappedTeeState(cx,
                                       UnwrapCalleeSlot<TeeState>(cx, args, 0));
-  if (!unwrappedTeeState) {
+  if (!unwrappedTeeState) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -205,7 +205,7 @@ static bool TeeReaderReadHandler(JSConte
     // Step 12.c.iii: Let done be ? Get(result, "done").
     // (This can fail only if `result` was nuked.)
     Rooted<Value> doneVal(cx);
-    if (!GetProperty(cx, result, result, cx->names().done, &doneVal)) {
+    if (!GetProperty(cx, result, result, cx->names().done, &doneVal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -222,7 +222,7 @@ static bool TeeReaderReadHandler(JSConte
     if (!unwrappedTeeState->canceled1()) {
       Rooted<ReadableStreamDefaultController*> unwrappedBranch1(
           cx, unwrappedTeeState->branch1());
-      if (!ReadableStreamDefaultControllerClose(cx, unwrappedBranch1)) {
+      if (!ReadableStreamDefaultControllerClose(cx, unwrappedBranch1)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -232,7 +232,7 @@ static bool TeeReaderReadHandler(JSConte
     if (!unwrappedTeeState->canceled2()) {
       Rooted<ReadableStreamDefaultController*> unwrappedBranch2(
           cx, unwrappedTeeState->branch2());
-      if (!ReadableStreamDefaultControllerClose(cx, unwrappedBranch2)) {
+      if (!ReadableStreamDefaultControllerClose(cx, unwrappedBranch2)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -241,7 +241,7 @@ static bool TeeReaderReadHandler(JSConte
     Rooted<PromiseObject*> unwrappedCancelPromise(
         cx, unwrappedTeeState->cancelPromise());
     MOZ_ASSERT(unwrappedCancelPromise != nullptr);
-    if (!ResolveUnwrappedPromiseWithUndefined(cx, unwrappedCancelPromise)) {
+    if (!ResolveUnwrappedPromiseWithUndefined(cx, unwrappedCancelPromise)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -252,7 +252,7 @@ static bool TeeReaderReadHandler(JSConte
   // Step 12.c.vi: Let value be ! Get(result, "value").
   // (This can fail only if `result` was nuked.)
   Rooted<Value> value(cx);
-  if (!GetProperty(cx, result, result, cx->names().value, &value)) {
+  if (!GetProperty(cx, result, result, cx->names().value, &value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -277,7 +277,7 @@ static bool TeeReaderReadHandler(JSConte
   if (!unwrappedTeeState->canceled1()) {
     unwrappedController = unwrappedTeeState->branch1();
     if (!ReadableStreamDefaultControllerEnqueue(cx, unwrappedController,
-                                                value1)) {
+                                                value1)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -316,12 +316,12 @@ static bool TeeReaderReadHandler(JSConte
       Rooted<ReadableStream*> unwrappedStream(
           cx, UnwrapInternalSlot<ReadableStream>(cx, unwrappedTeeState,
                                                  TeeState::Slot_Stream));
-      if (!unwrappedStream) {
+      if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       ReadableStreamReader* unwrappedReaderObj =
           UnwrapReaderFromStream(cx, unwrappedStream);
-      if (!unwrappedReaderObj) {
+      if (!unwrappedReaderObj) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -336,20 +336,20 @@ static bool TeeReaderReadHandler(JSConte
     // First, perform |ReadableStreamDefaultReaderRead(reader)|.
     Rooted<PromiseObject*> readerReadResultPromise(
         cx, js::ReadableStreamDefaultReaderRead(cx, unwrappedReader));
-    if (!readerReadResultPromise) {
+    if (!readerReadResultPromise) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     // Next, create a function to perform the fulfillment steps under step 12.c
     // (implemented in the |TeeReaderReadHandler| C++ function).
     Rooted<JSObject*> teeState(cx, unwrappedTeeState);
-    if (!cx->compartment()->wrap(cx, &teeState)) {
+    if (!cx->compartment()->wrap(cx, &teeState)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     Rooted<JSObject*> onFulfilled(
         cx, NewHandler(cx, TeeReaderReadHandler, teeState));
-    if (!onFulfilled) {
+    if (!onFulfilled) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -390,7 +390,7 @@ static bool TeeReaderReadHandler(JSConte
   Rooted<ReadableStream*> unwrappedStream(
       cx, UnwrapInternalSlot<ReadableStream>(cx, unwrappedTeeState,
                                              TeeState::Slot_Stream));
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -402,7 +402,7 @@ static bool TeeReaderReadHandler(JSConte
     AutoRealm ar(cx, unwrappedTeeState);
 
     Rooted<Value> unwrappedReason(cx, reason);
-    if (!cx->compartment()->wrap(cx, &unwrappedReason)) {
+    if (!cx->compartment()->wrap(cx, &unwrappedReason)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -429,12 +429,12 @@ static bool TeeReaderReadHandler(JSConte
       Rooted<Value> reason1(cx, unwrappedTeeState->reason1());
       Rooted<Value> reason2(cx, unwrappedTeeState->reason2());
       if (!cx->compartment()->wrap(cx, &reason1) ||
-          !cx->compartment()->wrap(cx, &reason2)) {
+          !cx->compartment()->wrap(cx, &reason2)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
       ArrayObject* reasonArray = NewDenseFullyAllocatedArray(cx, 2);
-      if (!reasonArray) {
+      if (!reasonArray) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       reasonArray->setDenseInitializedLength(2);
@@ -450,17 +450,17 @@ static bool TeeReaderReadHandler(JSConte
     // is to reject cancelPromise with an OOM error.
     Rooted<JSObject*> cancelResult(
         cx, js::ReadableStreamCancel(cx, unwrappedStream, compositeReason));
-    if (!cancelResult) {
+    if (!cancelResult) {MOZ_RELEASE_ASSERT(0);
       // Handle the OOM case mentioned above.
       AutoRealm ar(cx, unwrappedCancelPromise);
-      if (!RejectPromiseWithPendingError(cx, unwrappedCancelPromise)) {
+      if (!RejectPromiseWithPendingError(cx, unwrappedCancelPromise)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     } else {
       // Step 13/14.c.iii: Resolve cancelPromise with cancelResult.
       Rooted<Value> cancelResultVal(cx, ObjectValue(*cancelResult));
       if (!ResolveUnwrappedPromiseWithValue(cx, unwrappedCancelPromise,
-                                            cancelResultVal)) {
+                                            cancelResultVal)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -494,7 +494,7 @@ static bool TeeReaderErroredHandler(JSCo
   //               ! ReadableStreamDefaultControllerError(
   //                   branch1.[[controller]], r).
   unwrappedBranchController = teeState->branch1();
-  if (!ReadableStreamControllerError(cx, unwrappedBranchController, reason)) {
+  if (!ReadableStreamControllerError(cx, unwrappedBranchController, reason)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -502,7 +502,7 @@ static bool TeeReaderErroredHandler(JSCo
   //            ! ReadableStreamDefaultControllerError(
   //                branch2.[[controller]], r).
   unwrappedBranchController = teeState->branch2();
-  if (!ReadableStreamControllerError(cx, unwrappedBranchController, reason)) {
+  if (!ReadableStreamControllerError(cx, unwrappedBranchController, reason)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -543,7 +543,7 @@ static bool TeeReaderErroredHandler(JSCo
   Rooted<ReadableStreamDefaultReader*> reader(
       cx, CreateReadableStreamDefaultReader(cx, unwrappedStream,
                                             ForAuthorCodeBool::No));
-  if (!reader) {
+  if (!reader) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -561,7 +561,7 @@ static bool TeeReaderErroredHandler(JSCo
   // Step 10: Let branch2 be undefined.
   // Step 11: Let cancelPromise be a new promise.
   Rooted<TeeState*> teeState(cx, TeeState::create(cx, unwrappedStream));
-  if (!teeState) {
+  if (!teeState) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -586,7 +586,7 @@ static bool TeeReaderErroredHandler(JSCo
   Rooted<Value> underlyingSource(cx, ObjectValue(*teeState));
   branch1Stream.set(
       CreateReadableStream(cx, SourceAlgorithms::Tee, underlyingSource));
-  if (!branch1Stream) {
+  if (!branch1Stream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -600,7 +600,7 @@ static bool TeeReaderErroredHandler(JSCo
   //                                 cancel2Algorithm).
   branch2Stream.set(
       CreateReadableStream(cx, SourceAlgorithms::Tee, underlyingSource));
-  if (!branch2Stream) {
+  if (!branch2Stream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -614,7 +614,7 @@ static bool TeeReaderErroredHandler(JSCo
 
   Rooted<JSObject*> onRejected(
       cx, NewHandler(cx, TeeReaderErroredHandler, teeState));
-  if (!onRejected) {
+  if (!onRejected) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -636,7 +636,7 @@ PromiseObject* js::ReadableStreamPipeTo(
                                         Handle<WritableStream*> unwrappedDest,
                                         bool preventClose, bool preventAbort,
                                         bool preventCancel,
-                                        Handle<JSObject*> signal) {
+                                        Handle<JSObject*> signal) {MOZ_RELEASE_ASSERT(0);
   cx->check(signal);
 
   // Step 1. Assert: ! IsReadableStream(source) is true.
@@ -650,16 +650,16 @@ PromiseObject* js::ReadableStreamPipeTo(
   // We reorder this so that this promise can be rejected and returned in case
   // of internal error.
   Rooted<PromiseObject*> promise(cx, PromiseObject::createSkippingExecutor(cx));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Steps 4-11, 13-14.
   Rooted<PipeToState*> pipeToState(
       cx,
       PipeToState::create(cx, promise, unwrappedSource, unwrappedDest,
                           preventClose, preventAbort, preventCancel, signal));
-  if (!pipeToState) {
+  if (!pipeToState) {MOZ_RELEASE_ASSERT(0);
     if (!RejectPromiseWithPendingError(cx, promise)) {
       return nullptr;
     }
diff --git a/js/src/builtin/streams/ReadableStreamReader.cpp b/js/src/builtin/streams/ReadableStreamReader.cpp
--- a/js/src/builtin/streams/ReadableStreamReader.cpp
+++ b/js/src/builtin/streams/ReadableStreamReader.cpp
@@ -79,7 +79,7 @@ using js::UnwrapStreamFromReader;
   // Step 2: Set reader.[[ownerReadableStream]] to stream.
   {
     Rooted<JSObject*> readerCompartmentStream(cx, unwrappedStream);
-    if (!cx->compartment()->wrap(cx, &readerCompartmentStream)) {
+    if (!cx->compartment()->wrap(cx, &readerCompartmentStream)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     reader->setStream(readerCompartmentStream);
@@ -105,11 +105,11 @@ using js::UnwrapStreamFromReader;
     // Step b: Set reader.[[closedPromise]] to a promise rejected with
     //         stream.[[storedError]].
     Rooted<Value> storedError(cx, unwrappedStream->storedError());
-    if (!cx->compartment()->wrap(cx, &storedError)) {
+    if (!cx->compartment()->wrap(cx, &storedError)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     promise = PromiseObject::unforgeableReject(cx, storedError);
-    if (!promise) {
+    if (!promise) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -117,7 +117,7 @@ using js::UnwrapStreamFromReader;
     js::SetSettledPromiseIsHandled(cx, promise);
   }
 
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -127,7 +127,7 @@ using js::UnwrapStreamFromReader;
   // Step 5 of caller 3.7.3. new ReadableStreamBYOBReader(stream):
   //     Set this.[[read{Into}Requests]] to a new empty List.
   if (!StoreNewListInFixedSlot(cx, reader,
-                               ReadableStreamReader::Slot_Requests)) {
+                               ReadableStreamReader::Slot_Requests)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -171,7 +171,7 @@ using js::UnwrapStreamFromReader;
   JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                             JSMSG_READABLESTREAMREADER_RELEASED);
   Rooted<Value> exn(cx);
-  if (!cx->isExceptionPending() || !GetAndClearException(cx, &exn)) {
+  if (!cx->isExceptionPending() || !GetAndClearException(cx, &exn)) {MOZ_RELEASE_ASSERT(0);
     // Uncatchable error. Die immediately without resolving
     // reader.[[closedPromise]].
     return false;
@@ -183,15 +183,15 @@ using js::UnwrapStreamFromReader;
   if (unwrappedStream->readable()) {
     unwrappedClosedPromise = UnwrapInternalSlot<PromiseObject>(
         cx, unwrappedReader, ReadableStreamReader::Slot_ClosedPromise);
-    if (!unwrappedClosedPromise) {
+    if (!unwrappedClosedPromise) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     AutoRealm ar(cx, unwrappedClosedPromise);
-    if (!cx->compartment()->wrap(cx, &exn)) {
+    if (!cx->compartment()->wrap(cx, &exn)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!PromiseObject::reject(cx, unwrappedClosedPromise, exn)) {
+    if (!PromiseObject::reject(cx, unwrappedClosedPromise, exn)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -199,7 +199,7 @@ using js::UnwrapStreamFromReader;
     //         rejected with a TypeError exception.
     Rooted<JSObject*> closedPromise(cx,
                                     PromiseObject::unforgeableReject(cx, exn));
-    if (!closedPromise) {
+    if (!closedPromise) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     unwrappedClosedPromise = &closedPromise->as<PromiseObject>();
@@ -247,7 +247,7 @@ using js::UnwrapStreamFromReader;
   if (unwrappedStream->closed()) {
     PlainObject* iterResult = ReadableStreamCreateReadResult(
         cx, UndefinedHandleValue, true, unwrappedReader->forAuthorCode());
-    if (!iterResult) {
+    if (!iterResult) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
diff --git a/js/src/builtin/streams/StreamAPI.cpp b/js/src/builtin/streams/StreamAPI.cpp
--- a/js/src/builtin/streams/StreamAPI.cpp
+++ b/js/src/builtin/streams/StreamAPI.cpp
@@ -87,15 +87,15 @@ JS_PUBLIC_API JSObject* JS::NewReadableD
   // A copy of ReadableStream::constructor, with most of the
   // argument-checking done implicitly by C++ type checking.
   Rooted<ReadableStream*> stream(cx, ReadableStream::create(cx));
-  if (!stream) {
+  if (!stream) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   Rooted<Value> sourceVal(cx);
-  if (underlyingSource) {
+  if (underlyingSource) {MOZ_RELEASE_ASSERT(0);
     sourceVal.setObject(*underlyingSource);
   } else {
     JSObject* source = NewBuiltinClassInstance<PlainObject>(cx);
-    if (!source) {
+    if (!source) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     sourceVal.setObject(*source);
@@ -237,12 +237,12 @@ JS_PUBLIC_API bool JS::ReadableStreamGet
 
   Rooted<ReadableStream*> unwrappedStream(
       cx, APIUnwrapAndDowncast<ReadableStream>(cx, streamObj));
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MOZ_ASSERT(unwrappedStream->mode() == JS::ReadableStreamMode::ExternalSource);
-  if (unwrappedStream->locked()) {
+  if (unwrappedStream->locked()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_READABLESTREAM_LOCKED);
     return false;
@@ -283,7 +283,7 @@ JS_PUBLIC_API bool JS::ReadableStreamUpd
 
   Rooted<ReadableStream*> unwrappedStream(
       cx, APIUnwrapAndDowncast<ReadableStream>(cx, streamObj));
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -301,7 +301,7 @@ JS_PUBLIC_API bool JS::ReadableStreamUpd
       cx, &unwrappedStream->controller()->as<ReadableByteStreamController>());
 
   // Step 2: If this.[[closeRequested]] is true, throw a TypeError exception.
-  if (unwrappedController->closeRequested()) {
+  if (unwrappedController->closeRequested()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_READABLESTREAMCONTROLLER_CLOSED, "enqueue");
     return false;
@@ -309,7 +309,7 @@ JS_PUBLIC_API bool JS::ReadableStreamUpd
 
   // Step 3: If this.[[controlledReadableStream]].[[state]] is not "readable",
   //         throw a TypeError exception.
-  if (!unwrappedController->stream()->readable()) {
+  if (!unwrappedController->stream()->readable()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE,
                               "enqueue");
@@ -335,7 +335,7 @@ JS_PUBLIC_API bool JS::ReadableStreamUpd
 
   // Step 8: If ! ReadableStreamHasDefaultReader(stream) is true
   bool hasDefaultReader;
-  if (!ReadableStreamHasDefaultReader(cx, unwrappedStream, &hasDefaultReader)) {
+  if (!ReadableStreamHasDefaultReader(cx, unwrappedStream, &hasDefaultReader)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (hasDefaultReader) {
@@ -347,12 +347,12 @@ JS_PUBLIC_API bool JS::ReadableStreamUpd
     //          ! Construct(%Uint8Array%, transferredBuffer,
     //                      byteOffset, byteLength).
     JSObject* viewObj = JS_NewUint8Array(cx, availableData);
-    if (!viewObj) {
+    if (!viewObj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     Rooted<ArrayBufferViewObject*> transferredView(
         cx, &viewObj->as<ArrayBufferViewObject>());
-    if (!transferredView) {
+    if (!transferredView) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -375,7 +375,7 @@ JS_PUBLIC_API bool JS::ReadableStreamUpd
     //                                                      false).
     Rooted<Value> chunk(cx, ObjectValue(*transferredView));
     if (!ReadableStreamFulfillReadOrReadIntoRequest(cx, unwrappedStream, chunk,
-                                                    false)) {
+                                                    false)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -411,7 +411,7 @@ JS_PUBLIC_API bool JS::ReadableStreamTee
 
   Rooted<ReadableStream*> unwrappedStream(
       cx, APIUnwrapAndDowncast<ReadableStream>(cx, streamObj));
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -433,11 +433,11 @@ JS_PUBLIC_API bool JS::ReadableStreamGet
                                                     double* value) {
   ReadableStream* unwrappedStream =
       APIUnwrapAndDowncast<ReadableStream>(cx, streamObj);
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (unwrappedStream->errored()) {
+  if (unwrappedStream->errored()) {MOZ_RELEASE_ASSERT(0);
     *hasValue = false;
     return true;
   }
@@ -461,14 +461,14 @@ JS_PUBLIC_API bool JS::ReadableStreamClo
 
   Rooted<ReadableStream*> unwrappedStream(
       cx, APIUnwrapAndDowncast<ReadableStream>(cx, streamObj));
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Rooted<ReadableStreamController*> unwrappedControllerObj(
       cx, unwrappedStream->controller());
   if (!CheckReadableStreamControllerCanCloseOrEnqueue(
-          cx, unwrappedControllerObj, "close")) {
+          cx, unwrappedControllerObj, "close")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -494,7 +494,7 @@ JS_PUBLIC_API bool JS::ReadableStreamEnq
 
   Rooted<ReadableStream*> unwrappedStream(
       cx, APIUnwrapAndDowncast<ReadableStream>(cx, streamObj));
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -571,7 +571,7 @@ JS_PUBLIC_API bool JS::ReadableStreamRea
 
   Rooted<ReadableStreamReader*> unwrappedReader(
       cx, APIUnwrapAndDowncast<ReadableStreamReader>(cx, readerObj));
-  if (!unwrappedReader) {
+  if (!unwrappedReader) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(unwrappedReader->forAuthorCode() == ForAuthorCodeBool::No,
diff --git a/js/src/builtin/streams/TeeState.cpp b/js/src/builtin/streams/TeeState.cpp
--- a/js/src/builtin/streams/TeeState.cpp
+++ b/js/src/builtin/streams/TeeState.cpp
@@ -27,13 +27,13 @@ using JS::Rooted;
 /* static */ TeeState* TeeState::create(
     JSContext* cx, Handle<ReadableStream*> unwrappedStream) {
   Rooted<TeeState*> state(cx, NewBuiltinClassInstance<TeeState>(cx));
-  if (!state) {
+  if (!state) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   Rooted<PromiseObject*> cancelPromise(
       cx, PromiseObject::createSkippingExecutor(cx));
-  if (!cancelPromise) {
+  if (!cancelPromise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/builtin/streams/WritableStream.cpp b/js/src/builtin/streams/WritableStream.cpp
--- a/js/src/builtin/streams/WritableStream.cpp
+++ b/js/src/builtin/streams/WritableStream.cpp
@@ -62,7 +62,7 @@ bool WritableStream::constructor(JSConte
 
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (!ThrowIfNotConstructing(cx, args, "WritableStream")) {
+  if (!ThrowIfNotConstructing(cx, args, "WritableStream")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -70,7 +70,7 @@ bool WritableStream::constructor(JSConte
   Rooted<Value> underlyingSink(cx, args.get(0));
   if (underlyingSink.isUndefined()) {
     JSObject* emptyObj = NewBuiltinClassInstance<PlainObject>(cx);
-    if (!emptyObj) {
+    if (!emptyObj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     underlyingSink = ObjectValue(*emptyObj);
@@ -79,7 +79,7 @@ bool WritableStream::constructor(JSConte
   Rooted<Value> strategy(cx, args.get(1));
   if (strategy.isUndefined()) {
     JSObject* emptyObj = NewBuiltinClassInstance<PlainObject>(cx);
-    if (!emptyObj) {
+    if (!emptyObj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     strategy = ObjectValue(*emptyObj);
@@ -90,12 +90,12 @@ bool WritableStream::constructor(JSConte
   // Step 1: Perform ! InitializeWritableStream(this).
   Rooted<JSObject*> proto(cx);
   if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_WritableStream,
-                                          &proto)) {
+                                          &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   Rooted<WritableStream*> stream(cx,
                                  WritableStream::create(cx, nullptr, proto));
-  if (!stream) {
+  if (!stream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -114,12 +114,12 @@ bool WritableStream::constructor(JSConte
 
   // Step 4: Let type be ? GetV(underlyingSink, "type").
   Rooted<Value> type(cx);
-  if (!GetProperty(cx, underlyingSink, cx->names().type, &type)) {
+  if (!GetProperty(cx, underlyingSink, cx->names().type, &type)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Step 5: If type is not undefined, throw a RangeError exception.
-  if (!type.isUndefined()) {
+  if (!type.isUndefined()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_READABLESTREAM_UNDERLYINGSINK_TYPE_WRONG);
     return false;
@@ -183,7 +183,7 @@ static bool WritableStream_abort(JSConte
   //         with a TypeError exception.
   Rooted<WritableStream*> unwrappedStream(
       cx, UnwrapAndTypeCheckThis<WritableStream>(cx, args, "abort"));
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return ReturnPromiseRejectedWithPendingError(cx, args);
   }
 
@@ -216,7 +216,7 @@ static bool WritableStream_close(JSConte
   //         with a TypeError exception.
   Rooted<WritableStream*> unwrappedStream(
       cx, UnwrapAndTypeCheckThis<WritableStream>(cx, args, "close"));
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return ReturnPromiseRejectedWithPendingError(cx, args);
   }
 
@@ -255,7 +255,7 @@ static bool WritableStream_getWriter(JSC
   // Step 1: If ! WritableStream(this) is false, throw a TypeError exception.
   Rooted<WritableStream*> unwrappedStream(
       cx, UnwrapAndTypeCheckThis<WritableStream>(cx, args, "getWriter"));
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/builtin/streams/WritableStreamDefaultController.cpp b/js/src/builtin/streams/WritableStreamDefaultController.cpp
--- a/js/src/builtin/streams/WritableStreamDefaultController.cpp
+++ b/js/src/builtin/streams/WritableStreamDefaultController.cpp
@@ -55,7 +55,7 @@ static bool WritableStreamDefaultControl
   Rooted<WritableStreamDefaultController*> unwrappedController(
       cx, UnwrapAndTypeCheckThis<WritableStreamDefaultController>(cx, args,
                                                                   "error"));
-  if (!unwrappedController) {
+  if (!unwrappedController) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/builtin/streams/WritableStreamDefaultControllerOperations.cpp b/js/src/builtin/streams/WritableStreamDefaultControllerOperations.cpp
--- a/js/src/builtin/streams/WritableStreamDefaultControllerOperations.cpp
+++ b/js/src/builtin/streams/WritableStreamDefaultControllerOperations.cpp
@@ -80,7 +80,7 @@ JSObject* js::WritableStreamControllerAb
   if (unwrappedAbortMethod.isUndefined()) {
     // CreateAlgorithmFromUnderlyingMethod step 7.
     result = PromiseResolvedWithUndefined(cx);
-    if (!result) {
+    if (!result) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
@@ -93,13 +93,13 @@ JSObject* js::WritableStreamControllerAb
       cx->check(underlyingSink);
 
       Rooted<Value> wrappedReason(cx, reason);
-      if (!cx->compartment()->wrap(cx, &wrappedReason)) {
+      if (!cx->compartment()->wrap(cx, &wrappedReason)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
       result =
           PromiseCall(cx, unwrappedAbortMethod, underlyingSink, wrappedReason);
-      if (!result) {
+      if (!result) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -250,7 +250,7 @@ bool js::WritableStreamControllerStartFa
   // Done elsewhere in the standard: Create the new controller.
   Rooted<WritableStreamDefaultController*> controller(
       cx, NewBuiltinClassInstance<WritableStreamDefaultController>(cx));
-  if (!controller) {
+  if (!controller) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -267,7 +267,7 @@ bool js::WritableStreamControllerStartFa
   stream->setController(controller);
 
   // Step 5: Perform ! ResetQueue(controller).
-  if (!ResetQueue(cx, controller)) {
+  if (!ResetQueue(cx, controller)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -297,7 +297,7 @@ bool js::WritableStreamControllerStartFa
       WritableStreamDefaultControllerGetBackpressure(controller);
 
   // Step 13: Perform ! WritableStreamUpdateBackpressure(stream, backpressure).
-  if (!WritableStreamUpdateBackpressure(cx, stream, backpressure)) {
+  if (!WritableStreamUpdateBackpressure(cx, stream, backpressure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -315,7 +315,7 @@ bool js::WritableStreamControllerStartFa
   // Step 15: Let startPromise be a promise resolved with startResult.
   Rooted<JSObject*> startPromise(
       cx, PromiseObject::unforgeableResolve(cx, startResult));
-  if (!startPromise) {
+  if (!startPromise) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -329,7 +329,7 @@ bool js::WritableStreamControllerStartFa
   //    Perform ! WritableStreamDealWithRejection(stream, r).
   Rooted<JSObject*> onStartFulfilled(
       cx, NewHandler(cx, WritableStreamControllerStartHandler, controller));
-  if (!onStartFulfilled) {
+  if (!onStartFulfilled) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   Rooted<JSObject*> onStartRejected(
@@ -484,7 +484,7 @@ bool js::WritableStreamDefaultController
       cx->check(unwrappedStrategySize);
 
       Rooted<Value> wrappedChunk(cx, chunk);
-      if (!cx->compartment()->wrap(cx, &wrappedChunk)) {
+      if (!cx->compartment()->wrap(cx, &wrappedChunk)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -504,7 +504,7 @@ bool js::WritableStreamDefaultController
   }
 
   // Step 2: If returnValue is an abrupt completion,
-  if (!cx->isExceptionPending() || !cx->getPendingException(returnValue)) {
+  if (!cx->isExceptionPending() || !cx->getPendingException(returnValue)) {MOZ_RELEASE_ASSERT(0);
     // Uncatchable error.  Die immediately without erroring the stream.
     return false;
   }
@@ -554,7 +554,7 @@ bool js::WritableStreamDefaultController
   // Step 3: If enqueueResult is an abrupt completion,
   if (!succeeded) {
     Rooted<Value> enqueueResult(cx);
-    if (!cx->isExceptionPending() || !cx->getPendingException(&enqueueResult)) {
+    if (!cx->isExceptionPending() || !cx->getPendingException(&enqueueResult)) {MOZ_RELEASE_ASSERT(0);
       // Uncatchable error.  Die immediately without erroring the stream.
       return false;
     }
@@ -695,7 +695,7 @@ bool js::WritableStreamDefaultController
   //           following steps:
   // Step 6.b.ii: Return ! PromiseCall(method, underlyingObject, extraArgs).
   Rooted<Value> closeMethod(cx, unwrappedController->closeMethod());
-  if (!cx->compartment()->wrap(cx, &closeMethod)) {
+  if (!cx->compartment()->wrap(cx, &closeMethod)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -747,12 +747,12 @@ bool js::WritableStreamDefaultController
   //              elements of extraArgs in order.
   // Step 6.c.ii: Return ! PromiseCall(method, underlyingObject, fullArgs).
   Rooted<Value> writeMethod(cx, unwrappedController->writeMethod());
-  if (!cx->compartment()->wrap(cx, &writeMethod)) {
+  if (!cx->compartment()->wrap(cx, &writeMethod)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   Rooted<Value> underlyingSink(cx, unwrappedController->underlyingSink());
-  if (!cx->compartment()->wrap(cx, &underlyingSink)) {
+  if (!cx->compartment()->wrap(cx, &underlyingSink)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -819,7 +819,7 @@ bool js::WritableStreamDefaultController
       cx, TargetFromHandler<WritableStream>(args));
 
   // Step 4.a: Perform ! WritableStreamFinishInFlightWrite(stream).
-  if (!WritableStreamFinishInFlightWrite(cx, unwrappedStream)) {
+  if (!WritableStreamFinishInFlightWrite(cx, unwrappedStream)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -842,7 +842,7 @@ bool js::WritableStreamDefaultController
 
     // Step 4.e.ii: Perform
     //              ! WritableStreamUpdateBackpressure(stream, backpressure).
-    if (!WritableStreamUpdateBackpressure(cx, unwrappedStream, backpressure)) {
+    if (!WritableStreamUpdateBackpressure(cx, unwrappedStream, backpressure)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -940,7 +940,7 @@ bool WritableStreamDefaultControllerProc
     onRejectedFunc = WritableStreamWriteFailedHandler;
 
     Rooted<Value> chunk(cx, PeekQueueValue(unwrappedQueue));
-    if (!cx->compartment()->wrap(cx, &chunk)) {
+    if (!cx->compartment()->wrap(cx, &chunk)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -954,12 +954,12 @@ bool WritableStreamDefaultControllerProc
     sinkWriteOrClosePromise =
         PerformWriteAlgorithm(cx, unwrappedController, chunk);
   }
-  if (!sinkWriteOrClosePromise) {
+  if (!sinkWriteOrClosePromise) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Rooted<JSObject*> stream(cx, unwrappedController->stream());
-  if (!cx->compartment()->wrap(cx, &stream)) {
+  if (!cx->compartment()->wrap(cx, &stream)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -968,7 +968,7 @@ bool WritableStreamDefaultControllerProc
   // Step 8: Upon rejection of sinkClosePromise with reason reason,
   // Step 5: Upon rejection of sinkWritePromise with reason,
   Rooted<JSObject*> onFulfilled(cx, NewHandler(cx, onFulfilledFunc, stream));
-  if (!onFulfilled) {
+  if (!onFulfilled) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   Rooted<JSObject*> onRejected(cx, NewHandler(cx, onRejectedFunc, stream));
diff --git a/js/src/builtin/streams/WritableStreamDefaultWriter.cpp b/js/src/builtin/streams/WritableStreamDefaultWriter.cpp
--- a/js/src/builtin/streams/WritableStreamDefaultWriter.cpp
+++ b/js/src/builtin/streams/WritableStreamDefaultWriter.cpp
@@ -64,14 +64,14 @@ js::CreateWritableStreamDefaultWriter(JS
                                       Handle<JSObject*> proto /* = nullptr */) {
   Rooted<WritableStreamDefaultWriter*> writer(
       cx, NewObjectWithClassProto<WritableStreamDefaultWriter>(cx, proto));
-  if (!writer) {
+  if (!writer) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   // Step 3: Set this.[[ownerWritableStream]] to stream.
   {
     Rooted<JSObject*> stream(cx, unwrappedStream);
-    if (!cx->compartment()->wrap(cx, &stream)) {
+    if (!cx->compartment()->wrap(cx, &stream)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     writer->setStream(stream);
@@ -95,14 +95,14 @@ js::CreateWritableStreamDefaultWriter(JS
     else {
       promise = PromiseResolvedWithUndefined(cx);
     }
-    if (!promise) {
+    if (!promise) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     writer->setReadyPromise(promise);
 
     // Step 6.c: Set this.[[closedPromise]] to a new promise.
     promise = PromiseObject::createSkippingExecutor(cx);
-    if (!promise) {
+    if (!promise) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -112,7 +112,7 @@ js::CreateWritableStreamDefaultWriter(JS
   else if (unwrappedStream->closed()) {
     // Step 8.a: Set this.[[readyPromise]] to a promise resolved with undefined.
     PromiseObject* readyPromise = PromiseResolvedWithUndefined(cx);
-    if (!readyPromise) {
+    if (!readyPromise) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -121,7 +121,7 @@ js::CreateWritableStreamDefaultWriter(JS
     // Step 8.b: Set this.[[closedPromise]] to a promise resolved with
     //           undefined.
     PromiseObject* closedPromise = PromiseResolvedWithUndefined(cx);
-    if (!closedPromise) {
+    if (!closedPromise) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -129,7 +129,7 @@ js::CreateWritableStreamDefaultWriter(JS
   } else {
     // Wrap stream.[[StoredError]] just once for either step 7 or step 9.
     Rooted<Value> storedError(cx, unwrappedStream->storedError());
-    if (!cx->compartment()->wrap(cx, &storedError)) {
+    if (!cx->compartment()->wrap(cx, &storedError)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -139,7 +139,7 @@ js::CreateWritableStreamDefaultWriter(JS
       //           stream.[[storedError]].
       Rooted<JSObject*> promise(
           cx, PromiseObject::unforgeableReject(cx, storedError));
-      if (!promise) {
+      if (!promise) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -150,7 +150,7 @@ js::CreateWritableStreamDefaultWriter(JS
 
       // Step 7.c: Set this.[[closedPromise]] to a new promise.
       JSObject* closedPromise = PromiseObject::createSkippingExecutor(cx);
-      if (!closedPromise) {
+      if (!closedPromise) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -167,7 +167,7 @@ js::CreateWritableStreamDefaultWriter(JS
       // Step 9.c: Set this.[[readyPromise]] to a promise rejected with
       //           storedError.
       promise = PromiseObject::unforgeableReject(cx, storedError);
-      if (!promise) {
+      if (!promise) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -179,7 +179,7 @@ js::CreateWritableStreamDefaultWriter(JS
       // Step 9.e: Set this.[[closedPromise]] to a promise rejected with
       //           storedError.
       promise = PromiseObject::unforgeableReject(cx, storedError);
-      if (!promise) {
+      if (!promise) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -216,7 +216,7 @@ bool WritableStreamDefaultWriter::constr
 
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (!ThrowIfNotConstructing(cx, args, "WritableStreamDefaultWriter")) {
+  if (!ThrowIfNotConstructing(cx, args, "WritableStreamDefaultWriter")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -239,7 +239,7 @@ bool WritableStreamDefaultWriter::constr
 
   // Implicit in the spec: Find the prototype object to use.
   Rooted<JSObject*> proto(cx);
-  if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_Null, &proto)) {
+  if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_Null, &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -267,7 +267,7 @@ bool WritableStreamDefaultWriter::constr
   Rooted<WritableStreamDefaultWriter*> unwrappedWriter(
       cx, UnwrapAndTypeCheckThis<WritableStreamDefaultWriter>(cx, args,
                                                               "get closed"));
-  if (!unwrappedWriter) {
+  if (!unwrappedWriter) {MOZ_RELEASE_ASSERT(0);
     return ReturnPromiseRejectedWithPendingError(cx, args);
   }
 
@@ -294,7 +294,7 @@ bool WritableStreamDefaultWriter::constr
   Rooted<WritableStreamDefaultWriter*> unwrappedWriter(
       cx, UnwrapAndTypeCheckThis<WritableStreamDefaultWriter>(
               cx, args, "get desiredSize"));
-  if (!unwrappedWriter) {
+  if (!unwrappedWriter) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -331,7 +331,7 @@ bool WritableStreamDefaultWriter::constr
   Rooted<WritableStreamDefaultWriter*> unwrappedWriter(
       cx, UnwrapAndTypeCheckThis<WritableStreamDefaultWriter>(cx, args,
                                                               "get ready"));
-  if (!unwrappedWriter) {
+  if (!unwrappedWriter) {MOZ_RELEASE_ASSERT(0);
     return ReturnPromiseRejectedWithPendingError(cx, args);
   }
 
@@ -358,7 +358,7 @@ bool WritableStreamDefaultWriter::constr
   Rooted<WritableStreamDefaultWriter*> unwrappedWriter(
       cx,
       UnwrapAndTypeCheckThis<WritableStreamDefaultWriter>(cx, args, "abort"));
-  if (!unwrappedWriter) {
+  if (!unwrappedWriter) {MOZ_RELEASE_ASSERT(0);
     return ReturnPromiseRejectedWithPendingError(cx, args);
   }
 
@@ -395,7 +395,7 @@ bool WritableStreamDefaultWriter::constr
   Rooted<WritableStreamDefaultWriter*> unwrappedWriter(
       cx,
       UnwrapAndTypeCheckThis<WritableStreamDefaultWriter>(cx, args, "close"));
-  if (!unwrappedWriter) {
+  if (!unwrappedWriter) {MOZ_RELEASE_ASSERT(0);
     return ReturnPromiseRejectedWithPendingError(cx, args);
   }
 
@@ -409,7 +409,7 @@ bool WritableStreamDefaultWriter::constr
   }
 
   WritableStream* unwrappedStream = UnwrapStreamFromWriter(cx, unwrappedWriter);
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -445,7 +445,7 @@ bool WritableStreamDefaultWriter::constr
   Rooted<WritableStreamDefaultWriter*> unwrappedWriter(
       cx,
       UnwrapAndTypeCheckThis<WritableStreamDefaultWriter>(cx, args, "close"));
-  if (!unwrappedWriter) {
+  if (!unwrappedWriter) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -490,7 +490,7 @@ bool WritableStreamDefaultWriter::constr
   Rooted<WritableStreamDefaultWriter*> unwrappedWriter(
       cx,
       UnwrapAndTypeCheckThis<WritableStreamDefaultWriter>(cx, args, "write"));
-  if (!unwrappedWriter) {
+  if (!unwrappedWriter) {MOZ_RELEASE_ASSERT(0);
     return ReturnPromiseRejectedWithPendingError(cx, args);
   }
 
diff --git a/js/src/builtin/streams/WritableStreamOperations.cpp b/js/src/builtin/streams/WritableStreamOperations.cpp
--- a/js/src/builtin/streams/WritableStreamOperations.cpp
+++ b/js/src/builtin/streams/WritableStreamOperations.cpp
@@ -72,7 +72,7 @@ using JS::Value;
   // WritableStream object. We instead create it here and return it below.
   Rooted<WritableStream*> stream(
       cx, NewObjectWithClassProto<WritableStream>(cx, proto));
-  if (!stream) {
+  if (!stream) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -144,7 +144,7 @@ JSObject* js::WritableStreamAbort(JSCont
   if (unwrappedStream->hasPendingAbortRequest()) {
     Rooted<JSObject*> pendingPromise(
         cx, unwrappedStream->pendingAbortRequestPromise());
-    if (!cx->compartment()->wrap(cx, &pendingPromise)) {
+    if (!cx->compartment()->wrap(cx, &pendingPromise)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     return pendingPromise;
@@ -155,7 +155,7 @@ JSObject* js::WritableStreamAbort(JSCont
 
   // Step 7: Let promise be a new promise (reordered).
   Rooted<PromiseObject*> promise(cx, PromiseObject::createSkippingExecutor(cx));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -178,7 +178,7 @@ JSObject* js::WritableStreamAbort(JSCont
 
     JS::Compartment* comp = cx->compartment();
     if (!comp->wrap(cx, &wrappedPromise) ||
-        !comp->wrap(cx, &wrappedPendingReason)) {
+        !comp->wrap(cx, &wrappedPendingReason)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -224,7 +224,7 @@ JSObject* js::WritableStreamClose(JSCont
 
   // Step 5: Let promise be a new promise.
   Rooted<PromiseObject*> promise(cx, PromiseObject::createSkippingExecutor(cx));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -232,7 +232,7 @@ JSObject* js::WritableStreamClose(JSCont
   {
     AutoRealm ar(cx, unwrappedStream);
     Rooted<JSObject*> wrappedPromise(cx, promise);
-    if (!cx->compartment()->wrap(cx, &wrappedPromise)) {
+    if (!cx->compartment()->wrap(cx, &wrappedPromise)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -244,17 +244,17 @@ JSObject* js::WritableStreamClose(JSCont
   //         and state is "writable", resolve writer.[[readyPromise]] with
   //         undefined.
   if (unwrappedStream->hasWriter() && unwrappedStream->backpressure() &&
-      unwrappedStream->writable()) {
+      unwrappedStream->writable()) {MOZ_RELEASE_ASSERT(0);
     Rooted<WritableStreamDefaultWriter*> unwrappedWriter(
         cx, UnwrapWriterFromStream(cx, unwrappedStream));
-    if (!unwrappedWriter) {
+    if (!unwrappedWriter) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     if (!ResolveUnwrappedPromiseWithUndefined(
-            cx, unwrappedWriter->readyPromise())) {
+            cx, unwrappedWriter->readyPromise())) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   // Step 9: Perform
@@ -286,7 +286,7 @@ JSObject* js::WritableStreamClose(JSCont
 
   // Step 3: Let promise be a new promise.
   Rooted<PromiseObject*> promise(cx, PromiseObject::createSkippingExecutor(cx));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -355,7 +355,7 @@ static bool WritableStreamHasOperationMa
   {
     AutoRealm ar(cx, unwrappedStream);
     Rooted<Value> wrappedReason(cx, reason);
-    if (!cx->compartment()->wrap(cx, &wrappedReason)) {
+    if (!cx->compartment()->wrap(cx, &wrappedReason)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     unwrappedStream->setStoredError(wrappedReason);
@@ -368,12 +368,12 @@ static bool WritableStreamHasOperationMa
   if (unwrappedStream->hasWriter()) {
     Rooted<WritableStreamDefaultWriter*> unwrappedWriter(
         cx, UnwrapWriterFromStream(cx, unwrappedStream));
-    if (!unwrappedWriter) {
+    if (!unwrappedWriter) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (!WritableStreamDefaultWriterEnsureReadyPromiseRejected(
-            cx, unwrappedWriter, reason)) {
+            cx, unwrappedWriter, reason)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -401,7 +401,7 @@ static bool AbortRequestPromiseFulfilled
 
   // Step 13.a: Resolve abortRequest.[[promise]] with undefined.
   Rooted<JSObject*> abortRequestPromise(cx, TargetFromHandler<JSObject>(args));
-  if (!ResolvePromise(cx, abortRequestPromise, UndefinedHandleValue)) {
+  if (!ResolvePromise(cx, abortRequestPromise, UndefinedHandleValue)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -410,7 +410,7 @@ static bool AbortRequestPromiseFulfilled
   Rooted<WritableStream*> unwrappedStream(
       cx, UnwrapAndDowncastObject<WritableStream>(
               cx, ExtraFromHandler<JSObject>(args)));
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -432,7 +432,7 @@ static bool AbortRequestPromiseRejectedH
 
   // Step 14.a: Reject abortRequest.[[promise]] with reason.
   Rooted<JSObject*> abortRequestPromise(cx, TargetFromHandler<JSObject>(args));
-  if (!RejectPromise(cx, abortRequestPromise, args.get(0))) {
+  if (!RejectPromise(cx, abortRequestPromise, args.get(0))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -441,7 +441,7 @@ static bool AbortRequestPromiseRejectedH
   Rooted<WritableStream*> unwrappedStream(
       cx, UnwrapAndDowncastObject<WritableStream>(
               cx, ExtraFromHandler<JSObject>(args)));
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -473,14 +473,14 @@ static bool AbortRequestPromiseRejectedH
   {
     Rooted<WritableStreamDefaultController*> unwrappedController(
         cx, unwrappedStream->controller());
-    if (!WritableStreamControllerErrorSteps(cx, unwrappedController)) {
+    if (!WritableStreamControllerErrorSteps(cx, unwrappedController)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // Step 5: Let storedError be stream.[[storedError]].
   Rooted<Value> storedError(cx, unwrappedStream->storedError());
-  if (!cx->compartment()->wrap(cx, &storedError)) {
+  if (!cx->compartment()->wrap(cx, &storedError)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -494,7 +494,7 @@ static bool AbortRequestPromiseRejectedH
     for (uint32_t i = 0; i < len; i++) {
       // Step 6.a: Reject writeRequest with storedError.
       writeRequest = &unwrappedWriteRequests->get(i).toObject();
-      if (!RejectUnwrappedPromiseWithError(cx, &writeRequest, storedError)) {
+      if (!RejectUnwrappedPromiseWithError(cx, &writeRequest, storedError)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -519,7 +519,7 @@ static bool AbortRequestPromiseRejectedH
   // Step 10: Set stream.[[pendingAbortRequest]] to undefined.
   Rooted<Value> abortRequestReason(
       cx, unwrappedStream->pendingAbortRequestReason());
-  if (!cx->compartment()->wrap(cx, &abortRequestReason)) {
+  if (!cx->compartment()->wrap(cx, &abortRequestReason)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   Rooted<JSObject*> abortRequestPromise(
@@ -532,7 +532,7 @@ static bool AbortRequestPromiseRejectedH
   if (wasAlreadyErroring) {
     // Step 11.a: Reject abortRequest.[[promise]] with storedError.
     if (!RejectUnwrappedPromiseWithError(cx, &abortRequestPromise,
-                                         storedError)) {
+                                         storedError)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -551,17 +551,17 @@ static bool AbortRequestPromiseRejectedH
   Rooted<JSObject*> promise(
       cx, WritableStreamControllerAbortSteps(cx, unwrappedController,
                                              abortRequestReason));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   cx->check(promise);
 
-  if (!cx->compartment()->wrap(cx, &abortRequestPromise)) {
+  if (!cx->compartment()->wrap(cx, &abortRequestPromise)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Rooted<JSObject*> stream(cx, unwrappedStream);
-  if (!cx->compartment()->wrap(cx, &stream)) {
+  if (!cx->compartment()->wrap(cx, &stream)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -570,7 +570,7 @@ static bool AbortRequestPromiseRejectedH
   Rooted<JSObject*> onFulfilled(
       cx, NewHandlerWithExtra(cx, AbortRequestPromiseFulfilledHandler,
                               abortRequestPromise, stream));
-  if (!onFulfilled) {
+  if (!onFulfilled) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   Rooted<JSObject*> onRejected(
@@ -644,7 +644,7 @@ static bool AbortRequestPromiseRejectedH
 
   // Step 2: Resolve stream.[[inFlightCloseRequest]] with undefined.
   if (!ResolveUnwrappedPromiseWithUndefined(
-          cx, &unwrappedStream->inFlightCloseRequest().toObject())) {
+          cx, &unwrappedStream->inFlightCloseRequest().toObject())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -666,7 +666,7 @@ static bool AbortRequestPromiseRejectedH
       // Step 6.b.i: Resolve stream.[[pendingAbortRequest]].[[promise]] with
       //             undefined.
       if (!ResolveUnwrappedPromiseWithUndefined(
-              cx, unwrappedStream->pendingAbortRequestPromise())) {
+              cx, unwrappedStream->pendingAbortRequestPromise())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -684,7 +684,7 @@ static bool AbortRequestPromiseRejectedH
   if (unwrappedStream->hasWriter()) {
     WritableStreamDefaultWriter* unwrappedWriter =
         UnwrapWriterFromStream(cx, unwrappedStream);
-    if (!unwrappedWriter) {
+    if (!unwrappedWriter) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -718,7 +718,7 @@ static bool AbortRequestPromiseRejectedH
 
   // Step 2: Reject stream.[[inFlightCloseRequest]] with error.
   if (!RejectUnwrappedPromiseWithError(
-          cx, &unwrappedStream->inFlightCloseRequest().toObject(), error)) {
+          cx, &unwrappedStream->inFlightCloseRequest().toObject(), error)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -819,7 +819,7 @@ void js::WritableStreamMarkFirstWriteReq
   MOZ_ASSERT(unwrappedStream->errored());
 
   Rooted<Value> storedError(cx, unwrappedStream->storedError());
-  if (!cx->compartment()->wrap(cx, &storedError)) {
+  if (!cx->compartment()->wrap(cx, &storedError)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -830,7 +830,7 @@ void js::WritableStreamMarkFirstWriteReq
 
     // Step 2.b: Reject stream.[[closeRequest]] with stream.[[storedError]].
     if (!RejectUnwrappedPromiseWithError(
-            cx, &unwrappedStream->closeRequest().toObject(), storedError)) {
+            cx, &unwrappedStream->closeRequest().toObject(), storedError)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -843,13 +843,13 @@ void js::WritableStreamMarkFirstWriteReq
   if (unwrappedStream->hasWriter()) {
     Rooted<WritableStreamDefaultWriter*> unwrappedWriter(
         cx, UnwrapWriterFromStream(cx, unwrappedStream));
-    if (!unwrappedWriter) {
+    if (!unwrappedWriter) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // Step 4.a: Reject writer.[[closedPromise]] with stream.[[storedError]].
     if (!RejectUnwrappedPromiseWithError(cx, unwrappedWriter->closedPromise(),
-                                         storedError)) {
+                                         storedError)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -886,7 +886,7 @@ void js::WritableStreamMarkFirstWriteReq
       backpressure != unwrappedStream->backpressure()) {
     Rooted<WritableStreamDefaultWriter*> unwrappedWriter(
         cx, UnwrapWriterFromStream(cx, unwrappedStream));
-    if (!unwrappedWriter) {
+    if (!unwrappedWriter) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -894,12 +894,12 @@ void js::WritableStreamMarkFirstWriteReq
     //           promise.
     if (backpressure) {
       Rooted<JSObject*> promise(cx, PromiseObject::createSkippingExecutor(cx));
-      if (!promise) {
+      if (!promise) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       AutoRealm ar(cx, unwrappedWriter);
-      if (!cx->compartment()->wrap(cx, &promise)) {
+      if (!cx->compartment()->wrap(cx, &promise)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       unwrappedWriter->setReadyPromise(promise);
diff --git a/js/src/builtin/streams/WritableStreamWriterOperations.cpp b/js/src/builtin/streams/WritableStreamWriterOperations.cpp
--- a/js/src/builtin/streams/WritableStreamWriterOperations.cpp
+++ b/js/src/builtin/streams/WritableStreamWriterOperations.cpp
@@ -82,7 +82,7 @@ PromiseObject* js::WritableStreamDefault
   MOZ_ASSERT(unwrappedWriter->hasStream());
   Rooted<WritableStream*> unwrappedStream(
       cx, UnwrapStreamFromWriter(cx, unwrappedWriter));
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return PromiseRejectedWithPendingError(cx);
   }
 
@@ -103,7 +103,7 @@ PromiseObject* js::WritableStreamDefault
 
   // Step 7: Let promise be a new promise.
   Rooted<PromiseObject*> promise(cx, PromiseObject::createSkippingExecutor(cx));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -111,7 +111,7 @@ PromiseObject* js::WritableStreamDefault
   {
     AutoRealm ar(cx, unwrappedStream);
     Rooted<JSObject*> closeRequest(cx, promise);
-    if (!cx->compartment()->wrap(cx, &closeRequest)) {
+    if (!cx->compartment()->wrap(cx, &closeRequest)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -122,7 +122,7 @@ PromiseObject* js::WritableStreamDefault
   //         writer.[[readyPromise]] with undefined.
   if (unwrappedStream->backpressure() && unwrappedStream->writable()) {
     if (!ResolveUnwrappedPromiseWithUndefined(
-            cx, unwrappedWriter->readyPromise())) {
+            cx, unwrappedWriter->readyPromise())) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -145,25 +145,25 @@ PromiseObject* js::WritableStreamDefault
  * WritableStreamDefaultWriterCloseWithErrorPropagation ( writer )
  */
 PromiseObject* js::WritableStreamDefaultWriterCloseWithErrorPropagation(
-    JSContext* cx, Handle<WritableStreamDefaultWriter*> unwrappedWriter) {
+    JSContext* cx, Handle<WritableStreamDefaultWriter*> unwrappedWriter) {MOZ_RELEASE_ASSERT(0);
   // Step 1: Let stream be writer.[[ownerWritableStream]].
   // Step 2: Assert: stream is not undefined.
   WritableStream* unwrappedStream = UnwrapStreamFromWriter(cx, unwrappedWriter);
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Step 3: Let state be stream.[[state]].
   // Step 4: If ! WritableStreamCloseQueuedOrInFlight(stream) is true or state
   //         is "closed", return a promise resolved with undefined.
   if (WritableStreamCloseQueuedOrInFlight(unwrappedStream) ||
-      unwrappedStream->closed()) {
+      unwrappedStream->closed()) {MOZ_RELEASE_ASSERT(0);
     return PromiseResolvedWithUndefined(cx);
   }
 
   // Step 5: If state is "errored", return a promise rejected with
   //         stream.[[storedError]].
-  if (unwrappedStream->errored()) {
+  if (unwrappedStream->errored()) {MOZ_RELEASE_ASSERT(0);
     Rooted<Value> storedError(cx, unwrappedStream->storedError());
     if (!cx->compartment()->wrap(cx, &storedError)) {
       return nullptr;
@@ -190,14 +190,14 @@ static bool EnsurePromiseRejected(
   Rooted<PromiseObject*> unwrappedPromise(
       cx, UnwrapAndDowncastObject<PromiseObject>(
               cx, (unwrappedWriter->*getField)()));
-  if (!unwrappedPromise) {
+  if (!unwrappedPromise) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // 4.6.{5,6} step 1: If writer.[[<field>]].[[PromiseState]] is "pending",
   //                   reject writer.[[<field>]] with error.
   if (unwrappedPromise->state() == JS::PromiseState::Pending) {
-    if (!RejectUnwrappedPromiseWithError(cx, unwrappedPromise, error)) {
+    if (!RejectUnwrappedPromiseWithError(cx, unwrappedPromise, error)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -205,7 +205,7 @@ static bool EnsurePromiseRejected(
     //                   with error.
     Rooted<JSObject*> rejectedWithError(
         cx, PromiseObject::unforgeableReject(cx, error));
-    if (!rejectedWithError) {
+    if (!rejectedWithError) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -262,7 +262,7 @@ bool js::WritableStreamDefaultWriterGetD
   // Step 1: Let stream be writer.[[ownerWritableStream]].
   const WritableStream* unwrappedStream =
       UnwrapStreamFromWriter(cx, unwrappedWriter);
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -297,7 +297,7 @@ bool js::WritableStreamDefaultWriterRele
   MOZ_ASSERT(unwrappedWriter->hasStream());
   Rooted<WritableStream*> unwrappedStream(
       cx, UnwrapStreamFromWriter(cx, unwrappedWriter));
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -318,7 +318,7 @@ bool js::WritableStreamDefaultWriterRele
   Rooted<Value> releasedError(cx);
   JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                             JSMSG_WRITABLESTREAM_CANT_RELEASE_ALREADY_CLOSED);
-  if (!cx->isExceptionPending() || !GetAndClearException(cx, &releasedError)) {
+  if (!cx->isExceptionPending() || !GetAndClearException(cx, &releasedError)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -326,7 +326,7 @@ bool js::WritableStreamDefaultWriterRele
   //         ! WritableStreamDefaultWriterEnsureReadyPromiseRejected(
   //               writer, releasedError).
   if (!WritableStreamDefaultWriterEnsureReadyPromiseRejected(
-          cx, unwrappedWriter, releasedError)) {
+          cx, unwrappedWriter, releasedError)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -360,7 +360,7 @@ PromiseObject* js::WritableStreamDefault
   MOZ_ASSERT(unwrappedWriter->hasStream());
   Rooted<WritableStream*> unwrappedStream(
       cx, UnwrapStreamFromWriter(cx, unwrappedWriter));
-  if (!unwrappedStream) {
+  if (!unwrappedStream) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -372,7 +372,7 @@ PromiseObject* js::WritableStreamDefault
   //         ! WritableStreamDefaultControllerGetChunkSize(controller, chunk).
   Rooted<Value> chunkSize(cx);
   if (!WritableStreamDefaultControllerGetChunkSize(cx, unwrappedController,
-                                                   chunk, &chunkSize)) {
+                                                   chunk, &chunkSize)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   cx->check(chunkSize);
@@ -428,7 +428,7 @@ PromiseObject* js::WritableStreamDefault
   // Step 11: Let promise be ! WritableStreamAddWriteRequest(stream).
   Rooted<PromiseObject*> promise(
       cx, WritableStreamAddWriteRequest(cx, unwrappedStream));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/ctypes/CTypes.cpp b/js/src/ctypes/CTypes.cpp
--- a/js/src/ctypes/CTypes.cpp
+++ b/js/src/ctypes/CTypes.cpp
@@ -80,7 +80,7 @@ static bool HasUnpairedSurrogate(const c
     char16_t c = *chars;
     if (unicode::IsSurrogate(c)) {
       chars++;
-      if (unicode::IsTrailSurrogate(c) || chars == end) {
+      if (unicode::IsTrailSurrogate(c) || chars == end) {MOZ_RELEASE_ASSERT(0);
         *unpaired = c;
         return true;
       }
@@ -962,7 +962,7 @@ static void BuildCStyleFunctionTypeSourc
   if (nameStr) {
     MOZ_ASSERT(ptrCount == 0);
     AppendString(cx, source, nameStr);
-  } else if (ptrCount) {
+  } else if (ptrCount) {MOZ_RELEASE_ASSERT(0);
     AppendString(cx, source, "(");
     AppendChars(source, '*', ptrCount);
     AppendString(cx, source, ")");
@@ -1111,7 +1111,7 @@ static bool ConvError(JSContext* cx, con
                       HandleObject arrObj = nullptr, unsigned arrIndex = 0) {
   JS::UniqueChars valBytes;
   const char* valStr = CTypesToSourceForError(cx, actual, valBytes);
-  if (!valStr) {
+  if (!valStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1266,7 +1266,7 @@ static bool ArrayLengthMismatch(JSContex
 
   JS::UniqueChars valBytes;
   const char* valStr = CTypesToSourceForError(cx, actual, valBytes);
-  if (!valStr) {
+  if (!valStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1291,7 +1291,7 @@ static bool ArrayLengthOverflow(JSContex
 
   JS::UniqueChars valBytes;
   const char* valStr = CTypesToSourceForError(cx, actual, valBytes);
-  if (!valStr) {
+  if (!valStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1371,12 +1371,12 @@ static bool FieldCountMismatch(JSContext
 
   JS::UniqueChars valBytes;
   const char* valStr = CTypesToSourceForError(cx, actual, valBytes);
-  if (!valStr) {
+  if (!valStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JS::UniqueChars structStr = TypeSourceForError(cx, structObj);
-  if (!structStr) {
+  if (!structStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1431,7 +1431,7 @@ static bool FieldDescriptorSizeError(JSC
   RootedValue typeVal(cx, ObjectValue(*typeObj));
   JS::UniqueChars typeBytes;
   const char* typeStr = CTypesToSourceForError(cx, typeVal, typeBytes);
-  if (!typeStr) {
+  if (!typeStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1462,7 +1462,7 @@ static bool FieldDescriptorTypeError(JSC
                                      HandleId id) {
   JS::UniqueChars typeBytes;
   const char* typeStr = CTypesToSourceForError(cx, poroVal, typeBytes);
-  if (!typeStr) {
+  if (!typeStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1483,7 +1483,7 @@ static bool FieldMissingError(JSContext*
   RootedString name(cx, name_);
   RootedValue typeVal(cx, ObjectValue(*typeObj));
   const char* typeStr = CTypesToSourceForError(cx, typeVal, typeBytes);
-  if (!typeStr) {
+  if (!typeStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1503,7 +1503,7 @@ static bool FinalizerSizeError(JSContext
 
   JS::UniqueChars valBytes;
   const char* valStr = CTypesToSourceForError(cx, actual, valBytes);
-  if (!valStr) {
+  if (!valStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1522,7 +1522,7 @@ static bool FunctionArgumentLengthMismat
     HandleObject funObj, HandleObject typeObj, bool isVariadic) {
   JS::UniqueChars funStr;
   Value slot = JS::GetReservedSlot(funObj, SLOT_REFERENT);
-  if (!slot.isUndefined() && Library::IsLibrary(&slot.toObject())) {
+  if (!slot.isUndefined() && Library::IsLibrary(&slot.toObject())) {MOZ_RELEASE_ASSERT(0);
     funStr = FunctionTypeSourceForError(cx, funObj);
   } else {
     funStr = FunctionTypeSourceForError(cx, typeObj);
@@ -1576,7 +1576,7 @@ static bool FunctionReturnTypeError(JSCo
 }
 
 static bool IncompatibleCallee(JSContext* cx, const char* funName,
-                               HandleObject actualObj) {
+                               HandleObject actualObj) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(JS::StringIsASCII(funName));
 
   JS::UniqueChars valBytes;
@@ -1726,14 +1726,14 @@ static bool PropNameNonStringError(JSCon
                                    unsigned argIndex = 0) {
   JS::UniqueChars valBytes;
   const char* valStr = CTypesToSourceForError(cx, actual, valBytes);
-  if (!valStr) {
+  if (!valStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JS::UniqueChars idBytes;
   RootedValue idVal(cx, IdToValue(id));
   const char* propStr = CTypesToSourceForError(cx, idVal, idBytes);
-  if (!propStr) {
+  if (!propStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1801,7 +1801,7 @@ static bool SizeMismatchCastError(JSCont
                                   HandleObject targetTypeObj, size_t sourceSize,
                                   size_t targetSize) {
   JS::UniqueChars sourceTypeStr = TypeSourceForError(cx, sourceTypeObj);
-  if (!sourceTypeStr) {
+  if (!sourceTypeStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1837,7 +1837,7 @@ static bool UndefinedSizePointerError(JS
 }
 
 static bool VariadicArgumentTypeError(JSContext* cx, uint32_t index,
-                                      HandleValue actual) {
+                                      HandleValue actual) {MOZ_RELEASE_ASSERT(0);
   JS::UniqueChars valBytes;
   const char* valStr = CTypesToSourceForError(cx, actual, valBytes);
   if (!valStr) {
@@ -1877,13 +1877,13 @@ static bool DefineToStringTag(JSContext*
 static JSObject* InitCTypeClass(JSContext* cx, HandleObject ctypesObj) {
   JSFunction* fun = JS_DefineFunction(cx, ctypesObj, "CType", ConstructAbstract,
                                       0, CTYPESCTOR_FLAGS);
-  if (!fun) {
+  if (!fun) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedObject ctor(cx, JS_GetFunctionObject(fun));
   RootedObject fnproto(cx);
-  if (!JS_GetPrototype(cx, ctor, &fnproto)) {
+  if (!JS_GetPrototype(cx, ctor, &fnproto)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   MOZ_ASSERT(ctor);
@@ -1892,9 +1892,9 @@ static JSObject* InitCTypeClass(JSContex
   // Set up ctypes.CType.prototype.
   RootedObject prototype(
       cx, JS_NewObjectWithGivenProto(cx, &sCTypeProtoClass, fnproto));
-  if (!prototype) {
+  if (!prototype) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   if (!JS_DefineProperty(cx, ctor, "prototype", prototype,
                          JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT))
@@ -1909,7 +1909,7 @@ static JSObject* InitCTypeClass(JSContex
       !JS_DefineFunctions(cx, prototype, sCTypeFunctions))
     return nullptr;
 
-  if (!DefineToStringTag(cx, prototype, "CType")) {
+  if (!DefineToStringTag(cx, prototype, "CType")) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1923,11 +1923,11 @@ static JSObject* InitCTypeClass(JSContex
 static JSObject* InitABIClass(JSContext* cx) {
   RootedObject obj(cx, JS_NewPlainObject(cx));
 
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!JS_DefineFunctions(cx, obj, sCABIFunctions)) {
+  if (!JS_DefineFunctions(cx, obj, sCABIFunctions)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1952,15 +1952,15 @@ static JSObject* InitCDataClass(JSContex
   // Set up ctypes.CData.__proto__ === ctypes.CType.prototype.
   // (Note that 'ctypes.CData instanceof Function' is still true, thanks to the
   // prototype chain.)
-  if (!JS_SetPrototype(cx, ctor, CTypeProto)) {
+  if (!JS_SetPrototype(cx, ctor, CTypeProto)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   // Set up ctypes.CData.prototype.
   RootedObject prototype(cx, JS_NewObject(cx, &sCDataProtoClass));
-  if (!prototype) {
+  if (!prototype) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   if (!JS_DefineProperty(cx, ctor, "prototype", prototype,
                          JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT))
@@ -1990,7 +1990,7 @@ static bool DefineABIConstant(JSContext*
                               const char* name, ABICode code,
                               HandleObject prototype) {
   RootedObject obj(cx, JS_NewObjectWithGivenProto(cx, &sCABIClass, prototype));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   JS_SetReservedSlot(obj, SLOT_ABICODE, Int32Value(code));
@@ -2014,33 +2014,33 @@ static bool InitTypeConstructor(
     MutableHandleObject typeProto, MutableHandleObject dataProto) {
   JSFunction* fun = js::DefineFunctionWithReserved(
       cx, parent, spec.name.string(), spec.call.op, spec.nargs, spec.flags);
-  if (!fun) {
+  if (!fun) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject obj(cx, JS_GetFunctionObject(fun));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Set up the .prototype and .prototype.constructor properties.
   typeProto.set(JS_NewObjectWithGivenProto(cx, &sCTypeProtoClass, CTypeProto));
-  if (!typeProto) {
-    return false;
-  }
+  if (!typeProto) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
 
   // Define property before proceeding, for GC safety.
   if (!JS_DefineProperty(cx, obj, "prototype", typeProto,
                          JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT))
     return false;
 
-  if (fns && !JS_DefineFunctions(cx, typeProto, fns)) {
-    return false;
-  }
-
-  if (!JS_DefineProperties(cx, typeProto, props)) {
-    return false;
-  }
+  if (fns && !JS_DefineFunctions(cx, typeProto, fns)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!JS_DefineProperties(cx, typeProto, props)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
 
   if (!JS_DefineProperty(cx, typeProto, "constructor", obj,
                          JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT))
@@ -2056,14 +2056,14 @@ static bool InitTypeConstructor(
   // as its prototype, such that it inherits the properties and functions
   // common to all CDatas.
   dataProto.set(JS_NewObjectWithGivenProto(cx, &sCDataProtoClass, CDataProto));
-  if (!dataProto) {
+  if (!dataProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Define functions and properties on the 'dataProto' object that are common
   // to all CData objects created from this type constructor. (These will
   // become functions and properties on CData objects created from this type.)
-  if (instanceFns && !JS_DefineFunctions(cx, dataProto, instanceFns)) {
+  if (instanceFns && !JS_DefineFunctions(cx, dataProto, instanceFns)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2089,23 +2089,23 @@ static JSObject* InitInt64Class(JSContex
   // Init type class and constructor
   RootedObject prototype(cx, JS_InitClass(cx, parent, nullptr, clasp, construct,
                                           0, nullptr, fs, nullptr, static_fs));
-  if (!prototype) {
+  if (!prototype) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   if (clasp == &sInt64ProtoClass) {
-    if (!DefineToStringTag(cx, prototype, "Int64")) {
+    if (!DefineToStringTag(cx, prototype, "Int64")) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
     MOZ_ASSERT(clasp == &sUInt64ProtoClass);
-    if (!DefineToStringTag(cx, prototype, "UInt64")) {
+    if (!DefineToStringTag(cx, prototype, "UInt64")) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
 
   RootedObject ctor(cx, JS_GetConstructor(cx, prototype));
-  if (!ctor) {
+  if (!ctor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2114,14 +2114,14 @@ static JSObject* InitInt64Class(JSContex
   JSNative native = (clasp == &sInt64ProtoClass) ? Int64::Join : UInt64::Join;
   JSFunction* fun = js::DefineFunctionWithReserved(cx, ctor, "join", native, 2,
                                                    CTYPESFN_FLAGS);
-  if (!fun) {
+  if (!fun) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   js::SetFunctionNativeReserved(fun, SLOT_FN_INT64PROTO,
                                 ObjectValue(*prototype));
 
-  if (!JS_FreezeObject(cx, ctor)) {
+  if (!JS_FreezeObject(cx, ctor)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (!JS_FreezeObject(cx, prototype)) {
@@ -2155,7 +2155,7 @@ static bool InitTypeClasses(JSContext* c
   //     * 'constructor' property === ctypes.CType
   //     * Provides properties and functions common to all CTypes.
   RootedObject CTypeProto(cx, InitCTypeClass(cx, ctypesObj));
-  if (!CTypeProto) {
+  if (!CTypeProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2205,9 +2205,9 @@ static bool InitTypeClasses(JSContext* c
   //     * __proto__ === 'p', the prototype object from above
   //     * 'constructor' property === 't'
   RootedObjectVector protos(cx);
-  if (!protos.resize(CTYPEPROTO_SLOTS)) {
-    return false;
-  }
+  if (!protos.resize(CTYPEPROTO_SLOTS)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
   if (!InitTypeConstructor(
           cx, ctypesObj, CTypeProto, CDataProto, sPointerFunction, nullptr,
           sPointerProps, sPointerInstanceFunctions, sPointerInstanceProps,
@@ -2247,13 +2247,13 @@ static bool InitTypeClasses(JSContext* c
   protos[SLOT_INT64PROTO].set(InitInt64Class(cx, ctypesObj, &sInt64ProtoClass,
                                              Int64::Construct, sInt64Functions,
                                              sInt64StaticFunctions));
-  if (!protos[SLOT_INT64PROTO]) {
+  if (!protos[SLOT_INT64PROTO]) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   protos[SLOT_UINT64PROTO].set(
       InitInt64Class(cx, ctypesObj, &sUInt64ProtoClass, UInt64::Construct,
                      sUInt64Functions, sUInt64StaticFunctions));
-  if (!protos[SLOT_UINT64PROTO]) {
+  if (!protos[SLOT_UINT64PROTO]) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2271,9 +2271,9 @@ static bool InitTypeClasses(JSContext* c
   AttachProtos(protos[SLOT_FUNCTIONPROTO], protos);
 
   RootedObject ABIProto(cx, InitABIClass(cx));
-  if (!ABIProto) {
-    return false;
-  }
+  if (!ABIProto) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
 
   // Attach objects representing ABI constants.
   if (!DefineABIConstant(cx, ctypesObj, "default_abi", ABI_DEFAULT, ABIProto) ||
@@ -2323,7 +2323,7 @@ static bool InitTypeClasses(JSContext* c
       cx, CType::DefineBuiltin(cx, ctypesObj, "void_t", CTypeProto, CDataProto,
                                "void", TYPE_void_t, JS::UndefinedHandleValue,
                                JS::UndefinedHandleValue, &ffi_type_void));
-  if (!typeObj) {
+  if (!typeObj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2365,7 +2365,7 @@ static bool GetObjectProperty(JSContext*
                               const char* property,
                               MutableHandleObject result) {
   RootedValue val(cx);
-  if (!JS_GetProperty(cx, obj, property, &val)) {
+  if (!JS_GetProperty(cx, obj, property, &val)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2387,40 +2387,40 @@ JS_PUBLIC_API bool JS::InitCTypesClass(J
                                        Handle<JSObject*> global) {
   // attach ctypes property to global object
   RootedObject ctypes(cx, JS_NewObject(cx, &sCTypesGlobalClass));
-  if (!ctypes) {
+  if (!ctypes) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (!JS_DefineProperty(cx, global, "ctypes", ctypes,
-                         JSPROP_READONLY | JSPROP_PERMANENT)) {
+                         JSPROP_READONLY | JSPROP_PERMANENT)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (!InitTypeClasses(cx, ctypes)) {
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // attach API functions and properties
   if (!JS_DefineFunctions(cx, ctypes, sModuleFunctions) ||
       !JS_DefineProperties(cx, ctypes, sModuleProps))
     return false;
 
-  if (!DefineToStringTag(cx, ctypes, "ctypes")) {
+  if (!DefineToStringTag(cx, ctypes, "ctypes")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Set up ctypes.CDataFinalizer.prototype.
   RootedObject ctor(cx);
-  if (!GetObjectProperty(cx, ctypes, "CDataFinalizer", &ctor)) {
+  if (!GetObjectProperty(cx, ctypes, "CDataFinalizer", &ctor)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject prototype(cx, JS_NewObject(cx, &sCDataFinalizerProtoClass));
-  if (!prototype) {
-    return false;
-  }
-
-  if (!JS_DefineFunctions(cx, prototype, sCDataFinalizerFunctions)) {
+  if (!prototype) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!JS_DefineFunctions(cx, prototype, sCDataFinalizerFunctions)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2727,7 +2727,7 @@ static bool jsvalToInteger(JSContext* cx
 
     if (CDataFinalizer::IsCDataFinalizer(obj)) {
       RootedValue innerData(cx);
-      if (!CDataFinalizer::GetValue(cx, obj, &innerData)) {
+      if (!CDataFinalizer::GetValue(cx, obj, &innerData)) {MOZ_RELEASE_ASSERT(0);
         return false;  // Nothing to convert
       }
       return jsvalToInteger(cx, innerData, result);
@@ -2918,7 +2918,7 @@ static bool jsvalToBigInteger(JSContext*
       return ConvertExact(i, result);
     }
 
-    if (CDataFinalizer::IsCDataFinalizer(obj)) {
+    if (CDataFinalizer::IsCDataFinalizer(obj)) {MOZ_RELEASE_ASSERT(0);
       RootedValue innerData(cx);
       if (!CDataFinalizer::GetValue(cx, obj, &innerData)) {
         return false;  // Nothing to convert
@@ -3007,7 +3007,7 @@ static bool jsvalToIntegerExplicit(Handl
   if (val.isObject()) {
     // Convert Int64 and UInt64 values by C-style cast.
     JSObject* obj = &val.toObject();
-    if (Int64::IsInt64(obj)) {
+    if (Int64::IsInt64(obj)) {MOZ_RELEASE_ASSERT(0);
       int64_t i = Int64Base::GetInt(obj);
       *result = IntegerType(i);
       return true;
@@ -3031,18 +3031,18 @@ static bool jsvalToPtrExplicit(JSContext
     *result = i < 0 ? uintptr_t(intptr_t(i)) : uintptr_t(i);
     return true;
   }
-  if (val.isDouble()) {
+  if (val.isDouble()) {MOZ_RELEASE_ASSERT(0);
     double d = val.toDouble();
-    if (d < 0) {
+    if (d < 0) {MOZ_RELEASE_ASSERT(0);
       // Cast through an intptr_t intermediate to sign-extend.
       intptr_t i = Convert<intptr_t>(d);
-      if (double(i) != d) {
+      if (double(i) != d) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       *result = uintptr_t(i);
       return true;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Don't silently lose bits here -- check that val really is an
     // integer value, and has the right sign.
@@ -3051,14 +3051,14 @@ static bool jsvalToPtrExplicit(JSContext
   }
   if (val.isObject()) {
     JSObject* obj = &val.toObject();
-    if (Int64::IsInt64(obj)) {
+    if (Int64::IsInt64(obj)) {MOZ_RELEASE_ASSERT(0);
       int64_t i = Int64Base::GetInt(obj);
       intptr_t p = intptr_t(i);
 
       // Make sure the integer fits in the alotted precision.
-      if (int64_t(p) != i) {
+      if (int64_t(p) != i) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       *result = uintptr_t(p);
       return true;
     }
@@ -3778,7 +3778,7 @@ static bool ExplicitConvert(JSContext* c
   // hard failure (out of memory, or some other similarly serious condition).
   // We store any pending exception in case we need to re-throw it.
   RootedValue ex(cx);
-  if (!JS_GetPendingException(cx, &ex)) {
+  if (!JS_GetPendingException(cx, &ex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4294,7 +4294,7 @@ bool CType::ConstructData(JSContext* cx,
   CallArgs args = CallArgsFromVp(argc, vp);
   // get the callee object...
   RootedObject obj(cx, &args.callee());
-  if (!CType::IsCType(obj)) {
+  if (!CType::IsCType(obj)) {MOZ_RELEASE_ASSERT(0);
     return IncompatibleCallee(cx, "CType constructor", obj);
   }
 
@@ -4328,7 +4328,7 @@ bool CType::ConstructBasic(JSContext* cx
 
   // construct a CData object
   RootedObject result(cx, CData::Create(cx, obj, nullptr, nullptr, true));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4366,7 +4366,7 @@ JSObject* CType::Create(JSContext* cx, H
   //       specific type instance 't'.
   RootedObject typeObj(cx,
                        JS_NewObjectWithGivenProto(cx, &sCTypeClass, typeProto));
-  if (!typeObj) {
+  if (!typeObj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -4374,7 +4374,7 @@ JSObject* CType::Create(JSContext* cx, H
   JS_SetReservedSlot(typeObj, SLOT_TYPECODE, Int32Value(type));
   if (ffiType) {
     JS_SetReservedSlot(typeObj, SLOT_FFITYPE, PrivateValue(ffiType));
-    if (type == TYPE_struct || type == TYPE_array) {
+    if (type == TYPE_struct || type == TYPE_array) {MOZ_RELEASE_ASSERT(0);
       AddCellMemory(typeObj, sizeof(ffi_type), MemoryUse::CTypeFFIType);
     }
   }
@@ -4388,9 +4388,9 @@ JSObject* CType::Create(JSContext* cx, H
     // Set up the 'prototype' and 'prototype.constructor' properties.
     RootedObject prototype(
         cx, JS_NewObjectWithGivenProto(cx, &sCDataProtoClass, dataProto));
-    if (!prototype) {
+    if (!prototype) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     if (!JS_DefineProperty(cx, prototype, "constructor", typeObj,
                            JSPROP_READONLY | JSPROP_PERMANENT))
@@ -4423,7 +4423,7 @@ JSObject* CType::DefineBuiltin(JSContext
   RootedObject dataProto(cx, dataProto_);
 
   RootedString nameStr(cx, JS_NewStringCopyZ(cx, name));
-  if (!nameStr) {
+  if (!nameStr) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -4453,7 +4453,7 @@ static void FinalizeFFIType(JSFreeOp* fo
 void CType::Finalize(JSFreeOp* fop, JSObject* obj) {
   // Make sure our TypeCode slot is legit. If it's not, bail.
   Value slot = JS::GetReservedSlot(obj, SLOT_TYPECODE);
-  if (slot.isUndefined()) {
+  if (slot.isUndefined()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -4510,7 +4510,7 @@ void CType::Finalize(JSFreeOp* fop, JSOb
 void CType::Trace(JSTracer* trc, JSObject* obj) {
   // Make sure our TypeCode slot is legit. If it's not, bail.
   Value slot = obj->as<NativeObject>().getSlot(SLOT_TYPECODE);
-  if (slot.isUndefined()) {
+  if (slot.isUndefined()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -4860,7 +4860,7 @@ bool CType::ToString(JSContext* cx, unsi
   if (!obj) {
     return false;
   }
-  if (!CType::IsCType(obj) && !CType::IsCTypeProto(obj)) {
+  if (!CType::IsCType(obj) && !CType::IsCTypeProto(obj)) {MOZ_RELEASE_ASSERT(0);
     return IncompatibleThisProto(cx, "CType.prototype.toString",
                                  InformalValueTypeName(args.thisv()));
   }
@@ -4872,7 +4872,7 @@ bool CType::ToString(JSContext* cx, unsi
     AutoString type;
     AppendString(cx, type, "type ");
     AppendString(cx, type, GetName(cx, obj));
-    if (!type) {
+    if (!type) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     result = NewUCString(cx, type.finish());
@@ -4893,7 +4893,7 @@ bool CType::ToSource(JSContext* cx, unsi
   if (!obj) {
     return false;
   }
-  if (!CType::IsCType(obj) && !CType::IsCTypeProto(obj)) {
+  if (!CType::IsCType(obj) && !CType::IsCTypeProto(obj)) {MOZ_RELEASE_ASSERT(0);
     return IncompatibleThisProto(cx, "CType.prototype.toSource",
                                  InformalValueTypeName(args.thisv()));
   }
@@ -4904,7 +4904,7 @@ bool CType::ToSource(JSContext* cx, unsi
   if (CType::IsCType(obj)) {
     AutoString source;
     BuildTypeSource(cx, obj, false, source);
-    if (!source) {
+    if (!source) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     result = NewUCString(cx, source.finish());
@@ -4929,16 +4929,16 @@ bool CType::HasInstance(JSContext* cx, H
   MOZ_ASSERT(CData::IsCDataProto(prototype));
 
   *bp = false;
-  if (v.isPrimitive()) {
+  if (v.isPrimitive()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   RootedObject proto(cx, &v.toObject());
   for (;;) {
-    if (!JS_GetPrototype(cx, proto, &proto)) {
+    if (!JS_GetPrototype(cx, proto, &proto)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!proto) {
+    if (!proto) {MOZ_RELEASE_ASSERT(0);
       break;
     }
     if (proto == prototype) {
@@ -4981,7 +4981,7 @@ bool ABI::ToSource(JSContext* cx, unsign
   if (!obj) {
     return false;
   }
-  if (!ABI::IsABI(obj)) {
+  if (!ABI::IsABI(obj)) {MOZ_RELEASE_ASSERT(0);
     return IncompatibleThisProto(cx, "ABI.prototype.toSource",
                                  InformalValueTypeName(args.thisv()));
   }
@@ -5051,12 +5051,12 @@ JSObject* PointerType::CreateInternal(JS
                               ? SLOT_FUNCTIONDATAPROTO
                               : SLOT_POINTERDATAPROTO;
   RootedObject dataProto(cx, CType::GetProtoFromType(cx, baseType, slotId));
-  if (!dataProto) {
+  if (!dataProto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   RootedObject typeProto(
       cx, CType::GetProtoFromType(cx, baseType, SLOT_POINTERPROTO));
-  if (!typeProto) {
+  if (!typeProto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -5081,7 +5081,7 @@ JSObject* PointerType::CreateInternal(JS
 
 bool PointerType::ConstructData(JSContext* cx, HandleObject obj,
                                 const CallArgs& args) {
-  if (!CType::IsCType(obj) || CType::GetTypeCode(obj) != TYPE_pointer) {
+  if (!CType::IsCType(obj) || CType::GetTypeCode(obj) != TYPE_pointer) {MOZ_RELEASE_ASSERT(0);
     return IncompatibleCallee(cx, "PointerType constructor", obj);
   }
 
@@ -5091,7 +5091,7 @@ bool PointerType::ConstructData(JSContex
   }
 
   RootedObject result(cx, CData::Create(cx, obj, nullptr, nullptr, true));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5143,7 +5143,7 @@ bool PointerType::ConstructData(JSContex
       thisObj = nullptr;
     } else if (args[1].isObject()) {
       thisObj = &args[1].toObject();
-    } else if (!JS_ValueToObject(cx, args[1], &thisObj)) {
+    } else if (!JS_ValueToObject(cx, args[1], &thisObj)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -5337,12 +5337,12 @@ JSObject* ArrayType::CreateInternal(JSCo
   // of this type, from ctypes.CType.prototype.
   RootedObject typeProto(
       cx, CType::GetProtoFromType(cx, baseType, SLOT_ARRAYPROTO));
-  if (!typeProto) {
+  if (!typeProto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   RootedObject dataProto(
       cx, CType::GetProtoFromType(cx, baseType, SLOT_ARRAYDATAPROTO));
-  if (!dataProto) {
+  if (!dataProto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -5368,7 +5368,7 @@ JSObject* ArrayType::CreateInternal(JSCo
       SizeOverflow(cx, "array size", "JavaScript number");
       return nullptr;
     }
-    if (!SizeTojsval(cx, length, &lengthVal)) {
+    if (!SizeTojsval(cx, length, &lengthVal)) {MOZ_RELEASE_ASSERT(0);
       SizeOverflow(cx, "array length", "JavaScript number");
       return nullptr;
     }
@@ -5396,7 +5396,7 @@ bool ArrayType::ConstructData(JSContext*
                               const CallArgs& args) {
   RootedObject obj(cx, obj_);  // Make a mutable version
 
-  if (!CType::IsCType(obj) || CType::GetTypeCode(obj) != TYPE_array) {
+  if (!CType::IsCType(obj) || CType::GetTypeCode(obj) != TYPE_array) {MOZ_RELEASE_ASSERT(0);
     return IncompatibleCallee(cx, "ArrayType constructor", obj);
   }
 
@@ -5443,7 +5443,7 @@ bool ArrayType::ConstructData(JSContext*
       JSString* sourceString = args[0].toString();
       size_t sourceLength = sourceString->length();
       Rooted<JSLinearString*> sourceLinear(cx, sourceString->ensureLinear(cx));
-      if (!sourceLinear) {
+      if (!sourceLinear) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -5477,13 +5477,13 @@ bool ArrayType::ConstructData(JSContext*
 
     // Construct a new ArrayType of defined length, for the new CData object.
     obj = CreateInternal(cx, baseType, length, true);
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   JSObject* result = CData::Create(cx, obj, nullptr, nullptr, true);
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5546,16 +5546,16 @@ size_t ArrayType::GetLength(JSObject* ob
   return Convert<size_t>(length.toDouble());
 }
 
-UniquePtrFFIType ArrayType::BuildFFIType(JSContext* cx, JSObject* obj) {
+UniquePtrFFIType ArrayType::BuildFFIType(JSContext* cx, JSObject* obj) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(CType::IsCType(obj));
   MOZ_ASSERT(CType::GetTypeCode(obj) == TYPE_array);
   MOZ_ASSERT(CType::IsSizeDefined(obj));
 
   JSObject* baseType = ArrayType::GetBaseType(obj);
   ffi_type* ffiBaseType = CType::GetFFIType(cx, baseType);
-  if (!ffiBaseType) {
+  if (!ffiBaseType) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   size_t length = ArrayType::GetLength(obj);
 
@@ -5567,15 +5567,15 @@ UniquePtrFFIType ArrayType::BuildFFIType
   // but some libffi platforms currently require that it be meaningful. I'm
   // looking at you, x86_64.
   auto ffiType = cx->make_unique<ffi_type>();
-  if (!ffiType) {
+  if (!ffiType) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   ffiType->type = FFI_TYPE_STRUCT;
   ffiType->size = CType::GetSize(obj);
   ffiType->alignment = CType::GetAlignment(obj);
   ffiType->elements = cx->pod_malloc<ffi_type*>(length + 1);
-  if (!ffiType->elements) {
+  if (!ffiType->elements) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -5596,7 +5596,7 @@ bool ArrayType::IsArrayType(HandleValue 
 }
 
 bool ArrayType::IsArrayOrArrayType(HandleValue v) {
-  if (!v.isObject()) {
+  if (!v.isObject()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   JSObject* obj = MaybeUnwrapArrayWrapper(&v.toObject());
@@ -5635,7 +5635,7 @@ bool ArrayType::Getter(JSContext* cx, Ha
   *handled = false;
 
   // This should never happen, but we'll check to be safe.
-  if (!CData::IsCData(obj)) {
+  if (!CData::IsCData(obj)) {MOZ_RELEASE_ASSERT(0);
     RootedValue objVal(cx, ObjectValue(*obj));
     return IncompatibleThisProto(cx, "ArrayType property getter", objVal);
   }
@@ -5643,7 +5643,7 @@ bool ArrayType::Getter(JSContext* cx, Ha
   // Bail early if we're not an ArrayType. (This setter is present for all
   // CData, regardless of CType.)
   JSObject* typeObj = CData::GetCType(obj);
-  if (CType::GetTypeCode(typeObj) != TYPE_array) {
+  if (CType::GetTypeCode(typeObj) != TYPE_array) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -5682,7 +5682,7 @@ bool ArrayType::Setter(JSContext* cx, Ha
   *handled = false;
 
   // This should never happen, but we'll check to be safe.
-  if (!CData::IsCData(obj)) {
+  if (!CData::IsCData(obj)) {MOZ_RELEASE_ASSERT(0);
     RootedValue objVal(cx, ObjectValue(*obj));
     return IncompatibleThisProto(cx, "ArrayType property setter", objVal);
   }
@@ -5690,7 +5690,7 @@ bool ArrayType::Setter(JSContext* cx, Ha
   // Bail early if we're not an ArrayType. (This setter is present for all
   // CData, regardless of CType.)
   RootedObject typeObj(cx, CData::GetCType(obj));
-  if (CType::GetTypeCode(typeObj) != TYPE_array) {
+  if (CType::GetTypeCode(typeObj) != TYPE_array) {MOZ_RELEASE_ASSERT(0);
     return result.succeed();
   }
 
@@ -5699,7 +5699,7 @@ bool ArrayType::Setter(JSContext* cx, Ha
   size_t length = GetLength(typeObj);
   bool ok = jsidToSize(cx, idval, true, &index);
   int32_t dummy;
-  if (!ok && JSID_IS_SYMBOL(idval)) {
+  if (!ok && JSID_IS_SYMBOL(idval)) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
   bool dummy2;
@@ -5752,14 +5752,14 @@ bool ArrayType::AddressOfElement(JSConte
 
   RootedObject baseType(cx, GetBaseType(typeObj));
   RootedObject pointerType(cx, PointerType::CreateInternal(cx, baseType));
-  if (!pointerType) {
+  if (!pointerType) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Create a PointerType CData object containing null.
   RootedObject result(cx,
                       CData::Create(cx, pointerType, nullptr, nullptr, true));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5797,7 +5797,7 @@ static JSLinearString* ExtractStructFiel
 
   RootedObject obj(cx, &val.toObject());
   Rooted<IdVector> props(cx, IdVector(cx));
-  if (!JS_Enumerate(cx, obj, &props)) {
+  if (!JS_Enumerate(cx, obj, &props)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -5814,7 +5814,7 @@ static JSLinearString* ExtractStructFiel
   }
 
   RootedValue propVal(cx);
-  if (!JS_GetPropertyById(cx, obj, nameid, &propVal)) {
+  if (!JS_GetPropertyById(cx, obj, nameid, &propVal)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -5843,7 +5843,7 @@ static bool AddFieldToArray(JSContext* c
   RootedObject typeObj(cx, typeObj_);
   Rooted<JSLinearString*> name(cx, name_);
   RootedObject fieldObj(cx, JS_NewPlainObject(cx));
-  if (!fieldObj) {
+  if (!fieldObj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5886,7 +5886,7 @@ bool StructType::Create(JSContext* cx, u
       cx, CType::Create(cx, typeProto, nullptr, TYPE_struct, name.toString(),
                         JS::UndefinedHandleValue, JS::UndefinedHandleValue,
                         nullptr));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5896,7 +5896,7 @@ bool StructType::Create(JSContext* cx, u
     if (!arr) {
       isArray = false;
     } else {
-      if (!JS::IsArrayObject(cx, arr, &isArray)) {
+      if (!JS::IsArrayObject(cx, arr, &isArray)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -5926,7 +5926,7 @@ bool StructType::DefineInternal(JSContex
   // ctypes.CType.prototype.
   RootedObject dataProto(
       cx, CType::GetProtoFromType(cx, typeObj, SLOT_STRUCTDATAPROTO));
-  if (!dataProto) {
+  if (!dataProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5935,9 +5935,9 @@ bool StructType::DefineInternal(JSContex
   // created from this type.
   RootedObject prototype(
       cx, JS_NewObjectWithGivenProto(cx, &sCDataProtoClass, dataProto));
-  if (!prototype) {
-    return false;
-  }
+  if (!prototype) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
 
   if (!JS_DefineProperty(cx, prototype, "constructor", typeObj,
                          JSPROP_READONLY | JSPROP_PERMANENT))
@@ -5954,7 +5954,7 @@ bool StructType::DefineInternal(JSContex
 
     for (uint32_t i = 0; i < len; ++i) {
       RootedValue item(cx);
-      if (!JS_GetElement(cx, fieldsObj, i, &item)) {
+      if (!JS_GetElement(cx, fieldsObj, i, &item)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -5973,14 +5973,14 @@ bool StructType::DefineInternal(JSContex
 
       // Add the field to the StructType's 'prototype' property.
       AutoStableStringChars nameChars(cx);
-      if (!nameChars.initTwoByte(cx, name)) {
+      if (!nameChars.initTwoByte(cx, name)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       RootedFunction getter(
           cx,
           NewFunctionWithReserved(cx, StructType::FieldGetter, 0, 0, nullptr));
-      if (!getter) {
+      if (!getter) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       SetFunctionNativeReserved(getter, StructType::SLOT_FIELDNAME,
@@ -5990,7 +5990,7 @@ bool StructType::DefineInternal(JSContex
       RootedFunction setter(
           cx,
           NewFunctionWithReserved(cx, StructType::FieldSetter, 1, 0, nullptr));
-      if (!setter) {
+      if (!setter) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       SetFunctionNativeReserved(setter, StructType::SLOT_FIELDNAME,
@@ -6000,7 +6000,7 @@ bool StructType::DefineInternal(JSContex
       if (!JS_DefineUCProperty(cx, prototype, nameChars.twoByteChars(),
                                name->length(), getterObj, setterObj,
                                JSPROP_ENUMERATE | JSPROP_PERMANENT |
-                                   JSPROP_GETTER | JSPROP_SETTER)) {
+                                   JSPROP_GETTER | JSPROP_SETTER)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -6020,7 +6020,7 @@ bool StructType::DefineInternal(JSContex
       info.mType = fieldType;
       info.mIndex = i;
       info.mOffset = fieldOffset;
-      if (!fields.add(entryPtr, name, info)) {
+      if (!fields.add(entryPtr, name, info)) {MOZ_RELEASE_ASSERT(0);
         JS_ReportOutOfMemory(cx);
         return false;
       }
@@ -6083,14 +6083,14 @@ UniquePtrFFIType StructType::BuildFFITyp
   size_t structAlign = CType::GetAlignment(obj);
 
   auto ffiType = cx->make_unique<ffi_type>();
-  if (!ffiType) {
+  if (!ffiType) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   ffiType->type = FFI_TYPE_STRUCT;
 
   size_t count = len != 0 ? len + 1 : 2;
   auto elements = cx->make_pod_array<ffi_type*>(count);
-  if (!elements) {
+  if (!elements) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -6100,7 +6100,7 @@ UniquePtrFFIType StructType::BuildFFITyp
     for (FieldInfoHash::Range r = fields->all(); !r.empty(); r.popFront()) {
       const FieldInfoHash::Entry& entry = r.front();
       ffi_type* fieldType = CType::GetFFIType(cx, entry.value().mType);
-      if (!fieldType) {
+      if (!fieldType) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       elements[entry.value().mIndex] = fieldType;
@@ -6172,10 +6172,10 @@ bool StructType::Define(JSContext* cx, u
   }
 
   bool isArray;
-  if (!arg.isObject()) {
+  if (!arg.isObject()) {MOZ_RELEASE_ASSERT(0);
     isArray = false;
   } else {
-    if (!JS::IsArrayObject(cx, arg, &isArray)) {
+    if (!JS::IsArrayObject(cx, arg, &isArray)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -6191,7 +6191,7 @@ bool StructType::Define(JSContext* cx, u
 
 bool StructType::ConstructData(JSContext* cx, HandleObject obj,
                                const CallArgs& args) {
-  if (!CType::IsCType(obj) || CType::GetTypeCode(obj) != TYPE_struct) {
+  if (!CType::IsCType(obj) || CType::GetTypeCode(obj) != TYPE_struct) {MOZ_RELEASE_ASSERT(0);
     return IncompatibleCallee(cx, "StructType constructor", obj);
   }
 
@@ -6201,7 +6201,7 @@ bool StructType::ConstructData(JSContext
   }
 
   JSObject* result = CData::Create(cx, obj, nullptr, nullptr, true);
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6234,7 +6234,7 @@ bool StructType::ConstructData(JSContext
 
     // If ExplicitConvert failed, and there is no pending exception, then assume
     // hard failure (out of memory, or some other similarly serious condition).
-    if (!JS_IsExceptionPending(cx)) {
+    if (!JS_IsExceptionPending(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -6304,11 +6304,11 @@ JSObject* StructType::BuildFieldsArray(J
 
   // Prepare a new array for the 'fields' property of the StructType.
   JS::RootedValueVector fieldsVec(cx);
-  if (!fieldsVec.resize(len)) {
+  if (!fieldsVec.resize(len)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  for (FieldInfoHash::Range r = fields->all(); !r.empty(); r.popFront()) {
+  for (FieldInfoHash::Range r = fields->all(); !r.empty(); r.popFront()) {MOZ_RELEASE_ASSERT(0);
     const FieldInfoHash::Entry& entry = r.front();
     // Add the field descriptor to the array.
     if (!AddFieldToArray(cx, fieldsVec[entry.value().mIndex], entry.key(),
@@ -6317,7 +6317,7 @@ JSObject* StructType::BuildFieldsArray(J
   }
 
   RootedObject fieldsProp(cx, JS::NewArrayObject(cx, fieldsVec));
-  if (!fieldsProp) {
+  if (!fieldsProp) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -6366,7 +6366,7 @@ bool StructType::FieldsArrayGetter(JSCon
 bool StructType::FieldGetter(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (!args.thisv().isObject()) {
+  if (!args.thisv().isObject()) {MOZ_RELEASE_ASSERT(0);
     return IncompatibleThisProto(cx, "StructType property getter",
                                  args.thisv());
   }
@@ -6387,7 +6387,7 @@ bool StructType::FieldGetter(JSContext* 
       cx, GetFunctionNativeReserved(&args.callee(), SLOT_FIELDNAME));
   Rooted<JSLinearString*> name(cx,
                                JS_EnsureLinearString(cx, nameVal.toString()));
-  if (!name) {
+  if (!name) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6404,7 +6404,7 @@ bool StructType::FieldGetter(JSContext* 
 bool StructType::FieldSetter(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (!args.thisv().isObject()) {
+  if (!args.thisv().isObject()) {MOZ_RELEASE_ASSERT(0);
     return IncompatibleThisProto(cx, "StructType property setter",
                                  args.thisv());
   }
@@ -6425,7 +6425,7 @@ bool StructType::FieldSetter(JSContext* 
       cx, GetFunctionNativeReserved(&args.callee(), SLOT_FIELDNAME));
   Rooted<JSLinearString*> name(cx,
                                JS_EnsureLinearString(cx, nameVal.toString()));
-  if (!name) {
+  if (!name) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6472,7 +6472,7 @@ bool StructType::AddressOfField(JSContex
   }
 
   JSLinearString* str = JS_EnsureLinearString(cx, args[0].toString());
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6483,7 +6483,7 @@ bool StructType::AddressOfField(JSContex
 
   RootedObject baseType(cx, field->mType);
   RootedObject pointerType(cx, PointerType::CreateInternal(cx, baseType));
-  if (!pointerType) {
+  if (!pointerType) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6525,7 +6525,7 @@ struct AutoValue {
 };
 
 static bool GetABI(JSContext* cx, HandleValue abiType, ffi_abi* result) {
-  if (abiType.isPrimitive()) {
+  if (abiType.isPrimitive()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6591,7 +6591,7 @@ static JSObject* PrepareType(JSContext* 
     // ImplicitConvert will do the same, when passing an array as data.
     RootedObject baseType(cx, ArrayType::GetBaseType(result));
     result = PointerType::CreateInternal(cx, baseType);
-    if (!result) {
+    if (!result) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -6645,7 +6645,7 @@ static MOZ_ALWAYS_INLINE bool IsEllipsis
     return true;
   }
   JSString* str = v.toString();
-  if (str->length() != 3) {
+  if (str->length() != 3) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
   JSLinearString* linear = str->ensureLinear(cx);
@@ -6662,13 +6662,13 @@ static MOZ_ALWAYS_INLINE bool IsEllipsis
 static bool PrepareCIF(JSContext* cx, FunctionInfo* fninfo) {
   ffi_abi abi;
   RootedValue abiType(cx, ObjectOrNullValue(fninfo->mABI));
-  if (!GetABI(cx, abiType, &abi)) {
+  if (!GetABI(cx, abiType, &abi)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Invalid ABI specification");
     return false;
   }
 
   ffi_type* rtype = CType::GetFFIType(cx, fninfo->mReturnType);
-  if (!rtype) {
+  if (!rtype) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6744,7 +6744,7 @@ static bool CreateFunctionInfo(JSContext
                                HandleValue abiType, HandleObject returnType,
                                const HandleValueArray& args) {
   FunctionInfo* fninfo(cx->new_<FunctionInfo>(cx->zone()));
-  if (!fninfo) {
+  if (!fninfo) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6763,7 +6763,7 @@ static bool CreateFunctionInfo(JSContext
 
   // prepare the argument types
   if (!fninfo->mArgTypes.reserve(args.length()) ||
-      !fninfo->mFFITypes.reserve(args.length())) {
+      !fninfo->mFFITypes.reserve(args.length())) {MOZ_RELEASE_ASSERT(0);
     JS_ReportOutOfMemory(cx);
     return false;
   }
@@ -6772,7 +6772,7 @@ static bool CreateFunctionInfo(JSContext
 
   for (uint32_t i = 0; i < args.length(); ++i) {
     bool isEllipsis;
-    if (!IsEllipsis(cx, args[i], &isEllipsis)) {
+    if (!IsEllipsis(cx, args[i], &isEllipsis)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (isEllipsis) {
@@ -6804,7 +6804,7 @@ static bool CreateFunctionInfo(JSContext
     }
 
     ffi_type* ffiType = CType::GetFFIType(cx, argType);
-    if (!ffiType) {
+    if (!ffiType) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -6840,7 +6840,7 @@ bool FunctionType::Create(JSContext* cx,
     if (!args[2].isObject()) {
       isArray = false;
     } else {
-      if (!JS::IsArrayObject(cx, args[2], &isArray)) {
+      if (!JS::IsArrayObject(cx, args[2], &isArray)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -6854,7 +6854,7 @@ bool FunctionType::Create(JSContext* cx,
     uint32_t len;
     MOZ_ALWAYS_TRUE(JS::GetArrayLength(cx, arrayObj, &len));
 
-    if (!argTypes.resize(len)) {
+    if (!argTypes.resize(len)) {MOZ_RELEASE_ASSERT(0);
       JS_ReportOutOfMemory(cx);
       return false;
     }
@@ -6863,7 +6863,7 @@ bool FunctionType::Create(JSContext* cx,
   // Pull out the argument types from the array, if any.
   MOZ_ASSERT_IF(argTypes.length(), arrayObj);
   for (uint32_t i = 0; i < argTypes.length(); ++i) {
-    if (!JS_GetElement(cx, arrayObj, i, argTypes[i])) {
+    if (!JS_GetElement(cx, arrayObj, i, argTypes[i])) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -6890,12 +6890,12 @@ JSObject* FunctionType::CreateInternal(J
   // objects of this type, from ctypes.CType.prototype.
   RootedObject typeProto(
       cx, CType::GetProtoFromType(cx, returnType, SLOT_FUNCTIONPROTO));
-  if (!typeProto) {
+  if (!typeProto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   RootedObject dataProto(
       cx, CType::GetProtoFromType(cx, returnType, SLOT_FUNCTIONDATAPROTO));
-  if (!dataProto) {
+  if (!dataProto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -6904,7 +6904,7 @@ JSObject* FunctionType::CreateInternal(J
       cx, CType::Create(cx, typeProto, dataProto, TYPE_function, nullptr,
                         JS::UndefinedHandleValue, JS::UndefinedHandleValue,
                         nullptr));
-  if (!typeObj) {
+  if (!typeObj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -6961,7 +6961,7 @@ typedef Vector<AutoValue, 16, SystemAllo
 static bool ConvertArgument(JSContext* cx, HandleObject funObj,
                             unsigned argIndex, HandleValue arg, JSObject* type,
                             AutoValue* value, AutoValueAutoArray* strings) {
-  if (!value->SizeToType(cx, type)) {
+  if (!value->SizeToType(cx, type)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportAllocationOverflow(cx);
     return false;
   }
@@ -6988,7 +6988,7 @@ bool FunctionType::Call(JSContext* cx, u
   CallArgs args = CallArgsFromVp(argc, vp);
   // get the callee object...
   RootedObject obj(cx, &args.callee());
-  if (!CData::IsCDataMaybeUnwrap(&obj)) {
+  if (!CData::IsCDataMaybeUnwrap(&obj)) {MOZ_RELEASE_ASSERT(0);
     return IncompatibleThisProto(cx, "FunctionType.prototype.call",
                                  args.calleev());
   }
@@ -7027,7 +7027,7 @@ bool FunctionType::Call(JSContext* cx, u
   // prepare the values for each argument
   AutoValueAutoArray values;
   AutoValueAutoArray strings;
-  if (!values.resize(args.length())) {
+  if (!values.resize(args.length())) {MOZ_RELEASE_ASSERT(0);
     JS_ReportOutOfMemory(cx);
     return false;
   }
@@ -7040,7 +7040,7 @@ bool FunctionType::Call(JSContext* cx, u
   }
 
   if (fninfo->mIsVariadic) {
-    if (!fninfo->mFFITypes.resize(args.length())) {
+    if (!fninfo->mFFITypes.resize(args.length())) {MOZ_RELEASE_ASSERT(0);
       JS_ReportOutOfMemory(cx);
       return false;
     }
@@ -7051,33 +7051,33 @@ bool FunctionType::Call(JSContext* cx, u
 
     for (uint32_t i = argcFixed; i < args.length(); ++i) {
       obj = args[i].isObject() ? &args[i].toObject() : nullptr;
-      if (!obj || !CData::IsCDataMaybeUnwrap(&obj)) {
+      if (!obj || !CData::IsCDataMaybeUnwrap(&obj)) {MOZ_RELEASE_ASSERT(0);
         // Since we know nothing about the CTypes of the ... arguments,
         // they absolutely must be CData objects already.
         return VariadicArgumentTypeError(cx, i, args[i]);
       }
       type = CData::GetCType(obj);
-      if (!type) {
+      if (!type) {MOZ_RELEASE_ASSERT(0);
         // These functions report their own errors.
         return false;
       }
       RootedValue typeVal(cx, ObjectValue(*type));
       type = PrepareType(cx, i, typeVal);
-      if (!type) {
+      if (!type) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       // Relying on ImplicitConvert only for the limited purpose of
       // converting one CType to another (e.g., T[] to T*).
       arg = ObjectValue(*obj);
-      if (!ConvertArgument(cx, obj, i, arg, type, &values[i], &strings)) {
+      if (!ConvertArgument(cx, obj, i, arg, type, &values[i], &strings)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       fninfo->mFFITypes[i] = CType::GetFFIType(cx, type);
-      if (!fninfo->mFFITypes[i]) {
+      if (!fninfo->mFFITypes[i]) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
-    if (!PrepareCIF(cx, fninfo)) {
+    if (!PrepareCIF(cx, fninfo)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -7086,7 +7086,7 @@ bool FunctionType::Call(JSContext* cx, u
   AutoValue returnValue;
   TypeCode typeCode = CType::GetTypeCode(fninfo->mReturnType);
   if (typeCode != TYPE_void_t &&
-      !returnValue.SizeToType(cx, fninfo->mReturnType)) {
+      !returnValue.SizeToType(cx, fninfo->mReturnType)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportAllocationOverflow(cx);
     return false;
   }
@@ -7127,7 +7127,7 @@ bool FunctionType::Call(JSContext* cx, u
 
   // Store the error value for later consultation with |ctypes.getStatus|
   JSObject* objCTypes = CType::GetGlobalCTypes(cx, typeObj);
-  if (!objCTypes) {
+  if (!objCTypes) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -7195,7 +7195,7 @@ bool FunctionType::ArgTypesGetter(JSCont
   JS::Rooted<JSObject*> argTypes(cx);
   {
     JS::RootedValueVector vec(cx);
-    if (!vec.resize(len)) {
+    if (!vec.resize(len)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -7204,7 +7204,7 @@ bool FunctionType::ArgTypesGetter(JSCont
     }
 
     argTypes = JS::NewArrayObject(cx, vec);
-    if (!argTypes) {
+    if (!argTypes) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -7248,7 +7248,7 @@ JSObject* CClosure::Create(JSContext* cx
   MOZ_ASSERT(fnObj);
 
   RootedObject result(cx, JS_NewObject(cx, &sCClosureClass));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -7260,7 +7260,7 @@ JSObject* CClosure::Create(JSContext* cx
   // Get the prototype of the FunctionType object, of class CTypeProto,
   // which stores our JSContext for use with the closure.
   RootedObject proto(cx);
-  if (!JS_GetPrototype(cx, typeObj, &proto)) {
+  if (!JS_GetPrototype(cx, typeObj, &proto)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   MOZ_ASSERT(proto);
@@ -7285,7 +7285,7 @@ JSObject* CClosure::Create(JSContext* cx
     // Allocate a buffer for the return value.
     size_t rvSize = CType::GetSize(fninfo->mReturnType);
     errResult = cx->make_pod_array<uint8_t>(rvSize);
-    if (!errResult) {
+    if (!errResult) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -7296,7 +7296,7 @@ JSObject* CClosure::Create(JSContext* cx
   }
 
   ClosureInfo* cinfo = cx->new_<ClosureInfo>(cx);
-  if (!cinfo) {
+  if (!cinfo) {MOZ_RELEASE_ASSERT(0);
     JS_ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -7316,7 +7316,7 @@ JSObject* CClosure::Create(JSContext* cx
   void* code;
   cinfo->closure =
       static_cast<ffi_closure*>(ffi_closure_alloc(sizeof(ffi_closure), &code));
-  if (!cinfo->closure || !code) {
+  if (!cinfo->closure || !code) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "couldn't create closure - libffi error");
     return nullptr;
   }
@@ -7422,7 +7422,7 @@ bool CClosure::ArgClosure::operator()(JS
 
   // Set up an array for converted arguments.
   JS::RootedValueVector argv(cx);
-  if (!argv.resize(cif->nargs)) {
+  if (!argv.resize(cif->nargs)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportOutOfMemory(cx);
     return false;
   }
@@ -7431,7 +7431,7 @@ bool CClosure::ArgClosure::operator()(JS
     // Convert each argument, and have any CData objects created depend on
     // the existing buffers.
     RootedObject argType(cx, fninfo->mArgTypes[i]);
-    if (!ConvertToJS(cx, argType, nullptr, args[i], false, false, argv[i])) {
+    if (!ConvertToJS(cx, argType, nullptr, args[i], false, false, argv[i])) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -7543,7 +7543,7 @@ JSObject* CData::Create(JSContext* cx, H
   RootedObject proto(cx, &slot.toObject());
 
   RootedObject dataObj(cx, JS_NewObjectWithGivenProto(cx, &sCDataClass, proto));
-  if (!dataObj) {
+  if (!dataObj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -7561,7 +7561,7 @@ JSObject* CData::Create(JSContext* cx, H
   // attach the buffer. since it might not be 2-byte aligned, we need to
   // allocate an aligned space for it and store it there. :(
   UniquePtr<char*, JS::FreePolicy> buffer(cx->new_<char*>());
-  if (!buffer) {
+  if (!buffer) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -7572,7 +7572,7 @@ JSObject* CData::Create(JSContext* cx, H
     // Initialize our own buffer.
     size_t size = CType::GetSize(typeObj);
     data = cx->pod_malloc<char>(size);
-    if (!data) {
+    if (!data) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -7606,14 +7606,14 @@ JSObject* CData::Create(JSContext* cx, H
 void CData::Finalize(JSFreeOp* fop, JSObject* obj) {
   // Delete our buffer, and the data it contains if we own it.
   Value slot = JS::GetReservedSlot(obj, SLOT_OWNS);
-  if (slot.isUndefined()) {
+  if (slot.isUndefined()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
   bool owns = slot.toBoolean();
 
   slot = JS::GetReservedSlot(obj, SLOT_DATA);
-  if (slot.isUndefined()) {
+  if (slot.isUndefined()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
   char** buffer = static_cast<char**>(slot.toPrivate());
@@ -7700,7 +7700,7 @@ bool CData::Address(JSContext* cx, unsig
 
   RootedObject typeObj(cx, CData::GetCType(obj));
   RootedObject pointerType(cx, PointerType::CreateInternal(cx, typeObj));
-  if (!pointerType) {
+  if (!pointerType) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -7768,15 +7768,15 @@ bool CData::GetRuntime(JSContext* cx, un
 
   if (args[0].isPrimitive() || !CType::IsCType(&args[0].toObject())) {
     return ArgumentTypeMismatch(cx, "", "ctypes.getRuntime", "a CType");
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedObject targetType(cx, &args[0].toObject());
   size_t targetSize;
   if (!CType::GetSafeSize(targetType, &targetSize) ||
-      targetSize != sizeof(void*)) {
+      targetSize != sizeof(void*)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "target CType has non-pointer size");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   void* data = static_cast<void*>(cx->runtime());
   JSObject* result = CData::Create(cx, targetType, nullptr, &data, true);
@@ -7807,11 +7807,11 @@ static bool GetThisDataObject(JSContext*
     }
 
     RootedValue dataVal(cx);
-    if (!CDataFinalizer::GetValue(cx, obj, &dataVal)) {
+    if (!CDataFinalizer::GetValue(cx, obj, &dataVal)) {MOZ_RELEASE_ASSERT(0);
       return IncompatibleThisProto(cx, funName, args.thisv());
     }
 
-    if (dataVal.isPrimitive()) {
+    if (dataVal.isPrimitive()) {MOZ_RELEASE_ASSERT(0);
       return IncompatibleThisProto(cx, funName, args.thisv());
     }
 
@@ -7975,12 +7975,12 @@ static TypedArrayConstructor GetTypedArr
 static bool ReadTypedArrayCommon(JSContext* cx, unsigned argc, Value* vp,
                                  const char* funName) {
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (args.length() != 0) {
+  if (args.length() != 0) {MOZ_RELEASE_ASSERT(0);
     return ArgumentLengthError(cx, funName, "no", "s");
   }
 
   RootedObject obj(cx);
-  if (!GetThisDataObject(cx, args, funName, &obj)) {
+  if (!GetThisDataObject(cx, args, funName, &obj)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -8042,7 +8042,7 @@ static bool ReadTypedArrayCommon(JSConte
   CheckedInt<size_t> size = *length;
   size *= CType::GetSize(baseType);
   if (!size.isValid() ||
-      size.value() > ArrayBufferObject::maxBufferByteLength()) {
+      size.value() > ArrayBufferObject::maxBufferByteLength()) {MOZ_RELEASE_ASSERT(0);
     return SizeOverflow(cx, "data", "typed array");
   }
 
@@ -8083,7 +8083,7 @@ JSString* CData::GetSourceString(JSConte
   AutoString source;
   BuildTypeSource(cx, typeObj, true, source);
   AppendString(cx, source, "(");
-  if (!BuildDataSource(cx, typeObj, data, false, source)) {
+  if (!BuildDataSource(cx, typeObj, data, false, source)) {MOZ_RELEASE_ASSERT(0);
     source.handle(false);
   }
   AppendString(cx, source, ")");
@@ -8148,7 +8148,7 @@ bool CDataFinalizer::Methods::ToSource(J
   if (!objThis) {
     return false;
   }
-  if (!CDataFinalizer::IsCDataFinalizer(objThis)) {
+  if (!CDataFinalizer::IsCDataFinalizer(objThis)) {MOZ_RELEASE_ASSERT(0);
     return IncompatibleThisProto(cx, "CDataFinalizer.prototype.toSource",
                                  InformalValueTypeName(args.thisv()));
   }
@@ -8160,7 +8160,7 @@ bool CDataFinalizer::Methods::ToSource(J
     strMessage = JS_NewStringCopyZ(cx, "ctypes.CDataFinalizer()");
   } else {
     RootedObject objType(cx, CDataFinalizer::GetCType(cx, objThis));
-    if (!objType) {
+    if (!objType) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "CDataFinalizer has no type");
       return false;
     }
@@ -8168,26 +8168,26 @@ bool CDataFinalizer::Methods::ToSource(J
     AutoString source;
     AppendString(cx, source, "ctypes.CDataFinalizer(");
     JSString* srcValue = CData::GetSourceString(cx, objType, p->cargs);
-    if (!srcValue) {
+    if (!srcValue) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     AppendString(cx, source, srcValue);
     AppendString(cx, source, ", ");
     Value valCodePtrType =
         JS::GetReservedSlot(objThis, SLOT_DATAFINALIZER_CODETYPE);
-    if (valCodePtrType.isPrimitive()) {
+    if (valCodePtrType.isPrimitive()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedObject typeObj(cx, valCodePtrType.toObjectOrNull());
     JSString* srcDispose = CData::GetSourceString(cx, typeObj, &(p->code));
-    if (!srcDispose) {
+    if (!srcDispose) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     AppendString(cx, source, srcDispose);
     AppendString(cx, source, ")");
-    if (!source) {
+    if (!source) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     strMessage = NewUCString(cx, source.finish());
@@ -8210,7 +8210,7 @@ bool CDataFinalizer::Methods::ToString(J
   if (!objThis) {
     return false;
   }
-  if (!CDataFinalizer::IsCDataFinalizer(objThis)) {
+  if (!CDataFinalizer::IsCDataFinalizer(objThis)) {MOZ_RELEASE_ASSERT(0);
     return IncompatibleThisProto(cx, "CDataFinalizer.prototype.toString",
                                  InformalValueTypeName(args.thisv()));
   }
@@ -8221,10 +8221,10 @@ bool CDataFinalizer::Methods::ToString(J
     // Pre-check whether CDataFinalizer::GetValue can fail
     // to avoid reporting an error when not appropriate.
     strMessage = JS_NewStringCopyZ(cx, "[CDataFinalizer - empty]");
-    if (!strMessage) {
+    if (!strMessage) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-  } else if (!CDataFinalizer::GetValue(cx, objThis, &value)) {
+  } else if (!CDataFinalizer::GetValue(cx, objThis, &value)) {MOZ_RELEASE_ASSERT(0);
     MOZ_CRASH("Could not convert an empty CDataFinalizer");
   } else {
     strMessage = ToString(cx, value);
@@ -8286,14 +8286,14 @@ bool CDataFinalizer::Construct(JSContext
   CallArgs args = CallArgsFromVp(argc, vp);
   RootedObject objSelf(cx, &args.callee());
   RootedObject objProto(cx);
-  if (!GetObjectProperty(cx, objSelf, "prototype", &objProto)) {
+  if (!GetObjectProperty(cx, objSelf, "prototype", &objProto)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "CDataFinalizer.prototype does not exist");
     return false;
   }
 
   // Get arguments
   if (args.length() ==
-      0) {  // Special case: the empty (already finalized) object
+      0) {MOZ_RELEASE_ASSERT(0);  // Special case: the empty (already finalized) object
     JSObject* objResult =
         JS_NewObjectWithGivenProto(cx, &sCDataFinalizerClass, objProto);
     args.rval().setObject(*objResult);
@@ -8364,7 +8364,7 @@ bool CDataFinalizer::Construct(JSContext
 
   size_t sizeArg;
   RootedValue valData(cx, args[0]);
-  if (!CType::GetSafeSize(objArgType, &sizeArg)) {
+  if (!CType::GetSafeSize(objArgType, &sizeArg)) {MOZ_RELEASE_ASSERT(0);
     RootedValue valCodeType(cx, ObjectValue(*objCodeType));
     return TypeError(cx, "a function with one known size argument",
                      valCodeType);
@@ -8377,7 +8377,7 @@ bool CDataFinalizer::Construct(JSContext
                        0)) {
     return false;
   }
-  if (freePointer) {
+  if (freePointer) {MOZ_RELEASE_ASSERT(0);
     // Note: We could handle that case, if necessary.
     JS_ReportErrorASCII(
         cx,
@@ -8396,7 +8396,7 @@ bool CDataFinalizer::Construct(JSContext
 
   JSObject* objResult =
       JS_NewObjectWithGivenProto(cx, &sCDataFinalizerClass, objProto);
-  if (!objResult) {
+  if (!objResult) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -8409,7 +8409,7 @@ bool CDataFinalizer::Construct(JSContext
     if (CData::IsCDataMaybeUnwrap(&objData)) {
       objBestArgType = CData::GetCType(objData);
       size_t sizeBestArg;
-      if (!CType::GetSafeSize(objBestArgType, &sizeBestArg)) {
+      if (!CType::GetSafeSize(objBestArgType, &sizeBestArg)) {MOZ_RELEASE_ASSERT(0);
         MOZ_CRASH("object with unknown size");
       }
       if (sizeBestArg != sizeArg) {
@@ -8428,7 +8428,7 @@ bool CDataFinalizer::Construct(JSContext
 
   RootedValue abiType(cx, ObjectOrNullValue(funInfoFinalizer->mABI));
   ffi_abi abi;
-  if (!GetABI(cx, abiType, &abi)) {
+  if (!GetABI(cx, abiType, &abi)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx,
                         "Internal Error: "
                         "Invalid ABI specification in CDataFinalizer");
@@ -8519,7 +8519,7 @@ bool CDataFinalizer::Methods::Forget(JSC
   if (!obj) {
     return false;
   }
-  if (!CDataFinalizer::IsCDataFinalizer(obj)) {
+  if (!CDataFinalizer::IsCDataFinalizer(obj)) {MOZ_RELEASE_ASSERT(0);
     return IncompatibleThisProto(cx, "CDataFinalizer.prototype.forget",
                                  args.thisv());
   }
@@ -8565,7 +8565,7 @@ bool CDataFinalizer::Methods::Dispose(JS
   if (!obj) {
     return false;
   }
-  if (!CDataFinalizer::IsCDataFinalizer(obj)) {
+  if (!CDataFinalizer::IsCDataFinalizer(obj)) {MOZ_RELEASE_ASSERT(0);
     return IncompatibleThisProto(cx, "CDataFinalizer.prototype.dispose",
                                  args.thisv());
   }
@@ -8580,7 +8580,7 @@ bool CDataFinalizer::Methods::Dispose(JS
   MOZ_ASSERT(valType.isObject());
 
   RootedObject objCTypes(cx, CType::GetGlobalCTypes(cx, &valType.toObject()));
-  if (!objCTypes) {
+  if (!objCTypes) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -8651,7 +8651,7 @@ void CDataFinalizer::Finalize(JSFreeOp* 
  * CDataFinalizer object otherwise.
  */
 void CDataFinalizer::Cleanup(CDataFinalizer::Private* p, JSObject* obj) {
-  if (!p) {
+  if (!p) {MOZ_RELEASE_ASSERT(0);
     return;  // We have already cleaned up
   }
 
@@ -8679,13 +8679,13 @@ JSObject* Int64Base::Construct(JSContext
                                bool isUnsigned) {
   const JSClass* clasp = isUnsigned ? &sUInt64Class : &sInt64Class;
   RootedObject result(cx, JS_NewObjectWithGivenProto(cx, clasp, proto));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   // attach the Int64's data
   uint64_t* buffer = cx->new_<uint64_t>(data);
-  if (!buffer) {
+  if (!buffer) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -8751,7 +8751,7 @@ bool Int64Base::ToString(JSContext* cx, 
     IntegerToString(static_cast<int64_t>(GetInt(obj)), radix, intString);
   }
 
-  if (!intString) {
+  if (!intString) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   JSString* result = NewUCString(cx, intString.finish());
@@ -8782,7 +8782,7 @@ bool Int64Base::ToSource(JSContext* cx, 
     IntegerToString(static_cast<int64_t>(GetInt(obj)), 10, source);
   }
   AppendString(cx, source, "\")");
-  if (!source) {
+  if (!source) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/ctypes/Library.cpp b/js/src/ctypes/Library.cpp
--- a/js/src/ctypes/Library.cpp
+++ b/js/src/ctypes/Library.cpp
@@ -64,7 +64,7 @@ static const JSFunctionSpec sLibraryFunc
 
 bool Library::Name(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (args.length() != 1) {
+  if (args.length() != 1) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "libraryName takes one argument");
     return false;
   }
@@ -73,7 +73,7 @@ bool Library::Name(JSContext* cx, unsign
   JSString* str = nullptr;
   if (arg.isString()) {
     str = arg.toString();
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "name argument must be a string");
     return false;
   }
@@ -82,7 +82,7 @@ bool Library::Name(JSContext* cx, unsign
   AppendString(cx, resultString, MOZ_DLL_PREFIX);
   AppendString(cx, resultString, str);
   AppendString(cx, resultString, MOZ_DLL_SUFFIX);
-  if (!resultString) {
+  if (!resultString) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   auto resultStr = resultString.finish();
@@ -100,7 +100,7 @@ bool Library::Name(JSContext* cx, unsign
 JSObject* Library::Create(JSContext* cx, HandleValue path,
                           const JS::CTypesCallbacks* callbacks) {
   RootedObject libraryObj(cx, JS_NewObject(cx, &sLibraryClass));
-  if (!libraryObj) {
+  if (!libraryObj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -108,25 +108,25 @@ JSObject* Library::Create(JSContext* cx,
   JS_SetReservedSlot(libraryObj, SLOT_LIBRARY, PrivateValue(nullptr));
 
   // attach API functions
-  if (!JS_DefineFunctions(cx, libraryObj, sLibraryFunctions)) {
+  if (!JS_DefineFunctions(cx, libraryObj, sLibraryFunctions)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!path.isString()) {
+  if (!path.isString()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "open takes a string argument");
     return nullptr;
   }
 
   PRLibSpec libSpec;
   RootedLinearString pathStr(cx, JS_EnsureLinearString(cx, path.toString()));
-  if (!pathStr) {
+  if (!pathStr) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 #ifdef XP_WIN
   // On Windows, converting to native charset may corrupt path string.
   // So, we have to use Unicode path directly.
   JS::UniqueTwoByteChars pathZeroTerminated(JS_CopyStringCharsZ(cx, pathStr));
-  if (!pathZeroTerminated) {
+  if (!pathZeroTerminated) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   char16ptr_t pathChars = pathZeroTerminated.get();
@@ -138,26 +138,26 @@ JSObject* Library::Create(JSContext* cx,
   JS::UniqueChars pathBytes;
   if (callbacks && callbacks->unicodeToNative) {
     AutoStableStringChars pathStrChars(cx);
-    if (!pathStrChars.initTwoByte(cx, pathStr)) {
+    if (!pathStrChars.initTwoByte(cx, pathStr)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     pathBytes.reset(callbacks->unicodeToNative(cx, pathStrChars.twoByteChars(),
                                                pathStr->length()));
-    if (!pathBytes) {
+    if (!pathBytes) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
     // Fallback: assume the platform native charset is UTF-8. This is true
     // for Mac OS X, Android, and probably Linux.
-    if (!ReportErrorIfUnpairedSurrogatePresent(cx, pathStr)) {
+    if (!ReportErrorIfUnpairedSurrogatePresent(cx, pathStr)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     size_t nbytes = JS::GetDeflatedUTF8StringLength(pathStr);
 
     pathBytes.reset(static_cast<char*>(JS_malloc(cx, nbytes + 1)));
-    if (!pathBytes) {
+    if (!pathBytes) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -186,7 +186,7 @@ JSObject* Library::Create(JSContext* cx,
         JS_ReportErrorUTF8(cx, "couldn't open library %s: %s",
                            pathCharsUTF8.get(), error);
       }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       if (JS::UniqueChars pathCharsLatin1 =
               JS_EncodeStringToLatin1(cx, pathStr)) {
         JS_ReportErrorLatin1(cx, "couldn't open library %s: %s",
@@ -223,16 +223,16 @@ void Library::Finalize(JSFreeOp* fop, JS
 bool Library::Open(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
   JSObject* ctypesObj = GetThisObject(cx, args, "ctypes.open");
-  if (!ctypesObj) {
+  if (!ctypesObj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!IsCTypesGlobal(ctypesObj)) {
+  if (!IsCTypesGlobal(ctypesObj)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "not a ctypes object");
     return false;
   }
 
-  if (args.length() != 1 || args[0].isUndefined()) {
+  if (args.length() != 1 || args[0].isUndefined()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "open requires a single argument");
     return false;
   }
@@ -250,7 +250,7 @@ bool Library::Close(JSContext* cx, unsig
   CallArgs args = CallArgsFromVp(argc, vp);
 
   RootedObject obj(cx, GetThisObject(cx, args, "ctypes.close"));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -276,7 +276,7 @@ bool Library::Declare(JSContext* cx, uns
   CallArgs args = CallArgsFromVp(argc, vp);
 
   RootedObject obj(cx, GetThisObject(cx, args, "ctypes.declare"));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -301,12 +301,12 @@ bool Library::Declare(JSContext* cx, uns
   //    This data will be both readable and writable via the usual CData
   //    accessors. If 'type' is a PointerType to a FunctionType, the result will
   //    be a function pointer, as with 1).
-  if (args.length() < 2) {
+  if (args.length() < 2) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "declare requires at least two arguments");
     return false;
   }
 
-  if (!args[0].isString()) {
+  if (!args[0].isString()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "first argument must be a string");
     return false;
   }
@@ -326,13 +326,13 @@ bool Library::Declare(JSContext* cx, uns
 
     // Make a function pointer type.
     typeObj = PointerType::CreateInternal(cx, fnObj);
-    if (!typeObj) {
+    if (!typeObj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
     // Case 2).
     if (args[1].isPrimitive() || !CType::IsCType(args[1].toObjectOrNull()) ||
-        !CType::IsSizeDefined(args[1].toObjectOrNull())) {
+        !CType::IsSizeDefined(args[1].toObjectOrNull())) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "second argument must be a type of defined size");
       return false;
     }
@@ -352,7 +352,7 @@ bool Library::Declare(JSContext* cx, uns
     // Build the symbol, with mangling if necessary.
     FunctionType::BuildSymbolName(cx, nameStr, fnObj, symbol);
     AppendString(cx, symbol, "\0");
-    if (!symbol) {
+    if (!symbol) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -368,19 +368,19 @@ bool Library::Declare(JSContext* cx, uns
     // 'typeObj' is another data type. Look up the data symbol.
     AppendString(cx, symbol, nameStr);
     AppendString(cx, symbol, "\0");
-    if (!symbol) {
+    if (!symbol) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     data = PR_FindSymbol(library, symbol.finish().begin());
-    if (!data) {
+    if (!data) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "couldn't find symbol in library");
       return false;
     }
   }
 
   RootedObject result(cx, CData::Create(cx, typeObj, obj, data, isFunction));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/debugger/DebugScript.cpp b/js/src/debugger/DebugScript.cpp
--- a/js/src/debugger/DebugScript.cpp
+++ b/js/src/debugger/DebugScript.cpp
@@ -118,7 +118,7 @@ DebugScript* DebugScript::getOrCreate(JS
   size_t nbytes = allocSize(script->length());
   UniqueDebugScript debug(
       reinterpret_cast<DebugScript*>(cx->pod_calloc<uint8_t>(nbytes)));
-  if (!debug) {
+  if (!debug) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -126,7 +126,7 @@ DebugScript* DebugScript::getOrCreate(JS
 
   Rooted<DebugScriptObject*> object(
       cx, DebugScriptObject::create(cx, std::move(debug), nbytes));
-  if (!object) {
+  if (!object) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -135,7 +135,7 @@ DebugScript* DebugScript::getOrCreate(JS
   MOZ_ASSERT(cx->zone() == zone);
   if (!zone->debugScriptMap) {
     DebugScriptMap* map = cx->new_<DebugScriptMap>(cx);
-    if (!map) {
+    if (!map) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -144,7 +144,7 @@ DebugScript* DebugScript::getOrCreate(JS
 
   MOZ_ASSERT(script->hasBytecode());
 
-  if (!zone->debugScriptMap->putNew(script.get(), object.get())) {
+  if (!zone->debugScriptMap->putNew(script.get(), object.get())) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -180,7 +180,7 @@ JSBreakpointSite* DebugScript::getOrCrea
   AutoRealm ar(cx, script);
 
   DebugScript* debug = getOrCreate(cx, script);
-  if (!debug) {
+  if (!debug) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -188,7 +188,7 @@ JSBreakpointSite* DebugScript::getOrCrea
 
   if (!site) {
     site = cx->new_<JSBreakpointSite>(script, pc);
-    if (!site) {
+    if (!site) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     debug->numSites++;
@@ -266,7 +266,7 @@ bool DebugScript::incrementStepperCount(
   AutoRealm ar(cx, script);
 
   DebugScript* debug = getOrCreate(cx, script);
-  if (!debug) {
+  if (!debug) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/debugger/Debugger.cpp b/js/src/debugger/Debugger.cpp
--- a/js/src/debugger/Debugger.cpp
+++ b/js/src/debugger/Debugger.cpp
@@ -178,13 +178,13 @@ ArrayObject* js::GetFunctionParameterNam
   RootedValueVector names(cx);
 
   // The default value for each argument is |undefined|.
-  if (!names.growBy(fun->nargs())) {
+  if (!names.growBy(fun->nargs())) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   if (IsInterpretedNonSelfHostedFunction(fun) && fun->nargs() > 0) {
     RootedScript script(cx, GetOrCreateFunctionScript(cx, fun));
-    if (!script) {
+    if (!script) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -207,7 +207,7 @@ ArrayObject* js::GetFunctionParameterNam
 }
 
 bool js::ValueToIdentifier(JSContext* cx, HandleValue v, MutableHandleId id) {
-  if (!ToPropertyKey(cx, v, id)) {
+  if (!ToPropertyKey(cx, v, id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!id.isAtom() || !IsIdentifier(JSID_TO_ATOM(id))) {
@@ -281,11 +281,11 @@ static void PropagateForcedReturn(JSCont
   // The value passed in here is unwrapped and has no guarantees about what
   // compartment it may be associated with, so we explicitly wrap it into the
   // debuggee compartment.
-  if (!cx->compartment()->wrap(cx, &rval)) {
+  if (!cx->compartment()->wrap(cx, &rval)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!AdjustGeneratorResumptionValue(cx, frame, resumeMode, &rval)) {
+  if (!AdjustGeneratorResumptionValue(cx, frame, resumeMode, &rval)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -333,7 +333,7 @@ bool js::ValueToStableChars(JSContext* c
     return false;
   }
   RootedLinearString linear(cx, value.toString()->ensureLinear(cx));
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!stableChars.initTwoByte(cx, linear)) {
@@ -364,24 +364,24 @@ bool js::ParseEvalOptions(JSContext* cx,
   RootedObject opts(cx, &value.toObject());
 
   RootedValue v(cx);
-  if (!JS_GetProperty(cx, opts, "url", &v)) {
+  if (!JS_GetProperty(cx, opts, "url", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!v.isUndefined()) {
     RootedString url_str(cx, ToString<CanGC>(cx, v));
-    if (!url_str) {
+    if (!url_str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     UniqueChars url_bytes = JS_EncodeStringToLatin1(cx, url_str);
-    if (!url_bytes) {
+    if (!url_bytes) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!options.setFilename(cx, url_bytes.get())) {
+    if (!options.setFilename(cx, url_bytes.get())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!JS_GetProperty(cx, opts, "lineNumber", &v)) {
+  if (!JS_GetProperty(cx, opts, "lineNumber", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!v.isUndefined()) {
@@ -644,7 +644,7 @@ bool Debugger::getFrame(JSContext* cx, c
   MOZ_ASSERT_IF(referent.hasScript(), !referent.script()->selfHosted());
 
   if (referent.hasScript() &&
-      !referent.script()->ensureHasAnalyzedArgsUsage(cx)) {
+      !referent.script()->ensureHasAnalyzedArgsUsage(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -687,7 +687,7 @@ bool Debugger::getFrame(JSContext* cx, c
 
     RootedDebuggerFrame frame(
         cx, DebuggerFrame::create(cx, proto, debugger, &iter, genObj));
-    if (!frame) {
+    if (!frame) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -697,12 +697,12 @@ bool Debugger::getFrame(JSContext* cx, c
 
     if (genObj) {
       DependentAddPtr<GeneratorWeakMap> genPtr(cx, generatorFrames, genObj);
-      if (!genPtr.add(cx, generatorFrames, genObj, frame)) {
+      if (!genPtr.add(cx, generatorFrames, genObj, frame)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
 
-    if (!ensureExecutionObservabilityOfFrame(cx, referent)) {
+    if (!ensureExecutionObservabilityOfFrame(cx, referent)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -741,7 +741,7 @@ bool Debugger::getFrame(JSContext* cx, H
   RootedNativeObject debugger(cx, object);
 
   result.set(DebuggerFrame::create(cx, proto, debugger, nullptr, genObj));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -829,7 +829,7 @@ bool DebuggerList<HookIsEnabledFun>::dis
   // the debugger's microtask checkpoints don't run from the debuggee's
   // microtasks, and vice versa.
   JS::AutoDebuggerJobQueueInterruption adjqi;
-  if (!adjqi.init(cx)) {
+  if (!adjqi.init(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -939,7 +939,7 @@ bool DebugAPI::slowPathOnResumeFrame(JSC
             dbg->generatorFrames.lookup(genObj)) {
       DebuggerFrame* frameObj = generatorEntry->value();
       MOZ_ASSERT(&frameObj->unwrappedGenerator() == genObj);
-      if (!dbg->frames.putNew(frame, frameObj)) {
+      if (!dbg->frames.putNew(frame, frameObj)) {MOZ_RELEASE_ASSERT(0);
         ReportOutOfMemory(cx);
         return false;
       }
@@ -972,11 +972,11 @@ NativeResumeMode DebugAPI::slowPathOnNat
     return dbg->getHook(Debugger::OnNativeCall);
   });
 
-  if (!debuggerList.init(cx)) {
+  if (!debuggerList.init(cx)) {MOZ_RELEASE_ASSERT(0);
     return NativeResumeMode::Abort;
   }
 
-  if (debuggerList.empty()) {
+  if (debuggerList.empty()) {MOZ_RELEASE_ASSERT(0);
     return NativeResumeMode::Continue;
   }
 
@@ -998,13 +998,13 @@ NativeResumeMode DebugAPI::slowPathOnNat
   bool result = debuggerList.dispatchHook(cx, [&](Debugger* dbg) -> bool {
     return dbg->fireNativeCall(cx, args, reason, resumeMode, &rval);
   });
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return NativeResumeMode::Abort;
   }
 
   // The value is not in any particular compartment, so it needs to be
   // explicitly wrapped into the debuggee compartment.
-  if (!cx->compartment()->wrap(cx, &rval)) {
+  if (!cx->compartment()->wrap(cx, &rval)) {MOZ_RELEASE_ASSERT(0);
     return NativeResumeMode::Abort;
   }
 
@@ -1115,7 +1115,7 @@ bool DebugAPI::slowPathOnLeaveFrame(JSCo
   // called, the frame will not be present in the Debugger frame maps.
   Rooted<Debugger::DebuggerFrameVector> frames(
       cx, Debugger::DebuggerFrameVector(cx));
-  if (!Debugger::getDebuggerFrames(frame, &frames)) {
+  if (!Debugger::getDebuggerFrames(frame, &frames)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (frames.empty()) {
@@ -1132,7 +1132,7 @@ bool DebugAPI::slowPathOnLeaveFrame(JSCo
     // the debugger's microtask checkpoints don't run from the debuggee's
     // microtasks, and vice versa.
     JS::AutoDebuggerJobQueueInterruption adjqi;
-    if (!adjqi.init(cx)) {
+    if (!adjqi.init(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1184,7 +1184,7 @@ bool DebugAPI::slowPathOnLeaveFrame(JSCo
           });
           adjqi.runJobs();
 
-          if (!result) {
+          if (!result) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
 
@@ -1247,7 +1247,7 @@ bool DebugAPI::slowPathOnNewGenerator(JS
   bool ok = true;
   Debugger::forEachOnStackDebuggerFrame(
       frame, [&](Debugger* dbg, DebuggerFrame* frameObjPtr) {
-        if (!ok) {
+        if (!ok) {MOZ_RELEASE_ASSERT(0);
           return;
         }
 
@@ -1255,7 +1255,7 @@ bool DebugAPI::slowPathOnNewGenerator(JS
 
         AutoRealm ar(cx, frameObj);
 
-        if (!DebuggerFrame::setGeneratorInfo(cx, frameObj, genObj)) {
+        if (!DebuggerFrame::setGeneratorInfo(cx, frameObj, genObj)) {MOZ_RELEASE_ASSERT(0);
           // This leaves `genObj` and `frameObj` unassociated. It's OK
           // because we won't pause again with this generator on the stack:
           // the caller will immediately discard `genObj` and unwind `frame`.
@@ -1265,7 +1265,7 @@ bool DebugAPI::slowPathOnNewGenerator(JS
 
         DependentAddPtr<Debugger::GeneratorWeakMap> genPtr(
             cx, dbg->generatorFrames, genObj);
-        if (!genPtr.add(cx, dbg->generatorFrames, genObj, frameObj)) {
+        if (!genPtr.add(cx, dbg->generatorFrames, genObj, frameObj)) {MOZ_RELEASE_ASSERT(0);
           ok = false;
         }
       });
@@ -1308,7 +1308,7 @@ bool DebugAPI::slowPathOnExceptionUnwind
     return dbg->getHook(Debugger::OnExceptionUnwind);
   });
 
-  if (!debuggerList.init(cx)) {
+  if (!debuggerList.init(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1321,7 +1321,7 @@ bool DebugAPI::slowPathOnExceptionUnwind
   // only do it if the debuggerList contains items in order to avoid extra work.
   RootedValue exc(cx);
   RootedSavedFrame stack(cx, cx->getPendingExceptionStack());
-  if (!cx->getPendingException(&exc)) {
+  if (!cx->getPendingException(&exc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   cx->clearPendingException();
@@ -1344,7 +1344,7 @@ bool DebugAPI::slowPathOnExceptionUnwind
 ///      DebuggerEnvironment have been given a C++ interface (bug 1271649).
 bool Debugger::wrapEnvironment(JSContext* cx, Handle<Env*> env,
                                MutableHandleValue rval) {
-  if (!env) {
+  if (!env) {MOZ_RELEASE_ASSERT(0);
     rval.setNull();
     return true;
   }
@@ -1378,7 +1378,7 @@ bool Debugger::wrapEnvironment(JSContext
 
     RootedDebuggerEnvironment envobj(
         cx, DebuggerEnvironment::create(cx, proto, env, debugger));
-    if (!envobj) {
+    if (!envobj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1400,14 +1400,14 @@ bool Debugger::wrapDebuggeeValue(JSConte
     RootedObject obj(cx, &vp.toObject());
     RootedDebuggerObject dobj(cx);
 
-    if (!wrapDebuggeeObject(cx, obj, &dobj)) {
+    if (!wrapDebuggeeObject(cx, obj, &dobj)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     vp.setObject(*dobj);
   } else if (vp.isMagic()) {
     RootedPlainObject optObj(cx, NewBuiltinClassInstance<PlainObject>(cx));
-    if (!optObj) {
+    if (!optObj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1432,7 +1432,7 @@ bool Debugger::wrapDebuggeeValue(JSConte
     }
 
     RootedValue trueVal(cx, BooleanValue(true));
-    if (!DefineDataProperty(cx, optObj, name, trueVal)) {
+    if (!DefineDataProperty(cx, optObj, name, trueVal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1469,7 +1469,7 @@ bool Debugger::wrapDebuggeeObject(JSCont
         cx, &object->getReservedSlot(JSSLOT_DEBUG_OBJECT_PROTO).toObject());
     RootedDebuggerObject dobj(cx,
                               DebuggerObject::create(cx, proto, obj, debugger));
-    if (!dobj) {
+    if (!dobj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1568,7 +1568,7 @@ bool Debugger::unwrapPropertyDescriptor(
       if (!unwrapDebuggeeObject(cx, &get)) {
         return false;
       }
-      if (!CheckArgCompartment(cx, obj, get, "defineProperty", "get")) {
+      if (!CheckArgCompartment(cx, obj, get, "defineProperty", "get")) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1670,7 +1670,7 @@ static bool CheckResumptionValue(JSConte
     {
       AutoRealm ar(cx, frame.environmentChain());
       if (!GetThisValueForDebuggerFrameMaybeOptimizedOut(cx, frame, pc,
-                                                         &thisv)) {
+                                                         &thisv)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1680,7 +1680,7 @@ static bool CheckResumptionValue(JSConte
     }
     MOZ_ASSERT(!thisv.isMagic());
 
-    if (!cx->compartment()->wrap(cx, &thisv)) {
+    if (!cx->compartment()->wrap(cx, &thisv)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     vp.set(thisv);
@@ -1753,7 +1753,7 @@ static bool CheckResumptionValue(JSConte
     // twice:
     if (!genObj->is<AsyncGeneratorObject>()) {
       PlainObject* pair = CreateIterResultObject(cx, vp, true);
-      if (!pair) {
+      if (!pair) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       vp.setObject(*pair);
@@ -1783,7 +1783,7 @@ static bool CheckResumptionValue(JSConte
       Rooted<PromiseObject*> promise(cx, asyncGenObj->promise());
       if (promise->state() == JS::PromiseState::Pending) {
         if (!AsyncFunctionResolve(cx, asyncGenObj, vp,
-                                  AsyncFunctionResolveKind::Fulfill)) {
+                                  AsyncFunctionResolveKind::Fulfill)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -1873,7 +1873,7 @@ bool Debugger::callUncaughtExceptionHand
 
   if (cx->isExceptionPending() && uncaughtExceptionHook) {
     RootedValue exc(cx);
-    if (!cx->getPendingException(&exc)) {
+    if (!cx->getPendingException(&exc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     cx->clearPendingException();
@@ -2172,13 +2172,13 @@ static bool CallMethodIfPresent(JSContex
                                 MutableHandleValue rval) {
   rval.setUndefined();
   JSAtom* atom = Atomize(cx, name, strlen(name));
-  if (!atom) {
+  if (!atom) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedId id(cx, AtomToId(atom));
   RootedValue fval(cx);
-  if (!GetProperty(cx, obj, obj, id, &fval)) {
+  if (!GetProperty(cx, obj, obj, id, &fval)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2187,7 +2187,7 @@ static bool CallMethodIfPresent(JSContex
   }
 
   InvokeArgs args(cx);
-  if (!args.init(cx, argc)) {
+  if (!args.init(cx, argc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2281,7 +2281,7 @@ bool Debugger::fireNativeCall(JSContext*
 
   RootedValue fval(cx, ObjectValue(*hook));
   RootedValue calleeval(cx, args.calleev());
-  if (!wrapDebuggeeValue(cx, &calleeval)) {
+  if (!wrapDebuggeeValue(cx, &calleeval)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2400,7 +2400,7 @@ static bool RememberSourceURL(JSContext*
   RootedObject holder(cx, script->global().getSourceURLsHolder());
   if (!holder) {
     holder = NewDenseEmptyArray(cx);
-    if (!holder) {
+    if (!holder) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     script->global().setSourceURLsHolder(holder);
@@ -2425,7 +2425,7 @@ void DebugAPI::onNewScript(JSContext* cx
     // Remember the URLs associated with scripts in non-system realms,
     // in case the debugger is attached later.
     if (!script->realm()->isSystem()) {
-      if (!RememberSourceURL(cx, script)) {
+      if (!RememberSourceURL(cx, script)) {MOZ_RELEASE_ASSERT(0);
         cx->clearPendingException();
       }
     }
@@ -2491,7 +2491,7 @@ bool DebugAPI::onTrap(JSContext* cx) {
   // we check for that case below.
   Vector<Breakpoint*> triggered(cx);
   for (Breakpoint* bp = site->firstBreakpoint(); bp; bp = bp->nextInSite()) {
-    if (!triggered.append(bp)) {
+    if (!triggered.append(bp)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2504,7 +2504,7 @@ bool DebugAPI::onTrap(JSContext* cx) {
     // the debugger's microtask checkpoints don't run from the debuggee's
     // microtasks, and vice versa.
     JS::AutoDebuggerJobQueueInterruption adjqi;
-    if (!adjqi.init(cx)) {
+    if (!adjqi.init(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2551,7 +2551,7 @@ bool DebugAPI::onTrap(JSContext* cx) {
         });
         adjqi.runJobs();
 
-        if (!result) {
+        if (!result) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -2585,7 +2585,7 @@ bool DebugAPI::onSingleStep(JSContext* c
   // onStep handlers.
   Rooted<Debugger::DebuggerFrameVector> frames(
       cx, Debugger::DebuggerFrameVector(cx));
-  if (!Debugger::getDebuggerFrames(iter.abstractFramePtr(), &frames)) {
+  if (!Debugger::getDebuggerFrames(iter.abstractFramePtr(), &frames)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2661,7 +2661,7 @@ bool DebugAPI::onSingleStep(JSContext* c
     // the debugger's microtask checkpoints don't run from the debuggee's
     // microtasks, and vice versa.
     JS::AutoDebuggerJobQueueInterruption adjqi;
-    if (!adjqi.init(cx)) {
+    if (!adjqi.init(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2687,7 +2687,7 @@ bool DebugAPI::onSingleStep(JSContext* c
       });
       adjqi.runJobs();
 
-      if (!result) {
+      if (!result) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2707,7 +2707,7 @@ bool Debugger::fireNewGlobalObject(JSCon
   MOZ_ASSERT(hook->isCallable());
 
   RootedValue wrappedGlobal(cx, ObjectValue(*global));
-  if (!wrapDebuggeeValue(cx, &wrappedGlobal)) {
+  if (!wrapDebuggeeValue(cx, &wrappedGlobal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2745,9 +2745,9 @@ void DebugAPI::slowPathOnNewGlobalObject
     JSObject* obj = dbg.object;
     JS::ExposeObjectToActiveJS(obj);
     if (!watchers.append(obj)) {
-      if (cx->isExceptionPending()) {
+      if (cx->isExceptionPending()) {MOZ_RELEASE_ASSERT(0);
         cx->clearPendingException();
-      }
+      }MOZ_RELEASE_ASSERT(0);
       return;
     }
   }
@@ -2756,7 +2756,7 @@ void DebugAPI::slowPathOnNewGlobalObject
   // the debugger's microtask checkpoints don't run from the debuggee's
   // microtasks, and vice versa.
   JS::AutoDebuggerJobQueueInterruption adjqi;
-  if (!adjqi.init(cx)) {
+  if (!adjqi.init(cx)) {MOZ_RELEASE_ASSERT(0);
     cx->clearPendingException();
     return;
   }
@@ -2802,7 +2802,7 @@ void DebugAPI::slowPathNotifyParticipate
 /* static */
 Maybe<double> DebugAPI::allocationSamplingProbability(GlobalObject* global) {
   Realm::DebuggerVector& dbgs = global->getDebuggers();
-  if (dbgs.empty()) {
+  if (dbgs.empty()) {MOZ_RELEASE_ASSERT(0);
     return Nothing();
   }
 
@@ -2844,7 +2844,7 @@ bool DebugAPI::slowPathOnLogAllocationSi
   // Debuggers, and globals only hold their Debuggers weakly.
   Rooted<GCVector<JSObject*>> activeDebuggers(cx, GCVector<JSObject*>(cx));
   for (auto p = dbgs.begin(); p < dbgs.end(); p++) {
-    if (!activeDebuggers.append(p->dbg->object)) {
+    if (!activeDebuggers.append(p->dbg->object)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2876,7 +2876,7 @@ bool Debugger::appendAllocationSite(JSCo
 
   AutoRealm ar(cx, object);
   RootedObject wrappedFrame(cx, frame);
-  if (!cx->compartment()->wrap(cx, &wrappedFrame)) {
+  if (!cx->compartment()->wrap(cx, &wrappedFrame)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2886,7 +2886,7 @@ bool Debugger::appendAllocationSite(JSCo
   auto inNursery = gc::IsInsideNursery(obj);
 
   if (!allocationsLog.emplaceBack(wrappedFrame, when, className, size,
-                                  inNursery)) {
+                                  inNursery)) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -2908,7 +2908,7 @@ bool Debugger::firePromiseHook(JSContext
   MOZ_ASSERT(hookObj->isCallable());
 
   RootedValue dbgObj(cx, ObjectValue(*promise));
-  if (!wrapDebuggeeValue(cx, &dbgObj)) {
+  if (!wrapDebuggeeValue(cx, &dbgObj)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3089,7 +3089,7 @@ bool Debugger::updateExecutionObservabil
 
   {
     jit::JitContext jctx(cx, nullptr);
-    if (!jit::RecompileOnStackBaselineScriptsForDebugMode(cx, obs, observing)) {
+    if (!jit::RecompileOnStackBaselineScriptsForDebugMode(cx, obs, observing)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
@@ -3164,7 +3164,7 @@ static bool UpdateExecutionObservability
     RecompileInfoVector invalid;
     if (JSScript* script = obs.singleScriptForZoneInvalidation()) {
       if (obs.shouldRecompileOrInvalidate(script)) {
-        if (!AppendAndInvalidateScript(cx, zone, script, invalid, scripts)) {
+        if (!AppendAndInvalidateScript(cx, zone, script, invalid, scripts)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -3176,7 +3176,7 @@ static bool UpdateExecutionObservability
         }
         JSScript* script = base->asJSScript();
         if (obs.shouldRecompileOrInvalidate(script)) {
-          if (!AppendAndInvalidateScript(cx, zone, script, invalid, scripts)) {
+          if (!AppendAndInvalidateScript(cx, zone, script, invalid, scripts)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -3286,7 +3286,7 @@ void Debugger::forEachOnStackOrSuspended
     if (FrameMap::Ptr frameEntry = dbg->frames.lookup(frame)) {
       frameObj = frameEntry->value();
     } else if (GeneratorWeakMap::Ptr frameEntry =
-                   dbg->generatorFrames.lookup(genObj)) {
+                   dbg->generatorFrames.lookup(genObj)) {MOZ_RELEASE_ASSERT(0);
       frameObj = frameEntry->value();
     }
 
@@ -3360,7 +3360,7 @@ bool Debugger::ensureExecutionObservabil
 /* static */
 bool Debugger::ensureExecutionObservabilityOfRealm(JSContext* cx,
                                                    Realm* realm) {
-  if (realm->debuggerObservesAllExecution()) {
+  if (realm->debuggerObservesAllExecution()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
   ExecutionObservableRealms obs(cx);
@@ -3422,12 +3422,12 @@ bool Debugger::updateObservesAllExecutio
 
     // It's expensive to eagerly invalidate and recompile a realm,
     // so add the realm to the set only if we are observing.
-    if (observing && !obs.add(realm)) {
+    if (observing && !obs.add(realm)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!updateExecutionObservability(cx, obs, observing)) {
+  if (!updateExecutionObservability(cx, obs, observing)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3455,7 +3455,7 @@ bool Debugger::updateObservesCoverageOnD
     // Invalidate and recompile a realm to add or remove PCCounts
     // increments. We have to eagerly invalidate, as otherwise we might have
     // dangling pointers to freed PCCounts.
-    if (!obs.add(realm)) {
+    if (!obs.add(realm)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -3471,7 +3471,7 @@ bool Debugger::updateObservesCoverageOnD
     }
   }
 
-  if (!updateExecutionObservability(cx, obs, observing)) {
+  if (!updateExecutionObservability(cx, obs, observing)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3485,9 +3485,9 @@ bool Debugger::updateObservesCoverageOnD
   return true;
 }
 
-void Debugger::updateObservesAsmJSOnDebuggees(IsObserving observing) {
+void Debugger::updateObservesAsmJSOnDebuggees(IsObserving observing) {MOZ_RELEASE_ASSERT(0);
   for (WeakGlobalObjectSet::Range r = debuggees.all(); !r.empty();
-       r.popFront()) {
+       r.popFront()) {MOZ_RELEASE_ASSERT(0);
     GlobalObject* global = r.front();
     Realm* realm = global->realm();
 
@@ -4138,7 +4138,7 @@ bool Debugger::setHookImpl(JSContext* cx
   dbg.object->setReservedSlot(slot, args[0]);
   if (hookObservesAllExecution(which)) {
     if (!dbg.updateObservesAllExecutionOnDebuggees(
-            cx, dbg.observesAllExecution())) {
+            cx, dbg.observesAllExecution())) {MOZ_RELEASE_ASSERT(0);
       dbg.object->setReservedSlot(slot, oldHook);
       return false;
     }
@@ -4378,7 +4378,7 @@ GlobalObject* Debugger::unwrapDebuggeeAr
   // have to make sure to do a dynamic unwrap, and we want to unwrap the
   // WindowProxy too, if we have one.
   obj = CheckedUnwrapDynamic(obj, cx, /* stopAtWindowProxy = */ false);
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     ReportAccessDenied(cx);
     return nullptr;
   }
@@ -4395,7 +4395,7 @@ GlobalObject* Debugger::unwrapDebuggeeAr
 }
 
 bool Debugger::CallData::addDebuggee() {
-  if (!args.requireAtLeast(cx, "Debugger.addDebuggee", 1)) {
+  if (!args.requireAtLeast(cx, "Debugger.addDebuggee", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   Rooted<GlobalObject*> global(cx, dbg->unwrapDebuggeeArgument(cx, args[0]));
@@ -4440,7 +4440,7 @@ bool Debugger::CallData::addAllGlobalsAs
 }
 
 bool Debugger::CallData::removeDebuggee() {
-  if (!args.requireAtLeast(cx, "Debugger.removeDebuggee", 1)) {
+  if (!args.requireAtLeast(cx, "Debugger.removeDebuggee", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   Rooted<GlobalObject*> global(cx, dbg->unwrapDebuggeeArgument(cx, args[0]));
@@ -4457,7 +4457,7 @@ bool Debugger::CallData::removeDebuggee(
     // Only update the realm if there are no Debuggers left, as it's
     // expensive to check if no other Debugger has a live script or frame
     // hook on any of the current on-stack debuggee frames.
-    if (global->getDebuggers().empty() && !obs.add(global->realm())) {
+    if (global->getDebuggers().empty() && !obs.add(global->realm())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!updateExecutionObservability(cx, obs, NotObserving)) {
@@ -4478,7 +4478,7 @@ bool Debugger::CallData::removeAllDebugg
                               FromSweep::No);
 
     // See note about adding to the observable set in removeDebuggee.
-    if (global->getDebuggers().empty() && !obs.add(global->realm())) {
+    if (global->getDebuggers().empty() && !obs.add(global->realm())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -4492,7 +4492,7 @@ bool Debugger::CallData::removeAllDebugg
 }
 
 bool Debugger::CallData::hasDebuggee() {
-  if (!args.requireAtLeast(cx, "Debugger.hasDebuggee", 1)) {
+  if (!args.requireAtLeast(cx, "Debugger.hasDebuggee", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   GlobalObject* global = dbg->unwrapDebuggeeArgument(cx, args[0]);
@@ -4508,7 +4508,7 @@ bool Debugger::CallData::getDebuggees() 
   // update the debuggees set while we are iterating it.
   unsigned count = dbg->debuggees.count();
   RootedValueVector debuggees(cx);
-  if (!debuggees.resize(count)) {
+  if (!debuggees.resize(count)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   unsigned i = 0;
@@ -4521,7 +4521,7 @@ bool Debugger::CallData::getDebuggees() 
   }
 
   RootedArrayObject arrobj(cx, NewDenseFullyAllocatedArray(cx, count));
-  if (!arrobj) {
+  if (!arrobj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   arrobj->ensureDenseInitializedLength(0, count);
@@ -4543,7 +4543,7 @@ bool Debugger::CallData::getNewestFrame(
     if (dbg->observesFrame(i)) {
       // Ensure that Ion frames are rematerialized. Only rematerialized
       // Ion frames may be used as AbstractFramePtrs.
-      if (i.isIon() && !i.ensureHasRematerializedFrame(cx)) {
+      if (i.isIon() && !i.ensureHasRematerializedFrame(cx)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       AbstractFramePtr frame = i.abstractFramePtr();
@@ -4592,7 +4592,7 @@ bool Debugger::construct(JSContext* cx, 
   // Get Debugger.prototype.
   RootedValue v(cx);
   RootedObject callee(cx, &args.callee());
-  if (!GetProperty(cx, callee, callee, cx->names().prototype, &v)) {
+  if (!GetProperty(cx, callee, callee, cx->names().prototype, &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedNativeObject proto(cx, &v.toObject().as<NativeObject>());
@@ -4603,7 +4603,7 @@ bool Debugger::construct(JSContext* cx, 
   // rest of the reserved slots are for hooks; they default to undefined.
   Rooted<DebuggerInstanceObject*> obj(
       cx, NewTenuredObjectWithGivenProto<DebuggerInstanceObject>(cx, proto));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (unsigned slot = JSSLOT_DEBUG_PROTO_START; slot < JSSLOT_DEBUG_PROTO_STOP;
@@ -4614,7 +4614,7 @@ bool Debugger::construct(JSContext* cx, 
 
   RootedNativeObject livenessLink(
       cx, NewObjectWithGivenProto<DebuggerDebuggeeLink>(cx, nullptr));
-  if (!livenessLink) {
+  if (!livenessLink) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   obj->setReservedSlot(JSSLOT_DEBUG_DEBUGGEE_LINK, ObjectValue(*livenessLink));
@@ -4623,7 +4623,7 @@ bool Debugger::construct(JSContext* cx, 
   {
     // Construct the underlying C++ object.
     auto dbg = cx->make_unique<Debugger>(cx, obj.get());
-    if (!dbg) {
+    if (!dbg) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -4674,7 +4674,7 @@ bool Debugger::addDebuggeeGlobal(JSConte
   // global would create a cycle. (Typically nobody is debugging the
   // debugger, in which case we zip through this code without looping.)
   Vector<Realm*> visited(cx);
-  if (!visited.append(object->realm())) {
+  if (!visited.append(object->realm())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (size_t i = 0; i < visited.length(); i++) {
@@ -4690,7 +4690,7 @@ bool Debugger::addDebuggeeGlobal(JSConte
       for (Realm::DebuggerVectorEntry& entry : realm->getDebuggers()) {
         Realm* next = entry.dbg->object->realm();
         if (std::find(visited.begin(), visited.end(), next) == visited.end()) {
-          if (!visited.append(next)) {
+          if (!visited.append(next)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -4713,20 +4713,20 @@ bool Debugger::addDebuggeeGlobal(JSConte
   Zone* zone = global->zone();
 
   RootedObject debuggeeLink(cx, getDebuggeeLink());
-  if (!cx->compartment()->wrap(cx, &debuggeeLink)) {
+  if (!cx->compartment()->wrap(cx, &debuggeeLink)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // (1)
   auto& globalDebuggers = global->getDebuggers();
-  if (!globalDebuggers.append(Realm::DebuggerVectorEntry(this, debuggeeLink))) {
+  if (!globalDebuggers.append(Realm::DebuggerVectorEntry(this, debuggeeLink))) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
   auto globalDebuggersGuard = MakeScopeExit([&] { globalDebuggers.popBack(); });
 
   // (2)
-  if (!debuggees.put(global)) {
+  if (!debuggees.put(global)) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -4735,7 +4735,7 @@ bool Debugger::addDebuggeeGlobal(JSConte
   bool addingZoneRelation = !debuggeeZones.has(zone);
 
   // (3)
-  if (addingZoneRelation && !debuggeeZones.put(zone)) {
+  if (addingZoneRelation && !debuggeeZones.put(zone)) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -4747,7 +4747,7 @@ bool Debugger::addDebuggeeGlobal(JSConte
 
   // (4)
   if (trackingAllocationSites &&
-      !Debugger::addAllocationsTracking(cx, global)) {
+      !Debugger::addAllocationsTracking(cx, global)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4961,11 +4961,11 @@ class MOZ_STACK_CLASS Debugger::ScriptQu
     // Check for a 'global' property, which limits the results to those
     // scripts scoped to a particular global object.
     RootedValue global(cx);
-    if (!GetProperty(cx, query, query, cx->names().global, &global)) {
+    if (!GetProperty(cx, query, query, cx->names().global, &global)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (global.isUndefined()) {
-      if (!matchAllDebuggeeGlobals()) {
+      if (!matchAllDebuggeeGlobals()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -4977,14 +4977,14 @@ class MOZ_STACK_CLASS Debugger::ScriptQu
       // If the given global isn't a debuggee, just leave the set of
       // acceptable globals empty; we'll return no scripts.
       if (debugger->debuggees.has(globalObject)) {
-        if (!matchSingleGlobal(globalObject)) {
+        if (!matchSingleGlobal(globalObject)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
     }
 
     // Check for a 'url' property.
-    if (!GetProperty(cx, query, query, cx->names().url, &url)) {
+    if (!GetProperty(cx, query, query, cx->names().url, &url)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!url.isUndefined() && !url.isString()) {
@@ -4996,12 +4996,12 @@ class MOZ_STACK_CLASS Debugger::ScriptQu
 
     // Check for a 'source' property
     RootedValue debuggerSource(cx);
-    if (!GetProperty(cx, query, query, cx->names().source, &debuggerSource)) {
+    if (!GetProperty(cx, query, query, cx->names().source, &debuggerSource)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!debuggerSource.isUndefined()) {
       if (!debuggerSource.isObject() ||
-          !debuggerSource.toObject().is<DebuggerSource>()) {
+          !debuggerSource.toObject().is<DebuggerSource>()) {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                   JSMSG_UNEXPECTED_TYPE,
                                   "query object's 'source' property",
@@ -5037,7 +5037,7 @@ class MOZ_STACK_CLASS Debugger::ScriptQu
 
     // Check for a 'displayURL' property.
     RootedValue displayURL(cx);
-    if (!GetProperty(cx, query, query, cx->names().displayURL, &displayURL)) {
+    if (!GetProperty(cx, query, query, cx->names().displayURL, &displayURL)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!displayURL.isUndefined() && !displayURL.isString()) {
@@ -5050,14 +5050,14 @@ class MOZ_STACK_CLASS Debugger::ScriptQu
 
     if (displayURL.isString()) {
       displayURLString = displayURL.toString()->ensureLinear(cx);
-      if (!displayURLString) {
+      if (!displayURLString) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
 
     // Check for a 'line' property.
     RootedValue lineProperty(cx);
-    if (!GetProperty(cx, query, query, cx->names().line, &lineProperty)) {
+    if (!GetProperty(cx, query, query, cx->names().line, &lineProperty)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (lineProperty.isUndefined()) {
@@ -5087,7 +5087,7 @@ class MOZ_STACK_CLASS Debugger::ScriptQu
     // Check for an 'innermost' property.
     PropertyName* innermostName = cx->names().innermost;
     RootedValue innermostProperty(cx);
-    if (!GetProperty(cx, query, query, innermostName, &innermostProperty)) {
+    if (!GetProperty(cx, query, query, innermostName, &innermostProperty)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     innermost = ToBoolean(innermostProperty);
@@ -5118,7 +5118,7 @@ class MOZ_STACK_CLASS Debugger::ScriptQu
    * this query, and append the matching scripts to |scriptVector|.
    */
   bool findScripts() {
-    if (!prepareQuery()) {
+    if (!prepareQuery()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5132,7 +5132,7 @@ class MOZ_STACK_CLASS Debugger::ScriptQu
     MOZ_ASSERT(partialMatchVector.empty());
     oom = false;
     IterateScripts(cx, singletonRealm, this, considerScript);
-    if (oom) {
+    if (oom) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
@@ -5144,15 +5144,15 @@ class MOZ_STACK_CLASS Debugger::ScriptQu
     MOZ_ASSERT(hasLine || partialMatchVector.empty());
     Rooted<BaseScript*> script(cx);
     RootedFunction fun(cx);
-    while (!partialMatchVector.empty()) {
+    while (!partialMatchVector.empty()) {MOZ_RELEASE_ASSERT(0);
       script = partialMatchVector.popCopy();
 
       // As a performance optimization, we can skip scripts that are definitely
       // out-of-bounds for the target line. This was checked before adding to
       // the partialMatchVector, but the bound may have improved since then.
-      if (script->extent().sourceEnd <= sourceOffsetLowerBound) {
+      if (script->extent().sourceEnd <= sourceOffsetLowerBound) {MOZ_RELEASE_ASSERT(0);
         continue;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       MOZ_ASSERT(script->isFunction());
       MOZ_ASSERT(script->isReadyForDelazification());
@@ -5161,48 +5161,48 @@ class MOZ_STACK_CLASS Debugger::ScriptQu
 
       // Delazify script.
       JSScript* compiledScript = GetOrCreateFunctionScript(cx, fun);
-      if (!compiledScript) {
+      if (!compiledScript) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       // If target line isn't in script, we are done with it.
-      if (!scriptIsLineMatch(compiledScript)) {
+      if (!scriptIsLineMatch(compiledScript)) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
 
       // Add script to results now that we've completed checks.
-      if (!scriptVector.append(compiledScript)) {
+      if (!scriptVector.append(compiledScript)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       // If script was a leaf we are done with it. This is an optional
       // optimization to avoid inspecting the `gcthings` list below.
-      if (!script->hasInnerFunctions()) {
+      if (!script->hasInnerFunctions()) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
 
       // Now add inner scripts to `partialMatchVector` work list to determine if
       // they are matches. Note that out IterateScripts callback ignored them
       // already since they did not have a compiled parent at the time.
-      for (const JS::GCCellPtr& thing : script->gcthings()) {
-        if (!thing.is<JSObject>() || !thing.as<JSObject>().is<JSFunction>()) {
+      for (const JS::GCCellPtr& thing : script->gcthings()) {MOZ_RELEASE_ASSERT(0);
+        if (!thing.is<JSObject>() || !thing.as<JSObject>().is<JSFunction>()) {MOZ_RELEASE_ASSERT(0);
           continue;
         }
-        if (!thing.as<JSObject>().as<JSFunction>().hasBaseScript()) {
+        if (!thing.as<JSObject>().as<JSFunction>().hasBaseScript()) {MOZ_RELEASE_ASSERT(0);
           continue;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         BaseScript* inner = thing.as<JSObject>().as<JSFunction>().baseScript();
 
-        if (!scriptIsPartialLineMatch(inner)) {
+        if (!scriptIsPartialLineMatch(inner)) {MOZ_RELEASE_ASSERT(0);
           continue;
         }
 
         // Add the matching inner script to the back of the results queue
         // where it will be processed recursively.
-        if (!partialMatchVector.append(inner)) {
+        if (!partialMatchVector.append(inner)) {MOZ_RELEASE_ASSERT(0);
           return false;
-        }
-      }
+        }MOZ_RELEASE_ASSERT(0);
+      }MOZ_RELEASE_ASSERT(0);
     }
 
     // If this is an 'innermost' query, we want to filter the results again to
@@ -5229,7 +5229,7 @@ class MOZ_STACK_CLASS Debugger::ScriptQu
         } else {
           // This is the first matching script we've encountered for this
           // realm, so it is thus the innermost such script.
-          if (!innermostForRealm.add(p, realm, script)) {
+          if (!innermostForRealm.add(p, realm, script)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -5241,7 +5241,7 @@ class MOZ_STACK_CLASS Debugger::ScriptQu
       // Re-add only the innermost scripts to the results.
       for (RealmToScriptMap::Range r = innermostForRealm.all(); !r.empty();
            r.popFront()) {
-        if (!scriptVector.append(r.front().value())) {
+        if (!scriptVector.append(r.front().value())) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -5471,9 +5471,9 @@ class MOZ_STACK_CLASS Debugger::ScriptQu
         // the partial match list for be compiled and reprocessed later. We only
         // add scripts that are ready for delazification and they may in turn
         // process their inner functions.
-        if (!script->isReadyForDelazification()) {
+        if (!script->isReadyForDelazification()) {MOZ_RELEASE_ASSERT(0);
           return;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         partial = true;
       }
     }
@@ -5493,7 +5493,7 @@ class MOZ_STACK_CLASS Debugger::ScriptQu
    * Set |oom| if an out of memory condition occurred.
    */
   void consider(WasmInstanceObject* instanceObject) {
-    if (oom) {
+    if (oom) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
@@ -5516,12 +5516,12 @@ bool Debugger::CallData::findScripts() {
       return false;
     }
   } else {
-    if (!query.omittedQuery()) {
+    if (!query.omittedQuery()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!query.findScripts()) {
+  if (!query.findScripts()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5530,7 +5530,7 @@ bool Debugger::CallData::findScripts() {
 
   size_t resultLength = scripts.length() + wasmInstances.length();
   RootedArrayObject result(cx, NewDenseFullyAllocatedArray(cx, resultLength));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5538,7 +5538,7 @@ bool Debugger::CallData::findScripts() {
 
   for (size_t i = 0; i < scripts.length(); i++) {
     JSObject* scriptObject = dbg->wrapScript(cx, scripts[i]);
-    if (!scriptObject) {
+    if (!scriptObject) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     result->setDenseElement(i, ObjectValue(*scriptObject));
@@ -5569,7 +5569,7 @@ class MOZ_STACK_CLASS Debugger::SourceQu
       : QueryBase(cx, dbg), sources(cx, SourceSet(cx->zone())) {}
 
   bool findSources() {
-    if (!matchAllDebuggeeGlobals()) {
+    if (!matchAllDebuggeeGlobals()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5582,7 +5582,7 @@ class MOZ_STACK_CLASS Debugger::SourceQu
     MOZ_ASSERT(sources.empty());
     oom = false;
     IterateScripts(cx, singletonRealm, this, considerScript);
-    if (oom) {
+    if (oom) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
@@ -5631,7 +5631,7 @@ class MOZ_STACK_CLASS Debugger::SourceQu
   }
 
   void consider(WasmInstanceObject* instanceObject) {
-    if (oom) {
+    if (oom) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
@@ -5650,7 +5650,7 @@ static inline DebuggerSourceReferent AsS
 
 bool Debugger::CallData::findSources() {
   SourceQuery query(cx, dbg);
-  if (!query.findSources()) {
+  if (!query.findSources()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5658,7 +5658,7 @@ bool Debugger::CallData::findSources() {
 
   size_t resultLength = sources.count();
   RootedArrayObject result(cx, NewDenseFullyAllocatedArray(cx, resultLength));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5703,7 +5703,7 @@ class MOZ_STACK_CLASS Debugger::ObjectQu
   bool parseQuery(HandleObject query) {
     // Check for the 'class' property
     RootedValue cls(cx);
-    if (!GetProperty(cx, query, query, cx->names().class_, &cls)) {
+    if (!GetProperty(cx, query, query, cx->names().class_, &cls)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!cls.isUndefined()) {
@@ -5715,7 +5715,7 @@ class MOZ_STACK_CLASS Debugger::ObjectQu
         return false;
       }
       JSLinearString* str = cls.toString()->ensureLinear(cx);
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (!StringIsAscii(str)) {
@@ -5738,13 +5738,13 @@ class MOZ_STACK_CLASS Debugger::ObjectQu
    * provided vector.
    */
   bool findObjects() {
-    if (!prepareQuery()) {
+    if (!prepareQuery()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     for (WeakGlobalObjectSet::Range r = dbg->allDebuggees(); !r.empty();
          r.popFront()) {
-      if (!debuggeeCompartments.put(r.front()->compartment())) {
+      if (!debuggeeCompartments.put(r.front()->compartment())) {MOZ_RELEASE_ASSERT(0);
         ReportOutOfMemory(cx);
         return false;
       }
@@ -5804,7 +5804,7 @@ class MOZ_STACK_CLASS Debugger::ObjectQu
     // within a compartment can reference each other without going through
     // cross-compartment wrappers.
     Realm* realm = referent.realm();
-    if (realm && !dbg->isDebuggeeUnbarriered(realm)) {
+    if (realm && !dbg->isDebuggeeUnbarriered(realm)) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
 
@@ -5873,13 +5873,13 @@ bool Debugger::CallData::findObjects() {
     query.omittedQuery();
   }
 
-  if (!query.findObjects()) {
+  if (!query.findObjects()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   size_t length = query.objects.length();
   RootedArrayObject result(cx, NewDenseFullyAllocatedArray(cx, length));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5922,7 +5922,7 @@ bool Debugger::CallData::findAllGlobals(
 
       GlobalObject* global = r->maybeGlobal();
 
-      if (cx->runtime()->isSelfHostingGlobal(global)) {
+      if (cx->runtime()->isSelfHostingGlobal(global)) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
 
@@ -5930,20 +5930,20 @@ bool Debugger::CallData::findAllGlobals(
       // marked gray by XPConnect. Since we're now exposing it to JS code,
       // we need to mark it black.
       JS::ExposeObjectToActiveJS(global);
-      if (!globals.append(global)) {
+      if (!globals.append(global)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
   }
 
   RootedObject result(cx, NewDenseEmptyArray(cx));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   for (size_t i = 0; i < globals.length(); i++) {
     RootedValue globalValue(cx, ObjectValue(*globals[i]));
-    if (!dbg->wrapDebuggeeValue(cx, &globalValue)) {
+    if (!dbg->wrapDebuggeeValue(cx, &globalValue)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!NewbornArrayPush(cx, result, globalValue)) {
@@ -5957,7 +5957,7 @@ bool Debugger::CallData::findAllGlobals(
 
 bool Debugger::CallData::findSourceURLs() {
   RootedObject result(cx, NewDenseEmptyArray(cx));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5986,7 +5986,7 @@ bool Debugger::CallData::findSourceURLs(
 }
 
 bool Debugger::CallData::makeGlobalObjectReference() {
-  if (!args.requireAtLeast(cx, "Debugger.makeGlobalObjectReference", 1)) {
+  if (!args.requireAtLeast(cx, "Debugger.makeGlobalObjectReference", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6026,7 +6026,7 @@ bool Debugger::isCompilableUnit(JSContex
   size_t length = str->length();
 
   AutoStableStringChars chars(cx);
-  if (!chars.initTwoByte(cx, str)) {
+  if (!chars.initTwoByte(cx, str)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6035,13 +6035,13 @@ bool Debugger::isCompilableUnit(JSContex
   CompileOptions options(cx);
   Rooted<frontend::CompilationInput> input(cx,
                                            frontend::CompilationInput(options));
-  if (!input.get().initForGlobal(cx)) {
+  if (!input.get().initForGlobal(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   LifoAllocScope allocScope(&cx->tempLifoAlloc());
   frontend::CompilationState compilationState(cx, allocScope, input.get());
-  if (!compilationState.init(cx)) {
+  if (!compilationState.init(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6053,7 +6053,7 @@ bool Debugger::isCompilableUnit(JSContex
   if (!parser.checkOptions() || !parser.parse()) {
     // We ran into an error. If it was because we ran out of memory we report
     // it in the usual way.
-    if (cx->isThrowingOutOfMemory()) {
+    if (cx->isThrowingOutOfMemory()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -6071,7 +6071,7 @@ bool Debugger::isCompilableUnit(JSContex
 }
 
 bool Debugger::CallData::adoptDebuggeeValue() {
-  if (!args.requireAtLeast(cx, "Debugger.adoptDebuggeeValue", 1)) {
+  if (!args.requireAtLeast(cx, "Debugger.adoptDebuggeeValue", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6113,7 +6113,7 @@ class DebuggerAdoptSourceMatcher {
     }
     return dbg_->wrapSource(cx_, source);
   }
-  ReturnType match(Handle<WasmInstanceObject*> wasmInstance) {
+  ReturnType match(Handle<WasmInstanceObject*> wasmInstance) {MOZ_RELEASE_ASSERT(0);
     if (wasmInstance->compartment() == cx_->compartment()) {
       JS_ReportErrorASCII(
           cx_, "WasmInstance is in the same compartment as this debugger");
@@ -6124,24 +6124,24 @@ class DebuggerAdoptSourceMatcher {
 };
 
 bool Debugger::CallData::adoptFrame() {
-  if (!args.requireAtLeast(cx, "Debugger.adoptFrame", 1)) {
+  if (!args.requireAtLeast(cx, "Debugger.adoptFrame", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject obj(cx, RequireObject(cx, args[0]));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   obj = UncheckedUnwrap(obj);
-  if (!obj->is<DebuggerFrame>()) {
+  if (!obj->is<DebuggerFrame>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Argument is not a Debugger.Frame");
     return false;
   }
 
   RootedValue objVal(cx, ObjectValue(*obj));
   RootedDebuggerFrame frameObj(cx, DebuggerFrame::check(cx, objVal));
-  if (!frameObj) {
+  if (!frameObj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6152,7 +6152,7 @@ bool Debugger::CallData::adoptFrame() {
       JS_ReportErrorASCII(cx, "Debugger.Frame's global is not a debuggee");
       return false;
     }
-    if (!dbg->getFrame(cx, iter, &adoptedFrame)) {
+    if (!dbg->getFrame(cx, iter, &adoptedFrame)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else if (frameObj->isSuspended()) {
@@ -6162,7 +6162,7 @@ bool Debugger::CallData::adoptFrame() {
       return false;
     }
 
-    if (!dbg->getFrame(cx, gen, &adoptedFrame)) {
+    if (!dbg->getFrame(cx, gen, &adoptedFrame)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -6176,23 +6176,23 @@ bool Debugger::CallData::adoptFrame() {
 }
 
 bool Debugger::CallData::adoptSource() {
-  if (!args.requireAtLeast(cx, "Debugger.adoptSource", 1)) {
+  if (!args.requireAtLeast(cx, "Debugger.adoptSource", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject obj(cx, RequireObject(cx, args[0]));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   obj = UncheckedUnwrap(obj);
-  if (!obj->is<DebuggerSource>()) {
+  if (!obj->is<DebuggerSource>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Argument is not a Debugger.Source");
     return false;
   }
 
   RootedDebuggerSource sourceObj(cx, &obj->as<DebuggerSource>());
-  if (!sourceObj->getReferentRawObject()) {
+  if (!sourceObj->getReferentRawObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Argument is Debugger.Source.prototype");
     return false;
   }
@@ -6279,7 +6279,7 @@ typename Map::WrapperType* Debugger::wra
   DependentAddPtr<Map> p(cx, map, untaggedReferent);
   if (!p) {
     typename Map::WrapperType* wrapper = newVariantWrapper(cx, referent);
-    if (!wrapper) {
+    if (!wrapper) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -6375,7 +6375,7 @@ bool Debugger::observesFrame(const Frame
   // Skip frames not yet fully initialized during their prologue.
   if (iter.isInterp() && iter.isFunctionFrame()) {
     const Value& thisVal = iter.interpFrame()->thisArgument();
-    if (thisVal.isMagic() && thisVal.whyMagic() == JS_IS_CONSTRUCTING) {
+    if (thisVal.isMagic() && thisVal.whyMagic() == JS_IS_CONSTRUCTING) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -6423,7 +6423,7 @@ bool Debugger::replaceFrameGuts(JSContex
 
   // Forward live Debugger.Frame objects.
   Rooted<DebuggerFrameVector> frames(cx, DebuggerFrameVector(cx));
-  if (!getDebuggerFrames(from, &frames)) {
+  if (!getDebuggerFrames(from, &frames)) {MOZ_RELEASE_ASSERT(0);
     // An OOM here means that all Debuggers' frame maps still contain
     // entries for 'from' and no entries for 'to'. Since the 'from' frame
     // will be gone, they are removed by terminateDebuggerFramesOnExit
@@ -6436,7 +6436,7 @@ bool Debugger::replaceFrameGuts(JSContex
     Debugger* dbg = frameobj->owner();
 
     // Update frame object's ScriptFrameIter::data pointer.
-    if (!frameobj->replaceFrameIterData(cx, iter)) {
+    if (!frameobj->replaceFrameIterData(cx, iter)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -6460,7 +6460,7 @@ bool Debugger::replaceFrameGuts(JSContex
 }
 
 /* static */
-bool DebugAPI::inFrameMaps(AbstractFramePtr frame) {
+bool DebugAPI::inFrameMaps(AbstractFramePtr frame) {MOZ_RELEASE_ASSERT(0);
   bool foundAny = false;
   Debugger::forEachOnStackDebuggerFrame(
       frame, [&](Debugger*, DebuggerFrame* frameobj) { foundAny = true; });
@@ -6605,7 +6605,7 @@ void Builder::assertBuilt(JSObject* obj)
 #endif
 
 bool Builder::Object::definePropertyToTrusted(JSContext* cx, const char* name,
-                                              JS::MutableHandleValue trusted) {
+                                              JS::MutableHandleValue trusted) {MOZ_RELEASE_ASSERT(0);
   // We should have checked for false Objects before calling this.
   MOZ_ASSERT(value);
 
@@ -6619,7 +6619,7 @@ bool Builder::Object::definePropertyToTr
 }
 
 bool Builder::Object::defineProperty(JSContext* cx, const char* name,
-                                     JS::HandleValue propval_) {
+                                     JS::HandleValue propval_) {MOZ_RELEASE_ASSERT(0);
   AutoRealm ar(cx, debuggerObject());
 
   RootedValue propval(cx, propval_);
@@ -6678,32 +6678,32 @@ extern JS_PUBLIC_API bool JS_DefineDebug
       InitClass(cx, global, nullptr, &DebuggerInstanceObject::class_,
                 Debugger::construct, 1, Debugger::properties, Debugger::methods,
                 nullptr, Debugger::static_methods, debugCtor.address());
-  if (!debugProto) {
+  if (!debugProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   frameProto = DebuggerFrame::initClass(cx, global, debugCtor);
-  if (!frameProto) {
+  if (!frameProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   scriptProto = DebuggerScript::initClass(cx, global, debugCtor);
-  if (!scriptProto) {
+  if (!scriptProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   sourceProto = DebuggerSource::initClass(cx, global, debugCtor);
-  if (!sourceProto) {
+  if (!sourceProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   objectProto = DebuggerObject::initClass(cx, global, debugCtor);
-  if (!objectProto) {
+  if (!objectProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   envProto = DebuggerEnvironment::initClass(cx, global, debugCtor);
-  if (!envProto) {
+  if (!envProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6711,13 +6711,13 @@ extern JS_PUBLIC_API bool JS_DefineDebug
       InitClass(cx, debugCtor, nullptr, &DebuggerMemory::class_,
                 DebuggerMemory::construct, 0, DebuggerMemory::properties,
                 DebuggerMemory::methods, nullptr, nullptr);
-  if (!memoryProto) {
+  if (!memoryProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   debuggeeWouldRunProto = GlobalObject::getOrCreateCustomErrorPrototype(
       cx, global, JSEXN_DEBUGGEEWOULDRUN);
-  if (!debuggeeWouldRunProto) {
+  if (!debuggeeWouldRunProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   debuggeeWouldRunCtor = global->getConstructor(JSProto_DebuggeeWouldRun);
@@ -6756,7 +6756,7 @@ JS_PUBLIC_API bool JS::dbg::GetDebuggeeG
   /* Since we know we have a debugger object, CheckedUnwrapStatic is fine. */
   js::Debugger* dbg = js::Debugger::fromJSObject(CheckedUnwrapStatic(&dbgObj));
 
-  if (!vector.reserve(vector.length() + dbg->debuggees.count())) {
+  if (!vector.reserve(vector.length() + dbg->debuggees.count())) {MOZ_RELEASE_ASSERT(0);
     JS_ReportOutOfMemory(cx);
     return false;
   }
@@ -6813,7 +6813,7 @@ namespace dbg {
 /* static */ GarbageCollectionEvent::Ptr GarbageCollectionEvent::Create(
     JSRuntime* rt, ::js::gcstats::Statistics& stats, uint64_t gcNumber) {
   auto data = MakeUnique<GarbageCollectionEvent>(gcNumber);
-  if (!data) {
+  if (!data) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -6861,12 +6861,12 @@ JSObject* GarbageCollectionEvent::toJSOb
                             nonincrementalReason) ||
       !DefineStringProperty(cx, obj, cx->names().reason, reason) ||
       !DefineDataProperty(cx, obj, cx->names().gcCycleNumber,
-                          gcCycleNumberVal)) {
+                          gcCycleNumberVal)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedArrayObject slicesArray(cx, NewDenseEmptyArray(cx));
-  if (!slicesArray) {
+  if (!slicesArray) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -6876,7 +6876,7 @@ JSObject* GarbageCollectionEvent::toJSOb
   for (auto range = collections.all(); !range.empty(); range.popFront()) {
     RootedPlainObject collectionObj(cx,
                                     NewBuiltinClassInstance<PlainObject>(cx));
-    if (!collectionObj) {
+    if (!collectionObj) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -6887,12 +6887,12 @@ JSObject* GarbageCollectionEvent::toJSOb
         NumberValue((range.front().endTimestamp - originTime).ToMilliseconds());
     if (!DefineDataProperty(cx, collectionObj, cx->names().startTimestamp,
                             start) ||
-        !DefineDataProperty(cx, collectionObj, cx->names().endTimestamp, end)) {
+        !DefineDataProperty(cx, collectionObj, cx->names().endTimestamp, end)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     RootedValue collectionVal(cx, ObjectValue(*collectionObj));
-    if (!DefineDataElement(cx, slicesArray, idx++, collectionVal)) {
+    if (!DefineDataElement(cx, slicesArray, idx++, collectionVal)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -6931,7 +6931,7 @@ JS_PUBLIC_API bool FireOnGarbageCollecti
     for (auto& dbg : cx->runtime()->onGarbageCollectionWatchers()) {
       MOZ_ASSERT(dbg.getHook(Debugger::OnGarbageCollection));
       if (dbg.observedGC(data->majorGCNumber())) {
-        if (!triggered.append(dbg.object)) {
+        if (!triggered.append(dbg.object)) {MOZ_RELEASE_ASSERT(0);
           JS_ReportOutOfMemory(cx);
           return false;
         }
diff --git a/js/src/debugger/DebuggerMemory.cpp b/js/src/debugger/DebuggerMemory.cpp
--- a/js/src/debugger/DebuggerMemory.cpp
+++ b/js/src/debugger/DebuggerMemory.cpp
@@ -74,7 +74,7 @@ bool DebuggerMemory::construct(JSContext
 DebuggerMemory* DebuggerMemory::checkThis(JSContext* cx, CallArgs& args) {
   const Value& thisValue = args.thisv();
 
-  if (!thisValue.isObject()) {
+  if (!thisValue.isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_OBJECT_REQUIRED,
                               InformalValueTypeName(thisValue));
@@ -82,7 +82,7 @@ DebuggerMemory* DebuggerMemory::checkThi
   }
 
   JSObject& thisObject = thisValue.toObject();
-  if (!thisObject.is<DebuggerMemory>()) {
+  if (!thisObject.is<DebuggerMemory>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_INCOMPATIBLE_PROTO, class_.name, "method",
                               thisObject.getClass()->name);
@@ -165,7 +165,7 @@ bool DebuggerMemory::CallData::setTracki
   Debugger* dbg = memory->getDebugger();
   bool enabling = ToBoolean(args[0]);
 
-  if (enabling == dbg->trackingAllocationSites) {
+  if (enabling == dbg->trackingAllocationSites) {MOZ_RELEASE_ASSERT(0);
     return undefined(args);
   }
 
@@ -201,14 +201,14 @@ bool DebuggerMemory::CallData::drainAllo
   size_t length = dbg->allocationsLog.length();
 
   RootedArrayObject result(cx, NewDenseFullyAllocatedArray(cx, length));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   result->ensureDenseInitializedLength(0, length);
 
   for (size_t i = 0; i < length; i++) {
     RootedPlainObject obj(cx, NewBuiltinClassInstance<PlainObject>(cx));
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -219,29 +219,29 @@ bool DebuggerMemory::CallData::drainAllo
     Debugger::AllocationsLogEntry& entry = dbg->allocationsLog.front();
 
     RootedValue frame(cx, ObjectOrNullValue(entry.frame));
-    if (!DefineDataProperty(cx, obj, cx->names().frame, frame)) {
+    if (!DefineDataProperty(cx, obj, cx->names().frame, frame)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     double when =
         (entry.when - mozilla::TimeStamp::ProcessCreation()).ToMilliseconds();
     RootedValue timestampValue(cx, NumberValue(when));
-    if (!DefineDataProperty(cx, obj, cx->names().timestamp, timestampValue)) {
+    if (!DefineDataProperty(cx, obj, cx->names().timestamp, timestampValue)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedString className(
         cx, Atomize(cx, entry.className, strlen(entry.className)));
-    if (!className) {
+    if (!className) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     RootedValue classNameValue(cx, StringValue(className));
-    if (!DefineDataProperty(cx, obj, cx->names().class_, classNameValue)) {
+    if (!DefineDataProperty(cx, obj, cx->names().class_, classNameValue)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedValue size(cx, NumberValue(entry.size));
-    if (!DefineDataProperty(cx, obj, cx->names().size, size)) {
+    if (!DefineDataProperty(cx, obj, cx->names().size, size)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -274,11 +274,11 @@ bool DebuggerMemory::CallData::setMaxAll
   }
 
   int32_t max;
-  if (!ToInt32(cx, args[0], &max)) {
+  if (!ToInt32(cx, args[0], &max)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (max < 1) {
+  if (max < 1) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(
         cx, GetErrorMessage, nullptr, JSMSG_UNEXPECTED_TYPE,
         "(set maxAllocationsLogLength)'s parameter", "not a positive integer");
@@ -307,7 +307,7 @@ bool DebuggerMemory::CallData::setAlloca
   }
 
   double probability;
-  if (!ToNumber(cx, args[0], &probability)) {
+  if (!ToNumber(cx, args[0], &probability)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -391,7 +391,7 @@ bool DebuggerMemory::CallData::takeCensu
   }
 
   JS::ubi::RootedCount rootCount(cx, rootType->makeCount());
-  if (!rootCount) {
+  if (!rootCount) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   JS::ubi::CensusHandler handler(census, rootCount,
@@ -403,7 +403,7 @@ bool DebuggerMemory::CallData::takeCensu
   // Populate our target set of debuggee zones.
   for (WeakGlobalObjectSet::Range r = dbg->allDebuggees(); !r.empty();
        r.popFront()) {
-    if (!census.targetZones.put(r.front()->zone())) {
+    if (!census.targetZones.put(r.front()->zone())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -411,7 +411,7 @@ bool DebuggerMemory::CallData::takeCensu
   {
     Maybe<JS::AutoCheckCannotGC> maybeNoGC;
     JS::ubi::RootList rootList(cx, maybeNoGC);
-    if (!rootList.init(dbgObj)) {
+    if (!rootList.init(dbgObj)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
diff --git a/js/src/debugger/Environment.cpp b/js/src/debugger/Environment.cpp
--- a/js/src/debugger/Environment.cpp
+++ b/js/src/debugger/Environment.cpp
@@ -84,10 +84,10 @@ void DebuggerEnvironment::trace(JSTracer
 static DebuggerEnvironment* DebuggerEnvironment_checkThis(
     JSContext* cx, const CallArgs& args) {
   JSObject* thisobj = RequireObject(cx, args.thisv());
-  if (!thisobj) {
+  if (!thisobj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
-  if (!thisobj->is<DebuggerEnvironment>()) {
+  if (!thisobj->is<DebuggerEnvironment>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_INCOMPATIBLE_PROTO, "Debugger.Environment",
                               "method", thisobj->getClass()->name);
@@ -199,7 +199,7 @@ bool DebuggerEnvironment::CallData::type
 }
 
 bool DebuggerEnvironment::CallData::scopeKindGetter() {
-  if (!environment->requireDebuggee(cx)) {
+  if (!environment->requireDebuggee(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -207,7 +207,7 @@ bool DebuggerEnvironment::CallData::scop
   if (kind.isSome()) {
     const char* s = ScopeKindString(*kind);
     JSAtom* str = Atomize(cx, s, strlen(s), PinAtom);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     args.rval().setString(str);
@@ -282,7 +282,7 @@ bool DebuggerEnvironment::CallData::name
   }
 
   Rooted<IdVector> ids(cx, IdVector(cx));
-  if (!DebuggerEnvironment::getNames(cx, environment, &ids)) {
+  if (!DebuggerEnvironment::getNames(cx, environment, &ids)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -319,7 +319,7 @@ bool DebuggerEnvironment::CallData::find
 }
 
 bool DebuggerEnvironment::CallData::getVariableMethod() {
-  if (!args.requireAtLeast(cx, "Debugger.Environment.getVariable", 1)) {
+  if (!args.requireAtLeast(cx, "Debugger.Environment.getVariable", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -340,12 +340,12 @@ bool DebuggerEnvironment::CallData::setV
     return false;
   }
 
-  if (!environment->requireDebuggee(cx)) {
+  if (!environment->requireDebuggee(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedId id(cx);
-  if (!ValueToIdentifier(cx, args[0], &id)) {
+  if (!ValueToIdentifier(cx, args[0], &id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -396,7 +396,7 @@ NativeObject* DebuggerEnvironment::initC
 DebuggerEnvironment* DebuggerEnvironment::create(JSContext* cx,
                                                  HandleObject proto,
                                                  HandleObject referent,
-                                                 HandleNativeObject debugger) {
+                                                 HandleNativeObject debugger) {MOZ_RELEASE_ASSERT(0);
   DebuggerEnvironment* obj =
       IsInsideNursery(referent)
           ? NewObjectWithGivenProto<DebuggerEnvironment>(cx, proto)
@@ -521,7 +521,7 @@ bool DebuggerEnvironment::getNames(JSCon
     ar.emplace(cx, referent);
 
     ErrorCopier ec(ar);
-    if (!GetPropertyKeys(cx, referent, JSITER_HIDDEN, &ids)) {
+    if (!GetPropertyKeys(cx, referent, JSITER_HIDDEN, &ids)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -559,7 +559,7 @@ bool DebuggerEnvironment::find(JSContext
     ErrorCopier ec(ar);
     for (; env; env = env->enclosingEnvironment()) {
       bool found;
-      if (!HasProperty(cx, env, id, &found)) {
+      if (!HasProperty(cx, env, id, &found)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (found) {
@@ -595,7 +595,7 @@ bool DebuggerEnvironment::getVariable(JS
     ErrorCopier ec(ar);
 
     bool found;
-    if (!HasProperty(cx, referent, id, &found)) {
+    if (!HasProperty(cx, referent, id, &found)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!found) {
@@ -610,11 +610,11 @@ bool DebuggerEnvironment::getVariable(JS
     if (referent->is<DebugEnvironmentProxy>()) {
       Rooted<DebugEnvironmentProxy*> env(
           cx, &referent->as<DebugEnvironmentProxy>());
-      if (!DebugEnvironmentProxy::getMaybeSentinelValue(cx, env, id, result)) {
+      if (!DebugEnvironmentProxy::getMaybeSentinelValue(cx, env, id, result)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
-      if (!GetProperty(cx, referent, referent, id, result)) {
+      if (!GetProperty(cx, referent, referent, id, result)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -643,14 +643,14 @@ bool DebuggerEnvironment::setVariable(JS
   Debugger* dbg = environment->owner();
 
   RootedValue value(cx, value_);
-  if (!dbg->unwrapDebuggeeValue(cx, &value)) {
+  if (!dbg->unwrapDebuggeeValue(cx, &value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   {
     Maybe<AutoRealm> ar;
     ar.emplace(cx, referent);
-    if (!cx->compartment()->wrap(cx, &value)) {
+    if (!cx->compartment()->wrap(cx, &value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     cx->markId(id);
@@ -660,7 +660,7 @@ bool DebuggerEnvironment::setVariable(JS
 
     // Make sure the environment actually has the specified binding.
     bool found;
-    if (!HasProperty(cx, referent, id, &found)) {
+    if (!HasProperty(cx, referent, id, &found)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!found) {
diff --git a/js/src/debugger/Frame.cpp b/js/src/debugger/Frame.cpp
--- a/js/src/debugger/Frame.cpp
+++ b/js/src/debugger/Frame.cpp
@@ -157,7 +157,7 @@ bool ScriptedOnPopHandler::onPop(JSConte
   Debugger* dbg = frame->owner();
 
   RootedValue completionValue(cx);
-  if (!completion.buildCompletionValue(cx, dbg, &completionValue)) {
+  if (!completion.buildCompletionValue(cx, dbg, &completionValue)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -240,7 +240,7 @@ DebuggerFrame* DebuggerFrame::create(
     Handle<AbstractGeneratorObject*> maybeGenerator) {
   RootedDebuggerFrame frame(cx,
                             NewObjectWithGivenProto<DebuggerFrame>(cx, proto));
-  if (!frame) {
+  if (!frame) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -248,7 +248,7 @@ DebuggerFrame* DebuggerFrame::create(
 
   if (maybeIter) {
     FrameIter::Data* data = maybeIter->copyData();
-    if (!data) {
+    if (!data) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -380,7 +380,7 @@ bool DebuggerFrame::setGeneratorInfo(JSC
   RootedScript script(cx, genObj->callee().nonLazyScript());
   Rooted<UniquePtr<GeneratorInfo>> info(
       cx, cx->make_unique<GeneratorInfo>(genObj, script));
-  if (!info) {
+  if (!info) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -390,7 +390,7 @@ bool DebuggerFrame::setGeneratorInfo(JSC
   // debuggee frames. Bumping a script's generator observer count makes it a
   // debuggee, so we need to mark all frames on the stack running it as
   // debuggees as well, not just this one. This call takes care of all that.
-  if (!Debugger::ensureExecutionObservabilityOfScript(cx, script)) {
+  if (!Debugger::ensureExecutionObservabilityOfScript(cx, script)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -623,7 +623,7 @@ bool DebuggerFrame::getOlder(JSContext* 
       }
 
       if (dbg->observesFrame(iter)) {
-        if (iter.isIon() && !iter.ensureHasRematerializedFrame(cx)) {
+        if (iter.isIon() && !iter.ensureHasRematerializedFrame(cx)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         return dbg->getFrame(cx, iter, result);
@@ -675,7 +675,7 @@ bool DebuggerFrame::getThis(JSContext* c
   Debugger* dbg = frame->owner();
 
   if (frame->isOnStack()) {
-    if (!requireScriptReferent(cx, frame)) {
+    if (!requireScriptReferent(cx, frame)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     FrameIter iter = frame->getFrameIter(cx);
@@ -687,7 +687,7 @@ bool DebuggerFrame::getThis(JSContext* c
       UpdateFrameIterPc(iter);
 
       if (!GetThisValueForDebuggerFrameMaybeOptimizedOut(cx, frame, iter.pc(),
-                                                         result)) {
+                                                         result)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -788,7 +788,7 @@ bool DebuggerFrame::setOnStepHandler(JSC
     // Adjust execution observability and step counts on whatever code (JS or
     // Wasm) this frame is running.
     if (handler && !prior) {
-      if (!frame->incrementStepperCounter(cx, referent)) {
+      if (!frame->incrementStepperCounter(cx, referent)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (!handler && prior) {
@@ -798,7 +798,7 @@ bool DebuggerFrame::setOnStepHandler(JSC
     RootedScript script(cx, frame->generatorInfo()->generatorScript());
 
     if (handler && !prior) {
-      if (!frame->incrementStepperCounter(cx, script)) {
+      if (!frame->incrementStepperCounter(cx, script)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (!handler && prior) {
@@ -850,7 +850,7 @@ bool DebuggerFrame::incrementStepperCoun
   // Ensure observability *before* incrementing the step mode count.
   // Calling this function after calling incrementStepperCount
   // will make it a no-op.
-  if (!Debugger::ensureExecutionObservabilityOfScript(cx, script)) {
+  if (!Debugger::ensureExecutionObservabilityOfScript(cx, script)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!DebugScript::incrementStepperCount(cx, script)) {
@@ -895,11 +895,11 @@ bool DebuggerFrame::getArguments(JSConte
   if (referent.hasArgs()) {
     Rooted<GlobalObject*> global(cx, &frame->global());
     RootedObject proto(cx, GlobalObject::getOrCreateArrayPrototype(cx, global));
-    if (!proto) {
+    if (!proto) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     arguments = DebuggerArguments::create(cx, proto, frame);
-    if (!arguments) {
+    if (!arguments) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -946,7 +946,7 @@ static bool EvaluateInEnv(JSContext* cx,
 
   SourceText<char16_t> srcBuf;
   if (!srcBuf.init(cx, chars.begin().get(), chars.length(),
-                   SourceOwnership::Borrowed)) {
+                   SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -966,7 +966,7 @@ static bool EvaluateInEnv(JSContext* cx,
     MOZ_ASSERT(scopeKind == ScopeKind::NonSyntactic);
     RootedScope scope(cx,
                       GlobalScope::createEmpty(cx, ScopeKind::NonSyntactic));
-    if (!scope) {
+    if (!scope) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1010,13 +1010,13 @@ Result<Completion> js::DebuggerGenericEv
   RootedValueVector values(cx);
   if (bindings) {
     if (!GetPropertyKeys(cx, bindings, JSITER_OWNONLY, &keys) ||
-        !values.growBy(keys.length())) {
+        !values.growBy(keys.length())) {MOZ_RELEASE_ASSERT(0);
       return cx->alreadyReportedError();
     }
     for (size_t i = 0; i < keys.length(); i++) {
       MutableHandleValue valp = values[i];
       if (!GetProperty(cx, bindings, bindings, keys[i], valp) ||
-          !dbg->unwrapDebuggeeValue(cx, valp)) {
+          !dbg->unwrapDebuggeeValue(cx, valp)) {MOZ_RELEASE_ASSERT(0);
         return cx->alreadyReportedError();
       }
     }
@@ -1032,7 +1032,7 @@ Result<Completion> js::DebuggerGenericEv
   Rooted<Env*> env(cx);
   if (iter) {
     env = GetDebugEnvironmentForFrame(cx, iter->abstractFramePtr(), iter->pc());
-    if (!env) {
+    if (!env) {MOZ_RELEASE_ASSERT(0);
       return cx->alreadyReportedError();
     }
   } else {
@@ -1043,7 +1043,7 @@ Result<Completion> js::DebuggerGenericEv
   if (bindings) {
     RootedPlainObject nenv(cx,
                            NewObjectWithGivenProto<PlainObject>(cx, nullptr));
-    if (!nenv) {
+    if (!nenv) {MOZ_RELEASE_ASSERT(0);
       return cx->alreadyReportedError();
     }
     RootedId id(cx);
@@ -1052,13 +1052,13 @@ Result<Completion> js::DebuggerGenericEv
       cx->markId(id);
       MutableHandleValue val = values[i];
       if (!cx->compartment()->wrap(cx, val) ||
-          !NativeDefineDataProperty(cx, nenv, id, val, 0)) {
+          !NativeDefineDataProperty(cx, nenv, id, val, 0)) {MOZ_RELEASE_ASSERT(0);
         return cx->alreadyReportedError();
       }
     }
 
     RootedObjectVector envChain(cx);
-    if (!envChain.append(nenv)) {
+    if (!envChain.append(nenv)) {MOZ_RELEASE_ASSERT(0);
       return cx->alreadyReportedError();
     }
 
@@ -1235,7 +1235,7 @@ void DebuggerFrame::trace(JSTracer* trc)
 /* static */
 DebuggerFrame* DebuggerFrame::check(JSContext* cx, HandleValue thisv) {
   JSObject* thisobj = RequireObject(cx, thisv);
-  if (!thisobj) {
+  if (!thisobj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (!thisobj->is<DebuggerFrame>()) {
@@ -1377,7 +1377,7 @@ bool DebuggerFrame::CallData::typeGetter
 }
 
 bool DebuggerFrame::CallData::implementationGetter() {
-  if (!ensureOnStack()) {
+  if (!ensureOnStack()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1494,7 +1494,7 @@ bool DebuggerFrame::CallData::asyncPromi
 }
 
 bool DebuggerFrame::CallData::olderSavedFrameGetter() {
-  if (!ensureOnStackOrSuspended()) {
+  if (!ensureOnStackOrSuspended()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1525,7 +1525,7 @@ bool DebuggerFrame::getOlderSavedFrame(J
           (activation.asyncCallIsExplicit() || iter.done())) {
         const char* cause = activation.asyncCause();
         RootedAtom causeAtom(cx, AtomizeUTF8Chars(cx, cause, strlen(cause)));
-        if (!causeAtom) {
+        if (!causeAtom) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         RootedSavedFrame stackObj(cx, activation.asyncStack());
@@ -1541,7 +1541,7 @@ bool DebuggerFrame::getOlderSavedFrame(J
 
       // If we hit another frame that we observe, then there is no saved
       // frame that we'd want to return.
-      if (dbg->observesFrame(iter)) {
+      if (dbg->observesFrame(iter)) {MOZ_RELEASE_ASSERT(0);
         break;
       }
     }
@@ -1583,7 +1583,7 @@ static bool DebuggerArguments_getArg(JSC
 
   // Check that the this value is an Arguments object.
   RootedObject argsobj(cx, RequireObject(cx, args.thisv()));
-  if (!argsobj) {
+  if (!argsobj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (argsobj->getClass() != &DebuggerArguments::class_) {
@@ -1615,7 +1615,7 @@ static bool DebuggerArguments_getArg(JSC
     script = frame.script();
     {
       AutoRealm ar(cx, script);
-      if (!script->ensureHasAnalyzedArgsUsage(cx)) {
+      if (!script->ensureHasAnalyzedArgsUsage(cx)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1655,7 +1655,7 @@ DebuggerArguments* DebuggerArguments::cr
 
   Rooted<DebuggerArguments*> obj(
       cx, NewObjectWithGivenProto<DebuggerArguments>(cx, proto));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1665,7 +1665,7 @@ DebuggerArguments* DebuggerArguments::cr
   unsigned fargc = referent.numActualArgs();
   RootedValue fargcVal(cx, Int32Value(fargc));
   if (!NativeDefineDataProperty(cx, obj, cx->names().length, fargcVal,
-                                JSPROP_PERMANENT | JSPROP_READONLY)) {
+                                JSPROP_PERMANENT | JSPROP_READONLY)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1674,7 +1674,7 @@ DebuggerArguments* DebuggerArguments::cr
     RootedFunction getobj(cx);
     getobj = NewNativeFunction(cx, DebuggerArguments_getArg, 0, nullptr,
                                gc::AllocKind::FUNCTION_EXTENDED);
-    if (!getobj) {
+    if (!getobj) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     id = INT_TO_JSID(i);
@@ -1781,7 +1781,7 @@ bool DebuggerFrame::CallData::onStepSett
   if (!args.requireAtLeast(cx, "Debugger.Frame.set onStep", 1)) {
     return false;
   }
-  if (!IsValidHook(args[0])) {
+  if (!IsValidHook(args[0])) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_NOT_CALLABLE_OR_UNDEFINED);
     return false;
@@ -1790,7 +1790,7 @@ bool DebuggerFrame::CallData::onStepSett
   UniquePtr<ScriptedOnStepHandler> handler;
   if (!args[0].isUndefined()) {
     handler = cx->make_unique<ScriptedOnStepHandler>(&args[0].toObject());
-    if (!handler) {
+    if (!handler) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1841,13 +1841,13 @@ bool DebuggerFrame::CallData::evalMethod
     return false;
   }
 
-  if (!args.requireAtLeast(cx, "Debugger.Frame.prototype.eval", 1)) {
+  if (!args.requireAtLeast(cx, "Debugger.Frame.prototype.eval", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   AutoStableStringChars stableChars(cx);
   if (!ValueToStableChars(cx, "Debugger.Frame.prototype.eval", args[0],
-                          stableChars)) {
+                          stableChars)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   mozilla::Range<const char16_t> chars = stableChars.twoByteRange();
@@ -1864,24 +1864,24 @@ bool DebuggerFrame::CallData::evalMethod
 }
 
 bool DebuggerFrame::CallData::evalWithBindingsMethod() {
-  if (!ensureOnStack()) {
+  if (!ensureOnStack()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (!args.requireAtLeast(cx, "Debugger.Frame.prototype.evalWithBindings",
-                           2)) {
+                           2)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   AutoStableStringChars stableChars(cx);
   if (!ValueToStableChars(cx, "Debugger.Frame.prototype.evalWithBindings",
-                          args[0], stableChars)) {
+                          args[0], stableChars)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   mozilla::Range<const char16_t> chars = stableChars.twoByteRange();
 
   RootedObject bindings(cx, RequireObject(cx, args[1]));
-  if (!bindings) {
+  if (!bindings) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1930,7 +1930,7 @@ const JSFunctionSpec DebuggerFrame::meth
 
 JSObject* js::IdVectorToArray(JSContext* cx, Handle<IdVector> ids) {
   Rooted<ValueVector> vals(cx, ValueVector(cx));
-  if (!vals.growBy(ids.length())) {
+  if (!vals.growBy(ids.length())) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1938,7 +1938,7 @@ JSObject* js::IdVectorToArray(JSContext*
     jsid id = ids[i];
     if (JSID_IS_INT(id)) {
       JSString* str = Int32ToString<CanGC>(cx, JSID_TO_INT(id));
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       vals[i].setString(str);
diff --git a/js/src/debugger/NoExecute.cpp b/js/src/debugger/NoExecute.cpp
--- a/js/src/debugger/NoExecute.cpp
+++ b/js/src/debugger/NoExecute.cpp
@@ -69,7 +69,7 @@ bool EnterDebuggeeNoExecute::reportIfFou
     if (!warning || !nx->reported_) {
       AutoRealm ar(cx, nx->debugger().toJSObject());
       nx->reported_ = true;
-      if (cx->options().dumpStackOnDebuggeeWouldRun()) {
+      if (cx->options().dumpStackOnDebuggeeWouldRun()) {MOZ_RELEASE_ASSERT(0);
         fprintf(stdout, "Dumping stack for DebuggeeWouldRun:\n");
         DumpBacktrace(cx);
       }
diff --git a/js/src/debugger/Object.cpp b/js/src/debugger/Object.cpp
--- a/js/src/debugger/Object.cpp
+++ b/js/src/debugger/Object.cpp
@@ -116,10 +116,10 @@ void DebuggerObject::trace(JSTracer* trc
 static DebuggerObject* DebuggerObject_checkThis(JSContext* cx,
                                                 const CallArgs& args) {
   JSObject* thisobj = RequireObject(cx, args.thisv());
-  if (!thisobj) {
+  if (!thisobj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
-  if (!thisobj->is<DebuggerObject>()) {
+  if (!thisobj->is<DebuggerObject>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_INCOMPATIBLE_PROTO, "Debugger.Object",
                               "method", thisobj->getClass()->name);
@@ -381,7 +381,7 @@ bool DebuggerObject::CallData::scriptGet
   }
 
   RootedScript script(cx, GetOrCreateFunctionScript(cx, fun));
-  if (!script) {
+  if (!script) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -465,7 +465,7 @@ bool DebuggerObject::CallData::boundArgu
   }
 
   Rooted<ValueVector> result(cx, ValueVector(cx));
-  if (!DebuggerObject::getBoundArguments(cx, object, &result)) {
+  if (!DebuggerObject::getBoundArguments(cx, object, &result)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -494,7 +494,7 @@ bool DebuggerObject::CallData::allocatio
 // undefined if the object has no JSErrorReport.
 bool DebuggerObject::CallData::errorMessageNameGetter() {
   RootedString result(cx);
-  if (!DebuggerObject::getErrorMessageName(cx, object, &result)) {
+  if (!DebuggerObject::getErrorMessageName(cx, object, &result)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -640,7 +640,7 @@ bool DebuggerObject::CallData::promiseTi
 static PromiseObject* EnsurePromise(JSContext* cx, HandleObject referent) {
   // We only care about promises, so CheckedUnwrapStatic is OK.
   RootedObject obj(cx, CheckedUnwrapStatic(referent));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     ReportAccessDenied(cx);
     return nullptr;
   }
@@ -660,7 +660,7 @@ bool DebuggerObject::CallData::promiseAl
   }
 
   RootedObject allocSite(cx, promise->allocationSite());
-  if (!allocSite) {
+  if (!allocSite) {MOZ_RELEASE_ASSERT(0);
     args.rval().setNull();
     return true;
   }
@@ -685,7 +685,7 @@ bool DebuggerObject::CallData::promiseRe
   }
 
   RootedObject resolutionSite(cx, promise->resolutionSite());
-  if (!resolutionSite) {
+  if (!resolutionSite) {MOZ_RELEASE_ASSERT(0);
     args.rval().setNull();
     return true;
   }
@@ -718,12 +718,12 @@ bool DebuggerObject::CallData::promiseDe
   Rooted<GCVector<Value>> values(cx, GCVector<Value>(cx));
   {
     JSAutoRealm ar(cx, promise);
-    if (!promise->dependentPromises(cx, &values)) {
+    if (!promise->dependentPromises(cx, &values)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
   for (size_t i = 0; i < values.length(); i++) {
-    if (!dbg->wrapDebuggeeValue(cx, values[i])) {
+    if (!dbg->wrapDebuggeeValue(cx, values[i])) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -802,7 +802,7 @@ bool DebuggerObject::CallData::getOwnPro
 
 bool DebuggerObject::CallData::getOwnPropertyDescriptorMethod() {
   RootedId id(cx);
-  if (!ToPropertyKey(cx, args.get(0), &id)) {
+  if (!ToPropertyKey(cx, args.get(0), &id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -847,7 +847,7 @@ bool DebuggerObject::CallData::definePro
   }
 
   RootedId id(cx);
-  if (!ToPropertyKey(cx, args[0], &id)) {
+  if (!ToPropertyKey(cx, args[0], &id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -865,13 +865,13 @@ bool DebuggerObject::CallData::definePro
 }
 
 bool DebuggerObject::CallData::definePropertiesMethod() {
-  if (!args.requireAtLeast(cx, "Debugger.Object.defineProperties", 1)) {
+  if (!args.requireAtLeast(cx, "Debugger.Object.defineProperties", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedValue arg(cx, args[0]);
   RootedObject props(cx, ToObject(cx, arg));
-  if (!props) {
+  if (!props) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedIdVector ids(cx);
@@ -880,7 +880,7 @@ bool DebuggerObject::CallData::definePro
     return false;
   }
   Rooted<IdVector> ids2(cx, IdVector(cx));
-  if (!ids2.append(ids.begin(), ids.end())) {
+  if (!ids2.append(ids.begin(), ids.end())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -898,7 +898,7 @@ bool DebuggerObject::CallData::definePro
  */
 bool DebuggerObject::CallData::deletePropertyMethod() {
   RootedId id(cx);
-  if (!ToPropertyKey(cx, args.get(0), &id)) {
+  if (!ToPropertyKey(cx, args.get(0), &id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -916,7 +916,7 @@ bool DebuggerObject::CallData::callMetho
 
   Rooted<ValueVector> nargs(cx, ValueVector(cx));
   if (args.length() >= 2) {
-    if (!nargs.growBy(args.length() - 1)) {
+    if (!nargs.growBy(args.length() - 1)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     for (size_t i = 1; i < args.length(); ++i) {
@@ -982,12 +982,12 @@ bool DebuggerObject::CallData::applyMeth
     RootedObject argsobj(cx, &args[1].toObject());
 
     unsigned argc = 0;
-    if (!GetLengthProperty(cx, argsobj, &argc)) {
+    if (!GetLengthProperty(cx, argsobj, &argc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     argc = unsigned(std::min(argc, ARGS_LENGTH_MAX));
 
-    if (!nargs.growBy(argc) || !GetElements(cx, argsobj, argc, nargs.begin())) {
+    if (!nargs.growBy(argc) || !GetElements(cx, argsobj, argc, nargs.begin())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1013,23 +1013,23 @@ static bool RequireGlobalObject(JSContex
                                 HandleObject referent) {
   RootedObject obj(cx, referent);
 
-  if (!obj->is<GlobalObject>()) {
+  if (!obj->is<GlobalObject>()) {MOZ_RELEASE_ASSERT(0);
     const char* isWrapper = "";
     const char* isWindowProxy = "";
 
     // Help the poor programmer by pointing out wrappers around globals...
-    if (obj->is<WrapperObject>()) {
+    if (obj->is<WrapperObject>()) {MOZ_RELEASE_ASSERT(0);
       obj = js::UncheckedUnwrap(obj);
       isWrapper = "a wrapper around ";
     }
 
     // ... and WindowProxies around Windows.
-    if (IsWindowProxy(obj)) {
+    if (IsWindowProxy(obj)) {MOZ_RELEASE_ASSERT(0);
       obj = ToWindowIfWindowProxy(obj);
       isWindowProxy = "a WindowProxy referring to ";
     }
 
-    if (obj->is<GlobalObject>()) {
+    if (obj->is<GlobalObject>()) {MOZ_RELEASE_ASSERT(0);
       ReportValueError(cx, JSMSG_DEBUG_WRAPPER_IN_WAY, JSDVG_SEARCH_STACK,
                        dbgobj, nullptr, isWrapper, isWindowProxy);
     } else {
@@ -1045,7 +1045,7 @@ static bool RequireGlobalObject(JSContex
 bool DebuggerObject::CallData::asEnvironmentMethod() {
   Debugger* dbg = object->owner();
 
-  if (!RequireGlobalObject(cx, args.thisv(), referent)) {
+  if (!RequireGlobalObject(cx, args.thisv(), referent)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1068,11 +1068,11 @@ bool DebuggerObject::CallData::asEnviron
 bool DebuggerObject::CallData::forceLexicalInitializationByNameMethod() {
   if (!args.requireAtLeast(
           cx, "Debugger.Object.prototype.forceLexicalInitializationByName",
-          1)) {
+          1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!DebuggerObject::requireGlobal(cx, object)) {
+  if (!DebuggerObject::requireGlobal(cx, object)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1159,7 +1159,7 @@ bool DebuggerObject::CallData::executeIn
 template <typename T>
 static bool CopyStringToVector(JSContext* cx, JSString* str, Vector<T>& chars) {
   JSLinearString* linear = str->ensureLinear(cx);
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!chars.appendN(0, linear->length() + 1)) {
@@ -1170,11 +1170,11 @@ static bool CopyStringToVector(JSContext
 }
 
 bool DebuggerObject::CallData::createSource() {
-  if (!args.requireAtLeast(cx, "Debugger.Object.prototype.createSource", 1)) {
+  if (!args.requireAtLeast(cx, "Debugger.Object.prototype.createSource", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!DebuggerObject::requireGlobal(cx, object)) {
+  if (!DebuggerObject::requireGlobal(cx, object)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1187,51 +1187,51 @@ bool DebuggerObject::CallData::createSou
   }
 
   RootedObject options(cx, ToObject(cx, args[0]));
-  if (!options) {
+  if (!options) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedValue v(cx);
-  if (!JS_GetProperty(cx, options, "text", &v)) {
+  if (!JS_GetProperty(cx, options, "text", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedString text(cx, ToString<CanGC>(cx, v));
-  if (!text) {
+  if (!text) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!JS_GetProperty(cx, options, "url", &v)) {
+  if (!JS_GetProperty(cx, options, "url", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedString url(cx, ToString<CanGC>(cx, v));
-  if (!url) {
+  if (!url) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!JS_GetProperty(cx, options, "startLine", &v)) {
+  if (!JS_GetProperty(cx, options, "startLine", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   uint32_t startLine;
-  if (!ToUint32(cx, v, &startLine)) {
+  if (!ToUint32(cx, v, &startLine)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!JS_GetProperty(cx, options, "sourceMapURL", &v)) {
+  if (!JS_GetProperty(cx, options, "sourceMapURL", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedString sourceMapURL(cx);
   if (!v.isUndefined()) {
     sourceMapURL = ToString<CanGC>(cx, v);
-    if (!sourceMapURL) {
+    if (!sourceMapURL) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!JS_GetProperty(cx, options, "isScriptElement", &v)) {
+  if (!JS_GetProperty(cx, options, "isScriptElement", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1240,20 +1240,20 @@ bool DebuggerObject::CallData::createSou
   JS::CompileOptions compileOptions(cx);
   compileOptions.lineno = startLine;
 
-  if (!JS::StringHasLatin1Chars(url)) {
+  if (!JS::StringHasLatin1Chars(url)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "URL must be a narrow string");
     return false;
   }
 
   Vector<Latin1Char> urlChars(cx);
-  if (!CopyStringToVector(cx, url, urlChars)) {
+  if (!CopyStringToVector(cx, url, urlChars)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   compileOptions.setFile((const char*)urlChars.begin());
 
   Vector<char16_t> sourceMapURLChars(cx);
   if (sourceMapURL) {
-    if (!CopyStringToVector(cx, sourceMapURL, sourceMapURLChars)) {
+    if (!CopyStringToVector(cx, sourceMapURL, sourceMapURLChars)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     compileOptions.setSourceMapURL(sourceMapURLChars.begin());
@@ -1265,13 +1265,13 @@ bool DebuggerObject::CallData::createSou
   }
 
   Vector<char16_t> textChars(cx);
-  if (!CopyStringToVector(cx, text, textChars)) {
+  if (!CopyStringToVector(cx, text, textChars)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JS::SourceText<char16_t> srcBuf;
   if (!srcBuf.init(cx, textChars.begin(), text->length(),
-                   JS::SourceOwnership::Borrowed)) {
+                   JS::SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1343,17 +1343,17 @@ bool DebuggerObject::CallData::unwrapMet
 
 bool DebuggerObject::CallData::setInstrumentationMethod() {
   if (!args.requireAtLeast(cx, "Debugger.Object.prototype.setInstrumentation",
-                           2)) {
+                           2)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!DebuggerObject::requireGlobal(cx, object)) {
+  if (!DebuggerObject::requireGlobal(cx, object)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedGlobalObject global(cx, &object->referent()->as<GlobalObject>());
 
   RootedValue v(cx, args[0]);
-  if (!object->owner()->unwrapDebuggeeValue(cx, &v)) {
+  if (!object->owner()->unwrapDebuggeeValue(cx, &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!v.isObject()) {
@@ -1362,30 +1362,30 @@ bool DebuggerObject::CallData::setInstru
   }
   RootedObject callback(cx, &v.toObject());
 
-  if (!args[1].isObject()) {
+  if (!args[1].isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Instrumentation kinds must be an object");
     return false;
   }
   RootedObject kindsObj(cx, &args[1].toObject());
 
   unsigned length = 0;
-  if (!GetLengthProperty(cx, kindsObj, &length)) {
+  if (!GetLengthProperty(cx, kindsObj, &length)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Rooted<ValueVector> values(cx, ValueVector(cx));
   if (!values.growBy(length) ||
-      !GetElements(cx, kindsObj, length, values.begin())) {
+      !GetElements(cx, kindsObj, length, values.begin())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Rooted<StringVector> kinds(cx, StringVector(cx));
   for (size_t i = 0; i < values.length(); i++) {
-    if (!values[i].isString()) {
+    if (!values[i].isString()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "Instrumentation kind must be a string");
       return false;
     }
-    if (!kinds.append(values[i].toString())) {
+    if (!kinds.append(values[i].toString())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1404,12 +1404,12 @@ bool DebuggerObject::CallData::setInstru
 }
 
 bool DebuggerObject::CallData::setInstrumentationActiveMethod() {
-  if (!DebuggerObject::requireGlobal(cx, object)) {
+  if (!DebuggerObject::requireGlobal(cx, object)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (!args.requireAtLeast(
-          cx, "Debugger.Object.prototype.setInstrumentationActive", 1)) {
+          cx, "Debugger.Object.prototype.setInstrumentationActive", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1509,7 +1509,7 @@ bool DebuggerObject::CallData::getPromis
   }
 
   RootedArrayObject holder(cx, NewDenseEmptyArray(cx));
-  if (!holder) {
+  if (!holder) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1606,7 +1606,7 @@ NativeObject* DebuggerObject::initClass(
       cx, InitClass(cx, debugCtor, nullptr, &class_, construct, 0, properties_,
                     methods_, nullptr, nullptr));
 
-  if (!objectProto) {
+  if (!objectProto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1797,7 +1797,7 @@ bool DebuggerObject::getBoundArguments(J
   Debugger* dbg = object->owner();
 
   size_t length = referent->getBoundFunctionArgumentCount();
-  if (!result.resize(length)) {
+  if (!result.resize(length)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (size_t i = 0; i < length; i++) {
@@ -1844,7 +1844,7 @@ bool DebuggerObject::getErrorReport(JSCo
     obj = CheckedUnwrapStatic(obj);
   }
 
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     ReportAccessDenied(cx);
     return false;
   }
@@ -1864,7 +1864,7 @@ bool DebuggerObject::getErrorMessageName
                                          MutableHandleString result) {
   RootedObject referent(cx, object->referent());
   JSErrorReport* report;
-  if (!getErrorReport(cx, referent, report)) {
+  if (!getErrorReport(cx, referent, report)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1886,7 +1886,7 @@ bool DebuggerObject::getErrorNotes(JSCon
                                    MutableHandleValue result) {
   RootedObject referent(cx, object->referent());
   JSErrorReport* report;
-  if (!getErrorReport(cx, referent, report)) {
+  if (!getErrorReport(cx, referent, report)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1896,7 +1896,7 @@ bool DebuggerObject::getErrorNotes(JSCon
   }
 
   RootedObject errorNotesArray(cx, CreateErrorNotesArray(cx, report));
-  if (!errorNotesArray) {
+  if (!errorNotesArray) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1913,7 +1913,7 @@ bool DebuggerObject::getErrorLineNumber(
                                         MutableHandleValue result) {
   RootedObject referent(cx, object->referent());
   JSErrorReport* report;
-  if (!getErrorReport(cx, referent, report)) {
+  if (!getErrorReport(cx, referent, report)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1932,7 +1932,7 @@ bool DebuggerObject::getErrorColumnNumbe
                                           MutableHandleValue result) {
   RootedObject referent(cx, object->referent());
   JSErrorReport* report;
-  if (!getErrorReport(cx, referent, report)) {
+  if (!getErrorReport(cx, referent, report)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2093,13 +2093,13 @@ bool DebuggerObject::getOwnPropertyDescr
     Rooted<PropertyDescriptor> desc(cx, *desc_);
 
     // Rewrap the debuggee values in desc for the debugger.
-    if (!dbg->wrapDebuggeeValue(cx, desc.value())) {
+    if (!dbg->wrapDebuggeeValue(cx, desc.value())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (desc.hasGetterObject()) {
       RootedValue get(cx, ObjectOrNullValue(desc.getterObject()));
-      if (!dbg->wrapDebuggeeValue(cx, &get)) {
+      if (!dbg->wrapDebuggeeValue(cx, &get)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       desc.setGetterObject(get.toObjectOrNull());
@@ -2191,11 +2191,11 @@ bool DebuggerObject::defineProperties(JS
   Debugger* dbg = object->owner();
 
   Rooted<PropertyDescriptorVector> descs(cx, PropertyDescriptorVector(cx));
-  if (!descs.append(descs_.begin(), descs_.end())) {
+  if (!descs.append(descs_.begin(), descs_.end())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (size_t i = 0; i < descs.length(); i++) {
-    if (!dbg->unwrapPropertyDescriptor(cx, referent, descs[i])) {
+    if (!dbg->unwrapPropertyDescriptor(cx, referent, descs[i])) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     JS_TRY_OR_RETURN_FALSE(cx, CheckPropertyDescriptorAccessors(cx, descs[i]));
@@ -2205,7 +2205,7 @@ bool DebuggerObject::defineProperties(JS
   EnterDebuggeeObjectRealm(cx, ar, referent);
 
   for (size_t i = 0; i < descs.length(); i++) {
-    if (!cx->compartment()->wrap(cx, descs[i])) {
+    if (!cx->compartment()->wrap(cx, descs[i])) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     cx->markId(ids[i]);
@@ -2313,7 +2313,7 @@ Maybe<Completion> DebuggerObject::call(J
   RootedObject referent(cx, object->referent());
   Debugger* dbg = object->owner();
 
-  if (!referent->isCallable()) {
+  if (!referent->isCallable()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_INCOMPATIBLE_PROTO, "Debugger.Object",
                               "call", referent->getClass()->name);
@@ -2329,7 +2329,7 @@ Maybe<Completion> DebuggerObject::call(J
     return Nothing();
   }
   Rooted<ValueVector> args2(cx, ValueVector(cx));
-  if (!args2.append(args.begin(), args.end())) {
+  if (!args2.append(args.begin(), args.end())) {MOZ_RELEASE_ASSERT(0);
     return Nothing();
   }
   for (size_t i = 0; i < args2.length(); ++i) {
@@ -2344,11 +2344,11 @@ Maybe<Completion> DebuggerObject::call(J
   Maybe<AutoRealm> ar;
   EnterDebuggeeObjectRealm(cx, ar, referent);
   if (!cx->compartment()->wrap(cx, &calleev) ||
-      !cx->compartment()->wrap(cx, &thisv)) {
+      !cx->compartment()->wrap(cx, &thisv)) {MOZ_RELEASE_ASSERT(0);
     return Nothing();
   }
   for (size_t i = 0; i < args2.length(); ++i) {
-    if (!cx->compartment()->wrap(cx, args2[i])) {
+    if (!cx->compartment()->wrap(cx, args2[i])) {MOZ_RELEASE_ASSERT(0);
       return Nothing();
     }
   }
@@ -2379,7 +2379,7 @@ Maybe<Completion> DebuggerObject::call(J
 /* static */
 bool DebuggerObject::forceLexicalInitializationByName(
     JSContext* cx, HandleDebuggerObject object, HandleId id, bool& result) {
-  if (!JSID_IS_STRING(id)) {
+  if (!JSID_IS_STRING(id)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(
         cx, GetErrorMessage, nullptr, JSMSG_NOT_EXPECTED_TYPE,
         "Debugger.Object.prototype.forceLexicalInitializationByName", "string",
@@ -2399,7 +2399,7 @@ bool DebuggerObject::forceLexicalInitial
   RootedObject globalLexical(cx, &referent->lexicalEnvironment());
   RootedObject pobj(cx);
   Rooted<PropertyResult> prop(cx);
-  if (!LookupProperty(cx, globalLexical, id, &pobj, &prop)) {
+  if (!LookupProperty(cx, globalLexical, id, &pobj, &prop)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2451,7 +2451,7 @@ bool DebuggerObject::makeDebuggeeValue(J
     {
       Maybe<AutoRealm> ar;
       EnterDebuggeeObjectRealm(cx, ar, referent);
-      if (!cx->compartment()->wrap(cx, &value)) {
+      if (!cx->compartment()->wrap(cx, &value)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2469,7 +2469,7 @@ bool DebuggerObject::makeDebuggeeValue(J
 
 static JSFunction* EnsureNativeFunction(const Value& value,
                                         bool allowExtended = true) {
-  if (!value.isObject() || !value.toObject().is<JSFunction>()) {
+  if (!value.isObject() || !value.toObject().is<JSFunction>()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2508,7 +2508,7 @@ bool DebuggerObject::makeDebuggeeNativeF
       cx->markAtom(name);
     }
     JSFunction* newFun = NewNativeFunction(cx, fun->native(), nargs, name);
-    if (!newFun) {
+    if (!newFun) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2526,7 +2526,7 @@ bool DebuggerObject::makeDebuggeeNativeF
 }
 
 static JSAtom* MaybeGetSelfHostedFunctionName(const Value& v) {
-  if (!v.isObject() || !v.toObject().is<JSFunction>()) {
+  if (!v.isObject() || !v.toObject().is<JSFunction>()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2541,7 +2541,7 @@ static JSAtom* MaybeGetSelfHostedFunctio
 /* static */
 bool DebuggerObject::isSameNative(JSContext* cx, HandleDebuggerObject object,
                                   HandleValue value,
-                                  MutableHandleValue result) {
+                                  MutableHandleValue result) {MOZ_RELEASE_ASSERT(0);
   RootedValue referentValue(cx, ObjectValue(*object->referent()));
 
   RootedValue nonCCWValue(
@@ -2645,7 +2645,7 @@ bool DebuggerObject::requirePromise(JSCo
   if (IsCrossCompartmentWrapper(referent)) {
     /* We only care about promises, so CheckedUnwrapStatic is OK. */
     referent = CheckedUnwrapStatic(referent);
-    if (!referent) {
+    if (!referent) {MOZ_RELEASE_ASSERT(0);
       ReportAccessDenied(cx);
       return false;
     }
diff --git a/js/src/debugger/Script.cpp b/js/src/debugger/Script.cpp
--- a/js/src/debugger/Script.cpp
+++ b/js/src/debugger/Script.cpp
@@ -110,7 +110,7 @@ DebuggerScript* DebuggerScript::create(J
                                        HandleNativeObject debugger) {
   DebuggerScript* scriptobj =
       NewTenuredObjectWithGivenProto<DebuggerScript>(cx, proto);
-  if (!scriptobj) {
+  if (!scriptobj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -125,14 +125,14 @@ DebuggerScript* DebuggerScript::create(J
 static JSScript* DelazifyScript(JSContext* cx, Handle<BaseScript*> script) {
   if (script->hasBytecode()) {
     return script->asJSScript();
-  }
+  }MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(script->isFunction());
 
   // JSFunction::getOrCreateScript requires an enclosing scope. This requires
   // the enclosing script to be non-lazy.
-  if (script->hasEnclosingScript()) {
+  if (script->hasEnclosingScript()) {MOZ_RELEASE_ASSERT(0);
     Rooted<BaseScript*> enclosingScript(cx, script->enclosingScript());
-    if (!DelazifyScript(cx, enclosingScript)) {
+    if (!DelazifyScript(cx, enclosingScript)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -156,10 +156,10 @@ static JSScript* DelazifyScript(JSContex
 /* static */
 DebuggerScript* DebuggerScript::check(JSContext* cx, HandleValue v) {
   JSObject* thisobj = RequireObject(cx, v);
-  if (!thisobj) {
+  if (!thisobj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
-  if (!thisobj->is<DebuggerScript>()) {
+  if (!thisobj->is<DebuggerScript>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_INCOMPATIBLE_PROTO, "Debugger.Script",
                               "method", thisobj->getClass()->name);
@@ -357,10 +357,10 @@ bool DebuggerScript::CallData::getUrl() 
     if (script->scriptSource()->introducerFilename()) {
       str = NewStringCopyZ<CanGC>(cx,
                                   script->scriptSource()->introducerFilename());
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       str = NewStringCopyZ<CanGC>(cx, script->filename());
     }
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     args.rval().setString(str);
@@ -498,7 +498,7 @@ bool DebuggerScript::CallData::getFormat
 static bool PushFunctionScript(JSContext* cx, Debugger* dbg, HandleFunction fun,
                                HandleObject array) {
   // Ignore asm.js natives.
-  if (!IsInterpretedNonSelfHostedFunction(fun)) {
+  if (!IsInterpretedNonSelfHostedFunction(fun)) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -540,7 +540,7 @@ bool DebuggerScript::CallData::getChildS
   Debugger* dbg = obj->owner();
 
   RootedObject result(cx, NewDenseEmptyArray(cx));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -623,7 +623,7 @@ class DebuggerScript::GetPossibleBreakpo
     }
 
     if (OnlyOffsets) {
-      if (!NewbornArrayPush(cx_, result_, NumberValue(offset))) {
+      if (!NewbornArrayPush(cx_, result_, NumberValue(offset))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -631,27 +631,27 @@ class DebuggerScript::GetPossibleBreakpo
     }
 
     RootedPlainObject entry(cx_, NewBuiltinClassInstance<PlainObject>(cx_));
-    if (!entry) {
+    if (!entry) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedValue value(cx_, NumberValue(offset));
-    if (!DefineDataProperty(cx_, entry, cx_->names().offset, value)) {
+    if (!DefineDataProperty(cx_, entry, cx_->names().offset, value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     value = NumberValue(lineno);
-    if (!DefineDataProperty(cx_, entry, cx_->names().lineNumber, value)) {
+    if (!DefineDataProperty(cx_, entry, cx_->names().lineNumber, value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     value = NumberValue(colno);
-    if (!DefineDataProperty(cx_, entry, cx_->names().columnNumber, value)) {
+    if (!DefineDataProperty(cx_, entry, cx_->names().columnNumber, value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     value = BooleanValue(isStepStart);
-    if (!DefineDataProperty(cx_, entry, cx_->names().isStepStart, value)) {
+    if (!DefineDataProperty(cx_, entry, cx_->names().isStepStart, value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -699,41 +699,41 @@ class DebuggerScript::GetPossibleBreakpo
 
   bool parseQuery(HandleObject query) {
     RootedValue lineValue(cx_);
-    if (!GetProperty(cx_, query, query, cx_->names().line, &lineValue)) {
+    if (!GetProperty(cx_, query, query, cx_->names().line, &lineValue)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedValue minLineValue(cx_);
-    if (!GetProperty(cx_, query, query, cx_->names().minLine, &minLineValue)) {
+    if (!GetProperty(cx_, query, query, cx_->names().minLine, &minLineValue)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedValue minColumnValue(cx_);
     if (!GetProperty(cx_, query, query, cx_->names().minColumn,
-                     &minColumnValue)) {
+                     &minColumnValue)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedValue minOffsetValue(cx_);
     if (!GetProperty(cx_, query, query, cx_->names().minOffset,
-                     &minOffsetValue)) {
+                     &minOffsetValue)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedValue maxLineValue(cx_);
-    if (!GetProperty(cx_, query, query, cx_->names().maxLine, &maxLineValue)) {
+    if (!GetProperty(cx_, query, query, cx_->names().maxLine, &maxLineValue)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedValue maxColumnValue(cx_);
     if (!GetProperty(cx_, query, query, cx_->names().maxColumn,
-                     &maxColumnValue)) {
+                     &maxColumnValue)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedValue maxOffsetValue(cx_);
     if (!GetProperty(cx_, query, query, cx_->names().maxOffset,
-                     &maxOffsetValue)) {
+                     &maxOffsetValue)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -835,13 +835,13 @@ class DebuggerScript::GetPossibleBreakpo
   using ReturnType = bool;
   ReturnType match(Handle<BaseScript*> base) {
     RootedScript script(cx_, DelazifyScript(cx_, base));
-    if (!script) {
+    if (!script) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // Second pass: build the result array.
     result_.set(NewDenseEmptyArray(cx_));
-    if (!result_) {
+    if (!result_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -862,21 +862,21 @@ class DebuggerScript::GetPossibleBreakpo
 
     return true;
   }
-  ReturnType match(Handle<WasmInstanceObject*> instanceObj) {
+  ReturnType match(Handle<WasmInstanceObject*> instanceObj) {MOZ_RELEASE_ASSERT(0);
     wasm::Instance& instance = instanceObj->instance();
 
     Vector<wasm::ExprLoc> offsets(cx_);
     if (instance.debugEnabled() &&
-        !instance.debug().getAllColumnOffsets(&offsets)) {
+        !instance.debug().getAllColumnOffsets(&offsets)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }MOZ_RELEASE_ASSERT(0);
+
+    result_.set(NewDenseEmptyArray(cx_));
+    if (!result_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    result_.set(NewDenseEmptyArray(cx_));
-    if (!result_) {
-      return false;
-    }
-
-    for (uint32_t i = 0; i < offsets.length(); i++) {
+    for (uint32_t i = 0; i < offsets.length(); i++) {MOZ_RELEASE_ASSERT(0);
       size_t lineno = offsets[i].lineno;
       size_t column = offsets[i].column;
       size_t offset = offsets[i].offset;
@@ -908,11 +908,11 @@ bool DebuggerScript::CallData::getPossib
 bool DebuggerScript::CallData::getPossibleBreakpointOffsets() {
   RootedObject result(cx);
   GetPossibleBreakpointsMatcher<true> matcher(cx, &result);
-  if (args.length() >= 1 && !args[0].isUndefined()) {
+  if (args.length() >= 1 && !args[0].isUndefined()) {MOZ_RELEASE_ASSERT(0);
     RootedObject queryObject(cx, RequireObject(cx, args[0]));
-    if (!queryObject || !matcher.parseQuery(queryObject)) {
+    if (!queryObject || !matcher.parseQuery(queryObject)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
   if (!referent.match(matcher)) {
     return false;
@@ -934,16 +934,16 @@ class DebuggerScript::GetOffsetMetadataM
   using ReturnType = bool;
   ReturnType match(Handle<BaseScript*> base) {
     RootedScript script(cx_, DelazifyScript(cx_, base));
-    if (!script) {
+    if (!script) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!EnsureScriptOffsetIsValid(cx_, script, offset_)) {
+    if (!EnsureScriptOffsetIsValid(cx_, script, offset_)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     result_.set(NewBuiltinClassInstance<PlainObject>(cx_));
-    if (!result_) {
+    if (!result_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -953,17 +953,17 @@ class DebuggerScript::GetOffsetMetadataM
     }
 
     RootedValue value(cx_, NumberValue(r.frontLineNumber()));
-    if (!DefineDataProperty(cx_, result_, cx_->names().lineNumber, value)) {
+    if (!DefineDataProperty(cx_, result_, cx_->names().lineNumber, value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     value = NumberValue(r.frontColumnNumber());
-    if (!DefineDataProperty(cx_, result_, cx_->names().columnNumber, value)) {
+    if (!DefineDataProperty(cx_, result_, cx_->names().columnNumber, value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     value = BooleanValue(r.frontIsBreakablePoint());
-    if (!DefineDataProperty(cx_, result_, cx_->names().isBreakpoint, value)) {
+    if (!DefineDataProperty(cx_, result_, cx_->names().isBreakpoint, value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -976,7 +976,7 @@ class DebuggerScript::GetOffsetMetadataM
   }
   ReturnType match(Handle<WasmInstanceObject*> instanceObj) {
     wasm::Instance& instance = instanceObj->instance();
-    if (!instance.debugEnabled()) {
+    if (!instance.debugEnabled()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx_, GetErrorMessage, nullptr,
                                 JSMSG_DEBUG_BAD_OFFSET);
       return false;
@@ -984,29 +984,29 @@ class DebuggerScript::GetOffsetMetadataM
 
     size_t lineno;
     size_t column;
-    if (!instance.debug().getOffsetLocation(offset_, &lineno, &column)) {
+    if (!instance.debug().getOffsetLocation(offset_, &lineno, &column)) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx_, GetErrorMessage, nullptr,
                                 JSMSG_DEBUG_BAD_OFFSET);
       return false;
     }
 
     result_.set(NewBuiltinClassInstance<PlainObject>(cx_));
-    if (!result_) {
+    if (!result_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedValue value(cx_, NumberValue(lineno));
-    if (!DefineDataProperty(cx_, result_, cx_->names().lineNumber, value)) {
+    if (!DefineDataProperty(cx_, result_, cx_->names().lineNumber, value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     value = NumberValue(column);
-    if (!DefineDataProperty(cx_, result_, cx_->names().columnNumber, value)) {
+    if (!DefineDataProperty(cx_, result_, cx_->names().columnNumber, value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     value.setBoolean(true);
-    if (!DefineDataProperty(cx_, result_, cx_->names().isBreakpoint, value)) {
+    if (!DefineDataProperty(cx_, result_, cx_->names().isBreakpoint, value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1020,11 +1020,11 @@ class DebuggerScript::GetOffsetMetadataM
 };
 
 bool DebuggerScript::CallData::getOffsetMetadata() {
-  if (!args.requireAtLeast(cx, "Debugger.Script.getOffsetMetadata", 1)) {
+  if (!args.requireAtLeast(cx, "Debugger.Script.getOffsetMetadata", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   size_t offset;
-  if (!ScriptOffset(cx, args[0], &offset)) {
+  if (!ScriptOffset(cx, args[0], &offset)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1108,7 +1108,7 @@ class FlowGraphSummary {
   Entry& operator[](size_t index) { return entries_[index]; }
 
   bool populate(JSContext* cx, JSScript* script) {
-    if (!entries_.growBy(script->length())) {
+    if (!entries_.growBy(script->length())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     unsigned mainOffset = script->pcToOffset(script->main());
@@ -1217,7 +1217,7 @@ class DebuggerScript::GetOffsetLocationM
   using ReturnType = bool;
   ReturnType match(Handle<BaseScript*> base) {
     RootedScript script(cx_, DelazifyScript(cx_, base));
-    if (!script) {
+    if (!script) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1226,12 +1226,12 @@ class DebuggerScript::GetOffsetLocationM
     }
 
     FlowGraphSummary flowData(cx_);
-    if (!flowData.populate(cx_, script)) {
+    if (!flowData.populate(cx_, script)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     result_.set(NewBuiltinClassInstance<PlainObject>(cx_));
-    if (!result_) {
+    if (!result_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1267,12 +1267,12 @@ class DebuggerScript::GetOffsetLocationM
     }
 
     RootedValue value(cx_, NumberValue(lineno));
-    if (!DefineDataProperty(cx_, result_, cx_->names().lineNumber, value)) {
+    if (!DefineDataProperty(cx_, result_, cx_->names().lineNumber, value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     value = NumberValue(column);
-    if (!DefineDataProperty(cx_, result_, cx_->names().columnNumber, value)) {
+    if (!DefineDataProperty(cx_, result_, cx_->names().columnNumber, value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1297,24 +1297,24 @@ class DebuggerScript::GetOffsetLocationM
 
     size_t lineno;
     size_t column;
-    if (!instance.debug().getOffsetLocation(offset_, &lineno, &column)) {
+    if (!instance.debug().getOffsetLocation(offset_, &lineno, &column)) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx_, GetErrorMessage, nullptr,
                                 JSMSG_DEBUG_BAD_OFFSET);
       return false;
     }
 
     result_.set(NewBuiltinClassInstance<PlainObject>(cx_));
-    if (!result_) {
+    if (!result_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedValue value(cx_, NumberValue(lineno));
-    if (!DefineDataProperty(cx_, result_, cx_->names().lineNumber, value)) {
+    if (!DefineDataProperty(cx_, result_, cx_->names().lineNumber, value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     value = NumberValue(column);
-    if (!DefineDataProperty(cx_, result_, cx_->names().columnNumber, value)) {
+    if (!DefineDataProperty(cx_, result_, cx_->names().columnNumber, value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1593,12 +1593,12 @@ static bool BytecodeIsEffectful(JSOp op)
 }
 
 bool DebuggerScript::CallData::getEffectfulOffsets() {
-  if (!ensureScript()) {
+  if (!ensureScript()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject result(cx, NewDenseEmptyArray(cx));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (BytecodeRange r(cx, script); !r.empty(); r.popFront()) {
@@ -1621,13 +1621,13 @@ bool DebuggerScript::CallData::getAllOff
   // First pass: determine which offsets in this script are jump targets and
   // which line numbers jump to them.
   FlowGraphSummary flowData(cx);
-  if (!flowData.populate(cx, script)) {
+  if (!flowData.populate(cx, script)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Second pass: build the result array.
   RootedObject result(cx, NewDenseEmptyArray(cx));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (BytecodeRangeWithPosition r(cx, script); !r.empty(); r.popFront()) {
@@ -1648,14 +1648,14 @@ bool DebuggerScript::CallData::getAllOff
       RootedId id(cx, INT_TO_JSID(lineno));
 
       bool found;
-      if (!HasOwnProperty(cx, result, id, &found)) {
+      if (!HasOwnProperty(cx, result, id, &found)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
-      if (found && !GetProperty(cx, result, result, id, &offsetsv)) {
+      if (found && !GetProperty(cx, result, result, id, &offsetsv)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
-      if (offsetsv.isObject()) {
+      if (offsetsv.isObject()) {MOZ_RELEASE_ASSERT(0);
         offsets = &offsetsv.toObject();
       } else {
         MOZ_ASSERT(offsetsv.isUndefined());
@@ -1665,12 +1665,12 @@ bool DebuggerScript::CallData::getAllOff
         RootedId id(cx);
         RootedValue v(cx, NumberValue(lineno));
         offsets = NewDenseEmptyArray(cx);
-        if (!offsets || !PrimitiveValueToId<CanGC>(cx, v, &id)) {
+        if (!offsets || !PrimitiveValueToId<CanGC>(cx, v, &id)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         RootedValue value(cx, ObjectValue(*offsets));
-        if (!DefineDataProperty(cx, result, id, value)) {
+        if (!DefineDataProperty(cx, result, id, value)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -1692,17 +1692,17 @@ class DebuggerScript::GetAllColumnOffset
 
   bool appendColumnOffsetEntry(size_t lineno, size_t column, size_t offset) {
     RootedPlainObject entry(cx_, NewBuiltinClassInstance<PlainObject>(cx_));
-    if (!entry) {
+    if (!entry) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedValue value(cx_, NumberValue(lineno));
-    if (!DefineDataProperty(cx_, entry, cx_->names().lineNumber, value)) {
+    if (!DefineDataProperty(cx_, entry, cx_->names().lineNumber, value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     value = NumberValue(column);
-    if (!DefineDataProperty(cx_, entry, cx_->names().columnNumber, value)) {
+    if (!DefineDataProperty(cx_, entry, cx_->names().columnNumber, value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1720,20 +1720,20 @@ class DebuggerScript::GetAllColumnOffset
   using ReturnType = bool;
   ReturnType match(Handle<BaseScript*> base) {
     RootedScript script(cx_, DelazifyScript(cx_, base));
-    if (!script) {
+    if (!script) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // First pass: determine which offsets in this script are jump targets
     // and which positions jump to them.
     FlowGraphSummary flowData(cx_);
-    if (!flowData.populate(cx_, script)) {
+    if (!flowData.populate(cx_, script)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // Second pass: build the result array.
     result_.set(NewDenseEmptyArray(cx_));
-    if (!result_) {
+    if (!result_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1759,12 +1759,12 @@ class DebuggerScript::GetAllColumnOffset
 
     Vector<wasm::ExprLoc> offsets(cx_);
     if (instance.debugEnabled() &&
-        !instance.debug().getAllColumnOffsets(&offsets)) {
+        !instance.debug().getAllColumnOffsets(&offsets)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     result_.set(NewDenseEmptyArray(cx_));
-    if (!result_) {
+    if (!result_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1803,19 +1803,19 @@ class DebuggerScript::GetLineOffsetsMatc
   using ReturnType = bool;
   ReturnType match(Handle<BaseScript*> base) {
     RootedScript script(cx_, DelazifyScript(cx_, base));
-    if (!script) {
+    if (!script) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // First pass: determine which offsets in this script are jump targets and
     // which line numbers jump to them.
     FlowGraphSummary flowData(cx_);
-    if (!flowData.populate(cx_, script)) {
+    if (!flowData.populate(cx_, script)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     result_.set(NewDenseEmptyArray(cx_));
-    if (!result_) {
+    if (!result_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1843,12 +1843,12 @@ class DebuggerScript::GetLineOffsetsMatc
 
     Vector<uint32_t> offsets(cx_);
     if (instance.debugEnabled() &&
-        !instance.debug().getLineOffsets(lineno_, &offsets)) {
+        !instance.debug().getLineOffsets(lineno_, &offsets)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     result_.set(NewDenseEmptyArray(cx_));
-    if (!result_) {
+    if (!result_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1862,20 +1862,20 @@ class DebuggerScript::GetLineOffsetsMatc
 };
 
 bool DebuggerScript::CallData::getLineOffsets() {
-  if (!args.requireAtLeast(cx, "Debugger.Script.getLineOffsets", 1)) {
+  if (!args.requireAtLeast(cx, "Debugger.Script.getLineOffsets", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Parse lineno argument.
   RootedValue linenoValue(cx, args[0]);
   size_t lineno;
-  if (!ToNumber(cx, &linenoValue)) {
+  if (!ToNumber(cx, &linenoValue)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   {
     double d = linenoValue.toNumber();
     lineno = size_t(d);
-    if (lineno != d) {
+    if (lineno != d) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                 JSMSG_DEBUG_BAD_LINE);
       return false;
@@ -2005,18 +2005,18 @@ struct DebuggerScript::SetBreakpointMatc
 };
 
 bool DebuggerScript::CallData::setBreakpoint() {
-  if (!args.requireAtLeast(cx, "Debugger.Script.setBreakpoint", 2)) {
+  if (!args.requireAtLeast(cx, "Debugger.Script.setBreakpoint", 2)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   Debugger* dbg = obj->owner();
 
   size_t offset;
-  if (!ScriptOffset(cx, args[0], &offset)) {
+  if (!ScriptOffset(cx, args[0], &offset)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject handler(cx, RequireObject(cx, args[1]));
-  if (!handler) {
+  if (!handler) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2029,7 +2029,7 @@ bool DebuggerScript::CallData::setBreakp
 }
 
 bool DebuggerScript::CallData::getBreakpoints() {
-  if (!ensureScript()) {
+  if (!ensureScript()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   Debugger* dbg = obj->owner();
@@ -2038,7 +2038,7 @@ bool DebuggerScript::CallData::getBreakp
   if (args.length() > 0) {
     size_t offset;
     if (!ScriptOffset(cx, args[0], &offset) ||
-        !EnsureScriptOffsetIsValid(cx, script, offset)) {
+        !EnsureScriptOffsetIsValid(cx, script, offset)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     pc = script->offsetToPC(offset);
@@ -2047,7 +2047,7 @@ bool DebuggerScript::CallData::getBreakp
   }
 
   RootedObject arr(cx, NewDenseEmptyArray(cx));
-  if (!arr) {
+  if (!arr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2086,7 +2086,7 @@ class DebuggerScript::ClearBreakpointMat
 
   ReturnType match(Handle<BaseScript*> base) {
     RootedScript script(cx_, DelazifyScript(cx_, base));
-    if (!script) {
+    if (!script) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2106,7 +2106,7 @@ class DebuggerScript::ClearBreakpointMat
   }
   ReturnType match(Handle<WasmInstanceObject*> instanceObj) {
     wasm::Instance& instance = instanceObj->instance();
-    if (!instance.debugEnabled()) {
+    if (!instance.debugEnabled()) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
 
@@ -2127,13 +2127,13 @@ class DebuggerScript::ClearBreakpointMat
 };
 
 bool DebuggerScript::CallData::clearBreakpoint() {
-  if (!args.requireAtLeast(cx, "Debugger.Script.clearBreakpoint", 1)) {
+  if (!args.requireAtLeast(cx, "Debugger.Script.clearBreakpoint", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   Debugger* dbg = obj->owner();
 
   JSObject* handler = RequireObject(cx, args[0]);
-  if (!handler) {
+  if (!handler) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2170,11 +2170,11 @@ class DebuggerScript::IsInCatchScopeMatc
 
   ReturnType match(Handle<BaseScript*> base) {
     RootedScript script(cx_, DelazifyScript(cx_, base));
-    if (!script) {
+    if (!script) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!EnsureScriptOffsetIsValid(cx_, script, offset_)) {
+    if (!EnsureScriptOffsetIsValid(cx_, script, offset_)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2196,12 +2196,12 @@ class DebuggerScript::IsInCatchScopeMatc
 };
 
 bool DebuggerScript::CallData::isInCatchScope() {
-  if (!args.requireAtLeast(cx, "Debugger.Script.isInCatchScope", 1)) {
+  if (!args.requireAtLeast(cx, "Debugger.Script.isInCatchScope", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   size_t offset;
-  if (!ScriptOffset(cx, args[0], &offset)) {
+  if (!ScriptOffset(cx, args[0], &offset)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2242,7 +2242,7 @@ bool DebuggerScript::CallData::getOffset
   //  - columnNumber    Column of the current opcode.
   //  - count           Number of times the instruction got executed.
   RootedObject result(cx, NewDenseEmptyArray(cx));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2281,7 +2281,7 @@ bool DebuggerScript::CallData::getOffset
         !DefineDataProperty(cx, item, lineNumberId, lineNumberValue) ||
         !DefineDataProperty(cx, item, columnNumberId, columnNumberValue) ||
         !DefineDataProperty(cx, item, countId, countValue) ||
-        !NewbornArrayPush(cx, result, ObjectValue(*item))) {
+        !NewbornArrayPush(cx, result, ObjectValue(*item))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2298,7 +2298,7 @@ bool DebuggerScript::CallData::getOffset
 }
 
 bool DebuggerScript::CallData::setInstrumentationId() {
-  if (!ensureScriptMaybeLazy()) {
+  if (!ensureScriptMaybeLazy()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/debugger/Source.cpp b/js/src/debugger/Source.cpp
--- a/js/src/debugger/Source.cpp
+++ b/js/src/debugger/Source.cpp
@@ -82,7 +82,7 @@ DebuggerSource* DebuggerSource::create(J
                                        HandleNativeObject debugger) {
   Rooted<DebuggerSource*> sourceObj(
       cx, NewTenuredObjectWithGivenProto<DebuggerSource>(cx, proto));
-  if (!sourceObj) {
+  if (!sourceObj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   sourceObj->setReservedSlot(OWNER_SLOT, ObjectValue(*debugger));
@@ -134,10 +134,10 @@ bool DebuggerSource::construct(JSContext
 /* static */
 DebuggerSource* DebuggerSource::check(JSContext* cx, HandleValue thisv) {
   JSObject* thisobj = RequireObject(cx, thisv);
-  if (!thisobj) {
+  if (!thisobj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
-  if (!thisobj->is<DebuggerSource>()) {
+  if (!thisobj->is<DebuggerSource>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_INCOMPATIBLE_PROTO, "Debugger.Source",
                               "method", thisobj->getClass()->name);
@@ -213,10 +213,10 @@ class DebuggerSourceGetTextMatcher {
   ReturnType match(HandleScriptSourceObject sourceObject) {
     ScriptSource* ss = sourceObject->source();
     bool hasSourceText;
-    if (!ScriptSource::loadSource(cx_, ss, &hasSourceText)) {
+    if (!ScriptSource::loadSource(cx_, ss, &hasSourceText)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (!hasSourceText) {
+    if (!hasSourceText) {MOZ_RELEASE_ASSERT(0);
       return NewStringCopyZ<CanGC>(cx_, "[no source]");
     }
 
@@ -259,7 +259,7 @@ bool DebuggerSource::CallData::getText()
 }
 
 bool DebuggerSource::CallData::getBinary() {
-  if (!referent.is<WasmInstanceObject*>()) {
+  if (!referent.is<WasmInstanceObject*>()) {MOZ_RELEASE_ASSERT(0);
     ReportValueError(cx, JSMSG_DEBUG_BAD_REFERENT, JSDVG_SEARCH_STACK,
                      args.thisv(), nullptr, "a wasm source");
     return false;
@@ -268,7 +268,7 @@ bool DebuggerSource::CallData::getBinary
   RootedWasmInstanceObject instanceObj(cx, referent.as<WasmInstanceObject*>());
   wasm::Instance& instance = instanceObj->instance();
 
-  if (!instance.debugEnabled()) {
+  if (!instance.debugEnabled()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_DEBUG_NO_BINARY_SOURCE);
     return false;
@@ -313,7 +313,7 @@ bool DebuggerSource::CallData::getURL() 
   DebuggerSourceGetURLMatcher matcher(cx);
   Maybe<JSString*> str = referent.match(matcher);
   if (str.isSome()) {
-    if (!*str) {
+    if (!*str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     args.rval().setString(*str);
@@ -375,7 +375,7 @@ bool DebuggerSource::CallData::getDispla
   DebuggerSourceGetDisplayURLMatcher matcher;
   if (const char16_t* displayURL = referent.match(matcher)) {
     JSString* str = JS_NewUCStringCopyZ(cx, displayURL);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     args.rval().setString(str);
@@ -399,7 +399,7 @@ bool DebuggerSource::CallData::getElemen
   DebuggerSourceGetElementMatcher matcher(cx);
   if (JSObject* element = referent.match(matcher)) {
     args.rval().setObjectOrNull(element);
-    if (!obj->owner()->wrapDebuggeeValue(cx, args.rval())) {
+    if (!obj->owner()->wrapDebuggeeValue(cx, args.rval())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -441,7 +441,7 @@ class DebuggerSourceGetIntroductionScrip
                                sourceObject->unwrappedIntroductionScript());
     if (script) {
       RootedObject scriptDO(cx_, dbg_->wrapScript(cx_, script));
-      if (!scriptDO) {
+      if (!scriptDO) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       rval_.setObject(*scriptDO);
@@ -505,7 +505,7 @@ bool DebuggerSource::CallData::getIntrod
   DebuggerSourceGetIntroductionTypeMatcher matcher;
   if (const char* introductionType = referent.match(matcher)) {
     JSString* str = NewStringCopyZ<CanGC>(cx, introductionType);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     args.rval().setString(str);
@@ -540,12 +540,12 @@ bool DebuggerSource::CallData::setSource
   }
 
   JSString* str = ToString<CanGC>(cx, args[0]);
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   UniqueTwoByteChars chars = JS_CopyStringCharsZ(cx, str);
-  if (!chars) {
+  if (!chars) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -601,7 +601,7 @@ class DebuggerSourceGetSourceMapURLMatch
 bool DebuggerSource::CallData::getSourceMapURL() {
   RootedString result(cx);
   DebuggerSourceGetSourceMapURLMatcher matcher(cx, &result);
-  if (!referent.match(matcher)) {
+  if (!referent.match(matcher)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (result) {
@@ -624,7 +624,7 @@ static JSScript* ReparseSource(JSContext
   UncompressedSourceCache::AutoHoldEntry holder;
 
   ScriptSource::PinnedUnits<Unit> units(cx, ss, holder, 0, ss->length());
-  if (!units.get()) {
+  if (!units.get()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -639,11 +639,11 @@ static JSScript* ReparseSource(JSContext
 
 bool DebuggerSource::CallData::reparse() {
   RootedScriptSourceObject sourceObject(cx, EnsureSourceObject(cx, obj));
-  if (!sourceObject) {
+  if (!sourceObject) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!sourceObject->source()->hasSourceText()) {
+  if (!sourceObject->source()->hasSourceText()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Source object missing text");
     return false;
   }
@@ -655,7 +655,7 @@ bool DebuggerSource::CallData::reparse()
     script = ReparseSource<char16_t>(cx, sourceObject);
   }
 
-  if (!script) {
+  if (!script) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/ds/LifoAlloc.cpp b/js/src/ds/LifoAlloc.cpp
--- a/js/src/ds/LifoAlloc.cpp
+++ b/js/src/ds/LifoAlloc.cpp
@@ -102,10 +102,10 @@ void BumpChunk::setReadWrite() {
 void LifoAlloc::reset(size_t defaultChunkSize) {
   MOZ_ASSERT(mozilla::IsPowerOfTwo(defaultChunkSize));
 
-  while (!chunks_.empty()) {
+  while (!chunks_.empty()) {MOZ_RELEASE_ASSERT(0);
     chunks_.popFirst();
   }
-  while (!oversize_.empty()) {
+  while (!oversize_.empty()) {MOZ_RELEASE_ASSERT(0);
     oversize_.popFirst();
   }
   while (!unused_.empty()) {
@@ -177,7 +177,7 @@ LifoAlloc::UniqueBumpChunk LifoAlloc::ne
 
   size_t minSize;
   if (MOZ_UNLIKELY(!detail::BumpChunk::allocSizeWithRedZone(n, &minSize) ||
-                   (minSize & (size_t(1) << (BitSize<size_t>::value - 1))))) {
+                   (minSize & (size_t(1) << (BitSize<size_t>::value - 1))))) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/ds/MemoryProtectionExceptionHandler.cpp b/js/src/ds/MemoryProtectionExceptionHandler.cpp
--- a/js/src/ds/MemoryProtectionExceptionHandler.cpp
+++ b/js/src/ds/MemoryProtectionExceptionHandler.cpp
@@ -81,7 +81,7 @@ class ProtectedRegionTree {
 
   ~ProtectedRegionTree() { sProtectedRegionsInit = false; }
 
-  void insert(uintptr_t addr, size_t size) {
+  void insert(uintptr_t addr, size_t size) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(addr && size);
     LockGuard<Mutex> guard(lock);
     AutoEnterOOMUnsafeRegion oomUnsafe;
@@ -126,13 +126,13 @@ bool MemoryProtectionExceptionHandler::i
 #endif
 }
 
-void MemoryProtectionExceptionHandler::addRegion(void* addr, size_t size) {
+void MemoryProtectionExceptionHandler::addRegion(void* addr, size_t size) {MOZ_RELEASE_ASSERT(0);
   if (sExceptionHandlerInstalled && sProtectedRegionsInit) {
     sProtectedRegions.insert(uintptr_t(addr), size);
   }
 }
 
-void MemoryProtectionExceptionHandler::removeRegion(void* addr) {
+void MemoryProtectionExceptionHandler::removeRegion(void* addr) {MOZ_RELEASE_ASSERT(0);
   if (sExceptionHandlerInstalled && sProtectedRegionsInit) {
     sProtectedRegions.remove(uintptr_t(addr));
   }
@@ -243,35 +243,35 @@ static struct sigaction sPrevSEGVHandler
  */
 static mozilla::Atomic<bool> sHandlingException(false);
 
-static void UnixExceptionHandler(int signum, siginfo_t* info, void* context) {
+static void UnixExceptionHandler(int signum, siginfo_t* info, void* context) {MOZ_RELEASE_ASSERT(0);
   // Make absolutely sure we can only get here once.
-  if (sHandlingException.compareExchange(false, true)) {
+  if (sHandlingException.compareExchange(false, true)) {MOZ_RELEASE_ASSERT(0);
     // Restore the previous handler. We're going to forward to it
     // anyway, and if we crash while doing so we don't want to hang.
     MOZ_ALWAYS_FALSE(sigaction(SIGSEGV, &sPrevSEGVHandler, nullptr));
 
     MOZ_ASSERT(signum == SIGSEGV && info->si_signo == SIGSEGV);
 
-    if (info->si_code == SEGV_ACCERR) {
+    if (info->si_code == SEGV_ACCERR) {MOZ_RELEASE_ASSERT(0);
       // Get the address that the offending code tried to access.
       uintptr_t address = uintptr_t(info->si_addr);
 
       // If the faulting address is in one of our protected regions, we
       // want to annotate the crash to make it stand out from the crowd.
-      if (sProtectedRegionsInit && sProtectedRegions.isProtected(address)) {
+      if (sProtectedRegionsInit && sProtectedRegions.isProtected(address)) {MOZ_RELEASE_ASSERT(0);
         ReportCrashIfDebug(
             "Hit MOZ_CRASH(Tried to access a protected region!)\n");
         MOZ_CRASH_ANNOTATE("MOZ_CRASH(Tried to access a protected region!)");
-      }
-    }
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   // Forward to the previous handler which may be a debugger,
   // the crash reporter or something else entirely.
-  if (sPrevSEGVHandler.sa_flags & SA_SIGINFO) {
+  if (sPrevSEGVHandler.sa_flags & SA_SIGINFO) {MOZ_RELEASE_ASSERT(0);
     sPrevSEGVHandler.sa_sigaction(signum, info, context);
   } else if (sPrevSEGVHandler.sa_handler == SIG_DFL ||
-             sPrevSEGVHandler.sa_handler == SIG_IGN) {
+             sPrevSEGVHandler.sa_handler == SIG_IGN) {MOZ_RELEASE_ASSERT(0);
     sigaction(SIGSEGV, &sPrevSEGVHandler, nullptr);
   } else {
     sPrevSEGVHandler.sa_handler(signum);
diff --git a/js/src/dtoa.c b/js/src/dtoa.c
--- a/js/src/dtoa.c
+++ b/js/src/dtoa.c
@@ -593,7 +593,7 @@ Bfree
 	(STATE_PARAM Bigint *v)
 #endif
 {
-	if (v) {
+	if (v) {MOZ_RELEASE_ASSERT(0);
 		if (v->k > Kmax)
 			FREE((void*)v);
 		else {
@@ -1822,7 +1822,7 @@ static CONST double tinytens[] = { 1e-16
 		e1 = -e1;
 		if ((i = e1 & 15))
 			dval(rv) /= tens[i];
-		if (e1 >>= 4) {
+		if (e1 >>= 4) {MOZ_RELEASE_ASSERT(0);
 			if (e1 >= 1 << n_bigtens)
 				goto undfl;
 #ifdef Avoid_Underflow
@@ -2083,14 +2083,14 @@ static CONST double tinytens[] = { 1e-16
 			}
 		if (i == 0) {
 			/* exactly half-way between */
-			if (dsign) {
+			if (dsign) {MOZ_RELEASE_ASSERT(0);
 				if ((word0(rv) & Bndry_mask1) == Bndry_mask1
 				 &&  word1(rv) == (
 #ifdef Avoid_Underflow
 			(scale && (y = word0(rv) & Exp_mask) <= 2*P*Exp_msk1)
 		? (0xffffffff & (0xffffffff << (2*P+1-(y>>Exp_shift)))) :
 #endif
-						   0xffffffff)) {
+						   0xffffffff)) {MOZ_RELEASE_ASSERT(0);
 					/*boundary case -- increment exponent*/
 					word0(rv) = (word0(rv) & Exp_mask)
 						+ Exp_msk1
@@ -2123,7 +2123,7 @@ static CONST double tinytens[] = { 1e-16
 				L -= Exp_msk1;
 #else /*Sudden_Underflow}{*/
 #ifdef Avoid_Underflow
-				if (scale) {
+				if (scale) {MOZ_RELEASE_ASSERT(0);
 					L = word0(rv) & Exp_mask;
 					if (L <= (2*P+1)*Exp_msk1) {
 						if (L > (P+2)*Exp_msk1)
@@ -2168,7 +2168,7 @@ static CONST double tinytens[] = { 1e-16
 		if ((aadj = ratio(delta, bs)) <= 2.) {
 			if (dsign)
 				aadj = dval(aadj1) = 1.;
-			else if (word1(rv) || word0(rv) & Bndry_mask) {
+			else if (word1(rv) || word0(rv) & Bndry_mask) {MOZ_RELEASE_ASSERT(0);
 #ifndef Sudden_Underflow
 				if (word1(rv) == Tiny1 && !word0(rv))
 					goto undfl;
diff --git a/js/src/editline/editline.c b/js/src/editline/editline.c
--- a/js/src/editline/editline.c
+++ b/js/src/editline/editline.c
@@ -146,7 +146,7 @@ TTYflush()
 STATIC void
 TTYput(c)
     CHAR	c;
-{
+{MOZ_RELEASE_ASSERT(0);
     Screen[ScreenCount] = c;
     if (++ScreenCount >= ScreenSize - 1) {
 	ScreenSize += SCREEN_INC;
@@ -166,11 +166,11 @@ STATIC void
 TTYshow(c)
     CHAR	c;
 {
-    if (c == DEL) {
+    if (c == DEL) {MOZ_RELEASE_ASSERT(0);
 	TTYput('^');
 	TTYput('?');
     }
-    else if (ISCTL(c)) {
+    else if (ISCTL(c)) {MOZ_RELEASE_ASSERT(0);
 	TTYput('^');
 	TTYput(UNCTL(c));
     }
@@ -193,7 +193,7 @@ TTYstring(p)
 
 STATIC unsigned int
 TTYget()
-{
+{MOZ_RELEASE_ASSERT(0);
     CHAR	c;
 
     TTYflush();
@@ -229,17 +229,17 @@ TTYinfo()
     struct winsize	W;
 #endif	/* defined(TIOCGWINSZ) */
 
-    if (init) {
+    if (init) {MOZ_RELEASE_ASSERT(0);
 #if	defined(TIOCGWINSZ)
 	/* Perhaps we got resized. */
 	if (ioctl(0, TIOCGWINSZ, &W) >= 0
 	 && W.ws_col > 0 && W.ws_row > 0) {
 	    TTYwidth = (int)W.ws_col;
 	    TTYrows = (int)W.ws_row;
-	}
+	}MOZ_RELEASE_ASSERT(0);
 #endif	/* defined(TIOCGWINSZ) */
 	return;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     init++;
 
     TTYwidth = TTYrows = 0;
@@ -287,9 +287,9 @@ reposition()
 STATIC void
 left(Change)
     STATUS	Change;
-{
+{MOZ_RELEASE_ASSERT(0);
     TTYback();
-    if (Point) {
+    if (Point) {MOZ_RELEASE_ASSERT(0);
 	if (ISCTL(Line[Point - 1]))
 	    TTYback();
         else if (rl_meta_chars && ISMETA(Line[Point - 1])) {
@@ -321,7 +321,7 @@ ring_bell()
 STATIC STATUS
 do_macro(c)
     unsigned int	c;
-{
+{MOZ_RELEASE_ASSERT(0);
     CHAR		name[4];
 
     name[0] = '_';
@@ -339,7 +339,7 @@ do_macro(c)
 STATIC STATUS
 do_forward(move)
     STATUS	move;
-{
+{MOZ_RELEASE_ASSERT(0);
     int		i;
     CHAR	*p;
 
@@ -364,20 +364,20 @@ do_forward(move)
 STATIC STATUS
 do_case(type)
     CASE	type;
-{
+{MOZ_RELEASE_ASSERT(0);
     int		i;
     int		end;
     int		count;
     CHAR	*p;
 
     (void)do_forward(CSstay);
-    if (OldPoint != Point) {
+    if (OldPoint != Point) {MOZ_RELEASE_ASSERT(0);
 	if ((count = Point - OldPoint) < 0)
 	    count = -count;
 	Point = OldPoint;
 	if ((end = Point + count) > End)
 	    end = End;
-	for (i = Point, p = &Line[i]; i < end; i++, p++) {
+	for (i = Point, p = &Line[i]; i < end; i++, p++) {MOZ_RELEASE_ASSERT(0);
 	    if (type == TOupper) {
 		if (islower(*p))
 		    *p = toupper(*p);
@@ -404,14 +404,14 @@ case_up_word()
 
 STATIC void
 ceol()
-{
+{MOZ_RELEASE_ASSERT(0);
     int		extras;
     int		i;
     CHAR	*p;
 
-    for (extras = 0, i = Point, p = &Line[i]; i <= End; i++, p++) {
+    for (extras = 0, i = Point, p = &Line[i]; i <= End; i++, p++) {MOZ_RELEASE_ASSERT(0);
 	TTYput(' ');
-	if (ISCTL(*p)) {
+	if (ISCTL(*p)) {MOZ_RELEASE_ASSERT(0);
 	    TTYput(' ');
 	    extras++;
 	}
@@ -440,14 +440,14 @@ clear_line()
 STATIC STATUS
 insert_string(p)
     CHAR	*p;
-{
+{MOZ_RELEASE_ASSERT(0);
     SIZE_T	len;
     int		i;
     CHAR	*new;
     CHAR	*q;
 
     len = strlen((char *)p);
-    if (End + len >= Length) {
+    if (End + len >= Length) {MOZ_RELEASE_ASSERT(0);
 	if ((new = NEW(CHAR, Length + len + MEM_INC)) == NULL)
 	    return CSstay;
 	if (Length) {
@@ -514,7 +514,7 @@ do_insert_hist(p)
 STATIC STATUS
 do_hist(move)
     CHAR	*(*move)();
-{
+{MOZ_RELEASE_ASSERT(0);
     CHAR	*p;
     int		i;
 
@@ -573,7 +573,7 @@ STATIC CHAR *
 search_hist(search, move)
     CHAR	*search;
     CHAR	*(*move)();
-{
+{MOZ_RELEASE_ASSERT(0);
     static CHAR	*old_search;
     int		len;
     int		pos;
@@ -581,19 +581,19 @@ search_hist(search, move)
     char	*pat;
 
     /* Save or get remembered search pattern. */
-    if (search && *search) {
+    if (search && *search) {MOZ_RELEASE_ASSERT(0);
 	if (old_search)
 	    DISPOSE(old_search);
 	old_search = (CHAR *)strdup((char *)search);
     }
-    else {
+    else {MOZ_RELEASE_ASSERT(0);
 	if (old_search == NULL || *old_search == '\0')
             return NULL;
 	search = old_search;
     }
 
     /* Set up pattern-finder. */
-    if (*search == '^') {
+    if (*search == '^') {MOZ_RELEASE_ASSERT(0);
 	match = strncmp;
 	pat = (char *)(search + 1);
     }
@@ -612,7 +612,7 @@ search_hist(search, move)
 
 STATIC STATUS
 h_search()
-{
+{MOZ_RELEASE_ASSERT(0);
     static int	Searching;
     CONST char	*old_prompt;
     CHAR	*(*move)();
@@ -631,11 +631,11 @@ h_search()
     Prompt = old_prompt;
     Searching = 0;
     TTYputs((CONST CHAR *)Prompt);
-    if (p == NULL && Signal > 0) {
+    if (p == NULL && Signal > 0) {MOZ_RELEASE_ASSERT(0);
 	Signal = 0;
 	clear_line();
 	return redisplay();
-    }
+    }MOZ_RELEASE_ASSERT(0);
     p = search_hist(p, move);
     clear_line();
     if (p == NULL) {
@@ -647,7 +647,7 @@ h_search()
 
 STATIC STATUS
 fd_char()
-{
+{MOZ_RELEASE_ASSERT(0);
     int		i;
 
     i = 0;
@@ -664,10 +664,10 @@ save_yank(begin, i)
     int		begin;
     int		i;
 {
-    if (Yanked) {
+    if (Yanked) {MOZ_RELEASE_ASSERT(0);
 	DISPOSE(Yanked);
 	Yanked = NULL;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     if (i < 1)
 	return;
@@ -681,20 +681,20 @@ save_yank(begin, i)
 STATIC STATUS
 delete_string(count)
     int		count;
-{
+{MOZ_RELEASE_ASSERT(0);
     int		i;
     CHAR	*p;
 
     if (count <= 0 || End == Point)
 	return ring_bell();
 
-    if (count == 1 && Point == End - 1) {
+    if (count == 1 && Point == End - 1) {MOZ_RELEASE_ASSERT(0);
 	/* Optimize common case of delete at end of line. */
 	End--;
 	p = &Line[Point];
 	i = 1;
 	TTYput(' ');
-	if (ISCTL(*p)) {
+	if (ISCTL(*p)) {MOZ_RELEASE_ASSERT(0);
 	    i = 2;
 	    TTYput(' ');
 	}
@@ -723,7 +723,7 @@ delete_string(count)
 
 STATIC STATUS
 bk_char()
-{
+{MOZ_RELEASE_ASSERT(0);
     int		i;
 
     i = 0;
@@ -738,7 +738,7 @@ bk_char()
 
 STATIC STATUS
 bk_del_char()
-{
+{MOZ_RELEASE_ASSERT(0);
     int		i;
 
     i = 0;
@@ -753,11 +753,11 @@ bk_del_char()
 
 STATIC STATUS
 kill_line()
-{
+{MOZ_RELEASE_ASSERT(0);
     int		i;
 
-    if (Repeat != NO_ARG) {
-	if (Repeat < Point) {
+    if (Repeat != NO_ARG) {MOZ_RELEASE_ASSERT(0);
+	if (Repeat < Point) {MOZ_RELEASE_ASSERT(0);
 	    i = Point;
 	    Point = Repeat;
 	    reposition();
@@ -780,7 +780,7 @@ kill_line()
 STATIC STATUS
 insert_char(c)
     int		c;
-{
+{MOZ_RELEASE_ASSERT(0);
     STATUS	s;
     CHAR	buff[2];
     CHAR	*p;
@@ -806,7 +806,7 @@ insert_char(c)
 
 STATIC STATUS
 meta()
-{
+{MOZ_RELEASE_ASSERT(0);
     unsigned int	c;
     CONST KEYMAP	*kp;
 
@@ -845,7 +845,7 @@ meta()
 STATIC STATUS
 emacs(c)
     unsigned int	c;
-{
+{MOZ_RELEASE_ASSERT(0);
     STATUS		s;
     const KEYMAP	*kp;
 
@@ -867,23 +867,23 @@ emacs(c)
 STATIC STATUS
 TTYspecial(c)
     unsigned int	c;
-{
+{MOZ_RELEASE_ASSERT(0);
     if (ISMETA(c))
 	return CSdispatch;
 
     if (c == rl_erase || (int)c == DEL)
 	return bk_del_char();
-    if (c == rl_kill) {
-	if (Point != 0) {
+    if (c == rl_kill) {MOZ_RELEASE_ASSERT(0);
+	if (Point != 0) {MOZ_RELEASE_ASSERT(0);
 	    Point = 0;
 	    reposition();
-	}
+	}MOZ_RELEASE_ASSERT(0);
 	Repeat = NO_ARG;
 	return kill_line();
-    }
+    }MOZ_RELEASE_ASSERT(0);
     if (c == rl_eof && Point == 0 && End == 0)
 	return CSeof;
-    if (c == rl_intr) {
+    if (c == rl_intr) {MOZ_RELEASE_ASSERT(0);
 	Signal = SIGINT;
 	return CSsignal;
     }
@@ -897,7 +897,7 @@ TTYspecial(c)
 
 STATIC CHAR *
 editinput()
-{
+{MOZ_RELEASE_ASSERT(0);
     unsigned int	c;
 
     Repeat = NO_ARG;
@@ -944,7 +944,7 @@ editinput()
 STATIC void
 hist_add(p)
     CHAR	*p;
-{
+{MOZ_RELEASE_ASSERT(0);
     int		i;
 
     if ((p = (CHAR *)strdup((char *)p)) == NULL)
@@ -979,15 +979,15 @@ rl_initialize()
 char *
 readline(prompt)
     CONST char	*prompt;
-{
+{MOZ_RELEASE_ASSERT(0);
     CHAR	*line;
     int		s;
 
-    if (Line == NULL) {
+    if (Line == NULL) {MOZ_RELEASE_ASSERT(0);
 	Length = MEM_INC;
 	if ((Line = NEW(CHAR, Length)) == NULL)
 	    return NULL;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     TTYinfo();
     rl_ttyset(0);
@@ -996,11 +996,11 @@ readline(prompt)
     Screen = NEW(char, ScreenSize);
     Prompt = prompt ? prompt : (char *)NIL;
     TTYputs((CONST CHAR *)Prompt);
-    if ((line = editinput()) != NULL) {
+    if ((line = editinput()) != NULL) {MOZ_RELEASE_ASSERT(0);
 	line = (CHAR *)strdup((char *)line);
 	TTYputs((CONST CHAR *)NEWLINE);
 	TTYflush();
-    }
+    }MOZ_RELEASE_ASSERT(0);
     rl_ttyset(1);
     DISPOSE(Screen);
     DISPOSE(H.Lines[--H.Size]);
@@ -1062,7 +1062,7 @@ accept_line()
 
 STATIC STATUS
 transpose()
-{
+{MOZ_RELEASE_ASSERT(0);
     CHAR	c;
 
     if (Point) {
@@ -1088,7 +1088,7 @@ quote()
 
 STATIC STATUS
 wipe()
-{
+{MOZ_RELEASE_ASSERT(0);
     int		i;
 
     if (Mark > End)
@@ -1113,7 +1113,7 @@ mk_set()
 
 STATIC STATUS
 exchange()
-{
+{MOZ_RELEASE_ASSERT(0);
     unsigned int	c;
 
     if ((c = TTYget()) != CTL('X'))
@@ -1151,7 +1151,7 @@ copy_region()
 
 STATIC STATUS
 move_to_char()
-{
+{MOZ_RELEASE_ASSERT(0);
     unsigned int	c;
     int			i;
     CHAR		*p;
@@ -1174,7 +1174,7 @@ fd_word()
 
 STATIC STATUS
 fd_kill_word()
-{
+{MOZ_RELEASE_ASSERT(0);
     int		i;
 
     (void)do_forward(CSstay);
@@ -1188,7 +1188,7 @@ fd_kill_word()
 
 STATIC STATUS
 bk_word()
-{
+{MOZ_RELEASE_ASSERT(0);
     int		i;
     CHAR	*p;
 
@@ -1220,7 +1220,7 @@ STATIC int
 argify(line, avp)
     CHAR	*line;
     CHAR	***avp;
-{
+{MOZ_RELEASE_ASSERT(0);
     CHAR	*c;
     CHAR	**p;
     CHAR	**new;
@@ -1236,11 +1236,11 @@ argify(line, avp)
     if (*c == '\n' || *c == '\0')
 	return 0;
 
-    for (ac = 0, p[ac++] = c; *c && *c != '\n'; ) {
-	if (isspace(*c)) {
+    for (ac = 0, p[ac++] = c; *c && *c != '\n'; ) {MOZ_RELEASE_ASSERT(0);
+	if (isspace(*c)) {MOZ_RELEASE_ASSERT(0);
 	    *c++ = '\0';
-	    if (*c && *c != '\n') {
-		if (ac + 1 == i) {
+	    if (*c && *c != '\n') {MOZ_RELEASE_ASSERT(0);
+		if (ac + 1 == i) {MOZ_RELEASE_ASSERT(0);
 		    new = NEW(CHAR*, i + MEM_INC);
 		    if (new == NULL) {
 			p[ac] = NULL;
diff --git a/js/src/editline/sysunix.c b/js/src/editline/sysunix.c
--- a/js/src/editline/sysunix.c
+++ b/js/src/editline/sysunix.c
@@ -35,7 +35,7 @@
 void
 rl_ttyset(Reset)
     int				Reset;
-{
+{MOZ_RELEASE_ASSERT(0);
     static struct termios	old;
     struct termios		new;
 
diff --git a/js/src/frontend/AsyncEmitter.cpp b/js/src/frontend/AsyncEmitter.cpp
--- a/js/src/frontend/AsyncEmitter.cpp
+++ b/js/src/frontend/AsyncEmitter.cpp
@@ -69,15 +69,15 @@ bool AsyncEmitter::prepareForModule() {
 
   NameOpEmitter noe(bce_, TaggedParserAtomIndex::WellKnown::dotGenerator(),
                     NameOpEmitter::Kind::Initialize);
-  if (!noe.prepareForRhs()) {
+  if (!noe.prepareForRhs()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
-  if (!bce_->emit1(JSOp::Generator)) {
+  if (!bce_->emit1(JSOp::Generator)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] GEN
     return false;
   }
-  if (!noe.emitAssignment()) {
+  if (!noe.emitAssignment()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] GEN
     return false;
   }
@@ -109,7 +109,7 @@ bool AsyncEmitter::emitEnd() {
   MOZ_ASSERT(state_ == State::Body);
 #endif
 
-  if (!emitFinalYield()) {
+  if (!emitFinalYield()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -124,28 +124,28 @@ bool AsyncEmitter::emitEnd() {
 }
 
 bool AsyncEmitter::emitFinalYield() {
-  if (!bce_->emit1(JSOp::Undefined)) {
+  if (!bce_->emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] UNDEF
     return false;
   }
 
-  if (!bce_->emitGetDotGeneratorInInnermostScope()) {
+  if (!bce_->emitGetDotGeneratorInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] UNDEF GEN
     return false;
   }
 
   if (!bce_->emit2(JSOp::AsyncResolve,
-                   uint8_t(AsyncFunctionResolveKind::Fulfill))) {
+                   uint8_t(AsyncFunctionResolveKind::Fulfill))) {MOZ_RELEASE_ASSERT(0);
     //              [stack] PROMISE
     return false;
   }
 
-  if (!bce_->emit1(JSOp::SetRval)) {
+  if (!bce_->emit1(JSOp::SetRval)) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
-  if (!bce_->emitGetDotGeneratorInInnermostScope()) {
+  if (!bce_->emitGetDotGeneratorInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] GEN
     return false;
   }
@@ -159,33 +159,33 @@ bool AsyncEmitter::emitFinalYield() {
 }
 
 bool AsyncEmitter::emitRejectCatch() {
-  if (!rejectTryCatch_->emitCatch()) {
+  if (!rejectTryCatch_->emitCatch()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] EXC
     return false;
   }
 
-  if (!bce_->emitGetDotGeneratorInInnermostScope()) {
+  if (!bce_->emitGetDotGeneratorInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] EXC GEN
     return false;
   }
 
   if (!bce_->emit2(JSOp::AsyncResolve,
-                   uint8_t(AsyncFunctionResolveKind::Reject))) {
+                   uint8_t(AsyncFunctionResolveKind::Reject))) {MOZ_RELEASE_ASSERT(0);
     //              [stack] PROMISE
     return false;
   }
 
-  if (!bce_->emit1(JSOp::SetRval)) {
+  if (!bce_->emit1(JSOp::SetRval)) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
-  if (!bce_->emitGetDotGeneratorInInnermostScope()) {
+  if (!bce_->emitGetDotGeneratorInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] GEN
     return false;
   }
 
-  if (!bce_->emitYieldOp(JSOp::FinalYieldRval)) {
+  if (!bce_->emitYieldOp(JSOp::FinalYieldRval)) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
diff --git a/js/src/frontend/BytecodeCompiler.cpp b/js/src/frontend/BytecodeCompiler.cpp
--- a/js/src/frontend/BytecodeCompiler.cpp
+++ b/js/src/frontend/BytecodeCompiler.cpp
@@ -261,11 +261,11 @@ template <typename Unit>
 #endif  // JS_ENABLE_SMOOSH
 
   if (input.options.selfHostingMode) {
-    if (!input.initForSelfHostingGlobal(cx)) {
+    if (!input.initForSelfHostingGlobal(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
-    if (!input.initForGlobal(cx)) {
+    if (!input.initForGlobal(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -291,7 +291,7 @@ template <typename Unit>
   if (output.is<UniquePtr<ExtensibleCompilationStencil>>()) {
     auto stencil = cx->make_unique<ExtensibleCompilationStencil>(
         std::move(compiler.stencil()));
-    if (!stencil) {
+    if (!stencil) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     output.as<UniquePtr<ExtensibleCompilationStencil>>() = std::move(stencil);
@@ -300,11 +300,11 @@ template <typename Unit>
                                        JS::ProfilingCategoryPair::JS_Parsing);
 
     auto stencil = cx->make_unique<CompilationStencil>(input.source);
-    if (!stencil) {
+    if (!stencil) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!stencil->steal(cx, std::move(compiler.stencil()))) {
+    if (!stencil->steal(cx, std::move(compiler.stencil()))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -392,7 +392,7 @@ bool frontend::InstantiateStencils(JSCon
 
   // Enqueue an off-thread source compression task after finishing parsing.
   if (!cx->isHelperThreadContext()) {
-    if (!stencil.source->tryCompressOffThread(cx)) {
+    if (!stencil.source->tryCompressOffThread(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -449,14 +449,14 @@ static JSScript* CompileEvalScriptImpl(
   AutoAssertReportedException assertException(cx);
 
   Rooted<CompilationInput> input(cx, CompilationInput(options));
-  if (!input.get().initForEval(cx, enclosingScope)) {
+  if (!input.get().initForEval(cx, enclosingScope)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   LifoAllocScope allocScope(&cx->tempLifoAlloc());
 
   ScriptCompiler<Unit> compiler(cx, allocScope, input.get(), srcBuf);
-  if (!compiler.init(cx, InheritThis::Yes, enclosingEnv)) {
+  if (!compiler.init(cx, InheritThis::Yes, enclosingEnv)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -555,12 +555,12 @@ AutoFrontendTraceLog::AutoFrontendTraceL
     : logger_(TraceLoggerForCurrentThread(cx)) {
   if (!logger_) {
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // If the tokenizer hasn't yet gotten any tokens, use the line and column
   // numbers from CompileOptions.
   uint32_t line, column;
-  if (errorReporter.hasTokenizationStarted()) {
+  if (errorReporter.hasTokenizationStarted()) {MOZ_RELEASE_ASSERT(0);
     line = errorReporter.options().lineno;
     column = errorReporter.options().column;
   } else {
@@ -622,7 +622,7 @@ template <typename Unit>
 bool frontend::SourceAwareCompiler<Unit>::createSourceAndParser(JSContext* cx) {
   const auto& options = compilationState_.input.options;
 
-  if (!compilationState_.source->assignSource(cx, options, sourceBuffer_)) {
+  if (!compilationState_.source->assignSource(cx, options, sourceBuffer_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -693,7 +693,7 @@ bool frontend::ScriptCompiler<Unit>::com
   // Emplace the topLevel stencil
   MOZ_ASSERT(compilationState_.scriptData.length() ==
              CompilationStencil::TopLevelIndex);
-  if (!compilationState_.appendScriptStencilAndData(cx)) {
+  if (!compilationState_.appendScriptStencilAndData(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -723,7 +723,7 @@ bool frontend::ScriptCompiler<Unit>::com
                                        JS::ProfilingCategoryPair::JS_Parsing);
 
     Maybe<BytecodeEmitter> emitter;
-    if (!emplaceEmitter(emitter, sc)) {
+    if (!emplaceEmitter(emitter, sc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -742,7 +742,7 @@ bool frontend::ModuleCompiler<Unit>::com
   // Emplace the topLevel stencil
   MOZ_ASSERT(compilationState_.scriptData.length() ==
              CompilationStencil::TopLevelIndex);
-  if (!compilationState_.appendScriptStencilAndData(cx)) {
+  if (!compilationState_.appendScriptStencilAndData(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -761,7 +761,7 @@ bool frontend::ModuleCompiler<Unit>::com
   }
 
   Maybe<BytecodeEmitter> emitter;
-  if (!emplaceEmitter(emitter, &modulesc)) {
+  if (!emplaceEmitter(emitter, &modulesc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -830,11 +830,11 @@ bool frontend::StandaloneFunctionCompile
 
   if (funbox->isInterpreted()) {
     Maybe<BytecodeEmitter> emitter;
-    if (!emplaceEmitter(emitter, funbox)) {
+    if (!emplaceEmitter(emitter, funbox)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!emitter->emitFunctionScript(parsedFunction)) {
+    if (!emitter->emitFunctionScript(parsedFunction)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -872,7 +872,7 @@ template <typename Unit>
     BytecodeCompilerOutput& output) {
   MOZ_ASSERT(srcBuf.get());
 
-  if (!input.initForModule(cx)) {
+  if (!input.initForModule(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -880,7 +880,7 @@ template <typename Unit>
 
   LifoAllocScope allocScope(&cx->tempLifoAlloc());
   ModuleCompiler<Unit> compiler(cx, allocScope, input, srcBuf);
-  if (!compiler.init(cx)) {
+  if (!compiler.init(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -891,7 +891,7 @@ template <typename Unit>
   if (output.is<UniquePtr<ExtensibleCompilationStencil>>()) {
     auto stencil = cx->make_unique<ExtensibleCompilationStencil>(
         std::move(compiler.stencil()));
-    if (!stencil) {
+    if (!stencil) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     output.as<UniquePtr<ExtensibleCompilationStencil>>() = std::move(stencil);
@@ -900,11 +900,11 @@ template <typename Unit>
                                        JS::ProfilingCategoryPair::JS_Parsing);
 
     auto stencil = cx->make_unique<CompilationStencil>(input.source);
-    if (!stencil) {
+    if (!stencil) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!stencil->steal(cx, std::move(compiler.stencil()))) {
+    if (!stencil->steal(cx, std::move(compiler.stencil()))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -971,7 +971,7 @@ static ModuleObject* CompileModuleImpl(
     SourceText<Unit>& srcBuf) {
   AutoAssertReportedException assertException(cx);
 
-  if (!GlobalObject::ensureModulePrototypesCreated(cx, cx->global())) {
+  if (!GlobalObject::ensureModulePrototypesCreated(cx, cx->global())) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1024,7 +1024,7 @@ static bool CompileLazyFunction(JSContex
   CompilationState compilationState(cx, allocScope, input);
   compilationState.setFunctionKey(input.lazy);
   MOZ_ASSERT(!compilationState.isInitialStencil());
-  if (!compilationState.init(cx, inheritThis)) {
+  if (!compilationState.init(cx, inheritThis)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1032,24 +1032,24 @@ static bool CompileLazyFunction(JSContex
                                         /* foldConstants = */ true,
                                         compilationState,
                                         /* syntaxParser = */ nullptr);
-  if (!parser.checkOptions()) {
+  if (!parser.checkOptions()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   FunctionNode* pn = parser.standaloneLazyFunction(
       fun, input.lazy->toStringStart(), input.lazy->strict(),
       input.lazy->generatorKind(), input.lazy->asyncKind());
-  if (!pn) {
+  if (!pn) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   BytecodeEmitter bce(/* parent = */ nullptr, &parser, pn->funbox(),
                       compilationState, BytecodeEmitter::LazyFunction);
-  if (!bce.init(pn->pn_pos)) {
+  if (!bce.init(pn->pn_pos)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!bce.emitFunctionScript(pn)) {
+  if (!bce.emitFunctionScript(pn)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1069,7 +1069,7 @@ static bool CompileLazyFunction(JSContex
   {
     BorrowingCompilationStencil borrowingStencil(compilationState);
     if (!CompilationStencil::instantiateStencils(cx, input, borrowingStencil,
-                                                 gcOutput.get())) {
+                                                 gcOutput.get())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1079,7 +1079,7 @@ static bool CompileLazyFunction(JSContex
                gcOutput.get().script->immutableFlags().hasFlag(
                    JSScript::ImmutableFlags::HasNonSyntacticScope));
 
-    if (input.source->hasEncoder()) {
+    if (input.source->hasEncoder()) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(!js::UseOffThreadParseGlobal());
       if (!input.source->addDelazificationToIncrementalEncoding(
               cx, borrowingStencil)) {
@@ -1161,11 +1161,11 @@ static JSFunction* CompileStandaloneFunc
   Rooted<CompilationInput> input(cx, CompilationInput(options));
   if (enclosingScope) {
     if (!input.get().initForStandaloneFunctionInNonSyntacticScope(
-            cx, enclosingScope)) {
+            cx, enclosingScope)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
-    if (!input.get().initForStandaloneFunction(cx)) {
+    if (!input.get().initForStandaloneFunction(cx)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -1176,7 +1176,7 @@ static JSFunction* CompileStandaloneFunc
                                 : InheritThis::No;
   StandaloneFunctionCompiler<char16_t> compiler(cx, allocScope, input.get(),
                                                 srcBuf);
-  if (!compiler.init(cx, inheritThis)) {
+  if (!compiler.init(cx, inheritThis)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1203,7 +1203,7 @@ static JSFunction* CompileStandaloneFunc
 
   // Enqueue an off-thread source compression task after finishing parsing.
   if (!cx->isHelperThreadContext()) {
-    if (!source->tryCompressOffThread(cx)) {
+    if (!source->tryCompressOffThread(cx)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
diff --git a/js/src/frontend/BytecodeControlStructures.cpp b/js/src/frontend/BytecodeControlStructures.cpp
--- a/js/src/frontend/BytecodeControlStructures.cpp
+++ b/js/src/frontend/BytecodeControlStructures.cpp
@@ -57,13 +57,13 @@ bool LoopControl::emitLoopHead(BytecodeE
   // JSOp::LoopHead. This avoids JIT issues with prologue code + try notes
   // or OSR. See bug 1602390 and bug 1602681.
   if (bce->bytecodeSection().offset().toUint32() == 0) {
-    if (!bce->emit1(JSOp::Nop)) {
+    if (!bce->emit1(JSOp::Nop)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   if (nextPos) {
-    if (!bce->updateSourceCoordNotes(*nextPos)) {
+    if (!bce->updateSourceCoordNotes(*nextPos)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -84,7 +84,7 @@ bool LoopControl::emitLoopHead(BytecodeE
 bool LoopControl::emitLoopEnd(BytecodeEmitter* bce, JSOp op,
                               TryNoteKind tryNoteKind) {
   JumpList jump;
-  if (!bce->emitJumpNoFallthrough(op, &jump)) {
+  if (!bce->emitJumpNoFallthrough(op, &jump)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   bce->patchJumpsToTarget(jump, head_);
@@ -92,10 +92,10 @@ bool LoopControl::emitLoopEnd(BytecodeEm
   // Create a fallthrough for closing iterators, and as a target for break
   // statements.
   JumpTarget breakTarget;
-  if (!bce->emitJumpTarget(&breakTarget)) {
+  if (!bce->emitJumpTarget(&breakTarget)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!patchBreaks(bce)) {
+  if (!patchBreaks(bce)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!bce->addTryNote(tryNoteKind, bce->bytecodeSection().stackDepth(),
diff --git a/js/src/frontend/BytecodeEmitter.cpp b/js/src/frontend/BytecodeEmitter.cpp
--- a/js/src/frontend/BytecodeEmitter.cpp
+++ b/js/src/frontend/BytecodeEmitter.cpp
@@ -221,11 +221,11 @@ bool BytecodeEmitter::markStepBreakpoint
     return true;
   }
 
-  if (!emitInstrumentation(InstrumentationKind::Breakpoint)) {
-    return false;
-  }
-
-  if (!newSrcNote(SrcNoteType::StepSep)) {
+  if (!emitInstrumentation(InstrumentationKind::Breakpoint)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!newSrcNote(SrcNoteType::StepSep)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -251,7 +251,7 @@ bool BytecodeEmitter::markSimpleBreakpoi
   // having two breakpoints with the same line/column position.
   // Note: This assumes that the position for the call has already been set.
   if (!bytecodeSection().isDuplicateLocation()) {
-    if (!emitInstrumentation(InstrumentationKind::Breakpoint)) {
+    if (!emitInstrumentation(InstrumentationKind::Breakpoint)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -269,12 +269,12 @@ bool BytecodeEmitter::emitCheck(JSOp op,
   *offset = BytecodeOffset(oldLength);
 
   size_t newLength = oldLength + size_t(delta);
-  if (MOZ_UNLIKELY(newLength > MaxBytecodeLength)) {
+  if (MOZ_UNLIKELY(newLength > MaxBytecodeLength)) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return false;
   }
 
-  if (!bytecodeSection().code().growByUninitialized(delta)) {
+  if (!bytecodeSection().code().growByUninitialized(delta)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -355,7 +355,7 @@ bool BytecodeEmitter::emitN(JSOp op, siz
   ptrdiff_t length = 1 + ptrdiff_t(extra);
 
   BytecodeOffset off;
-  if (!emitCheck(op, length, &off)) {
+  if (!emitCheck(op, length, &off)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -428,7 +428,7 @@ bool BytecodeEmitter::emitJumpNoFallthro
 }
 
 bool BytecodeEmitter::emitJump(JSOp op, JumpList* jump) {
-  if (!emitJumpNoFallthrough(op, jump)) {
+  if (!emitJumpNoFallthrough(op, jump)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (BytecodeFallsThrough(op)) {
@@ -491,7 +491,7 @@ bool BytecodeEmitter::emitDupAt(unsigned
     return emit1(JSOp::Dup2);
   }
 
-  if (slotFromTop >= Bit(24)) {
+  if (slotFromTop >= Bit(24)) {MOZ_RELEASE_ASSERT(0);
     reportError(nullptr, JSMSG_TOO_MANY_LOCALS);
     return false;
   }
@@ -560,7 +560,7 @@ bool BytecodeEmitter::updateLineNumberNo
 
   ErrorReporter* er = &parser->errorReporter();
   bool onThisLine;
-  if (!er->isOnThisLine(offset, bytecodeSection().currentLine(), &onThisLine)) {
+  if (!er->isOnThisLine(offset, bytecodeSection().currentLine(), &onThisLine)) {MOZ_RELEASE_ASSERT(0);
     er->errorNoOffset(JSMSG_OUT_OF_MEMORY);
     return false;
   }
@@ -588,7 +588,7 @@ bool BytecodeEmitter::updateLineNumberNo
     bytecodeSection().setCurrentLine(line, offset);
     if (delta >= SrcNote::SetLine::lengthFor(line, initialLine)) {
       if (!newSrcNote2(SrcNoteType::SetLine,
-                       SrcNote::SetLine::toOperand(line, initialLine))) {
+                       SrcNote::SetLine::toOperand(line, initialLine))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -606,7 +606,7 @@ bool BytecodeEmitter::updateLineNumberNo
 
 /* Updates the line number and column number information in the source notes. */
 bool BytecodeEmitter::updateSourceCoordNotes(uint32_t offset) {
-  if (!updateLineNumberNotes(offset)) {
+  if (!updateLineNumberNotes(offset)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -636,7 +636,7 @@ bool BytecodeEmitter::updateSourceCoordN
 }
 
 Maybe<uint32_t> BytecodeEmitter::getOffsetForLoop(ParseNode* nextpn) {
-  if (!nextpn) {
+  if (!nextpn) {MOZ_RELEASE_ASSERT(0);
     return Nothing();
   }
 
@@ -727,7 +727,7 @@ class NonLocalExitControl {
 };
 
 bool NonLocalExitControl::leaveScope(EmitterScope* es) {
-  if (!es->leave(bce_, /* nonLocal = */ true)) {
+  if (!es->leave(bce_, /* nonLocal = */ true)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -785,7 +785,7 @@ bool NonLocalExitControl::prepareForNonL
     // may emit administrative ops like JSOp::PopLexicalEnv but never anything
     // that manipulates the stack.
     for (; es != control->emitterScope(); es = es->enclosingInFrame()) {
-      if (!leaveScope(es)) {
+      if (!leaveScope(es)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -851,7 +851,7 @@ bool NonLocalExitControl::prepareForNonL
     }
   }
 
-  if (!flushPops(bce_)) {
+  if (!flushPops(bce_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -860,11 +860,11 @@ bool NonLocalExitControl::prepareForNonL
     ForOfLoopControl& loopinfo = target->as<ForOfLoopControl>();
     if (!loopinfo.emitPrepareForNonLocalJumpFromScope(bce_, *es,
                                                       /* isTarget = */ true,
-                                                      &tryNoteStart)) {
+                                                      &tryNoteStart)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... UNDEF UNDEF UNDEF
       return false;
     }
-    if (!forOfIterCloseScopeStarts.append(tryNoteStart)) {
+    if (!forOfIterCloseScopeStarts.append(tryNoteStart)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -872,7 +872,7 @@ bool NonLocalExitControl::prepareForNonL
   EmitterScope* targetEmitterScope =
       target ? target->emitterScope() : bce_->varEmitterScope;
   for (; es != targetEmitterScope; es = es->enclosingInFrame()) {
-    if (!leaveScope(es)) {
+    if (!leaveScope(es)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1043,7 +1043,7 @@ JSOp BytecodeEmitter::strictifySetNameOp
 }
 
 bool BytecodeEmitter::checkSideEffects(ParseNode* pn, bool* answer) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1302,14 +1302,14 @@ restart:
     case ParseNodeKind::PropertyDefinition:
     case ParseNodeKind::Case: {
       BinaryNode* node = &pn->as<BinaryNode>();
-      if (!checkSideEffects(node->left(), answer)) {
+      if (!checkSideEffects(node->left(), answer)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (*answer) {
         return true;
       }
       return checkSideEffects(node->right(), answer);
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // More getters.
     case ParseNodeKind::OptionalElemExpr:
@@ -1360,23 +1360,23 @@ restart:
     case ParseNodeKind::IfStmt:
     case ParseNodeKind::ConditionalExpr: {
       TernaryNode* node = &pn->as<TernaryNode>();
-      if (!checkSideEffects(node->kid1(), answer)) {
+      if (!checkSideEffects(node->kid1(), answer)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (*answer) {
         return true;
       }
-      if (!checkSideEffects(node->kid2(), answer)) {
+      if (!checkSideEffects(node->kid2(), answer)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (*answer) {
         return true;
       }
-      if ((pn = node->kid3())) {
+      if ((pn = node->kid3())) {MOZ_RELEASE_ASSERT(0);
         goto restart;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       return true;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Function calls can invoke non-local code.
     case ParseNodeKind::NewExpr:
@@ -1456,51 +1456,51 @@ restart:
       *answer = false;
       return true;
 
-    case ParseNodeKind::TryStmt: {
+    case ParseNodeKind::TryStmt: {MOZ_RELEASE_ASSERT(0);
       TryNode* tryNode = &pn->as<TryNode>();
-      if (!checkSideEffects(tryNode->body(), answer)) {
-        return false;
-      }
-      if (*answer) {
+      if (!checkSideEffects(tryNode->body(), answer)) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }
+      if (*answer) {MOZ_RELEASE_ASSERT(0);
         return true;
       }
-      if (LexicalScopeNode* catchScope = tryNode->catchScope()) {
-        if (!checkSideEffects(catchScope, answer)) {
+      if (LexicalScopeNode* catchScope = tryNode->catchScope()) {MOZ_RELEASE_ASSERT(0);
+        if (!checkSideEffects(catchScope, answer)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
-        if (*answer) {
+        if (*answer) {MOZ_RELEASE_ASSERT(0);
           return true;
-        }
-      }
-      if (ParseNode* finallyBlock = tryNode->finallyBlock()) {
-        if (!checkSideEffects(finallyBlock, answer)) {
+        }MOZ_RELEASE_ASSERT(0);
+      }
+      if (ParseNode* finallyBlock = tryNode->finallyBlock()) {MOZ_RELEASE_ASSERT(0);
+        if (!checkSideEffects(finallyBlock, answer)) {MOZ_RELEASE_ASSERT(0);
           return false;
-        }
-      }
+        }MOZ_RELEASE_ASSERT(0);
+      }MOZ_RELEASE_ASSERT(0);
       return true;
     }
 
-    case ParseNodeKind::Catch: {
+    case ParseNodeKind::Catch: {MOZ_RELEASE_ASSERT(0);
       BinaryNode* catchClause = &pn->as<BinaryNode>();
-      if (ParseNode* name = catchClause->left()) {
-        if (!checkSideEffects(name, answer)) {
+      if (ParseNode* name = catchClause->left()) {MOZ_RELEASE_ASSERT(0);
+        if (!checkSideEffects(name, answer)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
-        if (*answer) {
+        if (*answer) {MOZ_RELEASE_ASSERT(0);
           return true;
-        }
-      }
+        }MOZ_RELEASE_ASSERT(0);
+      }MOZ_RELEASE_ASSERT(0);
       return checkSideEffects(catchClause->right(), answer);
     }
 
-    case ParseNodeKind::SwitchStmt: {
+    case ParseNodeKind::SwitchStmt: {MOZ_RELEASE_ASSERT(0);
       SwitchStatement* switchStmt = &pn->as<SwitchStatement>();
-      if (!checkSideEffects(&switchStmt->discriminant(), answer)) {
-        return false;
-      }
+      if (!checkSideEffects(&switchStmt->discriminant(), answer)) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }MOZ_RELEASE_ASSERT(0);
       return *answer ||
              checkSideEffects(&switchStmt->lexicalForCaseList(), answer);
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     case ParseNodeKind::LabelStmt:
       return checkSideEffects(pn->as<LabeledStatement>().statement(), answer);
@@ -1677,20 +1677,20 @@ void BytecodeEmitter::reportError(const 
 
 bool BytecodeEmitter::addObjLiteralData(ObjLiteralWriter& writer,
                                         GCThingIndex* outIndex) {
-  if (!writer.checkForDuplicatedNames(cx)) {
+  if (!writer.checkForDuplicatedNames(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   size_t len = writer.getCode().size();
   auto* code = compilationState.alloc.newArrayUninitialized<uint8_t>(len);
-  if (!code) {
+  if (!code) {MOZ_RELEASE_ASSERT(0);
     js::ReportOutOfMemory(cx);
     return false;
   }
   memcpy(code, writer.getCode().data(), len);
 
   ObjLiteralIndex objIndex(compilationState.objLiteralData.length());
-  if (uint32_t(objIndex) >= TaggedScriptThingIndex::IndexLimit) {
+  if (uint32_t(objIndex) >= TaggedScriptThingIndex::IndexLimit) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return false;
   }
@@ -1711,7 +1711,7 @@ bool BytecodeEmitter::iteratorResultShap
 
   writer.setPropNameNoDuplicateCheck(parserAtoms(),
                                      TaggedParserAtomIndex::WellKnown::value());
-  if (!writer.propWithUndefinedValue(cx)) {
+  if (!writer.propWithUndefinedValue(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   writer.setPropNameNoDuplicateCheck(parserAtoms(),
@@ -1732,10 +1732,10 @@ bool BytecodeEmitter::emitPrepareIterato
 }
 
 bool BytecodeEmitter::emitFinishIteratorResult(bool done) {
-  if (!emitAtomOp(JSOp::InitProp, TaggedParserAtomIndex::WellKnown::value())) {
-    return false;
-  }
-  if (!emit1(done ? JSOp::True : JSOp::False)) {
+  if (!emitAtomOp(JSOp::InitProp, TaggedParserAtomIndex::WellKnown::value())) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!emit1(done ? JSOp::True : JSOp::False)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!emitAtomOp(JSOp::InitProp, TaggedParserAtomIndex::WellKnown::done())) {
@@ -1794,7 +1794,7 @@ bool BytecodeEmitter::emitTDZCheckIfNeed
 
   Maybe<MaybeCheckTDZ> check =
       innermostTDZCheckCache->needsTDZCheck(this, name);
-  if (!check) {
+  if (!check) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1806,11 +1806,11 @@ bool BytecodeEmitter::emitTDZCheckIfNeed
   // If the value is not on the stack, we have to load it first.
   if (isOnStack == ValueIsOnStack::No) {
     if (loc.kind() == NameLocation::Kind::FrameSlot) {
-      if (!emitLocalOp(JSOp::GetLocal, loc.frameSlot())) {
+      if (!emitLocalOp(JSOp::GetLocal, loc.frameSlot())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
-      if (!emitEnvCoordOp(JSOp::GetAliasedVar, loc.environmentCoordinate())) {
+      if (!emitEnvCoordOp(JSOp::GetAliasedVar, loc.environmentCoordinate())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1818,12 +1818,12 @@ bool BytecodeEmitter::emitTDZCheckIfNeed
 
   // Emit the lexical check.
   if (loc.kind() == NameLocation::Kind::FrameSlot) {
-    if (!emitLocalOp(JSOp::CheckLexical, loc.frameSlot())) {
+    if (!emitLocalOp(JSOp::CheckLexical, loc.frameSlot())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
     if (!emitEnvCoordOp(JSOp::CheckAliasedLexical,
-                        loc.environmentCoordinate())) {
+                        loc.environmentCoordinate())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1867,14 +1867,14 @@ bool BytecodeEmitter::emitPropLHS(Proper
   }
 
   // pndown is a primary expression, not a dotted property reference.
-  if (!emitTree(pndown)) {
+  if (!emitTree(pndown)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   while (true) {
     // Walk back up the list, emitting annotated name ops.
     if (!emitAtomOp(JSOp::GetProp, pndot->key().atom(),
-                    ShouldInstrument::Yes)) {
+                    ShouldInstrument::Yes)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1904,17 +1904,17 @@ bool BytecodeEmitter::emitPropIncDec(Una
           ? PropOpEmitter::Kind::PostDecrement
           : PropOpEmitter::Kind::PreDecrement,
       isSuper ? PropOpEmitter::ObjKind::Super : PropOpEmitter::ObjKind::Other);
-  if (!poe.prepareForObj()) {
+  if (!poe.prepareForObj()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (isSuper) {
     UnaryNode* base = &prop->expression().as<UnaryNode>();
-    if (!emitGetThisForSuperBase(base)) {
+    if (!emitGetThisForSuperBase(base)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] THIS
       return false;
     }
   } else {
-    if (!emitPropLHS(prop)) {
+    if (!emitPropLHS(prop)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] OBJ
       return false;
     }
@@ -1951,7 +1951,7 @@ bool BytecodeEmitter::emitElemOpBase(JSO
                                      ShouldInstrument shouldInstrument) {
   GCThingIndex unused;
   if (shouldInstrument != ShouldInstrument::No &&
-      !emitInstrumentationForOpcode(op, unused)) {
+      !emitInstrumentationForOpcode(op, unused)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1965,20 +1965,20 @@ bool BytecodeEmitter::emitElemOpBase(JSO
 bool BytecodeEmitter::emitElemObjAndKey(PropertyByValue* elem, bool isSuper,
                                         ElemOpEmitter& eoe) {
   if (isSuper) {
-    if (!eoe.prepareForObj()) {
+    if (!eoe.prepareForObj()) {MOZ_RELEASE_ASSERT(0);
       //            [stack]
       return false;
     }
     UnaryNode* base = &elem->expression().as<UnaryNode>();
-    if (!emitGetThisForSuperBase(base)) {
+    if (!emitGetThisForSuperBase(base)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] THIS
       return false;
     }
-    if (!eoe.prepareForKey()) {
+    if (!eoe.prepareForKey()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] THIS
       return false;
     }
-    if (!emitTree(&elem->key())) {
+    if (!emitTree(&elem->key())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] THIS KEY
       return false;
     }
@@ -1986,15 +1986,15 @@ bool BytecodeEmitter::emitElemObjAndKey(
     return true;
   }
 
-  if (!eoe.prepareForObj()) {
+  if (!eoe.prepareForObj()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
-  if (!emitTree(&elem->expression())) {
+  if (!emitTree(&elem->expression())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ
     return false;
   }
-  if (!eoe.prepareForKey()) {
+  if (!eoe.prepareForKey()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ? OBJ
     return false;
   }
@@ -2022,7 +2022,7 @@ bool BytecodeEmitter::emitElemIncDec(Una
           : ElemOpEmitter::Kind::PreDecrement,
       isSuper ? ElemOpEmitter::ObjKind::Super : ElemOpEmitter::ObjKind::Other,
       isPrivate ? NameVisibility::Private : NameVisibility::Public);
-  if (!emitElemObjAndKey(elemExpr, isSuper, eoe)) {
+  if (!emitElemObjAndKey(elemExpr, isSuper, eoe)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] # if Super
     //              [stack] THIS KEY
     //              [stack] # otherwise
@@ -2045,7 +2045,7 @@ bool BytecodeEmitter::emitCallIncDec(Una
 
   ParseNode* call = incDec->kid();
   MOZ_ASSERT(call->isKind(ParseNodeKind::CallExpr));
-  if (!emitTree(call)) {
+  if (!emitTree(call)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] CALLRESULT
     return false;
   }
@@ -2087,12 +2087,12 @@ bool BytecodeEmitter::emitNumberOp(doubl
 
     uint32_t u = uint32_t(ival);
     if (u < Bit(16)) {
-      if (!emitUint16Operand(JSOp::Uint16, u)) {
+      if (!emitUint16Operand(JSOp::Uint16, u)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (u < Bit(24)) {
       BytecodeOffset off;
-      if (!emitN(JSOp::Uint24, 3, &off)) {
+      if (!emitN(JSOp::Uint24, 3, &off)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       SET_UINT24(bytecodeSection().code(off), u);
@@ -2121,14 +2121,14 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
   MOZ_ASSERT(cases->isKind(ParseNodeKind::StatementList));
 
   SwitchEmitter se(this);
-  if (!se.emitDiscriminant(Some(switchStmt->discriminant().pn_pos.begin))) {
-    return false;
-  }
-
-  if (!markStepBreakpoint()) {
-    return false;
-  }
-  if (!emitTree(&switchStmt->discriminant())) {
+  if (!se.emitDiscriminant(Some(switchStmt->discriminant().pn_pos.begin))) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!markStepBreakpoint()) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!emitTree(&switchStmt->discriminant())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2136,7 +2136,7 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
   // breaks are under this scope.
 
   if (!lexical.isEmptyScope()) {
-    if (!se.emitLexical(lexical.scopeBindings())) {
+    if (!se.emitLexical(lexical.scopeBindings())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2148,7 +2148,7 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
         CaseClause* caseClause = &item->as<CaseClause>();
         ListNode* statements = caseClause->statementList();
         if (statements->hasTopLevelFunctionDeclarations()) {
-          if (!emitHoistedFunctionsInList(statements)) {
+          if (!emitHoistedFunctionsInList(statements)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -2182,7 +2182,7 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
         break;
       }
 
-      if (!tableGen.addNumber(i)) {
+      if (!tableGen.addNumber(i)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2196,11 +2196,11 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
 
   bool isTableSwitch = tableGen.isValid();
   if (isTableSwitch) {
-    if (!se.emitTable(tableGen)) {
+    if (!se.emitTable(tableGen)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
-    if (!se.emitCond()) {
+    if (!se.emitCond()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2211,7 +2211,7 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
         continue;
       }
 
-      if (!se.prepareForCaseValue()) {
+      if (!se.prepareForCaseValue()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -2220,11 +2220,11 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
       // that debugging works more naturally.
       if (!emitTree(
               caseValue, ValueUsage::WantValue,
-              caseValue->isLiteral() ? SUPPRESS_LINENOTE : EMIT_LINENOTE)) {
-        return false;
-      }
-
-      if (!se.emitCaseJump()) {
+              caseValue->isLiteral() ? SUPPRESS_LINENOTE : EMIT_LINENOTE)) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }
+
+      if (!se.emitCaseJump()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2234,7 +2234,7 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
   for (ParseNode* item : cases->contents()) {
     CaseClause* caseClause = &item->as<CaseClause>();
     if (caseClause->isDefault()) {
-      if (!se.emitDefaultBody()) {
+      if (!se.emitDefaultBody()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -2252,17 +2252,17 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
 #endif
         int32_t i = int32_t(literal->value());
 
-        if (!se.emitCaseBody(i, tableGen)) {
+        if (!se.emitCaseBody(i, tableGen)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
-        if (!se.emitCaseBody()) {
+        if (!se.emitCaseBody()) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
     }
 
-    if (!emitTree(caseClause->statementList())) {
+    if (!emitTree(caseClause->statementList())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2302,7 +2302,7 @@ bool BytecodeEmitter::allocateResumeInde
 
   for (size_t i = 0, len = offsets.size(); i < len; i++) {
     uint32_t resumeIndex;
-    if (!allocateResumeIndex(offsets[i], &resumeIndex)) {
+    if (!allocateResumeIndex(offsets[i], &resumeIndex)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (i == 0) {
@@ -2315,7 +2315,7 @@ bool BytecodeEmitter::allocateResumeInde
 
 bool BytecodeEmitter::emitYieldOp(JSOp op) {
   // All yield operations pop or suspend the current frame.
-  if (!emitInstrumentation(InstrumentationKind::Exit)) {
+  if (!emitInstrumentation(InstrumentationKind::Exit)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2327,7 +2327,7 @@ bool BytecodeEmitter::emitYieldOp(JSOp o
              op == JSOp::Await);
 
   BytecodeOffset off;
-  if (!emitN(op, 3, &off)) {
+  if (!emitN(op, 3, &off)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2336,7 +2336,7 @@ bool BytecodeEmitter::emitYieldOp(JSOp o
   }
 
   uint32_t resumeIndex;
-  if (!allocateResumeIndex(bytecodeSection().offset(), &resumeIndex)) {
+  if (!allocateResumeIndex(bytecodeSection().offset(), &resumeIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2374,19 +2374,19 @@ bool BytecodeEmitter::emitSetThis(Binary
     uint8_t hops = AssertedCast<uint8_t>(coord.hops());
     lexicalLoc = NameLocation::EnvironmentCoordinate(BindingKind::Let, hops,
                                                      coord.slot());
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(loc.kind() == NameLocation::Kind::Dynamic);
     lexicalLoc = loc;
   }
 
   NameOpEmitter noe(this, name, lexicalLoc, NameOpEmitter::Kind::Initialize);
-  if (!noe.prepareForRhs()) {
+  if (!noe.prepareForRhs()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
   // Emit the new |this| value.
-  if (!emitTree(setThisNode->right())) {
+  if (!emitTree(setThisNode->right())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEWTHIS
     return false;
   }
@@ -2394,19 +2394,19 @@ bool BytecodeEmitter::emitSetThis(Binary
   // Get the original |this| and throw if we already initialized
   // it. Do *not* use the NameLocation argument, as that's the special
   // lexical location below to deal with super() semantics.
-  if (!emitGetName(name)) {
+  if (!emitGetName(name)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEWTHIS THIS
     return false;
   }
-  if (!emit1(JSOp::CheckThisReinit)) {
+  if (!emit1(JSOp::CheckThisReinit)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEWTHIS THIS
     return false;
   }
-  if (!emit1(JSOp::Pop)) {
+  if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEWTHIS
     return false;
   }
-  if (!noe.emitAssignment()) {
+  if (!noe.emitAssignment()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEWTHIS
     return false;
   }
@@ -2517,7 +2517,7 @@ bool BytecodeEmitter::emitScript(ParseNo
   EmitterScope emitterScope(this);
   Maybe<AsyncEmitter> topLevelAwait;
   if (sc->isGlobalContext()) {
-    if (!emitterScope.enterGlobal(this, sc->asGlobalContext())) {
+    if (!emitterScope.enterGlobal(this, sc->asGlobalContext())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else if (sc->isEvalContext()) {
@@ -2526,7 +2526,7 @@ bool BytecodeEmitter::emitScript(ParseNo
     }
   } else {
     MOZ_ASSERT(sc->isModuleContext());
-    if (!emitterScope.enterModule(this, sc->asModuleContext())) {
+    if (!emitterScope.enterModule(this, sc->asModuleContext())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (sc->asModuleContext()->isAsync()) {
@@ -2551,28 +2551,28 @@ bool BytecodeEmitter::emitScript(ParseNo
     LexicalScopeNode* scope = &body->as<LexicalScopeNode>();
 
     if (!lexicalEmitterScope.enterLexical(this, ScopeKind::Lexical,
-                                          scope->scopeBindings())) {
-      return false;
-    }
-
-    if (!emitDeclarationInstantiation(scope->scopeBody())) {
-      return false;
-    }
-
-    if (!switchToMain()) {
+                                          scope->scopeBindings())) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+
+    if (!emitDeclarationInstantiation(scope->scopeBody())) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+
+    if (!switchToMain()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     ParseNode* scopeBody = scope->scopeBody();
-    if (!emitLexicalScopeBody(scopeBody, EMIT_LINENOTE)) {
-      return false;
-    }
-
-    if (!updateSourceCoordNotes(scopeBody->pn_pos.end)) {
-      return false;
-    }
-
-    if (!lexicalEmitterScope.leave(this)) {
+    if (!emitLexicalScopeBody(scopeBody, EMIT_LINENOTE)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+
+    if (!updateSourceCoordNotes(scopeBody->pn_pos.end)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+
+    if (!lexicalEmitterScope.leave(this)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -2580,17 +2580,17 @@ bool BytecodeEmitter::emitScript(ParseNo
       return false;
     }
     if (topLevelAwait) {
-      if (!topLevelAwait->prepareForModule()) {
-        return false;
-      }
-    }
-
-    if (!switchToMain()) {
+      if (!topLevelAwait->prepareForModule()) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }
+    }
+
+    if (!switchToMain()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (topLevelAwait) {
-      if (!topLevelAwait->prepareForBody()) {
+      if (!topLevelAwait->prepareForBody()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2600,26 +2600,26 @@ bool BytecodeEmitter::emitScript(ParseNo
       return false;
     }
 
-    if (!updateSourceCoordNotes(body->pn_pos.end)) {
+    if (!updateSourceCoordNotes(body->pn_pos.end)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   if (topLevelAwait) {
-    if (!topLevelAwait->emitEnd()) {
-      return false;
-    }
-  }
-
-  if (!markSimpleBreakpoint()) {
-    return false;
-  }
-
-  if (!emitReturnRval()) {
-    return false;
-  }
-
-  if (!emitterScope.leave(this)) {
+    if (!topLevelAwait->emitEnd()) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+  }
+
+  if (!markSimpleBreakpoint()) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!emitReturnRval()) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!emitterScope.leave(this)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2680,12 +2680,12 @@ bool BytecodeEmitter::emitFunctionScript
     return false;
   }
 
-  if (!emitFunctionFormalParameters(paramsBody)) {
+  if (!emitFunctionFormalParameters(paramsBody)) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
-  if (!fse.prepareForBody()) {
+  if (!fse.prepareForBody()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
@@ -2695,7 +2695,7 @@ bool BytecodeEmitter::emitFunctionScript
     return false;
   }
 
-  if (!fse.emitEndBody()) {
+  if (!fse.emitEndBody()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
@@ -2715,7 +2715,7 @@ bool BytecodeEmitter::emitDestructuringL
 
   if (target->isKind(ParseNodeKind::Spread)) {
     target = target->as<UnaryNode>().kid();
-  } else if (target->isKind(ParseNodeKind::AssignExpr)) {
+  } else if (target->isKind(ParseNodeKind::AssignExpr)) {MOZ_RELEASE_ASSERT(0);
     target = target->as<AssignmentNode>().left();
   }
 
@@ -2829,12 +2829,12 @@ bool BytecodeEmitter::emitSetOrInitializ
   }
   if (target->isKind(ParseNodeKind::ArrayExpr) ||
       target->isKind(ParseNodeKind::ObjectExpr)) {
-    if (!emitDestructuringOps(&target->as<ListNode>(), flav)) {
+    if (!emitDestructuringOps(&target->as<ListNode>(), flav)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     // Per its post-condition, emitDestructuringOps has left the
     // to-be-destructured value on top of the stack.
-    if (!emit1(JSOp::Pop)) {
+    if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -2968,13 +2968,13 @@ bool BytecodeEmitter::emitIteratorNext(
   //                [stack] ... NEXT ITER
   MOZ_ASSERT(bytecodeSection().stackDepth() >= 2);
 
-  if (!emitCall(JSOp::Call, 0, callSourceCoordOffset)) {
+  if (!emitCall(JSOp::Call, 0, callSourceCoordOffset)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... RESULT
     return false;
   }
 
   if (iterKind == IteratorKind::Async) {
-    if (!emitAwaitInInnermostScope()) {
+    if (!emitAwaitInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... RESULT
       return false;
     }
@@ -2991,38 +2991,38 @@ bool BytecodeEmitter::emitPushNotUndefin
   //                [stack] V
   MOZ_ASSERT(bytecodeSection().stackDepth() > 0);
 
-  if (!emit1(JSOp::Dup)) {
+  if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] V V
     return false;
   }
-  if (!emit1(JSOp::Undefined)) {
+  if (!emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] V V UNDEFINED
     return false;
   }
-  if (!emit1(JSOp::StrictNe)) {
+  if (!emit1(JSOp::StrictNe)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] V NEQ
     return false;
   }
 
   JumpList undefinedOrNullJump;
-  if (!emitJump(JSOp::And, &undefinedOrNullJump)) {
+  if (!emitJump(JSOp::And, &undefinedOrNullJump)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] V NEQ
     return false;
   }
 
-  if (!emit1(JSOp::Pop)) {
+  if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] V
     return false;
   }
-  if (!emit1(JSOp::Dup)) {
+  if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] V V
     return false;
   }
-  if (!emit1(JSOp::Null)) {
+  if (!emit1(JSOp::Null)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] V V NULL
     return false;
   }
-  if (!emit1(JSOp::StrictNe)) {
+  if (!emit1(JSOp::StrictNe)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] V NEQ
     return false;
   }
@@ -3074,13 +3074,13 @@ bool BytecodeEmitter::emitIteratorCloseI
     tryCatch.emplace(this, TryEmitter::Kind::TryCatch,
                      TryEmitter::ControlKind::NonSyntactic);
 
-    if (!tryCatch->emitTry()) {
+    if (!tryCatch->emitTry()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... ITER
       return false;
     }
   }
 
-  if (!emit1(JSOp::Dup)) {
+  if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... ITER ITER
     return false;
   }
@@ -3090,7 +3090,7 @@ bool BytecodeEmitter::emitIteratorCloseI
   // Step 4.
   //
   // Get the "return" method.
-  if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::return_())) {
+  if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::return_())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... ITER RET
     return false;
   }
@@ -3099,12 +3099,12 @@ bool BytecodeEmitter::emitIteratorCloseI
   //
   // Do nothing if "return" is undefined or null.
   InternalIfEmitter ifReturnMethodIsDefined(this);
-  if (!emitPushNotUndefinedOrNull()) {
+  if (!emitPushNotUndefinedOrNull()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... ITER RET NOT-UNDEF-OR-NULL
     return false;
   }
 
-  if (!ifReturnMethodIsDefined.emitThenElse()) {
+  if (!ifReturnMethodIsDefined.emitThenElse()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... ITER RET
     return false;
   }
@@ -3112,12 +3112,12 @@ bool BytecodeEmitter::emitIteratorCloseI
   // Steps 5.c, 7.
   //
   // Call the "return" method.
-  if (!emit1(JSOp::Swap)) {
+  if (!emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... RET ITER
     return false;
   }
 
-  if (!emitCall(JSOp::Call, 0)) {
+  if (!emitCall(JSOp::Call, 0)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... RESULT
     return false;
   }
@@ -3126,27 +3126,27 @@ bool BytecodeEmitter::emitIteratorCloseI
   if (iterKind == IteratorKind::Async) {
     if (completionKind != CompletionKind::Throw) {
       // Await clobbers rval, so save the current rval.
-      if (!emit1(JSOp::GetRval)) {
+      if (!emit1(JSOp::GetRval)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... RESULT RVAL
         return false;
       }
-      if (!emit1(JSOp::Swap)) {
+      if (!emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... RVAL RESULT
         return false;
       }
     }
 
-    if (!emitAwaitInScope(currentScope)) {
+    if (!emitAwaitInScope(currentScope)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... RVAL? RESULT
       return false;
     }
 
     if (completionKind != CompletionKind::Throw) {
-      if (!emit1(JSOp::Swap)) {
+      if (!emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... RESULT RVAL
         return false;
       }
-      if (!emit1(JSOp::SetRval)) {
+      if (!emit1(JSOp::SetRval)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... RESULT
         return false;
       }
@@ -3158,34 +3158,34 @@ bool BytecodeEmitter::emitIteratorCloseI
   // Step 8.
   if (completionKind != CompletionKind::Throw) {
     // Check that the "return" result is an object.
-    if (!emitCheckIsObj(CheckIsObjectKind::IteratorReturn)) {
+    if (!emitCheckIsObj(CheckIsObjectKind::IteratorReturn)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... RESULT
       return false;
     }
   }
 
-  if (!ifReturnMethodIsDefined.emitElse()) {
+  if (!ifReturnMethodIsDefined.emitElse()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... ITER RET
     return false;
   }
 
-  if (!emit1(JSOp::Pop)) {
+  if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... ITER
     return false;
   }
 
-  if (!ifReturnMethodIsDefined.emitEnd()) {
+  if (!ifReturnMethodIsDefined.emitEnd()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (completionKind == CompletionKind::Throw) {
-    if (!tryCatch->emitCatch()) {
+    if (!tryCatch->emitCatch()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... ITER EXC
       return false;
     }
 
     // Just ignore the exception thrown by call and await.
-    if (!emit1(JSOp::Pop)) {
+    if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... ITER
       return false;
     }
@@ -3212,12 +3212,12 @@ bool BytecodeEmitter::wrapWithDestructur
   // corresponding to the pc *before* the start, in case the first bytecode
   // emitted by |emitter| is the start of an inner scope. See comment above
   // UnwindEnvironmentToTryPc.
-  if (!emit1(JSOp::TryDestructuring)) {
+  if (!emit1(JSOp::TryDestructuring)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   BytecodeOffset start = bytecodeSection().offset();
-  if (!emitter(this)) {
+  if (!emitter(this)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   BytecodeOffset end = bytecodeSection().offset();
@@ -3231,11 +3231,11 @@ bool BytecodeEmitter::emitDefault(ParseN
   //                [stack] VALUE
 
   DefaultEmitter de(this);
-  if (!de.prepareForDefault()) {
+  if (!de.prepareForDefault()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
-  if (!emitInitializer(defaultExpr, pattern)) {
+  if (!emitInitializer(defaultExpr, pattern)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] DEFAULTVALUE
     return false;
   }
@@ -3270,11 +3270,11 @@ bool BytecodeEmitter::emitAnonymousFunct
   MOZ_ASSERT(node->isDirectRHSAnonFunction());
 
   if (node->is<FunctionNode>()) {
-    if (!emitTree(node)) {
+    if (!emitTree(node)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NAME FUN
       return false;
     }
-    if (!emitDupAt(1)) {
+    if (!emitDupAt(1)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NAME FUN NAME
       return false;
     }
@@ -3312,7 +3312,7 @@ bool BytecodeEmitter::emitInitializer(Pa
   if (initializer->isDirectRHSAnonFunction()) {
     MOZ_ASSERT(!pattern->isInParens());
     auto name = pattern->as<NameNode>().name();
-    if (!emitAnonymousFunctionWithName(initializer, name)) {
+    if (!emitAnonymousFunctionWithName(initializer, name)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -3417,11 +3417,11 @@ bool BytecodeEmitter::emitDestructuringO
 
   // Use an iterator to destructure the RHS, instead of index lookup. We
   // must leave the *original* value on the stack.
-  if (!emit1(JSOp::Dup)) {
+  if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... OBJ OBJ
     return false;
   }
-  if (!emitIterator()) {
+  if (!emitIterator()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... OBJ NEXT ITER
     return false;
   }
@@ -3429,11 +3429,11 @@ bool BytecodeEmitter::emitDestructuringO
   // For an empty pattern [], call IteratorClose unconditionally. Nothing
   // else needs to be done.
   if (!pattern->head()) {
-    if (!emit1(JSOp::Swap)) {
+    if (!emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... OBJ ITER NEXT
       return false;
     }
-    if (!emit1(JSOp::Pop)) {
+    if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... OBJ ITER
       return false;
     }
@@ -3443,7 +3443,7 @@ bool BytecodeEmitter::emitDestructuringO
   }
 
   // Push an initial FALSE value for DONE.
-  if (!emit1(JSOp::False)) {
+  if (!emit1(JSOp::False)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... OBJ NEXT ITER FALSE
     return false;
   }
@@ -3471,14 +3471,14 @@ bool BytecodeEmitter::emitDestructuringO
         return bce->emitDestructuringLHSRef(lhsPattern, &emitted);
         //          [stack] ... OBJ NEXT ITER DONE LREF*
       };
-      if (!wrapWithDestructuringTryNote(tryNoteDepth, emitLHSRef)) {
+      if (!wrapWithDestructuringTryNote(tryNoteDepth, emitLHSRef)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
 
     // Pick the DONE value to the top of the stack.
     if (emitted) {
-      if (!emitPickN(emitted)) {
+      if (!emitPickN(emitted)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... OBJ NEXT ITER LREF* DONE
         return false;
       }
@@ -3489,7 +3489,7 @@ bool BytecodeEmitter::emitDestructuringO
       //
       // Non-first elements should emit if-else depending on the
       // member pattern, below.
-      if (!emit1(JSOp::Pop)) {
+      if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... OBJ NEXT ITER LREF*
         return false;
       }
@@ -3502,16 +3502,16 @@ bool BytecodeEmitter::emitDestructuringO
         // iterator can already be completed.
         //          [stack] ... OBJ NEXT ITER LREF* DONE
 
-        if (!ifThenElse.emitThenElse()) {
+        if (!ifThenElse.emitThenElse()) {MOZ_RELEASE_ASSERT(0);
           //        [stack] ... OBJ NEXT ITER LREF*
           return false;
         }
 
-        if (!emitUint32Operand(JSOp::NewArray, 0)) {
+        if (!emitUint32Operand(JSOp::NewArray, 0)) {MOZ_RELEASE_ASSERT(0);
           //        [stack] ... OBJ NEXT ITER LREF* ARRAY
           return false;
         }
-        if (!ifThenElse.emitElse()) {
+        if (!ifThenElse.emitElse()) {MOZ_RELEASE_ASSERT(0);
           //        [stack] ... OBJ NEXT ITER LREF*
           return false;
         }
@@ -3519,29 +3519,29 @@ bool BytecodeEmitter::emitDestructuringO
 
       // If iterator is not completed, create a new array with the rest
       // of the iterator.
-      if (!emitDupAt(emitted + 1, 2)) {
+      if (!emitDupAt(emitted + 1, 2)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... OBJ NEXT ITER LREF* NEXT
         return false;
       }
-      if (!emitUint32Operand(JSOp::NewArray, 0)) {
+      if (!emitUint32Operand(JSOp::NewArray, 0)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... OBJ NEXT ITER LREF* NEXT ITER ARRAY
         return false;
       }
-      if (!emitNumberOp(0)) {
+      if (!emitNumberOp(0)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... OBJ NEXT ITER LREF* NEXT ITER ARRAY INDEX
         return false;
       }
-      if (!emitSpread()) {
+      if (!emitSpread()) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... OBJ NEXT ITER LREF* ARRAY INDEX
         return false;
       }
-      if (!emit1(JSOp::Pop)) {
+      if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... OBJ NEXT ITER LREF* ARRAY
         return false;
       }
 
       if (!isFirst) {
-        if (!ifThenElse.emitEnd()) {
+        if (!ifThenElse.emitEnd()) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         MOZ_ASSERT(ifThenElse.pushed() == 1);
@@ -3549,11 +3549,11 @@ bool BytecodeEmitter::emitDestructuringO
 
       // At this point the iterator is done. Unpick a TRUE value for DONE above
       // ITER.
-      if (!emit1(JSOp::True)) {
+      if (!emit1(JSOp::True)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... OBJ NEXT ITER LREF* ARRAY TRUE
         return false;
       }
-      if (!emit2(JSOp::Unpick, emitted + 1)) {
+      if (!emit2(JSOp::Unpick, emitted + 1)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... OBJ NEXT ITER TRUE LREF* ARRAY
         return false;
       }
@@ -3562,7 +3562,7 @@ bool BytecodeEmitter::emitDestructuringO
         return bce->emitSetOrInitializeDestructuring(member, flav);
         //          [stack] ... OBJ NEXT ITER TRUE
       };
-      if (!wrapWithDestructuringTryNote(tryNoteDepth, emitAssignment)) {
+      if (!wrapWithDestructuringTryNote(tryNoteDepth, emitAssignment)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -3581,98 +3581,98 @@ bool BytecodeEmitter::emitDestructuringO
     if (!isFirst) {
       //            [stack] ... OBJ NEXT ITER LREF* DONE
 
-      if (!ifAlreadyDone.emitThenElse()) {
+      if (!ifAlreadyDone.emitThenElse()) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... OBJ NEXT ITER LREF*
         return false;
       }
 
-      if (!emit1(JSOp::Undefined)) {
+      if (!emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... OBJ NEXT ITER LREF* UNDEF
         return false;
       }
-      if (!emit1(JSOp::NopDestructuring)) {
+      if (!emit1(JSOp::NopDestructuring)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... OBJ NEXT ITER LREF* UNDEF
         return false;
       }
 
       // The iterator is done. Unpick a TRUE value for DONE above ITER.
-      if (!emit1(JSOp::True)) {
+      if (!emit1(JSOp::True)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... OBJ NEXT ITER LREF* UNDEF TRUE
         return false;
       }
-      if (!emit2(JSOp::Unpick, emitted + 1)) {
+      if (!emit2(JSOp::Unpick, emitted + 1)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... OBJ NEXT ITER TRUE LREF* UNDEF
         return false;
       }
 
-      if (!ifAlreadyDone.emitElse()) {
+      if (!ifAlreadyDone.emitElse()) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... OBJ NEXT ITER LREF*
         return false;
       }
     }
 
-    if (!emitDupAt(emitted + 1, 2)) {
+    if (!emitDupAt(emitted + 1, 2)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... OBJ NEXT ITER LREF* NEXT
       return false;
     }
-    if (!emitIteratorNext(Some(pattern->pn_pos.begin))) {
+    if (!emitIteratorNext(Some(pattern->pn_pos.begin))) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... OBJ NEXT ITER LREF* RESULT
       return false;
     }
-    if (!emit1(JSOp::Dup)) {
+    if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... OBJ NEXT ITER LREF* RESULT RESULT
       return false;
     }
-    if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::done())) {
+    if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::done())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... OBJ NEXT ITER LREF* RESULT DONE
       return false;
     }
 
-    if (!emit1(JSOp::Dup)) {
+    if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... OBJ NEXT ITER LREF* RESULT DONE DONE
       return false;
     }
-    if (!emit2(JSOp::Unpick, emitted + 2)) {
+    if (!emit2(JSOp::Unpick, emitted + 2)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... OBJ NEXT ITER DONE LREF* RESULT DONE
       return false;
     }
 
     InternalIfEmitter ifDone(this);
-    if (!ifDone.emitThenElse()) {
+    if (!ifDone.emitThenElse()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... OBJ NEXT ITER DONE LREF* RESULT
       return false;
     }
 
-    if (!emit1(JSOp::Pop)) {
+    if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... OBJ NEXT ITER DONE LREF*
       return false;
     }
-    if (!emit1(JSOp::Undefined)) {
+    if (!emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... OBJ NEXT ITER DONE LREF* UNDEF
       return false;
     }
-    if (!emit1(JSOp::NopDestructuring)) {
+    if (!emit1(JSOp::NopDestructuring)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... OBJ NEXT ITER DONE LREF* UNDEF
       return false;
     }
 
-    if (!ifDone.emitElse()) {
+    if (!ifDone.emitElse()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... OBJ NEXT ITER DONE LREF* RESULT
       return false;
     }
 
-    if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::value())) {
+    if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::value())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... OBJ NEXT ITER DONE LREF* VALUE
       return false;
     }
 
-    if (!ifDone.emitEnd()) {
+    if (!ifDone.emitEnd()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     MOZ_ASSERT(ifDone.pushed() == 0);
 
     if (!isFirst) {
-      if (!ifAlreadyDone.emitEnd()) {
+      if (!ifAlreadyDone.emitEnd()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       MOZ_ASSERT(ifAlreadyDone.pushed() == 2);
@@ -3684,7 +3684,7 @@ bool BytecodeEmitter::emitDestructuringO
         //          [stack] ... OBJ NEXT ITER DONE LREF* VALUE
       };
 
-      if (!wrapWithDestructuringTryNote(tryNoteDepth, emitDefault)) {
+      if (!wrapWithDestructuringTryNote(tryNoteDepth, emitDefault)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -3695,11 +3695,11 @@ bool BytecodeEmitter::emitDestructuringO
         //          [stack] ... OBJ NEXT ITER DONE
       };
 
-      if (!wrapWithDestructuringTryNote(tryNoteDepth, emitAssignment)) {
+      if (!wrapWithDestructuringTryNote(tryNoteDepth, emitAssignment)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
-      if (!emit1(JSOp::Pop)) {
+      if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... OBJ NEXT ITER DONE
         return false;
       }
@@ -3711,27 +3711,27 @@ bool BytecodeEmitter::emitDestructuringO
   //                [stack] ... OBJ NEXT ITER DONE
 
   InternalIfEmitter ifDone(this);
-  if (!ifDone.emitThenElse()) {
+  if (!ifDone.emitThenElse()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... OBJ NEXT ITER
     return false;
   }
-  if (!emitPopN(2)) {
+  if (!emitPopN(2)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... OBJ
     return false;
   }
-  if (!ifDone.emitElse()) {
+  if (!ifDone.emitElse()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... OBJ NEXT ITER
     return false;
   }
-  if (!emit1(JSOp::Swap)) {
+  if (!emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... OBJ ITER NEXT
     return false;
   }
-  if (!emit1(JSOp::Pop)) {
+  if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... OBJ ITER
     return false;
   }
-  if (!emitIteratorCloseInInnermostScope()) {
+  if (!emitIteratorCloseInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... OBJ
     return false;
   }
@@ -3754,7 +3754,7 @@ bool BytecodeEmitter::emitDestructuringO
   //                [stack] ... RHS
   MOZ_ASSERT(bytecodeSection().stackDepth() > 0);
 
-  if (!emit1(JSOp::CheckObjCoercible)) {
+  if (!emit1(JSOp::CheckObjCoercible)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... RHS
     return false;
   }
@@ -3762,12 +3762,12 @@ bool BytecodeEmitter::emitDestructuringO
   bool needsRestPropertyExcludedSet =
       pattern->count() > 1 && pattern->last()->isKind(ParseNodeKind::Spread);
   if (needsRestPropertyExcludedSet) {
-    if (!emitDestructuringObjRestExclusionSet(pattern)) {
+    if (!emitDestructuringObjRestExclusionSet(pattern)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... RHS SET
       return false;
     }
 
-    if (!emit1(JSOp::Swap)) {
+    if (!emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... SET RHS
       return false;
     }
@@ -3792,37 +3792,37 @@ bool BytecodeEmitter::emitDestructuringO
     }
 
     size_t emitted;
-    if (!emitDestructuringLHSRef(lhs, &emitted)) {
+    if (!emitDestructuringLHSRef(lhs, &emitted)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... SET? RHS LREF*
       return false;
     }
 
     // Duplicate the value being destructured to use as a reference base.
-    if (!emitDupAt(emitted)) {
+    if (!emitDupAt(emitted)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... SET? RHS LREF* RHS
       return false;
     }
 
     if (member->isKind(ParseNodeKind::Spread)) {
-      if (!updateSourceCoordNotes(member->pn_pos.begin)) {
-        return false;
-      }
-
-      if (!emit1(JSOp::NewInit)) {
+      if (!updateSourceCoordNotes(member->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }
+
+      if (!emit1(JSOp::NewInit)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... SET? RHS LREF* RHS TARGET
         return false;
       }
-      if (!emit1(JSOp::Dup)) {
+      if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... SET? RHS LREF* RHS TARGET TARGET
         return false;
       }
-      if (!emit2(JSOp::Pick, 2)) {
+      if (!emit2(JSOp::Pick, 2)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... SET? RHS LREF* TARGET TARGET RHS
         return false;
       }
 
       if (needsRestPropertyExcludedSet) {
-        if (!emit2(JSOp::Pick, emitted + 4)) {
+        if (!emit2(JSOp::Pick, emitted + 4)) {MOZ_RELEASE_ASSERT(0);
           //        [stack] ... RHS LREF* TARGET TARGET RHS SET
           return false;
         }
@@ -3830,13 +3830,13 @@ bool BytecodeEmitter::emitDestructuringO
 
       CopyOption option = needsRestPropertyExcludedSet ? CopyOption::Filtered
                                                        : CopyOption::Unfiltered;
-      if (!emitCopyDataProperties(option)) {
+      if (!emitCopyDataProperties(option)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... RHS LREF* TARGET
         return false;
       }
 
       // Destructure TARGET per this member's lhs.
-      if (!emitSetOrInitializeDestructuring(lhs, flav)) {
+      if (!emitSetOrInitializeDestructuring(lhs, flav)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... RHS
         return false;
       }
@@ -3852,7 +3852,7 @@ bool BytecodeEmitter::emitDestructuringO
 
     if (member->isKind(ParseNodeKind::MutateProto)) {
       if (!emitAtomOp(JSOp::GetProp,
-                      TaggedParserAtomIndex::WellKnown::proto())) {
+                      TaggedParserAtomIndex::WellKnown::proto())) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... SET? RHS LREF* PROP
         return false;
       }
@@ -3863,48 +3863,48 @@ bool BytecodeEmitter::emitDestructuringO
 
       ParseNode* key = member->as<BinaryNode>().left();
       if (key->isKind(ParseNodeKind::NumberExpr)) {
-        if (!emitNumberOp(key->as<NumericLiteral>().value())) {
+        if (!emitNumberOp(key->as<NumericLiteral>().value())) {MOZ_RELEASE_ASSERT(0);
           //        [stack]... SET? RHS LREF* RHS KEY
           return false;
         }
       } else if (key->isKind(ParseNodeKind::BigIntExpr)) {
-        if (!emitBigIntOp(&key->as<BigIntLiteral>())) {
+        if (!emitBigIntOp(&key->as<BigIntLiteral>())) {MOZ_RELEASE_ASSERT(0);
           //        [stack]... SET? RHS LREF* RHS KEY
           return false;
         }
       } else if (key->isKind(ParseNodeKind::ObjectPropertyName) ||
                  key->isKind(ParseNodeKind::StringExpr)) {
         if (!emitAtomOp(JSOp::GetProp, key->as<NameNode>().atom(),
-                        ShouldInstrument::Yes)) {
+                        ShouldInstrument::Yes)) {MOZ_RELEASE_ASSERT(0);
           //        [stack] ... SET? RHS LREF* PROP
           return false;
         }
         needsGetElem = false;
       } else {
-        if (!emitComputedPropertyName(&key->as<UnaryNode>())) {
+        if (!emitComputedPropertyName(&key->as<UnaryNode>())) {MOZ_RELEASE_ASSERT(0);
           //        [stack] ... SET? RHS LREF* RHS KEY
           return false;
         }
 
         // Add the computed property key to the exclusion set.
         if (needsRestPropertyExcludedSet) {
-          if (!emitDupAt(emitted + 3)) {
+          if (!emitDupAt(emitted + 3)) {MOZ_RELEASE_ASSERT(0);
             //      [stack] ... SET RHS LREF* RHS KEY SET
             return false;
           }
-          if (!emitDupAt(1)) {
+          if (!emitDupAt(1)) {MOZ_RELEASE_ASSERT(0);
             //      [stack] ... SET RHS LREF* RHS KEY SET KEY
             return false;
           }
-          if (!emit1(JSOp::Undefined)) {
+          if (!emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
             //      [stack] ... SET RHS LREF* RHS KEY SET KEY UNDEFINED
             return false;
           }
-          if (!emit1(JSOp::InitElem)) {
+          if (!emit1(JSOp::InitElem)) {MOZ_RELEASE_ASSERT(0);
             //      [stack] ... SET RHS LREF* RHS KEY SET
             return false;
           }
-          if (!emit1(JSOp::Pop)) {
+          if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
             //      [stack] ... SET RHS LREF* RHS KEY
             return false;
           }
@@ -3913,13 +3913,13 @@ bool BytecodeEmitter::emitDestructuringO
     }
 
     // Get the property value if not done already.
-    if (needsGetElem && !emitElemOpBase(JSOp::GetElem)) {
+    if (needsGetElem && !emitElemOpBase(JSOp::GetElem)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... SET? RHS LREF* PROP
       return false;
     }
 
     if (subpattern->isKind(ParseNodeKind::AssignExpr)) {
-      if (!emitDefault(subpattern->as<AssignmentNode>().right(), lhs)) {
+      if (!emitDefault(subpattern->as<AssignmentNode>().right(), lhs)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ... SET? RHS LREF* VALUE
         return false;
       }
@@ -3946,7 +3946,7 @@ static bool IsDestructuringRestExclusion
 
     propCount++;
 
-    if (member->isKind(ParseNodeKind::MutateProto)) {
+    if (member->isKind(ParseNodeKind::MutateProto)) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
@@ -3978,13 +3978,13 @@ bool BytecodeEmitter::emitDestructuringO
 
   // See if we can use ObjLiteral to construct the exclusion set object.
   if (IsDestructuringRestExclusionSetObjLiteralCompatible(pattern)) {
-    if (!emitDestructuringRestExclusionSetObjLiteral(pattern)) {
+    if (!emitDestructuringRestExclusionSetObjLiteral(pattern)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] OBJ
       return false;
     }
   } else {
     // Take the slow but sure way and start off with a blank object.
-    if (!emit1(JSOp::NewInit)) {
+    if (!emit1(JSOp::NewInit)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] OBJ
       return false;
     }
@@ -3998,19 +3998,19 @@ bool BytecodeEmitter::emitDestructuringO
     }
 
     bool isIndex = false;
-    if (member->isKind(ParseNodeKind::MutateProto)) {
+    if (member->isKind(ParseNodeKind::MutateProto)) {MOZ_RELEASE_ASSERT(0);
       pnatom = TaggedParserAtomIndex::WellKnown::proto();
     } else {
       ParseNode* key = member->as<BinaryNode>().left();
       if (key->isKind(ParseNodeKind::NumberExpr)) {
-        if (!emitNumberOp(key->as<NumericLiteral>().value())) {
+        if (!emitNumberOp(key->as<NumericLiteral>().value())) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         isIndex = true;
       } else if (key->isKind(ParseNodeKind::BigIntExpr)) {
-        if (!emitBigIntOp(&key->as<BigIntLiteral>())) {
+        if (!emitBigIntOp(&key->as<BigIntLiteral>())) {MOZ_RELEASE_ASSERT(0);
           return false;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         isIndex = true;
       } else if (key->isKind(ParseNodeKind::ObjectPropertyName) ||
                  key->isKind(ParseNodeKind::StringExpr)) {
@@ -4024,12 +4024,12 @@ bool BytecodeEmitter::emitDestructuringO
     }
 
     // Initialize elements with |undefined|.
-    if (!emit1(JSOp::Undefined)) {
+    if (!emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (isIndex) {
-      if (!emit1(JSOp::InitElem)) {
+      if (!emit1(JSOp::InitElem)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -4067,18 +4067,18 @@ bool BytecodeEmitter::emitTemplateString
 
     if (!isString) {
       // We update source notes before emitting the expression
-      if (!updateSourceCoordNotes(item->pn_pos.begin)) {
-        return false;
-      }
-    }
-
-    if (!emitTree(item)) {
+      if (!updateSourceCoordNotes(item->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }
+    }
+
+    if (!emitTree(item)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (!isString) {
       // We need to convert the expression to a string
-      if (!emit1(JSOp::ToString)) {
+      if (!emit1(JSOp::ToString)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -4086,7 +4086,7 @@ bool BytecodeEmitter::emitTemplateString
     if (pushedString) {
       // We've pushed two strings onto the stack. Add them together, leaving
       // just one.
-      if (!emit1(JSOp::Add)) {
+      if (!emit1(JSOp::Add)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -4121,7 +4121,7 @@ bool BytecodeEmitter::emitDeclarationLis
     if (pattern->isKind(ParseNodeKind::Name)) {
       // initializer can be null here.
       if (!emitSingleDeclaration(declList, &pattern->as<NameNode>(),
-                                 initializer)) {
+                                 initializer)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -4129,18 +4129,18 @@ bool BytecodeEmitter::emitDeclarationLis
                  pattern->isKind(ParseNodeKind::ObjectExpr));
       MOZ_ASSERT(initializer != nullptr);
 
-      if (!updateSourceCoordNotes(initializer->pn_pos.begin)) {
-        return false;
-      }
-      if (!markStepBreakpoint()) {
-        return false;
-      }
-      if (!emitTree(initializer)) {
+      if (!updateSourceCoordNotes(initializer->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }
+      if (!markStepBreakpoint()) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }
+      if (!emitTree(initializer)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       if (!emitDestructuringOps(&pattern->as<ListNode>(),
-                                DestructuringFlavor::Declaration)) {
+                                DestructuringFlavor::Declaration)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -4163,7 +4163,7 @@ bool BytecodeEmitter::emitSingleDeclarat
 
   auto nameAtom = decl->name();
   NameOpEmitter noe(this, nameAtom, NameOpEmitter::Kind::Initialize);
-  if (!noe.prepareForRhs()) {
+  if (!noe.prepareForRhs()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ENV?
     return false;
   }
@@ -4173,25 +4173,25 @@ bool BytecodeEmitter::emitSingleDeclarat
     MOZ_ASSERT(declList->isKind(ParseNodeKind::LetDecl),
                "var declarations without initializers handled above, "
                "and const declarations must have initializers");
-    if (!emit1(JSOp::Undefined)) {
+    if (!emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ENV? UNDEF
       return false;
     }
   } else {
     MOZ_ASSERT(initializer);
 
-    if (!updateSourceCoordNotes(initializer->pn_pos.begin)) {
-      return false;
-    }
-    if (!markStepBreakpoint()) {
-      return false;
-    }
-    if (!emitInitializer(initializer, decl)) {
+    if (!updateSourceCoordNotes(initializer->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!markStepBreakpoint()) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!emitInitializer(initializer, decl)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ENV? V
       return false;
     }
   }
-  if (!noe.emitAssignment()) {
+  if (!noe.emitAssignment()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] V
     return false;
   }
@@ -4460,13 +4460,13 @@ bool BytecodeEmitter::emitAssignmentOrIn
   }
 
   if (rhs) {
-    if (!emitAssignmentRhs(rhs, anonFunctionName)) {
+    if (!emitAssignmentRhs(rhs, anonFunctionName)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... VAL? RHS
       return false;
     }
   } else {
     // Assumption: Things with pre-emitted RHS values never need to be named.
-    if (!emitAssignmentRhs(offset)) {
+    if (!emitAssignmentRhs(offset)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... VAL? RHS
       return false;
     }
@@ -4474,10 +4474,10 @@ bool BytecodeEmitter::emitAssignmentOrIn
 
   /* If += etc., emit the binary operator with a source note. */
   if (isCompound) {
-    if (!newSrcNote(SrcNoteType::AssignOp)) {
-      return false;
-    }
-    if (!emit1(compoundOp)) {
+    if (!newSrcNote(SrcNoteType::AssignOp)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!emit1(compoundOp)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... VAL
       return false;
     }
@@ -4663,19 +4663,19 @@ bool BytecodeEmitter::emitShortCircuitAs
 
   // Test for the short-circuit condition.
   JumpList jump;
-  if (!emitJump(op, &jump)) {
+  if (!emitJump(op, &jump)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... LHS
     return false;
   }
 
   // The short-circuit condition wasn't fulfilled, pop the left-hand side value
   // which was kept on the stack.
-  if (!emit1(JSOp::Pop)) {
+  if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ...
     return false;
   }
 
-  if (!emitAssignmentRhs(rhs, name)) {
+  if (!emitAssignmentRhs(rhs, name)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... RHS
     return false;
   }
@@ -4717,12 +4717,12 @@ bool BytecodeEmitter::emitShortCircuitAs
   // Join with the short-circuit jump and pop anything left on the stack.
   if (numPushed > 0) {
     JumpList jumpAroundPop;
-    if (!emitJump(JSOp::Goto, &jumpAroundPop)) {
+    if (!emitJump(JSOp::Goto, &jumpAroundPop)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] RHS
       return false;
     }
 
-    if (!emitJumpTargetAndPatch(jump)) {
+    if (!emitJumpTargetAndPatch(jump)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... LHS
       return false;
     }
@@ -4731,16 +4731,16 @@ bool BytecodeEmitter::emitShortCircuitAs
     bytecodeSection().setStackDepth(depth + 1 + numPushed);
 
     // Move the left-hand side value to the bottom and pop the rest.
-    if (!emitUnpickN(numPushed)) {
+    if (!emitUnpickN(numPushed)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] LHS ...
       return false;
     }
-    if (!emitPopN(numPushed)) {
+    if (!emitPopN(numPushed)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] LHS
       return false;
     }
 
-    if (!emitJumpTargetAndPatch(jumpAroundPop)) {
+    if (!emitJumpTargetAndPatch(jumpAroundPop)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] LHS | RHS
       return false;
     }
@@ -4792,7 +4792,7 @@ bool BytecodeEmitter::emitCallSiteObject
 
 bool BytecodeEmitter::emitCallSiteObject(CallSiteNode* callSiteObj) {
   GCThingIndex cookedIndex;
-  if (!emitCallSiteObjectArray(callSiteObj, &cookedIndex)) {
+  if (!emitCallSiteObjectArray(callSiteObj, &cookedIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4813,7 +4813,7 @@ bool BytecodeEmitter::emitCatch(BinaryNo
   ParseNode* param = catchClause->left();
   if (!param) {
     // Catch parameter was omitted; just discard the exception.
-    if (!emit1(JSOp::Pop)) {
+    if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -4870,7 +4870,7 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
     return false;
   }
 
-  if (!emitTree(tryNode->body())) {
+  if (!emitTree(tryNode->body())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4887,23 +4887,23 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
     // if there is a finally block:
     //   gosub <finally>
     //   goto <after finally>
-    if (!tryCatch.emitCatch()) {
+    if (!tryCatch.emitCatch()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // Emit the lexical scope and catch body.
-    if (!emitTree(catchScope)) {
+    if (!emitTree(catchScope)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // Emit the finally handler, if there is one.
   if (finallyNode) {
-    if (!tryCatch.emitFinally(Some(finallyNode->pn_pos.begin))) {
-      return false;
-    }
-
-    if (!emitTree(finallyNode)) {
+    if (!tryCatch.emitFinally(Some(finallyNode->pn_pos.begin))) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+
+    if (!emitTree(finallyNode)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -4927,16 +4927,16 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
   // The order is important: the Baseline Interpreter relies on JSOp::JumpTarget
   // setting the frame's ICEntry when resuming at resumeOffset.
 
-  if (!emit1(JSOp::False)) {
+  if (!emit1(JSOp::False)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   BytecodeOffset off;
-  if (!emitN(JSOp::ResumeIndex, 3, &off)) {
-    return false;
-  }
-
-  if (!emitJumpNoFallthrough(JSOp::Gosub, jump)) {
+  if (!emitN(JSOp::ResumeIndex, 3, &off)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!emitJumpNoFallthrough(JSOp::Gosub, jump)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4954,7 +4954,7 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
 bool BytecodeEmitter::emitIf(TernaryNode* ifNode) {
   IfEmitter ifThenElse(this);
 
-  if (!ifThenElse.emitIf(Some(ifNode->kid1()->pn_pos.begin))) {
+  if (!ifThenElse.emitIf(Some(ifNode->kid1()->pn_pos.begin))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4966,30 +4966,30 @@ if_again:
     conditionKind = IfEmitter::ConditionKind::Negative;
   }
 
-  if (!markStepBreakpoint()) {
+  if (!markStepBreakpoint()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Emit code for the condition before pushing stmtInfo.
   // NOTE: NotExpr of testNode may be unwrapped, and in that case the negation
   //       is handled by conditionKind.
-  if (!emitTree(testNode)) {
+  if (!emitTree(testNode)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   ParseNode* elseNode = ifNode->kid3();
   if (elseNode) {
-    if (!ifThenElse.emitThenElse(conditionKind)) {
+    if (!ifThenElse.emitThenElse(conditionKind)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
-    if (!ifThenElse.emitThen(conditionKind)) {
+    if (!ifThenElse.emitThen(conditionKind)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   /* Emit code for the then part. */
-  if (!emitTree(ifNode->kid2())) {
+  if (!emitTree(ifNode->kid2())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4997,19 +4997,19 @@ if_again:
     if (elseNode->isKind(ParseNodeKind::IfStmt)) {
       ifNode = &elseNode->as<TernaryNode>();
 
-      if (!ifThenElse.emitElseIf(Some(ifNode->kid1()->pn_pos.begin))) {
+      if (!ifThenElse.emitElseIf(Some(ifNode->kid1()->pn_pos.begin))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       goto if_again;
     }
 
-    if (!ifThenElse.emitElse()) {
+    if (!ifThenElse.emitElse()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     /* Emit code for the else part. */
-    if (!emitTree(elseNode)) {
+    if (!emitTree(elseNode)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -5075,7 +5075,7 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
 
   ParseNode* body = lexicalScope->scopeBody();
   if (lexicalScope->isEmptyScope()) {
-    if (!lse.emitEmptyScope()) {
+    if (!lse.emitEmptyScope()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5083,7 +5083,7 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
       return false;
     }
 
-    if (!lse.emitEnd()) {
+    if (!lse.emitEnd()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5095,7 +5095,7 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
   // block. (Using the location of each declaration we're instantiating is
   // too weird when stepping in the debugger.)
   if (!ParseNodeRequiresSpecialLineNumberNotes(body)) {
-    if (!updateSourceCoordNotes(lexicalScope->pn_pos.begin)) {
+    if (!updateSourceCoordNotes(lexicalScope->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -5111,7 +5111,7 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
     kind = lexicalScope->kind();
   }
 
-  if (!lse.emitScope(kind, lexicalScope->scopeBindings())) {
+  if (!lse.emitScope(kind, lexicalScope->scopeBindings())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5119,11 +5119,11 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
     // for loops need to emit {FRESHEN,RECREATE}LEXICALENV if there are
     // lexical declarations in the head. Signal this by passing a
     // non-nullptr lexical scope.
-    if (!emitFor(&body->as<ForNode>(), &lse.emitterScope())) {
+    if (!emitFor(&body->as<ForNode>(), &lse.emitterScope())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
-    if (!emitLexicalScopeBody(body, SUPPRESS_LINENOTE)) {
+    if (!emitLexicalScopeBody(body, SUPPRESS_LINENOTE)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -5136,20 +5136,20 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
 
 bool BytecodeEmitter::emitWith(BinaryNode* withNode) {
   // Ensure that the column of the 'with' is set properly.
-  if (!updateSourceCoordNotes(withNode->left()->pn_pos.begin)) {
-    return false;
-  }
-
-  if (!markStepBreakpoint()) {
-    return false;
-  }
-
-  if (!emitTree(withNode->left())) {
+  if (!updateSourceCoordNotes(withNode->left()->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!markStepBreakpoint()) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!emitTree(withNode->left())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   EmitterScope emitterScope(this);
-  if (!emitterScope.enterWith(this)) {
+  if (!emitterScope.enterWith(this)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5170,7 +5170,7 @@ bool BytecodeEmitter::emitCopyDataProper
     argc = 3;
 
     if (!emitAtomOp(JSOp::GetIntrinsic,
-                    TaggedParserAtomIndex::WellKnown::CopyDataProperties())) {
+                    TaggedParserAtomIndex::WellKnown::CopyDataProperties())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] TARGET SOURCE SET COPYDATAPROPERTIES
       return false;
     }
@@ -5181,34 +5181,34 @@ bool BytecodeEmitter::emitCopyDataProper
 
     if (!emitAtomOp(
             JSOp::GetIntrinsic,
-            TaggedParserAtomIndex::WellKnown::CopyDataPropertiesUnfiltered())) {
+            TaggedParserAtomIndex::WellKnown::CopyDataPropertiesUnfiltered())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] TARGET SOURCE COPYDATAPROPERTIES
       return false;
     }
   }
 
-  if (!emit1(JSOp::Undefined)) {
+  if (!emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] TARGET SOURCE SET? COPYDATAPROPERTIES
     //                    UNDEFINED
     return false;
   }
-  if (!emit2(JSOp::Pick, argc + 1)) {
+  if (!emit2(JSOp::Pick, argc + 1)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] SOURCE SET? COPYDATAPROPERTIES UNDEFINED
     //                    TARGET
     return false;
   }
-  if (!emit2(JSOp::Pick, argc + 1)) {
+  if (!emit2(JSOp::Pick, argc + 1)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] SET? COPYDATAPROPERTIES UNDEFINED TARGET
     //                    SOURCE
     return false;
   }
   if (option == CopyOption::Filtered) {
-    if (!emit2(JSOp::Pick, argc + 1)) {
+    if (!emit2(JSOp::Pick, argc + 1)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] COPYDATAPROPERTIES UNDEFINED TARGET SOURCE SET
       return false;
     }
   }
-  if (!emitCall(JSOp::CallIgnoresRv, argc)) {
+  if (!emitCall(JSOp::CallIgnoresRv, argc)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] IGNORED
     return false;
   }
@@ -5232,35 +5232,35 @@ bool BytecodeEmitter::emitBigIntOp(BigIn
 
 bool BytecodeEmitter::emitIterator() {
   // Convert iterable to iterator.
-  if (!emit1(JSOp::Dup)) {
+  if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ OBJ
     return false;
   }
-  if (!emit2(JSOp::Symbol, uint8_t(JS::SymbolCode::iterator))) {
+  if (!emit2(JSOp::Symbol, uint8_t(JS::SymbolCode::iterator))) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ OBJ @@ITERATOR
     return false;
   }
-  if (!emitElemOpBase(JSOp::GetElem)) {
+  if (!emitElemOpBase(JSOp::GetElem)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ ITERFN
     return false;
   }
-  if (!emit1(JSOp::Swap)) {
+  if (!emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITERFN OBJ
     return false;
   }
-  if (!emitCall(JSOp::CallIter, 0)) {
+  if (!emitCall(JSOp::CallIter, 0)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER
     return false;
   }
-  if (!emitCheckIsObj(CheckIsObjectKind::GetIterator)) {
+  if (!emitCheckIsObj(CheckIsObjectKind::GetIterator)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER
     return false;
   }
-  if (!emit1(JSOp::Dup)) {
+  if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER ITER
     return false;
   }
-  if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::next())) {
+  if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::next())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER NEXT
     return false;
   }
@@ -5273,101 +5273,101 @@ bool BytecodeEmitter::emitIterator() {
 
 bool BytecodeEmitter::emitAsyncIterator() {
   // Convert iterable to iterator.
-  if (!emit1(JSOp::Dup)) {
+  if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ OBJ
     return false;
   }
-  if (!emit2(JSOp::Symbol, uint8_t(JS::SymbolCode::asyncIterator))) {
+  if (!emit2(JSOp::Symbol, uint8_t(JS::SymbolCode::asyncIterator))) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ OBJ @@ASYNCITERATOR
     return false;
   }
-  if (!emitElemOpBase(JSOp::GetElem)) {
+  if (!emitElemOpBase(JSOp::GetElem)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ ITERFN
     return false;
   }
 
   InternalIfEmitter ifAsyncIterIsUndefined(this);
-  if (!emitPushNotUndefinedOrNull()) {
+  if (!emitPushNotUndefinedOrNull()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ ITERFN !UNDEF-OR-NULL
     return false;
   }
   if (!ifAsyncIterIsUndefined.emitThenElse(
-          IfEmitter::ConditionKind::Negative)) {
+          IfEmitter::ConditionKind::Negative)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ ITERFN
     return false;
   }
 
-  if (!emit1(JSOp::Pop)) {
+  if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ
     return false;
   }
-  if (!emit1(JSOp::Dup)) {
+  if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ OBJ
     return false;
   }
-  if (!emit2(JSOp::Symbol, uint8_t(JS::SymbolCode::iterator))) {
+  if (!emit2(JSOp::Symbol, uint8_t(JS::SymbolCode::iterator))) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ OBJ @@ITERATOR
     return false;
   }
-  if (!emitElemOpBase(JSOp::GetElem)) {
+  if (!emitElemOpBase(JSOp::GetElem)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ ITERFN
     return false;
   }
-  if (!emit1(JSOp::Swap)) {
+  if (!emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITERFN OBJ
     return false;
   }
-  if (!emitCall(JSOp::CallIter, 0)) {
+  if (!emitCall(JSOp::CallIter, 0)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER
     return false;
   }
-  if (!emitCheckIsObj(CheckIsObjectKind::GetIterator)) {
+  if (!emitCheckIsObj(CheckIsObjectKind::GetIterator)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER
     return false;
   }
 
-  if (!emit1(JSOp::Dup)) {
+  if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER ITER
     return false;
   }
-  if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::next())) {
+  if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::next())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER SYNCNEXT
     return false;
   }
 
-  if (!emit1(JSOp::ToAsyncIter)) {
+  if (!emit1(JSOp::ToAsyncIter)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER
     return false;
   }
 
-  if (!ifAsyncIterIsUndefined.emitElse()) {
+  if (!ifAsyncIterIsUndefined.emitElse()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ ITERFN
     return false;
   }
 
-  if (!emit1(JSOp::Swap)) {
+  if (!emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITERFN OBJ
     return false;
   }
-  if (!emitCall(JSOp::CallIter, 0)) {
+  if (!emitCall(JSOp::CallIter, 0)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER
     return false;
   }
-  if (!emitCheckIsObj(CheckIsObjectKind::GetIterator)) {
+  if (!emitCheckIsObj(CheckIsObjectKind::GetIterator)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER
     return false;
   }
 
-  if (!ifAsyncIterIsUndefined.emitEnd()) {
+  if (!ifAsyncIterIsUndefined.emitEnd()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER
     return false;
   }
 
-  if (!emit1(JSOp::Dup)) {
+  if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER ITER
     return false;
   }
-  if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::next())) {
+  if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::next())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER NEXT
     return false;
   }
@@ -5382,7 +5382,7 @@ bool BytecodeEmitter::emitAsyncIterator(
 bool BytecodeEmitter::emitSpread(bool allowSelfHosted) {
   LoopControl loopInfo(this, StatementKind::Spread);
 
-  if (!loopInfo.emitLoopHead(this, Nothing())) {
+  if (!loopInfo.emitLoopHead(this, Nothing())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER ARR I
     return false;
   }
@@ -5395,38 +5395,38 @@ bool BytecodeEmitter::emitSpread(bool al
     // Spread operations can't contain |continue|, so don't bother setting loop
     // and enclosing "update" offsets, as we do with for-loops.
 
-    if (!emitDupAt(3, 2)) {
+    if (!emitDupAt(3, 2)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER ARR I NEXT
       return false;
     }
-    if (!emitIteratorNext(Nothing(), IteratorKind::Sync, allowSelfHosted)) {
+    if (!emitIteratorNext(Nothing(), IteratorKind::Sync, allowSelfHosted)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER ARR I RESULT
       return false;
     }
-    if (!emit1(JSOp::Dup)) {
+    if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER ARR I RESULT RESULT
       return false;
     }
-    if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::done())) {
+    if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::done())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER ARR I RESULT DONE
       return false;
     }
-    if (!emitJump(JSOp::JumpIfTrue, &loopInfo.breaks)) {
+    if (!emitJump(JSOp::JumpIfTrue, &loopInfo.breaks)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER ARR I RESULT
       return false;
     }
 
     // Emit code to assign result.value to the iteration variable.
-    if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::value())) {
+    if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::value())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER ARR I VALUE
       return false;
     }
-    if (!emit1(JSOp::InitElemInc)) {
+    if (!emit1(JSOp::InitElemInc)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER ARR (I+1)
       return false;
     }
 
-    if (!loopInfo.emitLoopEnd(this, JSOp::Goto, TryNoteKind::ForOf)) {
+    if (!loopInfo.emitLoopEnd(this, JSOp::Goto, TryNoteKind::ForOf)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER ARR (I+1)
       return false;
     }
@@ -5442,7 +5442,7 @@ bool BytecodeEmitter::emitSpread(bool al
   // No continues should occur in spreads.
   MOZ_ASSERT(!loopInfo.continues.offset.valid());
 
-  if (!emit2(JSOp::Pick, 4)) {
+  if (!emit2(JSOp::Pick, 4)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER ARR FINAL_INDEX RESULT NEXT
     return false;
   }
@@ -5479,7 +5479,7 @@ bool BytecodeEmitter::emitInitializeForI
   // assignment to that name (which does *not* necessarily assign to the
   // variable!) must be generated.
 
-  if (!updateSourceCoordNotes(target->pn_pos.begin)) {
+  if (!updateSourceCoordNotes(target->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5501,7 +5501,7 @@ bool BytecodeEmitter::emitInitializeForI
   if (nameNode) {
     auto nameAtom = nameNode->name();
     NameOpEmitter noe(this, nameAtom, NameOpEmitter::Kind::Initialize);
-    if (!noe.prepareForRhs()) {
+    if (!noe.prepareForRhs()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (noe.emittedBindOp()) {
@@ -5510,7 +5510,7 @@ bool BytecodeEmitter::emitInitializeForI
       // value may be buried under a bind-specific value on the stack.
       // Swap it to the top of the stack.
       MOZ_ASSERT(bytecodeSection().stackDepth() >= 2);
-      if (!emit1(JSOp::Swap)) {
+      if (!emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -5558,18 +5558,18 @@ bool BytecodeEmitter::emitForOf(ForNode*
   ForOfEmitter forOf(this, headLexicalEmitterScope,
                      allowSelfHostedIter(forHeadExpr), iterKind);
 
-  if (!forOf.emitIterated()) {
+  if (!forOf.emitIterated()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
-  if (!updateSourceCoordNotes(forHeadExpr->pn_pos.begin)) {
-    return false;
-  }
-  if (!markStepBreakpoint()) {
-    return false;
-  }
-  if (!emitTree(forHeadExpr)) {
+  if (!updateSourceCoordNotes(forHeadExpr->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!markStepBreakpoint()) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!emitTree(forHeadExpr)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITERABLE
     return false;
   }
@@ -5580,24 +5580,24 @@ bool BytecodeEmitter::emitForOf(ForNode*
                forOfTarget->isKind(ParseNodeKind::ConstDecl));
   }
 
-  if (!forOf.emitInitialize(Some(forOfHead->pn_pos.begin))) {
+  if (!forOf.emitInitialize(Some(forOfHead->pn_pos.begin))) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER VALUE
     return false;
   }
 
-  if (!emitInitializeForInOrOfTarget(forOfHead)) {
+  if (!emitInitializeForInOrOfTarget(forOfHead)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER VALUE
     return false;
   }
 
-  if (!forOf.emitBody()) {
+  if (!forOf.emitBody()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER UNDEF
     return false;
   }
 
   // Perform the loop body.
   ParseNode* forBody = forOfLoop->body();
-  if (!emitTree(forBody)) {
+  if (!emitTree(forBody)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER UNDEF
     return false;
   }
@@ -5633,31 +5633,31 @@ bool BytecodeEmitter::emitForIn(ForNode*
             forInTarget->isKind(ParseNodeKind::VarStmt),
             "for-in initializers are only permitted for |var| declarations");
 
-        if (!updateSourceCoordNotes(decl->pn_pos.begin)) {
+        if (!updateSourceCoordNotes(decl->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         auto nameAtom = nameNode->name();
         NameOpEmitter noe(this, nameAtom, NameOpEmitter::Kind::Initialize);
-        if (!noe.prepareForRhs()) {
+        if (!noe.prepareForRhs()) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
-        if (!emitInitializer(initializer, nameNode)) {
+        if (!emitInitializer(initializer, nameNode)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
-        if (!noe.emitAssignment()) {
+        if (!noe.emitAssignment()) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         // Pop the initializer.
-        if (!emit1(JSOp::Pop)) {
+        if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
     }
   }
 
-  if (!forIn.emitIterated()) {
+  if (!forIn.emitIterated()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
@@ -5665,13 +5665,13 @@ bool BytecodeEmitter::emitForIn(ForNode*
   // Evaluate the expression being iterated.
   ParseNode* expr = forInHead->kid3();
 
-  if (!updateSourceCoordNotes(expr->pn_pos.begin)) {
-    return false;
-  }
-  if (!markStepBreakpoint()) {
-    return false;
-  }
-  if (!emitTree(expr)) {
+  if (!updateSourceCoordNotes(expr->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!markStepBreakpoint()) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!emitTree(expr)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] EXPR
     return false;
   }
@@ -5682,24 +5682,24 @@ bool BytecodeEmitter::emitForIn(ForNode*
                 forInTarget->isKind(ParseNodeKind::LetDecl) ||
                     forInTarget->isKind(ParseNodeKind::ConstDecl));
 
-  if (!forIn.emitInitialize()) {
+  if (!forIn.emitInitialize()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER ITERVAL
     return false;
   }
 
-  if (!emitInitializeForInOrOfTarget(forInHead)) {
+  if (!emitInitializeForInOrOfTarget(forInHead)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER ITERVAL
     return false;
   }
 
-  if (!forIn.emitBody()) {
+  if (!forIn.emitBody()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER ITERVAL
     return false;
   }
 
   // Perform the loop body.
   ParseNode* forBody = forInLoop->body();
-  if (!emitTree(forBody)) {
+  if (!emitTree(forBody)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER ITERVAL
     return false;
   }
@@ -5724,7 +5724,7 @@ bool BytecodeEmitter::emitCStyleFor(
 
   CForEmitter cfor(this, isLet ? headLexicalEmitterScope : nullptr);
 
-  if (!cfor.emitInit(init ? Some(init->pn_pos.begin) : Nothing())) {
+  if (!cfor.emitInit(init ? Some(init->pn_pos.begin) : Nothing())) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
@@ -5738,76 +5738,76 @@ bool BytecodeEmitter::emitCStyleFor(
     // declaration. (The loop variables were hoisted into an enclosing
     // scope, but we still need to emit code for the initializers.)
     if (init->isForLoopDeclaration()) {
-      if (!emitTree(init)) {
+      if (!emitTree(init)) {MOZ_RELEASE_ASSERT(0);
         //          [stack]
         return false;
       }
     } else {
-      if (!updateSourceCoordNotes(init->pn_pos.begin)) {
-        return false;
-      }
-      if (!markStepBreakpoint()) {
+      if (!updateSourceCoordNotes(init->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }
+      if (!markStepBreakpoint()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       // 'init' is an expression, not a declaration. emitTree left its
       // value on the stack.
-      if (!emitTree(init, ValueUsage::IgnoreValue)) {
+      if (!emitTree(init, ValueUsage::IgnoreValue)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] VAL
         return false;
       }
-      if (!emit1(JSOp::Pop)) {
+      if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
         //          [stack]
         return false;
       }
     }
   }
 
-  if (!cfor.emitCond(cond ? Some(cond->pn_pos.begin) : Nothing())) {
+  if (!cfor.emitCond(cond ? Some(cond->pn_pos.begin) : Nothing())) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
   if (cond) {
-    if (!updateSourceCoordNotes(cond->pn_pos.begin)) {
-      return false;
-    }
-    if (!markStepBreakpoint()) {
-      return false;
-    }
-    if (!emitTree(cond)) {
+    if (!updateSourceCoordNotes(cond->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!markStepBreakpoint()) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!emitTree(cond)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] VAL
       return false;
     }
   }
 
   if (!cfor.emitBody(cond ? CForEmitter::Cond::Present
-                          : CForEmitter::Cond::Missing)) {
+                          : CForEmitter::Cond::Missing)) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
-  if (!emitTree(forBody)) {
+  if (!emitTree(forBody)) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
   if (!cfor.emitUpdate(
           update ? CForEmitter::Update::Present : CForEmitter::Update::Missing,
-          update ? Some(update->pn_pos.begin) : Nothing())) {
+          update ? Some(update->pn_pos.begin) : Nothing())) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
   // Check for update code to do before the condition (if any).
   if (update) {
-    if (!updateSourceCoordNotes(update->pn_pos.begin)) {
-      return false;
-    }
-    if (!markStepBreakpoint()) {
-      return false;
-    }
-    if (!emitTree(update, ValueUsage::IgnoreValue)) {
+    if (!updateSourceCoordNotes(update->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!markStepBreakpoint()) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!emitTree(update, ValueUsage::IgnoreValue)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] VAL
       return false;
     }
@@ -5827,7 +5827,7 @@ bool BytecodeEmitter::emitFor(ForNode* f
     return emitCStyleFor(forNode, headLexicalEmitterScope);
   }
 
-  if (!updateLineNumberNotes(forNode->pn_pos.begin)) {
+  if (!updateLineNumberNotes(forNode->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5854,7 +5854,7 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
   // been emitted. Function definitions that need hoisting to the top of the
   // function will be seen by emitFunction in two places.
   if (funbox->wasEmittedByEnclosingScript()) {
-    if (!fe.emitAgain()) {
+    if (!fe.emitAgain()) {MOZ_RELEASE_ASSERT(0);
       //            [stack]
       return false;
     }
@@ -5868,13 +5868,13 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
       //            [stack] FUN?
     }
 
-    if (!fe.prepareForNonLazy()) {
+    if (!fe.prepareForNonLazy()) {MOZ_RELEASE_ASSERT(0);
       //            [stack]
       return false;
     }
 
     BytecodeEmitter bce2(this, parser, funbox, compilationState, emitterMode);
-    if (!bce2.init(funNode->pn_pos)) {
+    if (!bce2.init(funNode->pn_pos)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5883,7 +5883,7 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
       return false;
     }
 
-    if (!fe.emitNonLazyEnd()) {
+    if (!fe.emitNonLazyEnd()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] FUN?
       return false;
     }
@@ -5904,26 +5904,26 @@ bool BytecodeEmitter::emitDo(BinaryNode*
 
   DoWhileEmitter doWhile(this);
   if (!doWhile.emitBody(Some(doNode->pn_pos.begin),
-                        getOffsetForLoop(bodyNode))) {
-    return false;
-  }
-
-  if (!emitTree(bodyNode)) {
-    return false;
-  }
-
-  if (!doWhile.emitCond()) {
+                        getOffsetForLoop(bodyNode))) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!emitTree(bodyNode)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!doWhile.emitCond()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   ParseNode* condNode = doNode->right();
-  if (!updateSourceCoordNotes(condNode->pn_pos.begin)) {
-    return false;
-  }
-  if (!markStepBreakpoint()) {
-    return false;
-  }
-  if (!emitTree(condNode)) {
+  if (!updateSourceCoordNotes(condNode->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!markStepBreakpoint()) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!emitTree(condNode)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5941,24 +5941,24 @@ bool BytecodeEmitter::emitWhile(BinaryNo
 
   ParseNode* condNode = whileNode->left();
   if (!wh.emitCond(Some(whileNode->pn_pos.begin), getOffsetForLoop(condNode),
-                   Some(whileNode->pn_pos.end))) {
-    return false;
-  }
-
-  if (!updateSourceCoordNotes(condNode->pn_pos.begin)) {
-    return false;
-  }
-  if (!markStepBreakpoint()) {
-    return false;
-  }
-  if (!emitTree(condNode)) {
-    return false;
-  }
-
-  if (!wh.emitBody()) {
-    return false;
-  }
-  if (!emitTree(bodyNode)) {
+                   Some(whileNode->pn_pos.end))) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!updateSourceCoordNotes(condNode->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!markStepBreakpoint()) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!emitTree(condNode)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!wh.emitBody()) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!emitTree(bodyNode)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6015,12 +6015,12 @@ bool BytecodeEmitter::emitGetFunctionThi
 bool BytecodeEmitter::emitGetFunctionThis(
     const mozilla::Maybe<uint32_t>& offset) {
   if (offset) {
-    if (!updateLineNumberNotes(*offset)) {
-      return false;
-    }
-  }
-
-  if (!emitGetName(TaggedParserAtomIndex::WellKnown::dotThis())) {
+    if (!updateLineNumberNotes(*offset)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+  }
+
+  if (!emitGetName(TaggedParserAtomIndex::WellKnown::dotThis())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] THIS
     return false;
   }
@@ -6061,7 +6061,7 @@ bool BytecodeEmitter::emitThisLiteral(Th
 bool BytecodeEmitter::emitCheckDerivedClassConstructorReturn() {
   MOZ_ASSERT(
       lookupName(TaggedParserAtomIndex::WellKnown::dotThis()).hasKnownSlot());
-  if (!emitGetName(TaggedParserAtomIndex::WellKnown::dotThis())) {
+  if (!emitGetName(TaggedParserAtomIndex::WellKnown::dotThis())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!emit1(JSOp::CheckReturn)) {
@@ -6071,46 +6071,46 @@ bool BytecodeEmitter::emitCheckDerivedCl
 }
 
 bool BytecodeEmitter::emitReturn(UnaryNode* returnNode) {
-  if (!updateSourceCoordNotes(returnNode->pn_pos.begin)) {
+  if (!updateSourceCoordNotes(returnNode->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   bool needsIteratorResult =
       sc->isFunctionBox() && sc->asFunctionBox()->needsIteratorResult();
   if (needsIteratorResult) {
-    if (!emitPrepareIteratorResult()) {
-      return false;
-    }
-  }
-
-  if (!updateSourceCoordNotes(returnNode->pn_pos.begin)) {
-    return false;
-  }
-  if (!markStepBreakpoint()) {
+    if (!emitPrepareIteratorResult()) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+  }
+
+  if (!updateSourceCoordNotes(returnNode->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!markStepBreakpoint()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   /* Push a return value */
   if (ParseNode* expr = returnNode->kid()) {
-    if (!emitTree(expr)) {
+    if (!emitTree(expr)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (sc->asSuspendableContext()->isAsync() &&
         sc->asSuspendableContext()->isGenerator()) {
-      if (!emitAwaitInInnermostScope()) {
+      if (!emitAwaitInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
   } else {
     /* No explicit return value provided */
-    if (!emit1(JSOp::Undefined)) {
+    if (!emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   if (needsIteratorResult) {
-    if (!emitFinishIteratorResult(true)) {
+    if (!emitFinishIteratorResult(true)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -6118,7 +6118,7 @@ bool BytecodeEmitter::emitReturn(UnaryNo
   // We know functionBodyEndPos is set because "return" is only
   // valid in a function, and so we've passed through
   // emitFunctionScript.
-  if (!updateSourceCoordNotes(*functionBodyEndPos)) {
+  if (!updateSourceCoordNotes(*functionBodyEndPos)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6141,7 +6141,7 @@ bool BytecodeEmitter::emitReturn(UnaryNo
       sc->isFunctionBox() && sc->asFunctionBox()->isDerivedClassConstructor();
 
   if (!emit1((needsFinalYield || isDerivedClassConstructor) ? JSOp::SetRval
-                                                            : JSOp::Return)) {
+                                                            : JSOp::Return)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6149,14 +6149,14 @@ bool BytecodeEmitter::emitReturn(UnaryNo
   // prepareForNonLocalJump, to ensure that the error is thrown while the
   // scope-chain is still intact.
   if (isDerivedClassConstructor) {
-    if (!emitCheckDerivedClassConstructorReturn()) {
+    if (!emitCheckDerivedClassConstructorReturn()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   NonLocalExitControl nle(this, NonLocalExitControl::Return);
 
-  if (!nle.prepareForNonLocalJumpToOutermost()) {
+  if (!nle.prepareForNonLocalJumpToOutermost()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6168,36 +6168,36 @@ bool BytecodeEmitter::emitReturn(UnaryNo
 
     // Resolve the return value before emitting the final yield.
     if (sc->asFunctionBox()->needsPromiseResult()) {
-      if (!emit1(JSOp::GetRval)) {
+      if (!emit1(JSOp::GetRval)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] RVAL
         return false;
       }
       if (!emitGetNameAtLocation(
-              TaggedParserAtomIndex::WellKnown::dotGenerator(), loc)) {
+              TaggedParserAtomIndex::WellKnown::dotGenerator(), loc)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] RVAL GEN
         return false;
       }
       if (!emit2(JSOp::AsyncResolve,
-                 uint8_t(AsyncFunctionResolveKind::Fulfill))) {
+                 uint8_t(AsyncFunctionResolveKind::Fulfill))) {MOZ_RELEASE_ASSERT(0);
         //          [stack] PROMISE
         return false;
       }
-      if (!emit1(JSOp::SetRval)) {
+      if (!emit1(JSOp::SetRval)) {MOZ_RELEASE_ASSERT(0);
         //          [stack]
         return false;
       }
     }
 
     if (!emitGetNameAtLocation(TaggedParserAtomIndex::WellKnown::dotGenerator(),
-                               loc)) {
-      return false;
-    }
-    if (!emitYieldOp(JSOp::FinalYieldRval)) {
+                               loc)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!emitYieldOp(JSOp::FinalYieldRval)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else if (isDerivedClassConstructor) {
     MOZ_ASSERT(JSOp(bytecodeSection().code()[top.value()]) == JSOp::SetRval);
-    if (!emitReturnRval()) {
+    if (!emitReturnRval()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else if (top + BytecodeOffsetDiff(JSOpLength_Return) !=
@@ -6229,15 +6229,15 @@ bool BytecodeEmitter::emitGetDotGenerato
 }
 
 bool BytecodeEmitter::emitInitialYield(UnaryNode* yieldNode) {
-  if (!emitTree(yieldNode->kid())) {
-    return false;
-  }
-
-  if (!emitYieldOp(JSOp::InitialYield)) {
+  if (!emitTree(yieldNode->kid())) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!emitYieldOp(JSOp::InitialYield)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] RVAL GENERATOR RESUMEKIND
     return false;
   }
-  if (!emit1(JSOp::CheckResumeKind)) {
+  if (!emit1(JSOp::CheckResumeKind)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] RVAL
     return false;
   }
@@ -6256,18 +6256,18 @@ bool BytecodeEmitter::emitYield(UnaryNod
 
   bool needsIteratorResult = sc->asFunctionBox()->needsIteratorResult();
   if (needsIteratorResult) {
-    if (!emitPrepareIteratorResult()) {
+    if (!emitPrepareIteratorResult()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ITEROBJ
       return false;
     }
   }
   if (ParseNode* expr = yieldNode->kid()) {
-    if (!emitTree(expr)) {
+    if (!emitTree(expr)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ITEROBJ? VAL
       return false;
     }
   } else {
-    if (!emit1(JSOp::Undefined)) {
+    if (!emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ITEROBJ? UNDEFINED
       return false;
     }
@@ -6276,20 +6276,20 @@ bool BytecodeEmitter::emitYield(UnaryNod
   // 25.5.3.7 AsyncGeneratorYield step 5.
   if (sc->asSuspendableContext()->isAsync()) {
     MOZ_ASSERT(!needsIteratorResult);
-    if (!emitAwaitInInnermostScope()) {
+    if (!emitAwaitInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] RESULT
       return false;
     }
   }
 
   if (needsIteratorResult) {
-    if (!emitFinishIteratorResult(false)) {
+    if (!emitFinishIteratorResult(false)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ITEROBJ
       return false;
     }
   }
 
-  if (!emitGetDotGeneratorInInnermostScope()) {
+  if (!emitGetDotGeneratorInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] # if needsIteratorResult
     //              [stack] ITEROBJ .GENERATOR
     //              [stack] # else
@@ -6297,7 +6297,7 @@ bool BytecodeEmitter::emitYield(UnaryNod
     return false;
   }
 
-  if (!emitYieldOp(JSOp::Yield)) {
+  if (!emitYieldOp(JSOp::Yield)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] YIELDRESULT GENERATOR RESUMEKIND
     return false;
   }
@@ -6321,42 +6321,42 @@ bool BytecodeEmitter::emitAwaitInInnermo
 }
 
 bool BytecodeEmitter::emitAwaitInScope(EmitterScope& currentScope) {
-  if (!emit1(JSOp::CanSkipAwait)) {
+  if (!emit1(JSOp::CanSkipAwait)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] VALUE CANSKIP
     return false;
   }
 
-  if (!emit1(JSOp::MaybeExtractAwaitValue)) {
+  if (!emit1(JSOp::MaybeExtractAwaitValue)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] VALUE_OR_RESOLVED CANSKIP
     return false;
   }
 
   InternalIfEmitter ifCanSkip(this);
-  if (!ifCanSkip.emitThen(IfEmitter::ConditionKind::Negative)) {
+  if (!ifCanSkip.emitThen(IfEmitter::ConditionKind::Negative)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] VALUE_OR_RESOLVED
     return false;
   }
 
   if (sc->asSuspendableContext()->needsPromiseResult()) {
-    if (!emitGetDotGeneratorInScope(currentScope)) {
+    if (!emitGetDotGeneratorInScope(currentScope)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] VALUE GENERATOR
       return false;
     }
-    if (!emit1(JSOp::AsyncAwait)) {
+    if (!emit1(JSOp::AsyncAwait)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] PROMISE
       return false;
     }
   }
 
-  if (!emitGetDotGeneratorInScope(currentScope)) {
+  if (!emitGetDotGeneratorInScope(currentScope)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] VALUE|PROMISE GENERATOR
     return false;
   }
-  if (!emitYieldOp(JSOp::Await)) {
+  if (!emitYieldOp(JSOp::Await)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] RESOLVED GENERATOR RESUMEKIND
     return false;
   }
-  if (!emit1(JSOp::CheckResumeKind)) {
+  if (!emit1(JSOp::CheckResumeKind)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] RESOLVED
     return false;
   }
@@ -6384,17 +6384,17 @@ bool BytecodeEmitter::emitYieldStar(Pars
   bool needsIteratorResult = sc->asSuspendableContext()->needsIteratorResult();
 
   // Steps 2-5.
-  if (!emitTree(iter)) {
+  if (!emitTree(iter)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITERABLE
     return false;
   }
   if (iterKind == IteratorKind::Async) {
-    if (!emitAsyncIterator()) {
+    if (!emitAsyncIterator()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER
       return false;
     }
   } else {
-    if (!emitIterator()) {
+    if (!emitIterator()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER
       return false;
     }
@@ -6402,11 +6402,11 @@ bool BytecodeEmitter::emitYieldStar(Pars
 
   // Step 6.
   // Start with NormalCompletion(undefined).
-  if (!emit1(JSOp::Undefined)) {
+  if (!emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RECEIVED
     return false;
   }
-  if (!emitPushResumeKind(GeneratorResumeKind::Next)) {
+  if (!emitPushResumeKind(GeneratorResumeKind::Next)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RECEIVED RESUMEKIND
     return false;
   }
@@ -6416,65 +6416,65 @@ bool BytecodeEmitter::emitYieldStar(Pars
 
   // Step 7 is a loop.
   LoopControl loopInfo(this, StatementKind::YieldStar);
-  if (!loopInfo.emitLoopHead(this, Nothing())) {
+  if (!loopInfo.emitLoopHead(this, Nothing())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RECEIVED RESUMEKIND
     return false;
   }
 
   // Step 7.a. Check for Normal completion.
-  if (!emit1(JSOp::Dup)) {
+  if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RECEIVED RESUMEKIND RESUMEKIND
     return false;
   }
-  if (!emitPushResumeKind(GeneratorResumeKind::Next)) {
+  if (!emitPushResumeKind(GeneratorResumeKind::Next)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RECEIVED RESUMEKIND RESUMEKIND NORMAL
     return false;
   }
-  if (!emit1(JSOp::StrictEq)) {
+  if (!emit1(JSOp::StrictEq)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RECEIVED RESUMEKIND IS_NORMAL
     return false;
   }
 
   InternalIfEmitter ifKind(this);
-  if (!ifKind.emitThenElse()) {
+  if (!ifKind.emitThenElse()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RECEIVED RESUMEKIND
     return false;
   }
   {
-    if (!emit1(JSOp::Pop)) {
+    if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED
       return false;
     }
 
     // Step 7.a.i.
     // result = iter.next(received)
-    if (!emit2(JSOp::Unpick, 2)) {
+    if (!emit2(JSOp::Unpick, 2)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] RECEIVED NEXT ITER
       return false;
     }
-    if (!emit1(JSOp::Dup2)) {
+    if (!emit1(JSOp::Dup2)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] RECEIVED NEXT ITER NEXT ITER
       return false;
     }
-    if (!emit2(JSOp::Pick, 4)) {
+    if (!emit2(JSOp::Pick, 4)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER NEXT ITER RECEIVED
       return false;
     }
-    if (!emitCall(JSOp::Call, 1, iter)) {
+    if (!emitCall(JSOp::Call, 1, iter)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RESULT
       return false;
     }
 
     // Step 7.a.ii.
     if (iterKind == IteratorKind::Async) {
-      if (!emitAwaitInInnermostScope()) {
+      if (!emitAwaitInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
         //          [stack] NEXT ITER RESULT
         return false;
       }
     }
 
     // Step 7.a.iii.
-    if (!emitCheckIsObj(CheckIsObjectKind::IteratorNext)) {
+    if (!emitCheckIsObj(CheckIsObjectKind::IteratorNext)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RESULT
       return false;
     }
@@ -6484,84 +6484,84 @@ bool BytecodeEmitter::emitYieldStar(Pars
   }
 
   // Step 7.b. Check for Throw completion.
-  if (!ifKind.emitElseIf(Nothing())) {
+  if (!ifKind.emitElseIf(Nothing())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RECEIVED RESUMEKIND
     return false;
   }
-  if (!emit1(JSOp::Dup)) {
+  if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RECEIVED RESUMEKIND RESUMEKIND
     return false;
   }
-  if (!emitPushResumeKind(GeneratorResumeKind::Throw)) {
+  if (!emitPushResumeKind(GeneratorResumeKind::Throw)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RECEIVED RESUMEKIND RESUMEKIND THROW
     return false;
   }
-  if (!emit1(JSOp::StrictEq)) {
+  if (!emit1(JSOp::StrictEq)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RECEIVED RESUMEKIND IS_THROW
     return false;
   }
-  if (!ifKind.emitThenElse()) {
+  if (!ifKind.emitThenElse()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RECEIVED RESUMEKIND
     return false;
   }
   {
-    if (!emit1(JSOp::Pop)) {
+    if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED
       return false;
     }
     // Step 7.b.i.
-    if (!emitDupAt(1)) {
+    if (!emitDupAt(1)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED ITER
       return false;
     }
-    if (!emit1(JSOp::Dup)) {
+    if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED ITER ITER
       return false;
     }
     if (!emitAtomOp(JSOp::GetProp,
-                    TaggedParserAtomIndex::WellKnown::throw_())) {
+                    TaggedParserAtomIndex::WellKnown::throw_())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED ITER THROW
       return false;
     }
 
     // Step 7.b.ii.
     InternalIfEmitter ifThrowMethodIsNotDefined(this);
-    if (!emitPushNotUndefinedOrNull()) {
+    if (!emitPushNotUndefinedOrNull()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED ITER THROW
       //            [stack]   NOT-UNDEF-OR_NULL
       return false;
     }
 
-    if (!ifThrowMethodIsNotDefined.emitThenElse()) {
+    if (!ifThrowMethodIsNotDefined.emitThenElse()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED ITER THROW
       return false;
     }
 
     // Step 7.b.ii.1.
     // RESULT = ITER.throw(EXCEPTION)
-    if (!emit1(JSOp::Swap)) {
+    if (!emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED THROW ITER
       return false;
     }
-    if (!emit2(JSOp::Pick, 2)) {
+    if (!emit2(JSOp::Pick, 2)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER THROW ITER RECEIVED
       return false;
     }
-    if (!emitCall(JSOp::Call, 1, iter)) {
+    if (!emitCall(JSOp::Call, 1, iter)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RESULT
       return false;
     }
 
     // Step 7.b.ii.2.
     if (iterKind == IteratorKind::Async) {
-      if (!emitAwaitInInnermostScope()) {
+      if (!emitAwaitInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
         //          [stack] NEXT ITER RESULT
         return false;
       }
     }
 
     // Step 7.b.ii.4.
-    if (!emitCheckIsObj(CheckIsObjectKind::IteratorThrow)) {
+    if (!emitCheckIsObj(CheckIsObjectKind::IteratorThrow)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RESULT
       return false;
     }
@@ -6570,11 +6570,11 @@ bool BytecodeEmitter::emitYieldStar(Pars
     // it's shared with other branches.
 
     // Step 7.b.iii.
-    if (!ifThrowMethodIsNotDefined.emitElse()) {
+    if (!ifThrowMethodIsNotDefined.emitElse()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED ITER THROW
       return false;
     }
-    if (!emit1(JSOp::Pop)) {
+    if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED ITER
       return false;
     }
@@ -6584,29 +6584,29 @@ bool BytecodeEmitter::emitYieldStar(Pars
     // If the iterator does not have a "throw" method, it calls IteratorClose
     // and then throws a TypeError.
     if (!emitIteratorCloseInInnermostScope(iterKind, CompletionKind::Normal,
-                                           allowSelfHostedIter(iter))) {
+                                           allowSelfHostedIter(iter))) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED ITER
       return false;
     }
     // Steps 7.b.iii.5-6.
-    if (!emit2(JSOp::ThrowMsg, uint8_t(ThrowMsgKind::IteratorNoThrow))) {
+    if (!emit2(JSOp::ThrowMsg, uint8_t(ThrowMsgKind::IteratorNoThrow))) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED ITER
       //            [stack] # throw
       return false;
     }
 
-    if (!ifThrowMethodIsNotDefined.emitEnd()) {
+    if (!ifThrowMethodIsNotDefined.emitEnd()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // Step 7.c. It must be a Return completion.
-  if (!ifKind.emitElse()) {
+  if (!ifKind.emitElse()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RECEIVED RESUMEKIND
     return false;
   }
   {
-    if (!emit1(JSOp::Pop)) {
+    if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED
       return false;
     }
@@ -6619,16 +6619,16 @@ bool BytecodeEmitter::emitYieldStar(Pars
     // Step 7.c.ii.
     //
     // Get the "return" method.
-    if (!emitDupAt(1)) {
+    if (!emitDupAt(1)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED ITER
       return false;
     }
-    if (!emit1(JSOp::Dup)) {
+    if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED ITER ITER
       return false;
     }
     if (!emitAtomOp(JSOp::GetProp,
-                    TaggedParserAtomIndex::WellKnown::return_())) {
+                    TaggedParserAtomIndex::WellKnown::return_())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED ITER RET
       return false;
     }
@@ -6637,7 +6637,7 @@ bool BytecodeEmitter::emitYieldStar(Pars
     //
     // Do nothing if "return" is undefined or null.
     InternalIfEmitter ifReturnMethodIsDefined(this);
-    if (!emitPushNotUndefinedOrNull()) {
+    if (!emitPushNotUndefinedOrNull()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED ITER RET NOT-UNDEF-OR_NULL
       return false;
     }
@@ -6645,40 +6645,40 @@ bool BytecodeEmitter::emitYieldStar(Pars
     // Step 7.c.iv.
     //
     // Call "return" with the argument passed to Generator.prototype.return.
-    if (!ifReturnMethodIsDefined.emitThenElse()) {
+    if (!ifReturnMethodIsDefined.emitThenElse()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED ITER RET
       return false;
     }
-    if (!emit1(JSOp::Swap)) {
+    if (!emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED RET ITER
       return false;
     }
-    if (!emit2(JSOp::Pick, 2)) {
+    if (!emit2(JSOp::Pick, 2)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RET ITER RECEIVED
       return false;
     }
     if (needsIteratorResult) {
       if (!emitAtomOp(JSOp::GetProp,
-                      TaggedParserAtomIndex::WellKnown::value())) {
+                      TaggedParserAtomIndex::WellKnown::value())) {MOZ_RELEASE_ASSERT(0);
         //          [stack] NEXT ITER RET ITER VAL
         return false;
       }
     }
-    if (!emitCall(JSOp::Call, 1)) {
+    if (!emitCall(JSOp::Call, 1)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RESULT
       return false;
     }
 
     // Step 7.c.v.
     if (iterKind == IteratorKind::Async) {
-      if (!emitAwaitInInnermostScope()) {
+      if (!emitAwaitInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
         //          [stack] NEXT ITER RESULT
         return false;
       }
     }
 
     // Step 7.c.vi.
-    if (!emitCheckIsObj(CheckIsObjectKind::IteratorReturn)) {
+    if (!emitCheckIsObj(CheckIsObjectKind::IteratorReturn)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RESULT
       return false;
     }
@@ -6688,72 +6688,72 @@ bool BytecodeEmitter::emitYieldStar(Pars
 
     // Steps 7.c.vii-viii.
     InternalIfEmitter ifReturnDone(this);
-    if (!emit1(JSOp::Dup)) {
+    if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RESULT RESULT
       return false;
     }
-    if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::done())) {
+    if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::done())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RESULT DONE
       return false;
     }
-    if (!ifReturnDone.emitThenElse()) {
+    if (!ifReturnDone.emitThenElse()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RESULT
       return false;
     }
 
     // Step 7.c.viii.1.
-    if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::value())) {
+    if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::value())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER VALUE
       return false;
     }
     if (needsIteratorResult) {
-      if (!emitPrepareIteratorResult()) {
+      if (!emitPrepareIteratorResult()) {MOZ_RELEASE_ASSERT(0);
         //          [stack] NEXT ITER VALUE RESULT
         return false;
       }
-      if (!emit1(JSOp::Swap)) {
+      if (!emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] NEXT ITER RESULT VALUE
         return false;
       }
-      if (!emitFinishIteratorResult(true)) {
+      if (!emitFinishIteratorResult(true)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] NEXT ITER RESULT
         return false;
       }
     }
 
-    if (!ifReturnDone.emitElse()) {
+    if (!ifReturnDone.emitElse()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RESULT
       return false;
     }
 
     // Jump to continue label for steps 7.c.ix-x.
-    if (!emitJump(JSOp::Goto, &loopInfo.continues)) {
+    if (!emitJump(JSOp::Goto, &loopInfo.continues)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RESULT
       return false;
     }
 
-    if (!ifReturnDone.emitEnd()) {
+    if (!ifReturnDone.emitEnd()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RESULT
       return false;
     }
 
     // Step 7.c.iii.
-    if (!ifReturnMethodIsDefined.emitElse()) {
+    if (!ifReturnMethodIsDefined.emitElse()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED ITER RET
       return false;
     }
-    if (!emitPopN(2)) {
+    if (!emitPopN(2)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED
       return false;
     }
     if (iterKind == IteratorKind::Async) {
       // Step 7.c.iii.1.
-      if (!emitAwaitInInnermostScope()) {
+      if (!emitAwaitInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
         //          [stack] NEXT ITER RECEIVED
         return false;
       }
     }
-    if (!ifReturnMethodIsDefined.emitEnd()) {
+    if (!ifReturnMethodIsDefined.emitEnd()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RECEIVED
       return false;
     }
@@ -6762,21 +6762,21 @@ bool BytecodeEmitter::emitYieldStar(Pars
     //
     // Step 7.c.iii.2.
     // Step 7.c.viii.2.
-    if (!emitGetDotGeneratorInInnermostScope()) {
+    if (!emitGetDotGeneratorInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RESULT GENOBJ
       return false;
     }
-    if (!emitPushResumeKind(GeneratorResumeKind::Return)) {
+    if (!emitPushResumeKind(GeneratorResumeKind::Return)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RESULT GENOBJ RESUMEKIND
       return false;
     }
-    if (!emit1(JSOp::CheckResumeKind)) {
+    if (!emit1(JSOp::CheckResumeKind)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RESULT GENOBJ RESUMEKIND
       return false;
     }
   }
 
-  if (!ifKind.emitEnd()) {
+  if (!ifKind.emitEnd()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RESULT
     return false;
   }
@@ -6789,15 +6789,15 @@ bool BytecodeEmitter::emitYieldStar(Pars
   //                [stack] NEXT ITER RESULT
 
   // if (result.done) break;
-  if (!emit1(JSOp::Dup)) {
+  if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RESULT RESULT
     return false;
   }
-  if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::done())) {
+  if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::done())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RESULT DONE
     return false;
   }
-  if (!emitJump(JSOp::JumpIfTrue, &loopInfo.breaks)) {
+  if (!emitJump(JSOp::JumpIfTrue, &loopInfo.breaks)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RESULT
     return false;
   }
@@ -6805,37 +6805,37 @@ bool BytecodeEmitter::emitYieldStar(Pars
   // Steps 7.a.vi-vii.
   // Steps 7.b.ii.7-8.
   // Steps 7.c.ix-x.
-  if (!loopInfo.emitContinueTarget(this)) {
+  if (!loopInfo.emitContinueTarget(this)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RESULT
     return false;
   }
   if (iterKind == IteratorKind::Async) {
-    if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::value())) {
+    if (!emitAtomOp(JSOp::GetProp, TaggedParserAtomIndex::WellKnown::value())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RESULT
       return false;
     }
-    if (!emitAwaitInInnermostScope()) {
+    if (!emitAwaitInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER RESULT
       return false;
     }
   }
-  if (!emitGetDotGeneratorInInnermostScope()) {
+  if (!emitGetDotGeneratorInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RESULT GENOBJ
     return false;
   }
-  if (!emitYieldOp(JSOp::Yield)) {
+  if (!emitYieldOp(JSOp::Yield)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RVAL GENOBJ RESUMEKIND
     return false;
   }
-  if (!emit1(JSOp::Swap)) {
+  if (!emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RVAL RESUMEKIND GENOBJ
     return false;
   }
-  if (!emit1(JSOp::Pop)) {
+  if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RVAL RESUMEKIND
     return false;
   }
-  if (!loopInfo.emitLoopEnd(this, JSOp::Goto, TryNoteKind::Loop)) {
+  if (!loopInfo.emitLoopEnd(this, JSOp::Goto, TryNoteKind::Loop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RVAL RESUMEKIND
     return false;
   }
@@ -6850,11 +6850,11 @@ bool BytecodeEmitter::emitYieldStar(Pars
   // Step 7.b.ii.6.a.
   //
   // result.value
-  if (!emit2(JSOp::Unpick, 2)) {
+  if (!emit2(JSOp::Unpick, 2)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] RESULT NEXT ITER
     return false;
   }
-  if (!emitPopN(2)) {
+  if (!emitPopN(2)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] RESULT
     return false;
   }
@@ -6898,7 +6898,7 @@ bool BytecodeEmitter::emitExpressionStat
   /* Don't eliminate expressions with side effects. */
   ParseNode* expr = exprStmt->kid();
   if (!useful) {
-    if (!checkSideEffects(expr, &useful)) {
+    if (!checkSideEffects(expr, &useful)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -6919,10 +6919,10 @@ bool BytecodeEmitter::emitExpressionStat
     ValueUsage valueUsage =
         wantval ? ValueUsage::WantValue : ValueUsage::IgnoreValue;
     ExpressionStatementEmitter ese(this, valueUsage);
-    if (!ese.prepareForExpr(Some(exprStmt->pn_pos.begin))) {
-      return false;
-    }
-    if (!markStepBreakpoint()) {
+    if (!ese.prepareForExpr(Some(exprStmt->pn_pos.begin))) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!markStepBreakpoint()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!emitTree(expr, valueUsage)) {
@@ -6959,15 +6959,15 @@ bool BytecodeEmitter::emitDeleteProperty
     // call or the super-base is not an object, before throwing a
     // ReferenceError for attempting to delete a super-reference.
     UnaryNode* base = &propExpr->expression().as<UnaryNode>();
-    if (!emitGetThisForSuperBase(base)) {
+    if (!emitGetThisForSuperBase(base)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] THIS
       return false;
     }
   } else {
-    if (!poe.prepareForObj()) {
-      return false;
-    }
-    if (!emitPropLHS(propExpr)) {
+    if (!poe.prepareForObj()) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!emitPropLHS(propExpr)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] OBJ
       return false;
     }
@@ -7002,26 +7002,26 @@ bool BytecodeEmitter::emitDeleteElement(
     // call, or trigger side-effects when evaluating ToPropertyKey(foo),
     // or also throw when the super-base is not an object, before throwing
     // a ReferenceError for attempting to delete a super-reference.
-    if (!eoe.prepareForObj()) {
+    if (!eoe.prepareForObj()) {MOZ_RELEASE_ASSERT(0);
       //            [stack]
       return false;
     }
 
     UnaryNode* base = &elemExpr->expression().as<UnaryNode>();
-    if (!emitGetThisForSuperBase(base)) {
+    if (!emitGetThisForSuperBase(base)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] THIS
       return false;
     }
-    if (!eoe.prepareForKey()) {
+    if (!eoe.prepareForKey()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] THIS
       return false;
     }
-    if (!emitTree(&elemExpr->key())) {
+    if (!emitTree(&elemExpr->key())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] THIS KEY
       return false;
     }
   } else {
-    if (!emitElemObjAndKey(elemExpr, false, eoe)) {
+    if (!emitElemObjAndKey(elemExpr, false, eoe)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] OBJ KEY
       return false;
     }
@@ -7045,12 +7045,12 @@ bool BytecodeEmitter::emitDeleteExpressi
   // If useless, just emit JSOp::True; otherwise convert |delete <expr>| to
   // effectively |<expr>, true|.
   bool useful = false;
-  if (!checkSideEffects(expression, &useful)) {
+  if (!checkSideEffects(expression, &useful)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (useful) {
-    if (!emitTree(expression)) {
+    if (!emitTree(expression)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!emit1(JSOp::Pop)) {
@@ -7115,16 +7115,16 @@ bool BytecodeEmitter::emitDeleteProperty
   PropOpEmitter poe(this, PropOpEmitter::Kind::Delete,
                     PropOpEmitter::ObjKind::Other);
 
-  if (!poe.prepareForObj()) {
+  if (!poe.prepareForObj()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
-  if (!emitOptionalTree(&propExpr->expression(), oe)) {
+  if (!emitOptionalTree(&propExpr->expression(), oe)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ
     return false;
   }
   if (propExpr->isKind(ParseNodeKind::OptionalDotExpr)) {
-    if (!oe.emitJumpShortCircuit()) {
+    if (!oe.emitJumpShortCircuit()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] # if Jump
       //            [stack] UNDEFINED-OR-NULL
       //            [stack] # otherwise
@@ -7148,18 +7148,18 @@ bool BytecodeEmitter::emitDeleteElementI
   ElemOpEmitter eoe(this, ElemOpEmitter::Kind::Delete,
                     ElemOpEmitter::ObjKind::Other, NameVisibility::Public);
 
-  if (!eoe.prepareForObj()) {
+  if (!eoe.prepareForObj()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
-  if (!emitOptionalTree(&elemExpr->expression(), oe)) {
+  if (!emitOptionalTree(&elemExpr->expression(), oe)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ
     return false;
   }
 
   if (elemExpr->isKind(ParseNodeKind::OptionalElemExpr)) {
-    if (!oe.emitJumpShortCircuit()) {
+    if (!oe.emitJumpShortCircuit()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] # if Jump
       //            [stack] UNDEFINED-OR-NULL
       //            [stack] # otherwise
@@ -7168,12 +7168,12 @@ bool BytecodeEmitter::emitDeleteElementI
     }
   }
 
-  if (!eoe.prepareForKey()) {
+  if (!eoe.prepareForKey()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ
     return false;
   }
 
-  if (!emitTree(&elemExpr->key())) {
+  if (!emitTree(&elemExpr->key())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ KEY
     return false;
   }
@@ -7216,13 +7216,13 @@ bool BytecodeEmitter::emitSelfHostedCall
 
   const char* errorName = SelfHostedCallFunctionName(calleeNode->name(), cx);
 
-  if (argsList->count() < 2) {
+  if (argsList->count() < 2) {MOZ_RELEASE_ASSERT(0);
     reportNeedMoreArgsError(calleeNode, errorName, "2", "s", argsList);
     return false;
   }
 
   JSOp callOp = callNode->callOp();
-  if (callOp != JSOp::Call) {
+  if (callOp != JSOp::Call) {MOZ_RELEASE_ASSERT(0);
     reportError(callNode, JSMSG_NOT_CONSTRUCTOR, errorName);
     return false;
   }
@@ -7238,7 +7238,7 @@ bool BytecodeEmitter::emitSelfHostedCall
     callOp = JSOp::FunApply;
   }
 
-  if (!emitTree(funNode)) {
+  if (!emitTree(funNode)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -7255,25 +7255,25 @@ bool BytecodeEmitter::emitSelfHostedCall
   if (constructing) {
     // Save off the new.target value, but here emit a proper |this| for a
     // constructing call.
-    if (!emit1(JSOp::IsConstructing)) {
+    if (!emit1(JSOp::IsConstructing)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
     // It's |this|, emit it.
-    if (!emitTree(thisOrNewTarget)) {
+    if (!emitTree(thisOrNewTarget)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   for (ParseNode* argpn = thisOrNewTarget->pn_next; argpn;
        argpn = argpn->pn_next) {
-    if (!emitTree(argpn)) {
+    if (!emitTree(argpn)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   if (constructing) {
-    if (!emitTree(thisOrNewTarget)) {
+    if (!emitTree(thisOrNewTarget)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -7290,19 +7290,19 @@ bool BytecodeEmitter::emitSelfHostedResu
   ListNode* argsList = &callNode->right()->as<ListNode>();
 
   // Syntax: resumeGenerator(gen, value, 'next'|'throw'|'return')
-  if (argsList->count() != 3) {
+  if (argsList->count() != 3) {MOZ_RELEASE_ASSERT(0);
     reportNeedMoreArgsError(callNode, "resumeGenerator", "3", "s", argsList);
     return false;
   }
 
   ParseNode* genNode = argsList->head();
-  if (!emitTree(genNode)) {
+  if (!emitTree(genNode)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] GENERATOR
     return false;
   }
 
   ParseNode* valNode = genNode->pn_next;
-  if (!emitTree(valNode)) {
+  if (!emitTree(valNode)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] GENERATOR VALUE
     return false;
   }
@@ -7313,7 +7313,7 @@ bool BytecodeEmitter::emitSelfHostedResu
       ParserAtomToResumeKind(cx, kindNode->as<NameNode>().atom());
   MOZ_ASSERT(!kindNode->pn_next);
 
-  if (!emitPushResumeKind(kind)) {
+  if (!emitPushResumeKind(kind)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] GENERATOR VALUE RESUMEKIND
     return false;
   }
@@ -7331,7 +7331,7 @@ bool BytecodeEmitter::emitSelfHostedForc
   // the first bytecode op in the script.
   MOZ_ASSERT(bytecodeSection().code().empty());
 
-  if (!emit1(JSOp::ForceInterpreter)) {
+  if (!emit1(JSOp::ForceInterpreter)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!emit1(JSOp::Undefined)) {
@@ -7360,12 +7360,12 @@ bool BytecodeEmitter::emitSelfHostedDefi
   MOZ_ASSERT(argsList->count() == 3);
 
   ParseNode* objNode = argsList->head();
-  if (!emitTree(objNode)) {
+  if (!emitTree(objNode)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   ParseNode* idNode = objNode->pn_next;
-  if (!emitTree(idNode)) {
+  if (!emitTree(idNode)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -7383,13 +7383,13 @@ bool BytecodeEmitter::emitSelfHostedDefi
 bool BytecodeEmitter::emitSelfHostedHasOwn(BinaryNode* callNode) {
   ListNode* argsList = &callNode->right()->as<ListNode>();
 
-  if (argsList->count() != 2) {
+  if (argsList->count() != 2) {MOZ_RELEASE_ASSERT(0);
     reportNeedMoreArgsError(callNode, "hasOwn", "2", "s", argsList);
     return false;
   }
 
   ParseNode* idNode = argsList->head();
-  if (!emitTree(idNode)) {
+  if (!emitTree(idNode)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -7404,7 +7404,7 @@ bool BytecodeEmitter::emitSelfHostedHasO
 bool BytecodeEmitter::emitSelfHostedGetPropertySuper(BinaryNode* callNode) {
   ListNode* argsList = &callNode->right()->as<ListNode>();
 
-  if (argsList->count() != 3) {
+  if (argsList->count() != 3) {MOZ_RELEASE_ASSERT(0);
     reportNeedMoreArgsError(callNode, "getPropertySuper", "3", "s", argsList);
     return false;
   }
@@ -7413,11 +7413,11 @@ bool BytecodeEmitter::emitSelfHostedGetP
   ParseNode* idNode = objNode->pn_next;
   ParseNode* receiverNode = idNode->pn_next;
 
-  if (!emitTree(receiverNode)) {
-    return false;
-  }
-
-  if (!emitTree(idNode)) {
+  if (!emitTree(receiverNode)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!emitTree(idNode)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -7431,7 +7431,7 @@ bool BytecodeEmitter::emitSelfHostedGetP
 bool BytecodeEmitter::emitSelfHostedToNumeric(BinaryNode* callNode) {
   ListNode* argsList = &callNode->right()->as<ListNode>();
 
-  if (argsList->count() != 1) {
+  if (argsList->count() != 1) {MOZ_RELEASE_ASSERT(0);
     reportNeedMoreArgsError(callNode, "ToNumeric", "1", "", argsList);
     return false;
   }
@@ -7448,7 +7448,7 @@ bool BytecodeEmitter::emitSelfHostedToNu
 bool BytecodeEmitter::emitSelfHostedToString(BinaryNode* callNode) {
   ListNode* argsList = &callNode->right()->as<ListNode>();
 
-  if (argsList->count() != 1) {
+  if (argsList->count() != 1) {MOZ_RELEASE_ASSERT(0);
     reportNeedMoreArgsError(callNode, "ToString", "1", "", argsList);
     return false;
   }
@@ -7466,7 +7466,7 @@ bool BytecodeEmitter::emitSelfHostedGetB
     BinaryNode* callNode, bool isConstructor) {
   ListNode* argsList = &callNode->right()->as<ListNode>();
 
-  if (argsList->count() != 1) {
+  if (argsList->count() != 1) {MOZ_RELEASE_ASSERT(0);
     const char* name =
         isConstructor ? "GetBuiltinConstructor" : "GetBuiltinPrototype";
     reportNeedMoreArgsError(callNode, name, "1", "", argsList);
@@ -7475,7 +7475,7 @@ bool BytecodeEmitter::emitSelfHostedGetB
 
   ParseNode* argNode = argsList->head();
 
-  if (!argNode->isKind(ParseNodeKind::StringExpr)) {
+  if (!argNode->isKind(ParseNodeKind::StringExpr)) {MOZ_RELEASE_ASSERT(0);
     reportError(callNode, JSMSG_UNEXPECTED_TYPE, "built-in name",
                 "not a string constant");
     return false;
@@ -7580,7 +7580,7 @@ bool BytecodeEmitter::emitOptionalCallee
                                                 CallNode* call,
                                                 CallOrNewEmitter& cone,
                                                 OptionalEmitter& oe) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -7776,24 +7776,24 @@ bool BytecodeEmitter::emitCalleeAndThis(
   return true;
 }
 
-bool BytecodeEmitter::emitPipeline(ListNode* node) {
+bool BytecodeEmitter::emitPipeline(ListNode* node) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(node->count() >= 2);
 
-  if (!emitTree(node->head())) {
+  if (!emitTree(node->head())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ARG
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   ParseNode* callee = node->head()->pn_next;
   CallOrNewEmitter cone(this, JSOp::Call,
                         CallOrNewEmitter::ArgumentsKind::Other,
                         ValueUsage::WantValue);
-  do {
-    if (!emitCalleeAndThis(callee, node, cone)) {
+  do {MOZ_RELEASE_ASSERT(0);
+    if (!emitCalleeAndThis(callee, node, cone)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ARG CALLEE THIS
       return false;
     }
-    if (!emit2(JSOp::Pick, 2)) {
+    if (!emit2(JSOp::Pick, 2)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CALLEE THIS ARG
       return false;
     }
@@ -7858,18 +7858,18 @@ ParseNode* BytecodeEmitter::getCoordNode
 bool BytecodeEmitter::emitArguments(ListNode* argsList, bool isCall,
                                     bool isSpread, CallOrNewEmitter& cone) {
   uint32_t argc = argsList->count();
-  if (argc >= ARGC_LIMIT) {
+  if (argc >= ARGC_LIMIT) {MOZ_RELEASE_ASSERT(0);
     reportError(argsList,
                 isCall ? JSMSG_TOO_MANY_FUN_ARGS : JSMSG_TOO_MANY_CON_ARGS);
     return false;
   }
   if (!isSpread) {
-    if (!cone.prepareForNonSpreadArguments()) {
+    if (!cone.prepareForNonSpreadArguments()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CALLEE THIS
       return false;
     }
     for (ParseNode* arg : argsList->contents()) {
-      if (!emitTree(arg)) {
+      if (!emitTree(arg)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] CALLEE THIS ARG*
         return false;
       }
@@ -7877,12 +7877,12 @@ bool BytecodeEmitter::emitArguments(List
   } else {
     if (cone.wantSpreadOperand()) {
       UnaryNode* spreadNode = &argsList->head()->as<UnaryNode>();
-      if (!emitTree(spreadNode->kid())) {
+      if (!emitTree(spreadNode->kid())) {MOZ_RELEASE_ASSERT(0);
         //          [stack] CALLEE THIS ARG0
         return false;
       }
     }
-    if (!cone.emitSpreadArgumentsTest()) {
+    if (!cone.emitSpreadArgumentsTest()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CALLEE THIS
       return false;
     }
@@ -7927,19 +7927,19 @@ bool BytecodeEmitter::emitOptionalCall(C
 
   ParseNode* coordNode = getCoordNode(callNode, calleeNode, op, argsList);
 
-  if (!emitOptionalCalleeAndThis(calleeNode, callNode, cone, oe)) {
+  if (!emitOptionalCalleeAndThis(calleeNode, callNode, cone, oe)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] CALLEE THIS
     return false;
   }
 
   if (callNode->isKind(ParseNodeKind::OptionalCallExpr)) {
-    if (!oe.emitJumpShortCircuitForCall()) {
+    if (!oe.emitJumpShortCircuitForCall()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CALLEE THIS
       return false;
     }
   }
 
-  if (!emitArguments(argsList, /* isCall = */ true, isSpread, cone)) {
+  if (!emitArguments(argsList, /* isCall = */ true, isSpread, cone)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] CALLEE THIS ARGS...
     return false;
   }
@@ -8064,7 +8064,7 @@ bool BytecodeEmitter::emitCallOrNew(
     //              [stack] CALLEE THIS
     return false;
   }
-  if (!emitArguments(argsList, isCall, isSpread, cone)) {
+  if (!emitArguments(argsList, isCall, isSpread, cone)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] CALLEE THIS ARGS...
     return false;
   }
@@ -8112,7 +8112,7 @@ bool BytecodeEmitter::emitRightAssociati
 
   // Right-associative operator chain.
   for (ParseNode* subexpr : node->contents()) {
-    if (!emitTree(subexpr)) {
+    if (!emitTree(subexpr)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -8126,13 +8126,13 @@ bool BytecodeEmitter::emitRightAssociati
 
 bool BytecodeEmitter::emitLeftAssociative(ListNode* node) {
   // Left-associative operator chain.
-  if (!emitTree(node->head())) {
+  if (!emitTree(node->head())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   JSOp op = BinaryOpParseNodeKindToJSOp(node->getKind());
   ParseNode* nextExpr = node->head()->pn_next;
   do {
-    if (!emitTree(nextExpr)) {
+    if (!emitTree(nextExpr)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!emit1(op)) {
@@ -8150,7 +8150,7 @@ bool BytecodeEmitter::emitLeftAssociativ
 bool BytecodeEmitter::emitOptionalTree(
     ParseNode* pn, OptionalEmitter& oe,
     ValueUsage valueUsage /* = ValueUsage::WantValue */) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   ParseNodeKind kind = pn->getKind();
@@ -8262,7 +8262,7 @@ bool BytecodeEmitter::emitCalleeAndThisF
   // in isolation.
   OptionalEmitter oe(this, bytecodeSection().stackDepth());
 
-  if (!emitOptionalCalleeAndThis(calleeNode, callNode, cone, oe)) {
+  if (!emitOptionalCalleeAndThis(calleeNode, callNode, cone, oe)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] CALLEE THIS
     return false;
   }
@@ -8288,7 +8288,7 @@ bool BytecodeEmitter::emitOptionalChain(
 
   OptionalEmitter oe(this, bytecodeSection().stackDepth());
 
-  if (!emitOptionalTree(expr, oe, valueUsage)) {
+  if (!emitOptionalTree(expr, oe, valueUsage)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] VAL
     return false;
   }
@@ -8308,19 +8308,19 @@ bool BytecodeEmitter::emitOptionalDotExp
                                                 PropOpEmitter& poe,
                                                 bool isSuper,
                                                 OptionalEmitter& oe) {
-  if (!poe.prepareForObj()) {
+  if (!poe.prepareForObj()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
   if (isSuper) {
     UnaryNode* base = &prop->expression().as<UnaryNode>();
-    if (!emitGetThisForSuperBase(base)) {
+    if (!emitGetThisForSuperBase(base)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] OBJ
       return false;
     }
   } else {
-    if (!emitOptionalTree(&prop->expression(), oe)) {
+    if (!emitOptionalTree(&prop->expression(), oe)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] OBJ
       return false;
     }
@@ -8328,7 +8328,7 @@ bool BytecodeEmitter::emitOptionalDotExp
 
   if (prop->isKind(ParseNodeKind::OptionalDotExpr)) {
     MOZ_ASSERT(!isSuper);
-    if (!oe.emitJumpShortCircuit()) {
+    if (!oe.emitJumpShortCircuit()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] # if Jump
       //            [stack] UNDEFINED-OR-NULL
       //            [stack] # otherwise
@@ -8349,19 +8349,19 @@ bool BytecodeEmitter::emitOptionalElemEx
                                                  ElemOpEmitter& eoe,
                                                  bool isSuper,
                                                  OptionalEmitter& oe) {
-  if (!eoe.prepareForObj()) {
+  if (!eoe.prepareForObj()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
   if (isSuper) {
     UnaryNode* base = &elem->expression().as<UnaryNode>();
-    if (!emitGetThisForSuperBase(base)) {
+    if (!emitGetThisForSuperBase(base)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] OBJ
       return false;
     }
   } else {
-    if (!emitOptionalTree(&elem->expression(), oe)) {
+    if (!emitOptionalTree(&elem->expression(), oe)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] OBJ
       return false;
     }
@@ -8369,7 +8369,7 @@ bool BytecodeEmitter::emitOptionalElemEx
 
   if (elem->isKind(ParseNodeKind::OptionalElemExpr)) {
     MOZ_ASSERT(!isSuper);
-    if (!oe.emitJumpShortCircuit()) {
+    if (!oe.emitJumpShortCircuit()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] # if Jump
       //            [stack] UNDEFINED-OR-NULL
       //            [stack] # otherwise
@@ -8378,12 +8378,12 @@ bool BytecodeEmitter::emitOptionalElemEx
     }
   }
 
-  if (!eoe.prepareForKey()) {
+  if (!eoe.prepareForKey()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ? OBJ
     return false;
   }
 
-  if (!emitTree(&elem->key())) {
+  if (!emitTree(&elem->key())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ? OBJ KEY
     return false;
   }
@@ -8416,7 +8416,7 @@ bool BytecodeEmitter::emitShortCircuit(L
   /* Left-associative operator chain: avoid too much recursion. */
   ParseNode* expr = node->head();
 
-  if (!emitTree(expr)) {
+  if (!emitTree(expr)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -8439,23 +8439,23 @@ bool BytecodeEmitter::emitShortCircuit(L
   if (!emitJump(op, &jump)) {
     return false;
   }
-  if (!emit1(JSOp::Pop)) {
+  if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   /* Emit nodes between the head and the tail. */
   while ((expr = expr->pn_next)->pn_next) {
-    if (!emitTree(expr)) {
-      return false;
-    }
-    if (!emitJump(op, &jump)) {
-      return false;
-    }
-    if (!emit1(JSOp::Pop)) {
-      return false;
-    }
-  }
-  if (!emitTree(expr)) {
+    if (!emitTree(expr)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!emitJump(op, &jump)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+  }
+  if (!emitTree(expr)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -8468,11 +8468,11 @@ bool BytecodeEmitter::emitShortCircuit(L
 bool BytecodeEmitter::emitSequenceExpr(
     ListNode* node, ValueUsage valueUsage /* = ValueUsage::WantValue */) {
   for (ParseNode* child = node->head();; child = child->pn_next) {
-    if (!updateSourceCoordNotes(child->pn_pos.begin)) {
+    if (!updateSourceCoordNotes(child->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!emitTree(child,
-                  child->pn_next ? ValueUsage::IgnoreValue : valueUsage)) {
+                  child->pn_next ? ValueUsage::IgnoreValue : valueUsage)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!child->pn_next) {
@@ -8509,7 +8509,7 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
 
   label.emitLabel(name);
 
-  if (!emitTree(labeledStmt->statement())) {
+  if (!emitTree(labeledStmt->statement())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!label.emitEnd()) {
@@ -8523,7 +8523,7 @@ bool BytecodeEmitter::emitConditionalExp
     ConditionalExpression& conditional,
     ValueUsage valueUsage /* = ValueUsage::WantValue */) {
   CondEmitter cond(this);
-  if (!cond.emitCond()) {
+  if (!cond.emitCond()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -8536,23 +8536,23 @@ bool BytecodeEmitter::emitConditionalExp
 
   // NOTE: NotExpr of conditionNode may be unwrapped, and in that case the
   //       negation is handled by conditionKind.
-  if (!emitTree(conditionNode)) {
-    return false;
-  }
-
-  if (!cond.emitThenElse(conditionKind)) {
-    return false;
-  }
-
-  if (!emitTree(&conditional.thenExpression(), valueUsage)) {
-    return false;
-  }
-
-  if (!cond.emitElse()) {
-    return false;
-  }
-
-  if (!emitTree(&conditional.elseExpression(), valueUsage)) {
+  if (!emitTree(conditionNode)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!cond.emitThenElse(conditionKind)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!emitTree(&conditional.thenExpression(), valueUsage)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!cond.emitElse()) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!emitTree(&conditional.elseExpression(), valueUsage)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -8605,7 +8605,7 @@ void BytecodeEmitter::isPropertyListObjL
         keysOK = false;
         break;
       }
-      if (!ObjLiteralWriter::arrayIndexInRange(i)) {
+      if (!ObjLiteralWriter::arrayIndexInRange(i)) {MOZ_RELEASE_ASSERT(0);
         keysOK = false;
         break;
       }
@@ -8640,7 +8640,7 @@ void BytecodeEmitter::isPropertyListObjL
 
 bool BytecodeEmitter::isArrayObjLiteralCompatible(ParseNode* arrayHead) {
   for (ParseNode* elem = arrayHead; elem; elem = elem->pn_next) {
-    if (elem->isKind(ParseNodeKind::Spread)) {
+    if (elem->isKind(ParseNodeKind::Spread)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!isRHSObjLiteralCompatible(elem)) {
@@ -8667,19 +8667,19 @@ bool BytecodeEmitter::emitPropertyList(L
             field->isStatic()
                 ? TaggedParserAtomIndex::WellKnown::dotStaticFieldKeys()
                 : TaggedParserAtomIndex::WellKnown::dotFieldKeys();
-        if (!emitGetName(fieldKeys)) {
+        if (!emitGetName(fieldKeys)) {MOZ_RELEASE_ASSERT(0);
           //        [stack] CTOR? OBJ ARRAY
           return false;
         }
 
         ParseNode* nameExpr = field->name().as<UnaryNode>().kid();
 
-        if (!emitTree(nameExpr, ValueUsage::WantValue, EMIT_LINENOTE)) {
+        if (!emitTree(nameExpr, ValueUsage::WantValue, EMIT_LINENOTE)) {MOZ_RELEASE_ASSERT(0);
           //        [stack] CTOR? OBJ ARRAY KEY
           return false;
         }
 
-        if (!emit1(JSOp::ToPropertyKey)) {
+        if (!emit1(JSOp::ToPropertyKey)) {MOZ_RELEASE_ASSERT(0);
           //        [stack] CTOR? OBJ ARRAY KEY
           return false;
         }
@@ -8691,12 +8691,12 @@ bool BytecodeEmitter::emitPropertyList(L
           fieldKeysIndex = curFieldKeyIndex++;
         }
 
-        if (!emitUint32Operand(JSOp::InitElemArray, fieldKeysIndex)) {
+        if (!emitUint32Operand(JSOp::InitElemArray, fieldKeysIndex)) {MOZ_RELEASE_ASSERT(0);
           //        [stack] CTOR? OBJ ARRAY
           return false;
         }
 
-        if (!emit1(JSOp::Pop)) {
+        if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
           //        [stack] CTOR? OBJ
           return false;
         }
@@ -8717,15 +8717,15 @@ bool BytecodeEmitter::emitPropertyList(L
     if (propdef->isKind(ParseNodeKind::MutateProto)) {
       //            [stack] OBJ
       MOZ_ASSERT(type == ObjectLiteral);
-      if (!pe.prepareForProtoValue(Some(propdef->pn_pos.begin))) {
+      if (!pe.prepareForProtoValue(Some(propdef->pn_pos.begin))) {MOZ_RELEASE_ASSERT(0);
         //          [stack] OBJ
         return false;
       }
-      if (!emitTree(propdef->as<UnaryNode>().kid())) {
+      if (!emitTree(propdef->as<UnaryNode>().kid())) {MOZ_RELEASE_ASSERT(0);
         //          [stack] OBJ PROTO
         return false;
       }
-      if (!pe.emitMutateProto()) {
+      if (!pe.emitMutateProto()) {MOZ_RELEASE_ASSERT(0);
         //          [stack] OBJ
         return false;
       }
@@ -8735,15 +8735,15 @@ bool BytecodeEmitter::emitPropertyList(L
     if (propdef->isKind(ParseNodeKind::Spread)) {
       MOZ_ASSERT(type == ObjectLiteral);
       //            [stack] OBJ
-      if (!pe.prepareForSpreadOperand(Some(propdef->pn_pos.begin))) {
+      if (!pe.prepareForSpreadOperand(Some(propdef->pn_pos.begin))) {MOZ_RELEASE_ASSERT(0);
         //          [stack] OBJ OBJ
         return false;
       }
-      if (!emitTree(propdef->as<UnaryNode>().kid())) {
+      if (!emitTree(propdef->as<UnaryNode>().kid())) {MOZ_RELEASE_ASSERT(0);
         //          [stack] OBJ OBJ VAL
         return false;
       }
-      if (!pe.emitSpread()) {
+      if (!pe.emitSpread()) {MOZ_RELEASE_ASSERT(0);
         //          [stack] OBJ
         return false;
       }
@@ -8841,31 +8841,31 @@ bool BytecodeEmitter::emitPropertyList(L
     if (key->isKind(ParseNodeKind::NumberExpr) ||
         key->isKind(ParseNodeKind::BigIntExpr)) {
       //            [stack] CTOR? OBJ
-      if (!pe.prepareForIndexPropKey(Some(propdef->pn_pos.begin), kind)) {
+      if (!pe.prepareForIndexPropKey(Some(propdef->pn_pos.begin), kind)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] CTOR? OBJ CTOR?
         return false;
       }
       if (key->isKind(ParseNodeKind::NumberExpr)) {
-        if (!emitNumberOp(key->as<NumericLiteral>().value())) {
+        if (!emitNumberOp(key->as<NumericLiteral>().value())) {MOZ_RELEASE_ASSERT(0);
           //        [stack] CTOR? OBJ CTOR? KEY
           return false;
         }
       } else {
-        if (!emitBigIntOp(&key->as<BigIntLiteral>())) {
+        if (!emitBigIntOp(&key->as<BigIntLiteral>())) {MOZ_RELEASE_ASSERT(0);
           //        [stack] CTOR? OBJ CTOR? KEY
           return false;
         }
       }
-      if (!pe.prepareForIndexPropValue()) {
+      if (!pe.prepareForIndexPropValue()) {MOZ_RELEASE_ASSERT(0);
         //          [stack] CTOR? OBJ CTOR? KEY
         return false;
       }
-      if (!emitValue()) {
+      if (!emitValue()) {MOZ_RELEASE_ASSERT(0);
         //          [stack] CTOR? OBJ CTOR? KEY VAL
         return false;
       }
 
-      if (!pe.emitInitIndexOrComputed(accessorType)) {
+      if (!pe.emitInitIndexOrComputed(accessorType)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -8880,23 +8880,23 @@ bool BytecodeEmitter::emitPropertyList(L
       if (type == ClassBody &&
           key->as<NameNode>().atom() ==
               TaggedParserAtomIndex::WellKnown::constructor() &&
-          !propdef->as<ClassMethod>().isStatic()) {
+          !propdef->as<ClassMethod>().isStatic()) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
 
-      if (!pe.prepareForPropValue(Some(propdef->pn_pos.begin), kind)) {
+      if (!pe.prepareForPropValue(Some(propdef->pn_pos.begin), kind)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] CTOR? OBJ CTOR?
         return false;
       }
 
-      if (!emitValue()) {
+      if (!emitValue()) {MOZ_RELEASE_ASSERT(0);
         //          [stack] CTOR? OBJ CTOR? VAL
         return false;
       }
 
       auto keyAtom = key->as<NameNode>().atom();
 
-      if (!pe.emitInit(accessorType, keyAtom)) {
+      if (!pe.emitInit(accessorType, keyAtom)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -8908,42 +8908,42 @@ bool BytecodeEmitter::emitPropertyList(L
 
     //              [stack] CTOR? OBJ
 
-    if (!pe.prepareForComputedPropKey(Some(propdef->pn_pos.begin), kind)) {
+    if (!pe.prepareForComputedPropKey(Some(propdef->pn_pos.begin), kind)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CTOR? OBJ CTOR?
       return false;
     }
     if (key->is<NameNode>()) {
-      if (!emitGetPrivateName(&key->as<NameNode>())) {
+      if (!emitGetPrivateName(&key->as<NameNode>())) {MOZ_RELEASE_ASSERT(0);
         //          [stack] CTOR? OBJ CTOR? KEY
         return false;
       }
     } else {
-      if (!emitTree(key->as<UnaryNode>().kid())) {
+      if (!emitTree(key->as<UnaryNode>().kid())) {MOZ_RELEASE_ASSERT(0);
         //          [stack] CTOR? OBJ CTOR? KEY
         return false;
       }
     }
-    if (!pe.prepareForComputedPropValue()) {
+    if (!pe.prepareForComputedPropValue()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CTOR? OBJ CTOR? KEY
       return false;
     }
-    if (!emitValue()) {
+    if (!emitValue()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CTOR? OBJ CTOR? KEY VAL
       return false;
     }
 
-    if (!pe.emitInitIndexOrComputed(accessorType)) {
+    if (!pe.emitInitIndexOrComputed(accessorType)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (key->isKind(ParseNodeKind::PrivateName) &&
         key->as<NameNode>().privateNameKind() == PrivateNameKind::Setter) {
-      if (!emitGetPrivateName(&key->as<NameNode>())) {
+      if (!emitGetPrivateName(&key->as<NameNode>())) {MOZ_RELEASE_ASSERT(0);
         //          [stack] THIS NAME
         return false;
       }
       if (!emitAtomOp(JSOp::GetIntrinsic,
-                      TaggedParserAtomIndex::WellKnown::NoPrivateGetter())) {
+                      TaggedParserAtomIndex::WellKnown::NoPrivateGetter())) {MOZ_RELEASE_ASSERT(0);
         //          [stack] THIS NAME FUN
         return false;
       }
@@ -8994,7 +8994,7 @@ bool BytecodeEmitter::emitPropertyListOb
         writer.setPropNameNoDuplicateCheck(parserAtoms(), propName);
       } else {
         if (!writer.setPropName(cx, parserAtoms(),
-                                key->as<NameNode>().atom())) {
+                                key->as<NameNode>().atom())) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -9012,18 +9012,18 @@ bool BytecodeEmitter::emitPropertyListOb
     if (useObjLiteralValues) {
       MOZ_ASSERT(singleton);
       ParseNode* value = prop->right();
-      if (!emitObjLiteralValue(writer, value)) {
+      if (!emitObjLiteralValue(writer, value)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
-      if (!writer.propWithUndefinedValue(cx)) {
+      if (!writer.propWithUndefinedValue(cx)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
   }
 
   GCThingIndex index;
-  if (!addObjLiteralData(writer, &index)) {
+  if (!addObjLiteralData(writer, &index)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -9053,24 +9053,24 @@ bool BytecodeEmitter::emitDestructuringR
     }
 
     TaggedParserAtomIndex atom;
-    if (member->isKind(ParseNodeKind::MutateProto)) {
+    if (member->isKind(ParseNodeKind::MutateProto)) {MOZ_RELEASE_ASSERT(0);
       atom = TaggedParserAtomIndex::WellKnown::proto();
     } else {
       ParseNode* key = member->as<BinaryNode>().left();
       atom = key->as<NameNode>().atom();
     }
 
-    if (!writer.setPropName(cx, parserAtoms(), atom)) {
-      return false;
-    }
-
-    if (!writer.propWithUndefinedValue(cx)) {
+    if (!writer.setPropName(cx, parserAtoms(), atom)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+
+    if (!writer.propWithUndefinedValue(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   GCThingIndex index;
-  if (!addObjLiteralData(writer, &index)) {
+  if (!addObjLiteralData(writer, &index)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -9098,13 +9098,13 @@ bool BytecodeEmitter::emitObjLiteralArra
 
   writer.beginDenseArrayElements();
   for (ParseNode* elem = arrayHead; elem; elem = elem->pn_next) {
-    if (!emitObjLiteralValue(writer, elem)) {
+    if (!emitObjLiteralValue(writer, elem)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   GCThingIndex index;
-  if (!addObjLiteralData(writer, &index)) {
+  if (!addObjLiteralData(writer, &index)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -9138,29 +9138,29 @@ bool BytecodeEmitter::emitObjLiteralValu
     } else {
       v.setDouble(numValue);
     }
-    if (!writer.propWithConstNumericValue(cx, v)) {
+    if (!writer.propWithConstNumericValue(cx, v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else if (value->isKind(ParseNodeKind::TrueExpr)) {
-    if (!writer.propWithTrueValue(cx)) {
+    if (!writer.propWithTrueValue(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else if (value->isKind(ParseNodeKind::FalseExpr)) {
-    if (!writer.propWithFalseValue(cx)) {
+    if (!writer.propWithFalseValue(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else if (value->isKind(ParseNodeKind::NullExpr)) {
-    if (!writer.propWithNullValue(cx)) {
+    if (!writer.propWithNullValue(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else if (value->isKind(ParseNodeKind::RawUndefinedExpr)) {
-    if (!writer.propWithUndefinedValue(cx)) {
+    if (!writer.propWithUndefinedValue(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else if (value->isKind(ParseNodeKind::StringExpr) ||
              value->isKind(ParseNodeKind::TemplateStringExpr)) {
     if (!writer.propWithAtomValue(cx, parserAtoms(),
-                                  value->as<NameNode>().atom())) {
+                                  value->as<NameNode>().atom())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -9235,16 +9235,16 @@ bool BytecodeEmitter::emitCreateFieldKey
                        ? TaggedParserAtomIndex::WellKnown::dotStaticFieldKeys()
                        : TaggedParserAtomIndex::WellKnown::dotFieldKeys();
   NameOpEmitter noe(this, fieldKeys, NameOpEmitter::Kind::Initialize);
-  if (!noe.prepareForRhs()) {
-    return false;
-  }
-
-  if (!emitUint32Operand(JSOp::NewArray, numFieldKeys)) {
+  if (!noe.prepareForRhs()) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!emitUint32Operand(JSOp::NewArray, numFieldKeys)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ARRAY
     return false;
   }
 
-  if (!noe.emitAssignment()) {
+  if (!noe.emitAssignment()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ARRAY
     return false;
   }
@@ -9267,7 +9267,7 @@ bool BytecodeEmitter::emitCreateMemberIn
   //                [stack] CTOR HOMEOBJ
   mozilla::Maybe<MemberInitializers> memberInitializers =
       setupMemberInitializers(obj, placement);
-  if (!memberInitializers) {
+  if (!memberInitializers) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return false;
   }
@@ -9278,7 +9278,7 @@ bool BytecodeEmitter::emitCreateMemberIn
   }
 
   bool isStatic = placement == FieldPlacement::Static;
-  if (!ce.prepareForMemberInitializers(numInitializers, isStatic)) {
+  if (!ce.prepareForMemberInitializers(numInitializers, isStatic)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] HOMEOBJ HERITAGE? ARRAY
     // or:
     //              [stack] CTOR HOMEOBJ ARRAY
@@ -9289,7 +9289,7 @@ bool BytecodeEmitter::emitCreateMemberIn
   // so we stamp them onto the instance first.
   // Static private methods aren't implemented, so skip this step
   // if emitting static initializers.
-  if (!isStatic && !emitPrivateMethodInitializers(ce, obj)) {
+  if (!isStatic && !emitPrivateMethodInitializers(ce, obj)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -9303,10 +9303,10 @@ bool BytecodeEmitter::emitCreateMemberIn
 
     FunctionNode* initializer = propdef->as<ClassField>().initializer();
 
-    if (!ce.prepareForMemberInitializer()) {
-      return false;
-    }
-    if (!emitTree(initializer)) {
+    if (!ce.prepareForMemberInitializer()) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!emitTree(initializer)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HOMEOBJ HERITAGE? ARRAY LAMBDA
       // or:
       //            [stack] CTOR HOMEOBJ ARRAY LAMBDA
@@ -9314,14 +9314,14 @@ bool BytecodeEmitter::emitCreateMemberIn
     }
     if (initializer->funbox()->needsHomeObject()) {
       MOZ_ASSERT(initializer->funbox()->allowSuperProperty());
-      if (!ce.emitMemberInitializerHomeObject(isStatic)) {
+      if (!ce.emitMemberInitializerHomeObject(isStatic)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] HOMEOBJ HERITAGE? ARRAY LAMBDA
         // or:
         //          [stack] CTOR HOMEOBJ ARRAY LAMBDA
         return false;
       }
     }
-    if (!ce.emitStoreMemberInitializer()) {
+    if (!ce.emitStoreMemberInitializer()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HOMEOBJ HERITAGE? ARRAY
       // or:
       //            [stack] CTOR HOMEOBJ ARRAY
@@ -9350,7 +9350,7 @@ bool BytecodeEmitter::emitPrivateMethodI
       continue;
     }
 
-    if (!ce.prepareForMemberInitializer()) {
+    if (!ce.prepareForMemberInitializer()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HOMEOBJ HERITAGE? ARRAY
       // or:
       //            [stack] CTOR HOMEOBJ ARRAY
@@ -9361,7 +9361,7 @@ bool BytecodeEmitter::emitPrivateMethodI
     // private method body.
     StringBuffer storedMethodName(cx);
     if (!storedMethodName.append(parserAtoms(),
-                                 propName->as<NameNode>().atom())) {
+                                 propName->as<NameNode>().atom())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     AccessorType accessorType = propdef->as<ClassMethod>().accessorType();
@@ -9387,7 +9387,7 @@ bool BytecodeEmitter::emitPrivateMethodI
     auto storedMethodAtom = storedMethodName.finishParserAtom(parserAtoms());
 
     // Emit the private method body and store it as a lexical var.
-    if (!emitFunction(&propdef->as<ClassMethod>().method())) {
+    if (!emitFunction(&propdef->as<ClassMethod>().method())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HOMEOBJ HERITAGE? ARRAY METHOD
       // or:
       //            [stack] CTOR HOMEOBJ ARRAY METHOD
@@ -9395,19 +9395,19 @@ bool BytecodeEmitter::emitPrivateMethodI
     }
     // The private method body needs to access the home object,
     // and the CE knows where that is on the stack.
-    if (!ce.emitMemberInitializerHomeObject(false)) {
+    if (!ce.emitMemberInitializerHomeObject(false)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HOMEOBJ HERITAGE? ARRAY METHOD
       // or:
       //            [stack] CTOR HOMEOBJ ARRAY METHOD
       return false;
     }
-    if (!emitLexicalInitialization(storedMethodAtom)) {
+    if (!emitLexicalInitialization(storedMethodAtom)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HOMEOBJ HERITAGE? ARRAY METHOD
       // or:
       //            [stack] CTOR HOMEOBJ ARRAY METHOD
       return false;
     }
-    if (!emit1(JSOp::Pop)) {
+    if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HOMEOBJ HERITAGE? ARRAY
       // or:
       //            [stack] CTOR HOMEOBJ ARRAY
@@ -9415,7 +9415,7 @@ bool BytecodeEmitter::emitPrivateMethodI
     }
 
     if (!emitPrivateMethodInitializer(ce, propdef, propName, storedMethodAtom,
-                                      accessorType)) {
+                                      accessorType)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HOMEOBJ HERITAGE? ARRAY
       // or:
       //            [stack] CTOR HOMEOBJ ARRAY
@@ -9443,39 +9443,39 @@ bool BytecodeEmitter::emitPrivateMethodI
   FunctionBox* funbox = funNode->funbox();
   FunctionEmitter fe(this, funbox, funNode->syntaxKind(),
                      FunctionEmitter::IsHoisted::No);
-  if (!fe.prepareForNonLazy()) {
+  if (!fe.prepareForNonLazy()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
   BytecodeEmitter bce2(this, parser, funbox, compilationState, emitterMode);
-  if (!bce2.init(funNode->pn_pos)) {
+  if (!bce2.init(funNode->pn_pos)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   ListNode* paramsBody = &funNode->body()->as<ListNode>();
   FunctionScriptEmitter fse(&bce2, funbox, Nothing(), Nothing());
-  if (!fse.prepareForParameters()) {
+  if (!fse.prepareForParameters()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
-  if (!bce2.emitFunctionFormalParameters(paramsBody)) {
+  if (!bce2.emitFunctionFormalParameters(paramsBody)) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
-  if (!fse.prepareForBody()) {
+  if (!fse.prepareForBody()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
-  if (!bce2.emit1(JSOp::FunctionThis)) {
+  if (!bce2.emit1(JSOp::FunctionThis)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] THIS
     return false;
   }
-  if (!bce2.emitGetPrivateName(&propName->as<NameNode>())) {
+  if (!bce2.emitGetPrivateName(&propName->as<NameNode>())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] THIS NAME
     return false;
   }
-  if (!bce2.emitGetName(storedMethodAtom)) {
+  if (!bce2.emitGetName(storedMethodAtom)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] THIS NAME METHOD
     return false;
   }
@@ -9527,16 +9527,16 @@ bool BytecodeEmitter::emitPrivateMethodI
   }
 
   // Pop remaining THIS.
-  if (!bce2.emit1(JSOp::Pop)) {
+  if (!bce2.emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
-  if (!fse.emitEndBody()) {
+  if (!fse.emitEndBody()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
-  if (!fse.intoStencil()) {
+  if (!fse.intoStencil()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -9582,7 +9582,7 @@ bool BytecodeEmitter::emitInitializeInst
     return true;
   }
 
-  if (!emitGetName(TaggedParserAtomIndex::WellKnown::dotInitializers())) {
+  if (!emitGetName(TaggedParserAtomIndex::WellKnown::dotInitializers())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ARRAY
     return false;
   }
@@ -9592,29 +9592,29 @@ bool BytecodeEmitter::emitInitializeInst
       // We Dup to keep the array around (it is consumed in the bytecode
       // below) for next iterations of this loop, except for the last
       // iteration, which avoids an extra Pop at the end of the loop.
-      if (!emit1(JSOp::Dup)) {
+      if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ARRAY ARRAY
         return false;
       }
     }
 
-    if (!emitNumberOp(index)) {
+    if (!emitNumberOp(index)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ARRAY? ARRAY INDEX
       return false;
     }
 
-    if (!emit1(JSOp::GetElem)) {
+    if (!emit1(JSOp::GetElem)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ARRAY? FUNC
       return false;
     }
 
     // This is guaranteed to run after super(), so we don't need TDZ checks.
-    if (!emitGetName(TaggedParserAtomIndex::WellKnown::dotThis())) {
+    if (!emitGetName(TaggedParserAtomIndex::WellKnown::dotThis())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ARRAY? FUNC THIS
       return false;
     }
 
-    if (!emitCall(JSOp::CallIgnoresRv, 0)) {
+    if (!emitCall(JSOp::CallIgnoresRv, 0)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ARRAY? RVAL
       return false;
     }
@@ -9640,7 +9640,7 @@ bool BytecodeEmitter::emitInitializeStat
     return true;
   }
 
-  if (!emitGetName(TaggedParserAtomIndex::WellKnown::dotStaticInitializers())) {
+  if (!emitGetName(TaggedParserAtomIndex::WellKnown::dotStaticInitializers())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] CTOR ARRAY
     return false;
   }
@@ -9651,33 +9651,33 @@ bool BytecodeEmitter::emitInitializeStat
       // We Dup to keep the array around (it is consumed in the bytecode below)
       // for next iterations of this loop, except for the last iteration, which
       // avoids an extra Pop at the end of the loop.
-      if (!emit1(JSOp::Dup)) {
+      if (!emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] CTOR ARRAY ARRAY
         return false;
       }
     }
 
-    if (!emitNumberOp(fieldIndex)) {
+    if (!emitNumberOp(fieldIndex)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CTOR ARRAY? ARRAY INDEX
       return false;
     }
 
-    if (!emit1(JSOp::GetElem)) {
+    if (!emit1(JSOp::GetElem)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CTOR ARRAY? FUNC
       return false;
     }
 
-    if (!emitDupAt(1 + hasNext)) {
+    if (!emitDupAt(1 + hasNext)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CTOR ARRAY? FUNC CTOR
       return false;
     }
 
-    if (!emitCall(JSOp::CallIgnoresRv, 0)) {
+    if (!emitCall(JSOp::CallIgnoresRv, 0)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CTOR ARRAY? RVAL
       return false;
     }
 
-    if (!emit1(JSOp::Pop)) {
+    if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CTOR ARRAY?
       return false;
     }
@@ -9711,7 +9711,7 @@ bool BytecodeEmitter::emitInitializeStat
   };
 
   if (!clearStaticFieldSlot(
-          TaggedParserAtomIndex::WellKnown::dotStaticInitializers())) {
+          TaggedParserAtomIndex::WellKnown::dotStaticInitializers())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -9799,21 +9799,21 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
     // fixups so that at GC-publish time at the end of parse, the full (case 1
     // or 2) or template-without-values (case 3) object can be allocated and
     // the bytecode can be patched to refer to it.
-    if (!emitPropertyListObjLiteral(objNode, flags, useObjLiteralValues)) {
+    if (!emitPropertyListObjLiteral(objNode, flags, useObjLiteralValues)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] OBJ
       return false;
     }
     // Put the ObjectEmitter in the right state. This tells it that there will
     // already be an object on the stack as a result of the (eventual)
     // NewObject or Object op, and prepares it to emit values if needed.
-    if (!oe.emitObjectWithTemplateOnStack()) {
+    if (!oe.emitObjectWithTemplateOnStack()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] OBJ
       return false;
     }
     if (!useObjLiteralValues) {
       // Case 2 or 3 above: we still need to emit bytecode to fill in the
       // object's property values.
-      if (!emitPropertyList(objNode, oe, ObjectLiteral)) {
+      if (!emitPropertyList(objNode, oe, ObjectLiteral)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] OBJ
         return false;
       }
@@ -9821,11 +9821,11 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
   } else {
     // Case 4 above: no ObjLiteral use, just bytecode to build the object from
     // scratch.
-    if (!oe.emitObject(objNode->count())) {
+    if (!oe.emitObject(objNode->count())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] OBJ
       return false;
     }
-    if (!emitPropertyList(objNode, oe, ObjectLiteral)) {
+    if (!emitPropertyList(objNode, oe, ObjectLiteral)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] OBJ
       return false;
     }
@@ -9880,7 +9880,7 @@ bool BytecodeEmitter::emitArray(ParseNod
 
   // For arrays with spread, this is a very pessimistic allocation, the
   // minimum possible final size.
-  if (!emitUint32Operand(JSOp::NewArray, count - nspread)) {
+  if (!emitUint32Operand(JSOp::NewArray, count - nspread)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ARRAY
     return false;
   }
@@ -9891,18 +9891,18 @@ bool BytecodeEmitter::emitArray(ParseNod
   for (index = 0; elem; index++, elem = elem->pn_next) {
     if (!afterSpread && elem->isKind(ParseNodeKind::Spread)) {
       afterSpread = true;
-      if (!emitNumberOp(index)) {
+      if (!emitNumberOp(index)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ARRAY INDEX
         return false;
       }
     }
-    if (!updateSourceCoordNotes(elem->pn_pos.begin)) {
+    if (!updateSourceCoordNotes(elem->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     bool allowSelfHostedIterFlag = false;
     if (elem->isKind(ParseNodeKind::Elision)) {
-      if (!emit1(JSOp::Hole)) {
+      if (!emit1(JSOp::Hole)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -9914,34 +9914,34 @@ bool BytecodeEmitter::emitArray(ParseNod
       } else {
         expr = elem;
       }
-      if (!emitTree(expr, ValueUsage::WantValue, EMIT_LINENOTE)) {
+      if (!emitTree(expr, ValueUsage::WantValue, EMIT_LINENOTE)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ARRAY INDEX? VALUE
         return false;
       }
     }
     if (elem->isKind(ParseNodeKind::Spread)) {
-      if (!emitIterator()) {
+      if (!emitIterator()) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ARRAY INDEX NEXT ITER
         return false;
       }
-      if (!emit2(JSOp::Pick, 3)) {
+      if (!emit2(JSOp::Pick, 3)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] INDEX NEXT ITER ARRAY
         return false;
       }
-      if (!emit2(JSOp::Pick, 3)) {
+      if (!emit2(JSOp::Pick, 3)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] NEXT ITER ARRAY INDEX
         return false;
       }
-      if (!emitSpread(allowSelfHostedIterFlag)) {
+      if (!emitSpread(allowSelfHostedIterFlag)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ARRAY INDEX
         return false;
       }
     } else if (afterSpread) {
-      if (!emit1(JSOp::InitElemInc)) {
+      if (!emit1(JSOp::InitElemInc)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
-      if (!emitUint32Operand(JSOp::InitElemArray, index)) {
+      if (!emitUint32Operand(JSOp::InitElemArray, index)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -9976,7 +9976,7 @@ static inline JSOp UnaryOpParseNodeKindT
 }
 
 bool BytecodeEmitter::emitUnary(UnaryNode* unaryNode) {
-  if (!updateSourceCoordNotes(unaryNode->pn_pos.begin)) {
+  if (!updateSourceCoordNotes(unaryNode->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!emitTree(unaryNode->kid())) {
@@ -9988,7 +9988,7 @@ bool BytecodeEmitter::emitUnary(UnaryNod
 bool BytecodeEmitter::emitTypeof(UnaryNode* typeofNode, JSOp op) {
   MOZ_ASSERT(op == JSOp::Typeof || op == JSOp::TypeofExpr);
 
-  if (!updateSourceCoordNotes(typeofNode->pn_pos.begin)) {
+  if (!updateSourceCoordNotes(typeofNode->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -10048,21 +10048,21 @@ bool BytecodeEmitter::emitFunctionFormal
 
     if (isRest) {
       if (isDestructuring) {
-        if (!fpe.prepareForDestructuringRest()) {
+        if (!fpe.prepareForDestructuringRest()) {MOZ_RELEASE_ASSERT(0);
           //        [stack]
           return false;
         }
-        if (!emitDestructuring()) {
+        if (!emitDestructuring()) {MOZ_RELEASE_ASSERT(0);
           //        [stack]
           return false;
         }
-        if (!fpe.emitDestructuringRestEnd()) {
+        if (!fpe.emitDestructuringRestEnd()) {MOZ_RELEASE_ASSERT(0);
           //        [stack]
           return false;
         }
       } else {
         auto paramName = bindingElement->as<NameNode>().name();
-        if (!fpe.emitRest(paramName)) {
+        if (!fpe.emitRest(paramName)) {MOZ_RELEASE_ASSERT(0);
           //        [stack]
           return false;
         }
@@ -10073,36 +10073,36 @@ bool BytecodeEmitter::emitFunctionFormal
 
     if (isDestructuring) {
       if (hasInitializer) {
-        if (!fpe.prepareForDestructuringDefaultInitializer()) {
+        if (!fpe.prepareForDestructuringDefaultInitializer()) {MOZ_RELEASE_ASSERT(0);
           //        [stack]
           return false;
         }
-        if (!emitDefaultInitializer()) {
+        if (!emitDefaultInitializer()) {MOZ_RELEASE_ASSERT(0);
           //        [stack]
           return false;
         }
-        if (!fpe.prepareForDestructuringDefault()) {
+        if (!fpe.prepareForDestructuringDefault()) {MOZ_RELEASE_ASSERT(0);
           //        [stack]
           return false;
         }
-        if (!emitDestructuring()) {
+        if (!emitDestructuring()) {MOZ_RELEASE_ASSERT(0);
           //        [stack]
           return false;
         }
-        if (!fpe.emitDestructuringDefaultEnd()) {
+        if (!fpe.emitDestructuringDefaultEnd()) {MOZ_RELEASE_ASSERT(0);
           //        [stack]
           return false;
         }
       } else {
-        if (!fpe.prepareForDestructuring()) {
+        if (!fpe.prepareForDestructuring()) {MOZ_RELEASE_ASSERT(0);
           //        [stack]
           return false;
         }
-        if (!emitDestructuring()) {
+        if (!emitDestructuring()) {MOZ_RELEASE_ASSERT(0);
           //        [stack]
           return false;
         }
-        if (!fpe.emitDestructuringEnd()) {
+        if (!fpe.emitDestructuringEnd()) {MOZ_RELEASE_ASSERT(0);
           //        [stack]
           return false;
         }
@@ -10112,16 +10112,16 @@ bool BytecodeEmitter::emitFunctionFormal
     }
 
     if (hasInitializer) {
-      if (!fpe.prepareForDefault()) {
+      if (!fpe.prepareForDefault()) {MOZ_RELEASE_ASSERT(0);
         //          [stack]
         return false;
       }
-      if (!emitDefaultInitializer()) {
+      if (!emitDefaultInitializer()) {MOZ_RELEASE_ASSERT(0);
         //          [stack]
         return false;
       }
       auto paramName = bindingElement->as<NameNode>().name();
-      if (!fpe.emitDefaultEnd(paramName)) {
+      if (!fpe.emitDefaultEnd(paramName)) {MOZ_RELEASE_ASSERT(0);
         //          [stack]
         return false;
       }
@@ -10175,7 +10175,7 @@ bool BytecodeEmitter::emitInitializeFunc
   if (funbox->argumentsHasVarBinding()) {
     if (!emitInitializeFunctionSpecialName(
             this, TaggedParserAtomIndex::WellKnown::arguments(),
-            JSOp::Arguments)) {
+            JSOp::Arguments)) {MOZ_RELEASE_ASSERT(0);
       //            [stack]
       return false;
     }
@@ -10187,7 +10187,7 @@ bool BytecodeEmitter::emitInitializeFunc
   if (funbox->functionHasThisBinding()) {
     if (!emitInitializeFunctionSpecialName(
             this, TaggedParserAtomIndex::WellKnown::dotThis(),
-            JSOp::FunctionThis)) {
+            JSOp::FunctionThis)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -10210,7 +10210,7 @@ bool BytecodeEmitter::emitLexicalInitial
 
 bool BytecodeEmitter::emitLexicalInitialization(TaggedParserAtomIndex name) {
   NameOpEmitter noe(this, name, NameOpEmitter::Kind::Initialize);
-  if (!noe.prepareForRhs()) {
+  if (!noe.prepareForRhs()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -10264,30 +10264,30 @@ bool BytecodeEmitter::emitNewPrivateName
 
     // TODO: Add a new bytecode to create private names.
     if (!emitAtomOp(JSOp::GetIntrinsic,
-                    TaggedParserAtomIndex::WellKnown::NewPrivateName())) {
+                    TaggedParserAtomIndex::WellKnown::NewPrivateName())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HERITAGE NEWPRIVATENAME
       return false;
     }
 
     // Push `undefined` as `this` parameter for call.
-    if (!emit1(JSOp::Undefined)) {
+    if (!emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HERITAGE NEWPRIVATENAME UNDEFINED
       return false;
     }
 
-    if (!emitAtomOp(JSOp::String, privateName)) {
+    if (!emitAtomOp(JSOp::String, privateName)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HERITAGE NEWPRIVATENAME UNDEFINED NAME
       return false;
     }
 
     int argc = 1;
-    if (!emitCall(JSOp::Call, argc)) {
+    if (!emitCall(JSOp::Call, argc)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HERITAGE PRIVATENAME
       return false;
     }
 
     // Add a binding for #name => privatename
-    if (!emitLexicalInitialization(privateName)) {
+    if (!emitLexicalInitialization(privateName)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HERITAGE PRIVATENAME
       return false;
     }
@@ -10336,7 +10336,7 @@ bool BytecodeEmitter::emitClass(
   }
 
   if (LexicalScopeNode* scopeBindings = classNode->scopeBindings()) {
-    if (!ce.emitScope(scopeBindings->scopeBindings())) {
+    if (!ce.emitScope(scopeBindings->scopeBindings())) {MOZ_RELEASE_ASSERT(0);
       //            [stack]
       return false;
     }
@@ -10344,13 +10344,13 @@ bool BytecodeEmitter::emitClass(
 
   bool isDerived = !!heritageExpression;
   if (isDerived) {
-    if (!updateSourceCoordNotes(classNode->pn_pos.begin)) {
-      return false;
-    }
-    if (!markStepBreakpoint()) {
-      return false;
-    }
-    if (!emitTree(heritageExpression)) {
+    if (!updateSourceCoordNotes(classNode->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!markStepBreakpoint()) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!emitTree(heritageExpression)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HERITAGE
       return false;
     }
@@ -10360,15 +10360,15 @@ bool BytecodeEmitter::emitClass(
   // the heritage expression and hence the scope must be emitted after the
   // heritage expression.
   if (LexicalScopeNode* bodyScopeBindings = classNode->bodyScopeBindings()) {
-    if (!ce.emitBodyScope(bodyScopeBindings->scopeBindings())) {
+    if (!ce.emitBodyScope(bodyScopeBindings->scopeBindings())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HERITAGE
       return false;
     }
 
-    if (!emitNewPrivateNames<ClassField>(classMembers)) {
-      return false;
-    }
-    if (!emitNewPrivateNames<ClassMethod>(classMembers)) {
+    if (!emitNewPrivateNames<ClassField>(classMembers)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!emitNewPrivateNames<ClassMethod>(classMembers)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -10376,12 +10376,12 @@ bool BytecodeEmitter::emitClass(
   bool hasNameOnStack = nameKind == ClassNameKind::ComputedName;
   if (isDerived) {
     if (!ce.emitDerivedClass(innerName, nameForAnonymousClass,
-                             hasNameOnStack)) {
+                             hasNameOnStack)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HERITAGE HOMEOBJ
       return false;
     }
   } else {
-    if (!ce.emitClass(innerName, nameForAnonymousClass, hasNameOnStack)) {
+    if (!ce.emitClass(innerName, nameForAnonymousClass, hasNameOnStack)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HOMEOBJ
       return false;
     }
@@ -10417,13 +10417,13 @@ bool BytecodeEmitter::emitClass(
     if (needsInitializers) {
       lse.emplace(this);
       if (!lse->emitScope(ScopeKind::Lexical,
-                          constructorScope->scopeBindings())) {
+                          constructorScope->scopeBindings())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       // Any class with field initializers will have a constructor
       if (!emitCreateMemberInitializers(ce, classMembers,
-                                        FieldPlacement::Instance)) {
+                                        FieldPlacement::Instance)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -10438,48 +10438,48 @@ bool BytecodeEmitter::emitClass(
   bool needsHomeObject = ctor->funbox()->needsHomeObject();
   // HERITAGE is consumed inside emitFunction.
   if (nameKind == ClassNameKind::InferredName) {
-    if (!setFunName(ctor->funbox(), nameForAnonymousClass)) {
-      return false;
-    }
-  }
-  if (!emitFunction(ctor, isDerived)) {
+    if (!setFunName(ctor->funbox(), nameForAnonymousClass)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+  }
+  if (!emitFunction(ctor, isDerived)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] HOMEOBJ CTOR
     return false;
   }
   if (lse.isSome()) {
-    if (!lse->emitEnd()) {
+    if (!lse->emitEnd()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     lse.reset();
   }
-  if (!ce.emitInitConstructor(needsHomeObject)) {
+  if (!ce.emitInitConstructor(needsHomeObject)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] CTOR HOMEOBJ
     return false;
   }
 
-  if (!emitCreateFieldKeys(classMembers, FieldPlacement::Instance)) {
-    return false;
-  }
-
-  if (!emitCreateMemberInitializers(ce, classMembers, FieldPlacement::Static)) {
-    return false;
-  }
-
-  if (!emitCreateFieldKeys(classMembers, FieldPlacement::Static)) {
-    return false;
-  }
-
-  if (!emitPropertyList(classMembers, ce, ClassBody)) {
+  if (!emitCreateFieldKeys(classMembers, FieldPlacement::Instance)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!emitCreateMemberInitializers(ce, classMembers, FieldPlacement::Static)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!emitCreateFieldKeys(classMembers, FieldPlacement::Static)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!emitPropertyList(classMembers, ce, ClassBody)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] CTOR HOMEOBJ
     return false;
   }
 
-  if (!ce.emitBinding()) {
+  if (!ce.emitBinding()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] CTOR
     return false;
   }
 
-  if (!emitInitializeStaticFields(classMembers)) {
+  if (!emitInitializeStaticFields(classMembers)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] CTOR
     return false;
   }
@@ -10503,17 +10503,17 @@ bool BytecodeEmitter::emitExportDefault(
     MOZ_ASSERT(exportNode->right());
 
     if (!emitAnonymousFunctionWithName(
-            valueNode, TaggedParserAtomIndex::WellKnown::default_())) {
+            valueNode, TaggedParserAtomIndex::WellKnown::default_())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
-    if (!emitTree(valueNode)) {
+    if (!emitTree(valueNode)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   if (ParseNode* binding = exportNode->right()) {
-    if (!emitLexicalInitialization(&binding->as<NameNode>())) {
+    if (!emitLexicalInitialization(&binding->as<NameNode>())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -10545,65 +10545,65 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
   unsigned initialDepth = bytecodeSection().stackDepth();
   InternalIfEmitter ifEmitter(this);
 
-  if (!emit1(JSOp::InstrumentationActive)) {
+  if (!emit1(JSOp::InstrumentationActive)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   //                [stack] ACTIVE
 
-  if (!ifEmitter.emitThen()) {
+  if (!ifEmitter.emitThen()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   //                [stack]
 
   // Push the instrumentation callback for the current realm as the callee.
-  if (!emit1(JSOp::InstrumentationCallback)) {
+  if (!emit1(JSOp::InstrumentationCallback)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   //                [stack] CALLBACK
 
   // Push undefined for the call's |this| value.
-  if (!emit1(JSOp::Undefined)) {
+  if (!emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   //                [stack] CALLBACK UNDEFINED
 
   auto atom =
       RealmInstrumentation::getInstrumentationKindName(cx, parserAtoms(), kind);
-  if (!atom) {
-    return false;
-  }
-
-  if (!emitAtomOp(JSOp::String, atom)) {
+  if (!atom) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!emitAtomOp(JSOp::String, atom)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   //                [stack] CALLBACK UNDEFINED KIND
 
-  if (!emit1(JSOp::InstrumentationScriptId)) {
+  if (!emit1(JSOp::InstrumentationScriptId)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   //                [stack] CALLBACK UNDEFINED KIND SCRIPT
 
   // Push the offset of the bytecode location following the instrumentation.
   BytecodeOffset updateOffset;
-  if (!emitN(JSOp::Int32, 4, &updateOffset)) {
+  if (!emitN(JSOp::Int32, 4, &updateOffset)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   //                [stack] CALLBACK UNDEFINED KIND SCRIPT OFFSET
 
   unsigned numPushed = bytecodeSection().stackDepth() - initialDepth;
 
-  if (pushOperandsCallback && !pushOperandsCallback(numPushed)) {
+  if (pushOperandsCallback && !pushOperandsCallback(numPushed)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   //                [stack] CALLBACK UNDEFINED KIND SCRIPT OFFSET ...EXTRA_ARGS
 
   unsigned argc = bytecodeSection().stackDepth() - initialDepth - 2;
-  if (!emitCall(JSOp::CallIgnoresRv, argc)) {
+  if (!emitCall(JSOp::CallIgnoresRv, argc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   //                [stack] RV
 
-  if (!emit1(JSOp::Pop)) {
+  if (!emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   //                [stack]
@@ -10652,7 +10652,7 @@ MOZ_NEVER_INLINE bool BytecodeEmitter::e
 bool BytecodeEmitter::emitTree(
     ParseNode* pn, ValueUsage valueUsage /* = ValueUsage::WantValue */,
     EmitLineNumberNote emitLineNote /* = EMIT_LINENOTE */) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -10661,7 +10661,7 @@ bool BytecodeEmitter::emitTree(
      relevant emitter functions for details. */
   if (emitLineNote == EMIT_LINENOTE &&
       !ParseNodeRequiresSpecialLineNumberNotes(pn)) {
-    if (!updateLineNumberNotes(pn->pn_pos.begin)) {
+    if (!updateLineNumberNotes(pn->pn_pos.begin)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -11235,7 +11235,7 @@ static bool AllocSrcNote(JSContext* cx, 
                          unsigned* index) {
   size_t oldLength = notes.length();
 
-  if (MOZ_UNLIKELY(oldLength + size > MaxSrcNotesLength)) {
+  if (MOZ_UNLIKELY(oldLength + size > MaxSrcNotesLength)) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return false;
   }
@@ -11278,7 +11278,7 @@ bool BytecodeEmitter::newSrcNote(SrcNote
     return &notes[index];
   };
 
-  if (!SrcNoteWriter::writeNote(type, delta, allocator)) {
+  if (!SrcNoteWriter::writeNote(type, delta, allocator)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11291,10 +11291,10 @@ bool BytecodeEmitter::newSrcNote(SrcNote
 bool BytecodeEmitter::newSrcNote2(SrcNoteType type, ptrdiff_t offset,
                                   unsigned* indexp) {
   unsigned index;
-  if (!newSrcNote(type, &index)) {
-    return false;
-  }
-  if (!newSrcNoteOperand(offset)) {
+  if (!newSrcNote(type, &index)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!newSrcNoteOperand(offset)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (indexp) {
@@ -11304,7 +11304,7 @@ bool BytecodeEmitter::newSrcNote2(SrcNot
 }
 
 bool BytecodeEmitter::newSrcNoteOperand(ptrdiff_t operand) {
-  if (!SrcNote::isRepresentableOperand(operand)) {
+  if (!SrcNote::isRepresentableOperand(operand)) {MOZ_RELEASE_ASSERT(0);
     reportError(nullptr, JSMSG_NEED_DIET, js_script_str);
     return false;
   }
@@ -11325,7 +11325,7 @@ bool BytecodeEmitter::newSrcNoteOperand(
 bool BytecodeEmitter::intoScriptStencil(ScriptIndex scriptIndex) {
   js::UniquePtr<ImmutableScriptData> immutableScriptData =
       createImmutableScriptData(cx);
-  if (!immutableScriptData) {
+  if (!immutableScriptData) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11333,19 +11333,19 @@ bool BytecodeEmitter::intoScriptStencil(
              sc->hasNonSyntacticScope());
 
   auto& things = perScriptData().gcThingList().objects();
-  if (!compilationState.appendGCThings(cx, scriptIndex, things)) {
+  if (!compilationState.appendGCThings(cx, scriptIndex, things)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Hand over the ImmutableScriptData instance generated by BCE.
   auto* sharedData =
       SharedImmutableScriptData::createWith(cx, std::move(immutableScriptData));
-  if (!sharedData) {
+  if (!sharedData) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // De-duplicate the bytecode within the runtime.
-  if (!compilationState.sharedData.addAndShare(cx, scriptIndex, sharedData)) {
+  if (!compilationState.sharedData.addAndShare(cx, scriptIndex, sharedData)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/frontend/CForEmitter.cpp b/js/src/frontend/CForEmitter.cpp
--- a/js/src/frontend/CForEmitter.cpp
+++ b/js/src/frontend/CForEmitter.cpp
@@ -60,7 +60,7 @@ bool CForEmitter::emitCond(const Maybe<u
                ScopeKind::Lexical);
 
     if (headLexicalEmitterScopeForLet_->hasEnvironment()) {
-      if (!bce_->emit1(JSOp::FreshenLexicalEnv)) {
+      if (!bce_->emit1(JSOp::FreshenLexicalEnv)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -103,7 +103,7 @@ bool CForEmitter::emitUpdate(Update upda
   // Set loop and enclosing "update" offsets, for continue.  Note that we
   // continue to immediately *before* the block-freshening: continuing must
   // refresh the block.
-  if (!loopInfo_->emitContinueTarget(bce_)) {
+  if (!loopInfo_->emitContinueTarget(bce_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -114,7 +114,7 @@ bool CForEmitter::emitUpdate(Update upda
                ScopeKind::Lexical);
 
     if (headLexicalEmitterScopeForLet_->hasEnvironment()) {
-      if (!bce_->emit1(JSOp::FreshenLexicalEnv)) {
+      if (!bce_->emit1(JSOp::FreshenLexicalEnv)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -146,7 +146,7 @@ bool CForEmitter::emitEnd(const Maybe<ui
 
     //              [stack] UPDATE
 
-    if (!bce_->emit1(JSOp::Pop)) {
+    if (!bce_->emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
       //            [stack]
       return false;
     }
@@ -158,7 +158,7 @@ bool CForEmitter::emitEnd(const Maybe<ui
     // This ensures that the debugger will stop on each loop
     // iteration.
     if (forPos) {
-      if (!bce_->updateSourceCoordNotes(*forPos)) {
+      if (!bce_->updateSourceCoordNotes(*forPos)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
diff --git a/js/src/frontend/CallOrNewEmitter.cpp b/js/src/frontend/CallOrNewEmitter.cpp
--- a/js/src/frontend/CallOrNewEmitter.cpp
+++ b/js/src/frontend/CallOrNewEmitter.cpp
@@ -80,11 +80,11 @@ bool CallOrNewEmitter::prepareForFunctio
 bool CallOrNewEmitter::emitSuperCallee() {
   MOZ_ASSERT(state_ == State::Start);
 
-  if (!bce_->emitThisEnvironmentCallee()) {
+  if (!bce_->emitThisEnvironmentCallee()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] CALLEE
     return false;
   }
-  if (!bce_->emit1(JSOp::SuperFun)) {
+  if (!bce_->emit1(JSOp::SuperFun)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] CALLEE
     return false;
   }
@@ -140,7 +140,7 @@ bool CallOrNewEmitter::emitThis() {
   }
   if (needsThis) {
     if (isNew() || isSuperCall()) {
-      if (!bce_->emit1(JSOp::IsConstructing)) {
+      if (!bce_->emit1(JSOp::IsConstructing)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] CALLEE THIS
         return false;
       }
@@ -197,11 +197,11 @@ bool CallOrNewEmitter::emitSpreadArgumen
     //              [stack] CALLEE THIS ARG0
 
     ifNotOptimizable_.emplace(bce_);
-    if (!bce_->emit1(JSOp::OptimizeSpreadCall)) {
+    if (!bce_->emit1(JSOp::OptimizeSpreadCall)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CALLEE THIS ARG0 OPTIMIZED
       return false;
     }
-    if (!ifNotOptimizable_->emitThen(IfEmitter::ConditionKind::Negative)) {
+    if (!ifNotOptimizable_->emitThen(IfEmitter::ConditionKind::Negative)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CALLEE THIS ARG0
       return false;
     }
@@ -227,7 +227,7 @@ bool CallOrNewEmitter::emitEnd(uint32_t 
   MOZ_ASSERT(state_ == State::Arguments);
 
   if (isSingleSpread()) {
-    if (!ifNotOptimizable_->emitEnd()) {
+    if (!ifNotOptimizable_->emitEnd()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CALLEE THIS ARR
       return false;
     }
@@ -236,7 +236,7 @@ bool CallOrNewEmitter::emitEnd(uint32_t 
   }
   if (isNew() || isSuperCall()) {
     if (isSuperCall()) {
-      if (!bce_->emit1(JSOp::NewTarget)) {
+      if (!bce_->emit1(JSOp::NewTarget)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] CALLEE THIS ARG.. NEW.TARGET
         return false;
       }
@@ -250,20 +250,20 @@ bool CallOrNewEmitter::emitEnd(uint32_t 
     }
   }
   if (beginPos) {
-    if (!bce_->updateSourceCoordNotes(*beginPos)) {
+    if (!bce_->updateSourceCoordNotes(*beginPos)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
-  if (!bce_->markSimpleBreakpoint()) {
+  if (!bce_->markSimpleBreakpoint()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!isSpread()) {
-    if (!bce_->emitCall(op_, argc)) {
+    if (!bce_->emitCall(op_, argc)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] RVAL
       return false;
     }
   } else {
-    if (!bce_->emit1(op_)) {
+    if (!bce_->emit1(op_)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] RVAL
       return false;
     }
diff --git a/js/src/frontend/DefaultEmitter.cpp b/js/src/frontend/DefaultEmitter.cpp
--- a/js/src/frontend/DefaultEmitter.cpp
+++ b/js/src/frontend/DefaultEmitter.cpp
@@ -25,24 +25,24 @@ bool DefaultEmitter::prepareForDefault()
   //                [stack] VALUE
 
   ifUndefined_.emplace(bce_);
-  if (!ifUndefined_->emitIf(Nothing())) {
+  if (!ifUndefined_->emitIf(Nothing())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!bce_->emit1(JSOp::Dup)) {
+  if (!bce_->emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] VALUE VALUE
     return false;
   }
-  if (!bce_->emit1(JSOp::Undefined)) {
+  if (!bce_->emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] VALUE VALUE UNDEFINED
     return false;
   }
-  if (!bce_->emit1(JSOp::StrictEq)) {
+  if (!bce_->emit1(JSOp::StrictEq)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] VALUE EQ?
     return false;
   }
 
-  if (!ifUndefined_->emitThen()) {
+  if (!ifUndefined_->emitThen()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] VALUE
     return false;
   }
diff --git a/js/src/frontend/DoWhileEmitter.cpp b/js/src/frontend/DoWhileEmitter.cpp
--- a/js/src/frontend/DoWhileEmitter.cpp
+++ b/js/src/frontend/DoWhileEmitter.cpp
@@ -25,13 +25,13 @@ bool DoWhileEmitter::emitBody(const Mayb
 
   // Ensure that the column of the 'do' is set properly.
   if (doPos) {
-    if (!bce_->updateSourceCoordNotes(*doPos)) {
+    if (!bce_->updateSourceCoordNotes(*doPos)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // We need a nop here to make it possible to set a breakpoint on `do`.
-  if (!bce_->emit1(JSOp::Nop)) {
+  if (!bce_->emit1(JSOp::Nop)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/frontend/ElemOpEmitter.cpp b/js/src/frontend/ElemOpEmitter.cpp
--- a/js/src/frontend/ElemOpEmitter.cpp
+++ b/js/src/frontend/ElemOpEmitter.cpp
@@ -35,7 +35,7 @@ bool ElemOpEmitter::prepareForKey() {
   MOZ_ASSERT(state_ == State::Obj);
 
   if (!isSuper() && isIncDec()) {
-    if (!bce_->emit1(JSOp::CheckObjCoercible)) {
+    if (!bce_->emit1(JSOp::CheckObjCoercible)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] OBJ
       return false;
     }
@@ -66,7 +66,7 @@ bool ElemOpEmitter::emitPrivateGuard() {
   if (isPropInit()) {
     //              [stack] OBJ KEY
     if (!bce_->emitCheckPrivateField(ThrowCondition::ThrowHas,
-                                     ThrowMsgKind::PrivateDoubleInit)) {
+                                     ThrowMsgKind::PrivateDoubleInit)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] OBJ KEY BOOL
       return false;
     }
@@ -91,12 +91,12 @@ bool ElemOpEmitter::emitPrivateGuardForA
   }
 
   //                [stack] OBJ KEY RHS
-  if (!bce_->emitUnpickN(2)) {
+  if (!bce_->emitUnpickN(2)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] RHS OBJ KEY
     return false;
   }
 
-  if (!emitPrivateGuard()) {
+  if (!emitPrivateGuard()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] RHS OBJ KEY
     return false;
   }
@@ -116,7 +116,7 @@ bool ElemOpEmitter::emitGet() {
   // it must be converted ToPropertyKey only once, per spec. But for a private
   // field, KEY is always a symbol and ToPropertyKey would be a no-op.
   if ((isIncDec() || isCompoundAssignment()) && !isPrivate()) {
-    if (!bce_->emit1(JSOp::ToPropertyKey)) {
+    if (!bce_->emit1(JSOp::ToPropertyKey)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] # if Super
       //            [stack] THIS KEY
       //            [stack] # otherwise
@@ -125,24 +125,24 @@ bool ElemOpEmitter::emitGet() {
     }
   }
 
-  if (!emitPrivateGuard()) {
+  if (!emitPrivateGuard()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (isSuper()) {
-    if (!bce_->emitSuperBase()) {
+    if (!bce_->emitSuperBase()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] THIS? THIS KEY SUPERBASE
       return false;
     }
   }
   if (isIncDec() || isCompoundAssignment()) {
     if (isSuper()) {
-      if (!bce_->emitDupAt(2, 3)) {
+      if (!bce_->emitDupAt(2, 3)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] THIS KEY SUPERBASE THIS KEY SUPERBASE
         return false;
       }
     } else {
-      if (!bce_->emit1(JSOp::Dup2)) {
+      if (!bce_->emit1(JSOp::Dup2)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] OBJ KEY OBJ KEY
         return false;
       }
@@ -155,7 +155,7 @@ bool ElemOpEmitter::emitGet() {
   } else {
     op = JSOp::GetElem;
   }
-  if (!bce_->emitElemOpBase(op, ShouldInstrument::Yes)) {
+  if (!bce_->emitElemOpBase(op, ShouldInstrument::Yes)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] # if Get
     //              [stack] ELEM
     //              [stack] # if Call
@@ -216,24 +216,24 @@ bool ElemOpEmitter::emitDelete() {
   MOZ_ASSERT(!isPrivate());
 
   if (isSuper()) {
-    if (!bce_->emit1(JSOp::ToPropertyKey)) {
+    if (!bce_->emit1(JSOp::ToPropertyKey)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] THIS KEY
       return false;
     }
-    if (!bce_->emitSuperBase()) {
+    if (!bce_->emitSuperBase()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] THIS KEY SUPERBASE
       return false;
     }
 
     // Unconditionally throw when attempting to delete a super-reference.
-    if (!bce_->emit2(JSOp::ThrowMsg, uint8_t(ThrowMsgKind::CantDeleteSuper))) {
+    if (!bce_->emit2(JSOp::ThrowMsg, uint8_t(ThrowMsgKind::CantDeleteSuper))) {MOZ_RELEASE_ASSERT(0);
       //            [stack] THIS KEY SUPERBASE
       return false;
     }
 
     // Another wrinkle: Balance the stack from the emitter's point of view.
     // Execution will not reach here, as the last bytecode threw.
-    if (!bce_->emitPopN(2)) {
+    if (!bce_->emitPopN(2)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] THIS
       return false;
     }
@@ -263,7 +263,7 @@ bool ElemOpEmitter::emitAssignment() {
     // we already went through emitGet() and emitted a guard for this object
     // and key. There's no point checking again--a private field can't be
     // removed from an object.
-    if (!emitPrivateGuardForAssignment()) {
+    if (!emitPrivateGuardForAssignment()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -288,7 +288,7 @@ bool ElemOpEmitter::emitIncDec() {
   MOZ_ASSERT(state_ == State::Key);
   MOZ_ASSERT(isIncDec());
 
-  if (!emitGet()) {
+  if (!emitGet()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... ELEM
     return false;
   }
@@ -296,22 +296,22 @@ bool ElemOpEmitter::emitIncDec() {
   MOZ_ASSERT(state_ == State::Get);
 
   JSOp incOp = isInc() ? JSOp::Inc : JSOp::Dec;
-  if (!bce_->emit1(JSOp::ToNumeric)) {
+  if (!bce_->emit1(JSOp::ToNumeric)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... N
     return false;
   }
   if (isPostIncDec()) {
     //              [stack] OBJ KEY SUPERBASE? N
-    if (!bce_->emit1(JSOp::Dup)) {
+    if (!bce_->emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ... N N
       return false;
     }
-    if (!bce_->emit2(JSOp::Unpick, 3 + isSuper())) {
+    if (!bce_->emit2(JSOp::Unpick, 3 + isSuper())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] N OBJ KEY SUPERBASE? N
       return false;
     }
   }
-  if (!bce_->emit1(incOp)) {
+  if (!bce_->emit1(incOp)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... N+1
     return false;
   }
@@ -320,7 +320,7 @@ bool ElemOpEmitter::emitIncDec() {
       isSuper()
           ? (bce_->sc->strict() ? JSOp::StrictSetElemSuper : JSOp::SetElemSuper)
           : (bce_->sc->strict() ? JSOp::StrictSetElem : JSOp::SetElem);
-  if (!bce_->emitElemOpBase(setOp, ShouldInstrument::Yes)) {
+  if (!bce_->emitElemOpBase(setOp, ShouldInstrument::Yes)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] N? N+1
     return false;
   }
diff --git a/js/src/frontend/EmitterScope.cpp b/js/src/frontend/EmitterScope.cpp
--- a/js/src/frontend/EmitterScope.cpp
+++ b/js/src/frontend/EmitterScope.cpp
@@ -254,11 +254,11 @@ bool EmitterScope::clearFrameSlotRange(B
   // generators and async functions, to avoid keeping garbage alive
   // indefinitely.
   if (slotStart != slotEnd) {
-    if (!bce->emit1(opcode)) {
+    if (!bce->emit1(opcode)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     for (uint32_t slot = slotStart; slot < slotEnd; slot++) {
-      if (!bce->emitLocalOp(JSOp::InitLexical, slot)) {
+      if (!bce->emitLocalOp(JSOp::InitLexical, slot)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -270,22 +270,22 @@ bool EmitterScope::clearFrameSlotRange(B
   return true;
 }
 
-void EmitterScope::dump(BytecodeEmitter* bce) {
+void EmitterScope::dump(BytecodeEmitter* bce) {MOZ_RELEASE_ASSERT(0);
   fprintf(stdout, "EmitterScope [%s] %p\n", ScopeKindString(scope(bce).kind()),
           this);
 
-  for (NameLocationMap::Range r = nameCache_->all(); !r.empty(); r.popFront()) {
+  for (NameLocationMap::Range r = nameCache_->all(); !r.empty(); r.popFront()) {MOZ_RELEASE_ASSERT(0);
     const NameLocation& l = r.front().value();
 
     auto atom = r.front().key();
     UniqueChars bytes = bce->parserAtoms().toPrintableString(bce->cx, atom);
-    if (!bytes) {
+    if (!bytes) {MOZ_RELEASE_ASSERT(0);
       return;
     }
-    if (l.kind() != NameLocation::Kind::Dynamic) {
+    if (l.kind() != NameLocation::Kind::Dynamic) {MOZ_RELEASE_ASSERT(0);
       fprintf(stdout, "  %s %s ", BindingKindString(l.bindingKind()),
               bytes.get());
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       fprintf(stdout, "  %s ", bytes.get());
     }
 
@@ -331,7 +331,7 @@ bool EmitterScope::enterLexical(Bytecode
              kind != ScopeKind::StrictNamedLambda);
   MOZ_ASSERT(this == bce->innermostEmitterScopeNoCheck());
 
-  if (!ensureCache(bce)) {
+  if (!ensureCache(bce)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -340,16 +340,16 @@ bool EmitterScope::enterLexical(Bytecode
   uint32_t firstFrameSlot = frameSlotStart();
   ParserBindingIter bi(*bindings, firstFrameSlot, /* isNamedLambda = */ false);
   for (; bi; bi++) {
-    if (!checkSlotLimits(bce, bi)) {
+    if (!checkSlotLimits(bce, bi)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     NameLocation loc = NameLocation::fromBinding(bi.kind(), bi.location());
-    if (!putNameInCache(bce, bi.name(), loc)) {
+    if (!putNameInCache(bce, bi.name(), loc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!tdzCache->noteTDZCheck(bce, bi.name(), CheckTDZ)) {
+    if (!tdzCache->noteTDZCheck(bce, bi.name(), CheckTDZ)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -359,22 +359,22 @@ bool EmitterScope::enterLexical(Bytecode
   ScopeIndex scopeIndex;
   if (!ScopeStencil::createForLexicalScope(
           bce->cx, bce->compilationState, kind, bindings, firstFrameSlot,
-          enclosingScopeIndex(bce), &scopeIndex)) {
+          enclosingScopeIndex(bce), &scopeIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!internScopeStencil(bce, scopeIndex)) {
+  if (!internScopeStencil(bce, scopeIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (ScopeKindIsInBody(kind) && hasEnvironment()) {
     // After interning the VM scope we can get the scope index.
-    if (!bce->emitInternedScopeOp(index(), JSOp::PushLexicalEnv)) {
+    if (!bce->emitInternedScopeOp(index(), JSOp::PushLexicalEnv)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // Lexical scopes need notes to be mapped from a pc.
-  if (!appendScopeNote(bce)) {
+  if (!appendScopeNote(bce)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -394,7 +394,7 @@ bool EmitterScope::enterNamedLambda(Byte
   MOZ_ASSERT(this == bce->innermostEmitterScopeNoCheck());
   MOZ_ASSERT(funbox->namedLambdaBindings());
 
-  if (!ensureCache(bce)) {
+  if (!ensureCache(bce)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -405,7 +405,7 @@ bool EmitterScope::enterNamedLambda(Byte
   // The lambda name, if not closed over, is accessed via JSOp::Callee and
   // not a frame slot. Do not update frame slot information.
   NameLocation loc = NameLocation::fromBinding(bi.kind(), bi.location());
-  if (!putNameInCache(bce, bi.name(), loc)) {
+  if (!putNameInCache(bce, bi.name(), loc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -419,7 +419,7 @@ bool EmitterScope::enterNamedLambda(Byte
   if (!ScopeStencil::createForLexicalScope(
           bce->cx, bce->compilationState, scopeKind,
           funbox->namedLambdaBindings(), LOCALNO_LIMIT,
-          enclosingScopeIndex(bce), &scopeIndex)) {
+          enclosingScopeIndex(bce), &scopeIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!internScopeStencil(bce, scopeIndex)) {
@@ -437,7 +437,7 @@ bool EmitterScope::enterFunction(Bytecod
     bce->setVarEmitterScope(this);
   }
 
-  if (!ensureCache(bce)) {
+  if (!ensureCache(bce)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -448,7 +448,7 @@ bool EmitterScope::enterFunction(Bytecod
 
     ParserBindingIter bi(*bindings, funbox->hasParameterExprs);
     for (; bi; bi++) {
-      if (!checkSlotLimits(bce, bi)) {
+      if (!checkSlotLimits(bce, bi)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -466,7 +466,7 @@ bool EmitterScope::enterFunction(Bytecod
         continue;
       }
 
-      if (!cache.add(p, bi.name(), loc)) {
+      if (!cache.add(p, bi.name(), loc)) {MOZ_RELEASE_ASSERT(0);
         ReportOutOfMemory(bce->cx);
         return false;
       }
@@ -510,7 +510,7 @@ bool EmitterScope::enterFunction(Bytecod
       }
     }
 
-    if (!deadZoneFrameSlotRange(bce, 0, paramFrameSlotEnd)) {
+    if (!deadZoneFrameSlotRange(bce, 0, paramFrameSlotEnd)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -520,7 +520,7 @@ bool EmitterScope::enterFunction(Bytecod
           bce->cx, bce->compilationState, funbox->functionScopeBindings(),
           funbox->hasParameterExprs,
           funbox->needsCallObjectRegardlessOfBindings(), funbox->index(),
-          funbox->isArrow(), enclosingScopeIndex(bce), &scopeIndex)) {
+          funbox->isArrow(), enclosingScopeIndex(bce), &scopeIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!internBodyScopeStencil(bce, scopeIndex)) {
@@ -541,7 +541,7 @@ bool EmitterScope::enterFunctionExtraBod
   // function scope as the var emitter scope.
   bce->setVarEmitterScope(this);
 
-  if (!ensureCache(bce)) {
+  if (!ensureCache(bce)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -550,13 +550,13 @@ bool EmitterScope::enterFunctionExtraBod
   if (auto bindings = funbox->extraVarScopeBindings()) {
     ParserBindingIter bi(*bindings, firstFrameSlot);
     for (; bi; bi++) {
-      if (!checkSlotLimits(bce, bi)) {
+      if (!checkSlotLimits(bce, bi)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       NameLocation loc = NameLocation::fromBinding(bi.kind(), bi.location());
       MOZ_ASSERT(bi.kind() == BindingKind::Var);
-      if (!putNameInCache(bce, bi.name(), loc)) {
+      if (!putNameInCache(bce, bi.name(), loc)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -569,7 +569,7 @@ bool EmitterScope::enterFunctionExtraBod
     // any in extra body var scopes. We assert above that bi.kind() is Var.
     uint32_t end = std::min(priorEnd, nextFrameSlot_);
     if (firstFrameSlot < end) {
-      if (!clearFrameSlotRange(bce, JSOp::Undefined, firstFrameSlot, end)) {
+      if (!clearFrameSlotRange(bce, JSOp::Undefined, firstFrameSlot, end)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -591,15 +591,15 @@ bool EmitterScope::enterFunctionExtraBod
           bce->cx, bce->compilationState, ScopeKind::FunctionBodyVar,
           funbox->extraVarScopeBindings(), firstFrameSlot,
           funbox->needsExtraBodyVarEnvironmentRegardlessOfBindings(),
-          enclosingScopeIndex(bce), &scopeIndex)) {
+          enclosingScopeIndex(bce), &scopeIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!internScopeStencil(bce, scopeIndex)) {
+  if (!internScopeStencil(bce, scopeIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (hasEnvironment()) {
-    if (!bce->emitInternedScopeOp(index(), JSOp::PushVarEnv)) {
+    if (!bce->emitInternedScopeOp(index(), JSOp::PushVarEnv)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -623,7 +623,7 @@ bool EmitterScope::enterGlobal(BytecodeE
 
   bce->setVarEmitterScope(this);
 
-  if (!ensureCache(bce)) {
+  if (!ensureCache(bce)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -643,10 +643,10 @@ bool EmitterScope::enterGlobal(BytecodeE
   ScopeIndex scopeIndex;
   if (!ScopeStencil::createForGlobalScope(bce->cx, bce->compilationState,
                                           globalsc->scopeKind(),
-                                          globalsc->bindings, &scopeIndex)) {
+                                          globalsc->bindings, &scopeIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!internBodyScopeStencil(bce, scopeIndex)) {
+  if (!internBodyScopeStencil(bce, scopeIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -661,7 +661,7 @@ bool EmitterScope::enterGlobal(BytecodeE
   if (globalsc->bindings) {
     for (ParserBindingIter bi(*globalsc->bindings); bi; bi++) {
       NameLocation loc = NameLocation::fromBinding(bi.kind(), bi.location());
-      if (!putNameInCache(bce, bi.name(), loc)) {
+      if (!putNameInCache(bce, bi.name(), loc)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -684,7 +684,7 @@ bool EmitterScope::enterEval(BytecodeEmi
 
   bce->setVarEmitterScope(this);
 
-  if (!ensureCache(bce)) {
+  if (!ensureCache(bce)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -696,10 +696,10 @@ bool EmitterScope::enterEval(BytecodeEmi
   ScopeIndex scopeIndex;
   if (!ScopeStencil::createForEvalScope(
           bce->cx, bce->compilationState, scopeKind, evalsc->bindings,
-          enclosingScopeIndex(bce), &scopeIndex)) {
+          enclosingScopeIndex(bce), &scopeIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!internBodyScopeStencil(bce, scopeIndex)) {
+  if (!internBodyScopeStencil(bce, scopeIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -707,12 +707,12 @@ bool EmitterScope::enterEval(BytecodeEmi
     if (evalsc->bindings) {
       ParserBindingIter bi(*evalsc->bindings, true);
       for (; bi; bi++) {
-        if (!checkSlotLimits(bce, bi)) {
+        if (!checkSlotLimits(bce, bi)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         NameLocation loc = NameLocation::fromBinding(bi.kind(), bi.location());
-        if (!putNameInCache(bce, bi.name(), loc)) {
+        if (!putNameInCache(bce, bi.name(), loc)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -726,7 +726,7 @@ bool EmitterScope::enterEval(BytecodeEmi
   }
 
   if (hasEnvironment()) {
-    if (!bce->emitInternedScopeOp(index(), JSOp::PushVarEnv)) {
+    if (!bce->emitInternedScopeOp(index(), JSOp::PushVarEnv)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -751,7 +751,7 @@ bool EmitterScope::enterModule(BytecodeE
 
   bce->setVarEmitterScope(this);
 
-  if (!ensureCache(bce)) {
+  if (!ensureCache(bce)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -761,12 +761,12 @@ bool EmitterScope::enterModule(BytecodeE
   if (ModuleScope::ParserData* bindings = modulesc->bindings) {
     ParserBindingIter bi(*bindings);
     for (; bi; bi++) {
-      if (!checkSlotLimits(bce, bi)) {
+      if (!checkSlotLimits(bce, bi)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       NameLocation loc = NameLocation::fromBinding(bi.kind(), bi.location());
-      if (!putNameInCache(bce, bi.name(), loc)) {
+      if (!putNameInCache(bce, bi.name(), loc)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -776,14 +776,14 @@ bool EmitterScope::enterModule(BytecodeE
           firstLexicalFrameSlot = Some(loc.frameSlot());
         }
 
-        if (!tdzCache->noteTDZCheck(bce, bi.name(), CheckTDZ)) {
+        if (!tdzCache->noteTDZCheck(bce, bi.name(), CheckTDZ)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
     }
 
     updateFrameFixedSlots(bce, bi);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     nextFrameSlot_ = 0;
   }
 
@@ -793,7 +793,7 @@ bool EmitterScope::enterModule(BytecodeE
   // Put lexical frame slots in TDZ. Environment slots are poisoned during
   // environment creation.
   if (firstLexicalFrameSlot) {
-    if (!deadZoneFrameSlotRange(bce, *firstLexicalFrameSlot, frameSlotEnd())) {
+    if (!deadZoneFrameSlotRange(bce, *firstLexicalFrameSlot, frameSlotEnd())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -802,7 +802,7 @@ bool EmitterScope::enterModule(BytecodeE
   ScopeIndex scopeIndex;
   if (!ScopeStencil::createForModuleScope(
           bce->cx, bce->compilationState, modulesc->bindings,
-          enclosingScopeIndex(bce), &scopeIndex)) {
+          enclosingScopeIndex(bce), &scopeIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!internBodyScopeStencil(bce, scopeIndex)) {
@@ -815,7 +815,7 @@ bool EmitterScope::enterModule(BytecodeE
 bool EmitterScope::enterWith(BytecodeEmitter* bce) {
   MOZ_ASSERT(this == bce->innermostEmitterScopeNoCheck());
 
-  if (!ensureCache(bce)) {
+  if (!ensureCache(bce)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -825,15 +825,15 @@ bool EmitterScope::enterWith(BytecodeEmi
   ScopeIndex scopeIndex;
   if (!ScopeStencil::createForWithScope(bce->cx, bce->compilationState,
                                         enclosingScopeIndex(bce),
-                                        &scopeIndex)) {
+                                        &scopeIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!internScopeStencil(bce, scopeIndex)) {
+  if (!internScopeStencil(bce, scopeIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!bce->emitInternedScopeOp(index(), JSOp::EnterWith)) {
+  if (!bce->emitInternedScopeOp(index(), JSOp::EnterWith)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/frontend/FoldConstants.cpp b/js/src/frontend/FoldConstants.cpp
--- a/js/src/frontend/FoldConstants.cpp
+++ b/js/src/frontend/FoldConstants.cpp
@@ -62,7 +62,7 @@ static bool ContainsHoistedDeclaration(J
 static bool ListContainsHoistedDeclaration(JSContext* cx, ListNode* list,
                                            bool* result) {
   for (ParseNode* node : list->contents()) {
-    if (!ContainsHoistedDeclaration(cx, node, result)) {
+    if (!ContainsHoistedDeclaration(cx, node, result)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (*result) {
@@ -84,7 +84,7 @@ static bool ListContainsHoistedDeclarati
 // |node| being completely eliminated as dead.
 static bool ContainsHoistedDeclaration(JSContext* cx, ParseNode* node,
                                        bool* result) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -663,7 +663,7 @@ static bool FoldNot(FoldInfo info, Parse
   UnaryNode* node = &(*nodePtr)->as<UnaryNode>();
   MOZ_ASSERT(node->isKind(ParseNodeKind::NotExpr));
 
-  if (!SimplifyCondition(info, node->unsafeKidReference())) {
+  if (!SimplifyCondition(info, node->unsafeKidReference())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -808,15 +808,15 @@ static bool FoldConditional(FoldInfo inf
     MOZ_ASSERT(node->isKind(ParseNodeKind::ConditionalExpr));
 
     ParseNode** expr = node->unsafeKid1Reference();
-    if (!Fold(info, expr)) {
+    if (!Fold(info, expr)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!SimplifyCondition(info, expr)) {
+    if (!SimplifyCondition(info, expr)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     ParseNode** ifTruthy = node->unsafeKid2Reference();
-    if (!Fold(info, ifTruthy)) {
+    if (!Fold(info, ifTruthy)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -833,7 +833,7 @@ static bool FoldConditional(FoldInfo inf
       MOZ_ASSERT((*ifFalsy)->is<TernaryNode>());
       nextNode = ifFalsy;
     } else {
-      if (!Fold(info, ifFalsy)) {
+      if (!Fold(info, ifFalsy)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -872,10 +872,10 @@ static bool FoldIf(FoldInfo info, ParseN
     MOZ_ASSERT(node->isKind(ParseNodeKind::IfStmt));
 
     ParseNode** expr = node->unsafeKid1Reference();
-    if (!Fold(info, expr)) {
+    if (!Fold(info, expr)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!SimplifyCondition(info, expr)) {
+    if (!SimplifyCondition(info, expr)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -895,7 +895,7 @@ static bool FoldIf(FoldInfo info, ParseN
         MOZ_ASSERT((*alternative)->is<TernaryNode>());
         nextNode = alternative;
       } else {
-        if (!Fold(info, alternative)) {
+        if (!Fold(info, alternative)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -926,7 +926,7 @@ static bool FoldIf(FoldInfo info, ParseN
       // |if| from being folded away.
       bool containsHoistedDecls;
       if (!ContainsHoistedDeclaration(info.cx, discarded,
-                                      &containsHoistedDecls)) {
+                                      &containsHoistedDecls)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -942,7 +942,7 @@ static bool FoldIf(FoldInfo info, ParseN
       // with no |else|.  Replace the entire thing with an empty
       // statement list.
       if (!TryReplaceNode(nodePtr,
-                          info.handler->newStatementList(node->pn_pos))) {
+                          info.handler->newStatementList(node->pn_pos))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -960,7 +960,7 @@ static bool FoldIf(FoldInfo info, ParseN
 }
 
 static double ComputeBinary(ParseNodeKind kind, double left, double right) {
-  if (kind == ParseNodeKind::AddExpr) {
+  if (kind == ParseNodeKind::AddExpr) {MOZ_RELEASE_ASSERT(0);
     return left + right;
   }
 
@@ -1005,7 +1005,7 @@ static bool FoldBinaryArithmetic(FoldInf
   // Fold each operand to a number if possible.
   ParseNode** listp = node->unsafeHeadReference();
   for (; *listp; listp = &(*listp)->pn_next) {
-    if (!FoldType(info, listp, ParseNodeKind::NumberExpr)) {
+    if (!FoldType(info, listp, ParseNodeKind::NumberExpr)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1029,7 +1029,7 @@ static bool FoldBinaryArithmetic(FoldInf
                                (*next)->as<NumericLiteral>().value());
 
       TokenPos pos((*elem)->pn_pos.begin, (*next)->pn_pos.end);
-      if (!TryReplaceNode(elem, info.handler->newNumber(d, NoDecimal, pos))) {
+      if (!TryReplaceNode(elem, info.handler->newNumber(d, NoDecimal, pos))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -1059,7 +1059,7 @@ static bool FoldExponentiation(FoldInfo 
   // Fold each operand, ideally into a number.
   ParseNode** listp = node->unsafeHeadReference();
   for (; *listp; listp = &(*listp)->pn_next) {
-    if (!FoldType(info, listp, ParseNodeKind::NumberExpr)) {
+    if (!FoldType(info, listp, ParseNodeKind::NumberExpr)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1103,7 +1103,7 @@ static bool FoldElement(FoldInfo info, P
       // equivalent to expr[100] which is faster.
       if (!TryReplaceNode(
               elem->unsafeRightReference(),
-              info.handler->newNumber(index, NoDecimal, key->pn_pos))) {
+              info.handler->newNumber(index, NoDecimal, key->pn_pos))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       key = &elem->key();
@@ -1118,7 +1118,7 @@ static bool FoldElement(FoldInfo info, P
       // isn't an array index, so it converts to a string ("3.14"),
       // enabling optimization 3 below.
       name = numeric->toAtom(info.cx, info.parserAtoms);
-      if (!name) {
+      if (!name) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1133,7 +1133,7 @@ static bool FoldElement(FoldInfo info, P
   // to a property access (like expr.foo) that optimizes better downstream.
 
   NameNode* propertyNameExpr = info.handler->newPropertyName(name, key->pn_pos);
-  if (!propertyNameExpr) {
+  if (!propertyNameExpr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!TryReplaceNode(
@@ -1169,7 +1169,7 @@ static bool FoldAdd(FoldInfo info, Parse
       TokenPos pos((*current)->pn_pos.begin, (*next)->pn_pos.end);
 
       if (!TryReplaceNode(
-              current, info.handler->newNumber(left + right, NoDecimal, pos))) {
+              current, info.handler->newNumber(left + right, NoDecimal, pos))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -1191,7 +1191,7 @@ static bool FoldAdd(FoldInfo info, Parse
     // the list: (x + 1 + "2" !== x + "12") when x is a number.
     if ((*current)->isKind(ParseNodeKind::NumberExpr) &&
         (*next)->isKind(ParseNodeKind::StringExpr)) {
-      if (!FoldType(info, current, ParseNodeKind::StringExpr)) {
+      if (!FoldType(info, current, ParseNodeKind::StringExpr)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       next = &(*current)->pn_next;
@@ -1225,7 +1225,7 @@ static bool FoldAdd(FoldInfo info, Parse
 
       do {
         // Try folding the next operand to a string.
-        if (!FoldType(info, next, ParseNodeKind::StringExpr)) {
+        if (!FoldType(info, next, ParseNodeKind::StringExpr)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -1236,12 +1236,12 @@ static bool FoldAdd(FoldInfo info, Parse
 
         if (!accum) {
           accum.emplace(info.cx);
-          if (!accum->append(info.parserAtoms, firstAtom)) {
+          if (!accum->append(info.parserAtoms, firstAtom)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
         // Append this string and remove the node.
-        if (!accum->append(info.parserAtoms, (*next)->as<NameNode>().atom())) {
+        if (!accum->append(info.parserAtoms, (*next)->as<NameNode>().atom())) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -1254,7 +1254,7 @@ static bool FoldAdd(FoldInfo info, Parse
       // Replace with concatenation if we multiple nodes.
       if (accum) {
         auto combination = accum->finishParserAtom(info.parserAtoms);
-        if (!combination) {
+        if (!combination) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -1281,7 +1281,7 @@ static bool FoldAdd(FoldInfo info, Parse
       do {
         current = next;
 
-        if (!FoldType(info, current, ParseNodeKind::StringExpr)) {
+        if (!FoldType(info, current, ParseNodeKind::StringExpr)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         next = &(*current)->pn_next;
@@ -1434,7 +1434,7 @@ class FoldVisitor : public RewritingPars
     ParseNode* callee = node->left();
     if (node->isKind(ParseNodeKind::NewExpr) || !callee->isInParens() ||
         callee->is<FunctionNode>()) {
-      if (!visit(*node->unsafeLeftReference())) {
+      if (!visit(*node->unsafeLeftReference())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1474,7 +1474,7 @@ class FoldVisitor : public RewritingPars
   }
 
   bool visitForStmt(ParseNode*& pn) {
-    if (!Base::visitForStmt(pn)) {
+    if (!Base::visitForStmt(pn)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1483,7 +1483,7 @@ class FoldVisitor : public RewritingPars
       TernaryNode& head = stmt.left()->as<TernaryNode>();
       ParseNode** test = head.unsafeKid2Reference();
       if (*test) {
-        if (!SimplifyCondition(info(), test)) {
+        if (!SimplifyCondition(info(), test)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         if ((*test)->isKind(ParseNodeKind::TrueExpr)) {
@@ -1520,7 +1520,7 @@ class FoldVisitor : public RewritingPars
   }
 
   bool visitArrayExpr(ParseNode*& pn) {
-    if (!Base::visitArrayExpr(pn)) {
+    if (!Base::visitArrayExpr(pn)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1539,7 +1539,7 @@ class FoldVisitor : public RewritingPars
   }
 
   bool visitObjectExpr(ParseNode*& pn) {
-    if (!Base::visitObjectExpr(pn)) {
+    if (!Base::visitObjectExpr(pn)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
diff --git a/js/src/frontend/ForInEmitter.cpp b/js/src/frontend/ForInEmitter.cpp
--- a/js/src/frontend/ForInEmitter.cpp
+++ b/js/src/frontend/ForInEmitter.cpp
@@ -37,27 +37,27 @@ bool ForInEmitter::emitInitialize() {
   MOZ_ASSERT(state_ == State::Iterated);
   tdzCacheForIteratedValue_.reset();
 
-  if (!bce_->emit1(JSOp::Iter)) {
+  if (!bce_->emit1(JSOp::Iter)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER
     return false;
   }
 
   loopInfo_.emplace(bce_, StatementKind::ForInLoop);
 
-  if (!loopInfo_->emitLoopHead(bce_, Nothing())) {
+  if (!loopInfo_->emitLoopHead(bce_, Nothing())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER
     return false;
   }
 
-  if (!bce_->emit1(JSOp::MoreIter)) {
+  if (!bce_->emit1(JSOp::MoreIter)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER NEXTITERVAL?
     return false;
   }
-  if (!bce_->emit1(JSOp::IsNoIter)) {
+  if (!bce_->emit1(JSOp::IsNoIter)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER NEXTITERVAL? ISNOITER
     return false;
   }
-  if (!bce_->emitJump(JSOp::JumpIfTrue, &loopInfo_->breaks)) {
+  if (!bce_->emitJump(JSOp::JumpIfTrue, &loopInfo_->breaks)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER NEXTITERVAL?
     return false;
   }
@@ -76,7 +76,7 @@ bool ForInEmitter::emitInitialize() {
                ScopeKind::Lexical);
 
     if (headLexicalEmitterScope_->hasEnvironment()) {
-      if (!bce_->emit1(JSOp::RecreateLexicalEnv)) {
+      if (!bce_->emit1(JSOp::RecreateLexicalEnv)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ITER ITERVAL
         return false;
       }
@@ -116,21 +116,21 @@ bool ForInEmitter::emitEnd(const Maybe<u
 
   if (forPos) {
     // Make sure this code is attributed to the "for".
-    if (!bce_->updateSourceCoordNotes(*forPos)) {
+    if (!bce_->updateSourceCoordNotes(*forPos)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!loopInfo_->emitContinueTarget(bce_)) {
+  if (!loopInfo_->emitContinueTarget(bce_)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER ITERVAL
     return false;
   }
 
-  if (!bce_->emit1(JSOp::Pop)) {
+  if (!bce_->emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER
     return false;
   }
-  if (!loopInfo_->emitLoopEnd(bce_, JSOp::Goto, TryNoteKind::ForIn)) {
+  if (!loopInfo_->emitLoopEnd(bce_, JSOp::Goto, TryNoteKind::ForIn)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER
     return false;
   }
diff --git a/js/src/frontend/ForOfEmitter.cpp b/js/src/frontend/ForOfEmitter.cpp
--- a/js/src/frontend/ForOfEmitter.cpp
+++ b/js/src/frontend/ForOfEmitter.cpp
@@ -49,12 +49,12 @@ bool ForOfEmitter::emitInitialize(const 
   tdzCacheForIteratedValue_.reset();
 
   if (iterKind_ == IteratorKind::Async) {
-    if (!bce_->emitAsyncIterator()) {
+    if (!bce_->emitAsyncIterator()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER
       return false;
     }
   } else {
-    if (!bce_->emitIterator()) {
+    if (!bce_->emitIterator()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEXT ITER
       return false;
     }
@@ -66,7 +66,7 @@ bool ForOfEmitter::emitInitialize(const 
   int32_t iterDepth = bce_->bytecodeSection().stackDepth();
   loopInfo_.emplace(bce_, iterDepth, allowSelfHostedIter_, iterKind_);
 
-  if (!loopInfo_->emitLoopHead(bce_, Nothing())) {
+  if (!loopInfo_->emitLoopHead(bce_, Nothing())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER
     return false;
   }
@@ -84,14 +84,14 @@ bool ForOfEmitter::emitInitialize(const 
                ScopeKind::Lexical);
 
     if (headLexicalEmitterScope_->hasEnvironment()) {
-      if (!bce_->emit1(JSOp::RecreateLexicalEnv)) {
+      if (!bce_->emit1(JSOp::RecreateLexicalEnv)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] NEXT ITER
         return false;
       }
     }
 
     // For uncaptured bindings, put them back in TDZ.
-    if (!headLexicalEmitterScope_->deadZoneFrameSlots(bce_)) {
+    if (!headLexicalEmitterScope_->deadZoneFrameSlots(bce_)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -102,27 +102,27 @@ bool ForOfEmitter::emitInitialize(const 
 
   // Make sure this code is attributed to the "for".
   if (forPos) {
-    if (!bce_->updateSourceCoordNotes(*forPos)) {
+    if (!bce_->updateSourceCoordNotes(*forPos)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!bce_->emit1(JSOp::Dup2)) {
+  if (!bce_->emit1(JSOp::Dup2)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER NEXT ITER
     return false;
   }
 
-  if (!bce_->emitIteratorNext(forPos, iterKind_, allowSelfHostedIter_)) {
+  if (!bce_->emitIteratorNext(forPos, iterKind_, allowSelfHostedIter_)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RESULT
     return false;
   }
 
-  if (!bce_->emit1(JSOp::Dup)) {
+  if (!bce_->emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RESULT RESULT
     return false;
   }
   if (!bce_->emitAtomOp(JSOp::GetProp,
-                        TaggedParserAtomIndex::WellKnown::done())) {
+                        TaggedParserAtomIndex::WellKnown::done())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RESULT DONE
     return false;
   }
@@ -130,7 +130,7 @@ bool ForOfEmitter::emitInitialize(const 
   // if (done) break;
   MOZ_ASSERT(bce_->innermostNestableControl == loopInfo_.ptr(),
              "must be at the top-level of the loop");
-  if (!bce_->emitJump(JSOp::JumpIfTrue, &loopInfo_->breaks)) {
+  if (!bce_->emitJump(JSOp::JumpIfTrue, &loopInfo_->breaks)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER RESULT
     return false;
   }
@@ -140,7 +140,7 @@ bool ForOfEmitter::emitInitialize(const 
   // Note that ES 13.7.5.13, step 5.c says getting result.value does not
   // call IteratorClose, so start TryNoteKind::ForOfIterClose after the GetProp.
   if (!bce_->emitAtomOp(JSOp::GetProp,
-                        TaggedParserAtomIndex::WellKnown::value())) {
+                        TaggedParserAtomIndex::WellKnown::value())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER VALUE
     return false;
   }
@@ -174,12 +174,12 @@ bool ForOfEmitter::emitEnd(const Maybe<u
   MOZ_ASSERT(bce_->bytecodeSection().stackDepth() == loopDepth_ + 1,
              "the stack must be balanced around the for-of body");
 
-  if (!loopInfo_->emitEndCodeNeedingIteratorClose(bce_)) {
+  if (!loopInfo_->emitEndCodeNeedingIteratorClose(bce_)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER VALUE
     return false;
   }
 
-  if (!loopInfo_->emitContinueTarget(bce_)) {
+  if (!loopInfo_->emitContinueTarget(bce_)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER VALUE
     return false;
   }
@@ -189,17 +189,17 @@ bool ForOfEmitter::emitEnd(const Maybe<u
   // This is a bit misleading for 2nd and later iterations and might need
   // some fix (bug 1482003).
   if (iteratedPos) {
-    if (!bce_->updateSourceCoordNotes(*iteratedPos)) {
+    if (!bce_->updateSourceCoordNotes(*iteratedPos)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!bce_->emit1(JSOp::Pop)) {
+  if (!bce_->emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER
     return false;
   }
 
-  if (!loopInfo_->emitLoopEnd(bce_, JSOp::Goto, TryNoteKind::ForOf)) {
+  if (!loopInfo_->emitLoopEnd(bce_, JSOp::Goto, TryNoteKind::ForOf)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER
     return false;
   }
diff --git a/js/src/frontend/ForOfLoopControl.cpp b/js/src/frontend/ForOfLoopControl.cpp
--- a/js/src/frontend/ForOfLoopControl.cpp
+++ b/js/src/frontend/ForOfLoopControl.cpp
@@ -40,13 +40,13 @@ bool ForOfLoopControl::emitBeginCodeNeed
 }
 
 bool ForOfLoopControl::emitEndCodeNeedingIteratorClose(BytecodeEmitter* bce) {
-  if (!tryCatch_->emitCatch()) {
+  if (!tryCatch_->emitCatch()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER ... EXCEPTION
     return false;
   }
 
   unsigned slotFromTop = bce->bytecodeSection().stackDepth() - iterDepth_;
-  if (!bce->emitDupAt(slotFromTop)) {
+  if (!bce->emitDupAt(slotFromTop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER ... EXCEPTION ITER
     return false;
   }
@@ -54,38 +54,38 @@ bool ForOfLoopControl::emitEndCodeNeedin
   // If ITER is undefined, it means the exception is thrown by
   // IteratorClose for non-local jump, and we should't perform
   // IteratorClose again here.
-  if (!bce->emit1(JSOp::Undefined)) {
+  if (!bce->emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER ... EXCEPTION ITER UNDEF
     return false;
   }
-  if (!bce->emit1(JSOp::StrictNe)) {
+  if (!bce->emit1(JSOp::StrictNe)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER ... EXCEPTION NE
     return false;
   }
 
   InternalIfEmitter ifIteratorIsNotClosed(bce);
-  if (!ifIteratorIsNotClosed.emitThen()) {
+  if (!ifIteratorIsNotClosed.emitThen()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER ... EXCEPTION
     return false;
   }
 
   MOZ_ASSERT(slotFromTop ==
              unsigned(bce->bytecodeSection().stackDepth() - iterDepth_));
-  if (!bce->emitDupAt(slotFromTop)) {
+  if (!bce->emitDupAt(slotFromTop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER ... EXCEPTION ITER
     return false;
   }
   if (!emitIteratorCloseInInnermostScopeWithTryNote(bce,
-                                                    CompletionKind::Throw)) {
+                                                    CompletionKind::Throw)) {MOZ_RELEASE_ASSERT(0);
     return false;  // ITER ... EXCEPTION
   }
 
-  if (!ifIteratorIsNotClosed.emitEnd()) {
+  if (!ifIteratorIsNotClosed.emitEnd()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER ... EXCEPTION
     return false;
   }
 
-  if (!bce->emit1(JSOp::Throw)) {
+  if (!bce->emit1(JSOp::Throw)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER ...
     return false;
   }
@@ -95,29 +95,29 @@ bool ForOfLoopControl::emitEndCodeNeedin
   // yield*, it is handled with a finally block.
   uint32_t numYieldsEmitted = bce->bytecodeSection().numYields();
   if (numYieldsEmitted > numYieldsAtBeginCodeNeedingIterClose_) {
-    if (!tryCatch_->emitFinally()) {
+    if (!tryCatch_->emitFinally()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     InternalIfEmitter ifGeneratorClosing(bce);
-    if (!bce->emit1(JSOp::IsGenClosing)) {
+    if (!bce->emit1(JSOp::IsGenClosing)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ITER ... FTYPE FVALUE CLOSING
       return false;
     }
-    if (!ifGeneratorClosing.emitThen()) {
+    if (!ifGeneratorClosing.emitThen()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ITER ... FTYPE FVALUE
       return false;
     }
-    if (!bce->emitDupAt(slotFromTop + 1)) {
+    if (!bce->emitDupAt(slotFromTop + 1)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ITER ... FTYPE FVALUE ITER
       return false;
     }
     if (!emitIteratorCloseInInnermostScopeWithTryNote(bce,
-                                                      CompletionKind::Normal)) {
+                                                      CompletionKind::Normal)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ITER ... FTYPE FVALUE
       return false;
     }
-    if (!ifGeneratorClosing.emitEnd()) {
+    if (!ifGeneratorClosing.emitEnd()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ITER ... FTYPE FVALUE
       return false;
     }
@@ -168,34 +168,34 @@ bool ForOfLoopControl::emitPrepareForNon
   // leaving try-catch block.  However, the performing IteratorClose can
   // reach the depth for try-catch, and effectively re-enter the
   // try-catch block.
-  if (!bce->emit1(JSOp::Pop)) {
+  if (!bce->emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NEXT ITER
     return false;
   }
 
   // Pop the iterator's next method.
-  if (!bce->emit1(JSOp::Swap)) {
+  if (!bce->emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER NEXT
     return false;
   }
-  if (!bce->emit1(JSOp::Pop)) {
+  if (!bce->emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER
     return false;
   }
 
   // Clear ITER slot on the stack to tell catch block to avoid performing
   // IteratorClose again.
-  if (!bce->emit1(JSOp::Undefined)) {
+  if (!bce->emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ITER UNDEF
     return false;
   }
-  if (!bce->emit1(JSOp::Swap)) {
+  if (!bce->emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] UNDEF ITER
     return false;
   }
 
   *tryNoteStart = bce->bytecodeSection().offset();
-  if (!emitIteratorCloseInScope(bce, currentScope, CompletionKind::Normal)) {
+  if (!emitIteratorCloseInScope(bce, currentScope, CompletionKind::Normal)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] UNDEF
     return false;
   }
@@ -204,11 +204,11 @@ bool ForOfLoopControl::emitPrepareForNon
     // At the level of the target block, there's bytecode after the
     // loop that will pop the next method, the iterator, and the
     // value, so push two undefineds to balance the stack.
-    if (!bce->emit1(JSOp::Undefined)) {
+    if (!bce->emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] UNDEF UNDEF
       return false;
     }
-    if (!bce->emit1(JSOp::Undefined)) {
+    if (!bce->emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] UNDEF UNDEF UNDEF
       return false;
     }
diff --git a/js/src/frontend/FunctionEmitter.cpp b/js/src/frontend/FunctionEmitter.cpp
--- a/js/src/frontend/FunctionEmitter.cpp
+++ b/js/src/frontend/FunctionEmitter.cpp
@@ -126,7 +126,7 @@ bool FunctionEmitter::emitAgain() {
   // If there are parameter expressions, the var name could be a
   // parameter.
   if (!lhsLoc && bce_->sc->isFunctionBox() &&
-      bce_->sc->asFunctionBox()->functionHasExtraBodyVarScope()) {
+      bce_->sc->asFunctionBox()->functionHasExtraBodyVarScope()) {MOZ_RELEASE_ASSERT(0);
     lhsLoc = bce_->locationOfNameBoundInScope(
         name_, bce_->varEmitterScope->enclosingInFrame());
   }
@@ -142,17 +142,17 @@ bool FunctionEmitter::emitAgain() {
 
   NameOpEmitter noe(bce_, name_, *lhsLoc,
                     NameOpEmitter::Kind::SimpleAssignment);
-  if (!noe.prepareForRhs()) {
+  if (!noe.prepareForRhs()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
-  if (!bce_->emitGetName(name_)) {
+  if (!bce_->emitGetName(name_)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] FUN
     return false;
   }
 
-  if (!noe.emitAssignment()) {
+  if (!noe.emitAssignment()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] FUN
     return false;
   }
@@ -192,7 +192,7 @@ bool FunctionEmitter::emitAsmJSModule() 
 bool FunctionEmitter::emitFunction() {
   // Make the function object a literal in the outer script's pool.
   GCThingIndex index;
-  if (!bce_->perScriptData().gcThingList().append(funbox_, &index)) {
+  if (!bce_->perScriptData().gcThingList().append(funbox_, &index)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -236,7 +236,7 @@ bool FunctionEmitter::emitNonHoisted(GCT
   MOZ_ASSERT(funbox_->isArrow() == (syntaxKind_ == FunctionSyntaxKind::Arrow));
 
   if (funbox_->isArrow()) {
-    if (!emitNewTargetForArrow()) {
+    if (!emitNewTargetForArrow()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEW.TARGET/NULL
       return false;
     }
@@ -244,7 +244,7 @@ bool FunctionEmitter::emitNonHoisted(GCT
 
   if (syntaxKind_ == FunctionSyntaxKind::DerivedClassConstructor) {
     //              [stack] PROTO
-    if (!bce_->emitGCIndexOp(JSOp::FunWithProto, index)) {
+    if (!bce_->emitGCIndexOp(JSOp::FunWithProto, index)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] FUN
       return false;
     }
@@ -272,17 +272,17 @@ bool FunctionEmitter::emitHoisted(GCThin
   // initialize the binding name of the function in the current scope.
 
   NameOpEmitter noe(bce_, name_, NameOpEmitter::Kind::Initialize);
-  if (!noe.prepareForRhs()) {
+  if (!noe.prepareForRhs()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
-  if (!bce_->emitGCIndexOp(JSOp::Lambda, index)) {
+  if (!bce_->emitGCIndexOp(JSOp::Lambda, index)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] FUN
     return false;
   }
 
-  if (!noe.emitAssignment()) {
+  if (!noe.emitAssignment()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] FUN
     return false;
   }
@@ -321,7 +321,7 @@ bool FunctionEmitter::emitNewTargetForAr
   //                [stack]
 
   if (bce_->sc->allowNewTarget()) {
-    if (!bce_->emit1(JSOp::NewTarget)) {
+    if (!bce_->emit1(JSOp::NewTarget)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NEW.TARGET
       return false;
     }
@@ -351,7 +351,7 @@ bool FunctionScriptEmitter::prepareForPa
 
   if (funbox_->namedLambdaBindings()) {
     namedLambdaEmitterScope_.emplace(bce_);
-    if (!namedLambdaEmitterScope_->enterNamedLambda(bce_, funbox_)) {
+    if (!namedLambdaEmitterScope_->enterNamedLambda(bce_, funbox_)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -365,7 +365,7 @@ bool FunctionScriptEmitter::prepareForPa
   }
 
   if (paramStart_) {
-    if (!bce_->updateLineNumberNotes(*paramStart_)) {
+    if (!bce_->updateLineNumberNotes(*paramStart_)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -381,7 +381,7 @@ bool FunctionScriptEmitter::prepareForPa
     // parameter exprs, any unobservable environment ops (like pushing the
     // call object, setting '.this', etc) need to go in the prologue, else it
     // messes up breakpoint tests.
-    if (!bce_->switchToMain()) {
+    if (!bce_->switchToMain()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -390,20 +390,20 @@ bool FunctionScriptEmitter::prepareForPa
     return false;
   }
 
-  if (!bce_->emitInitializeFunctionSpecialNames()) {
+  if (!bce_->emitInitializeFunctionSpecialNames()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
   if (!funbox_->hasParameterExprs) {
-    if (!bce_->switchToMain()) {
+    if (!bce_->switchToMain()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   if (funbox_->needsPromiseResult()) {
     if (funbox_->hasParameterExprs) {
-      if (!asyncEmitter_->prepareForParamsWithExpression()) {
+      if (!asyncEmitter_->prepareForParamsWithExpression()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -425,18 +425,18 @@ bool FunctionScriptEmitter::prepareForBo
   //                [stack]
 
   if (funbox_->needsPromiseResult()) {
-    if (!asyncEmitter_->emitParamsEpilogue()) {
+    if (!asyncEmitter_->emitParamsEpilogue()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!emitExtraBodyVarScope()) {
+  if (!emitExtraBodyVarScope()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
   if (funbox_->needsPromiseResult()) {
-    if (!asyncEmitter_->prepareForBody()) {
+    if (!asyncEmitter_->prepareForBody()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -464,7 +464,7 @@ bool FunctionScriptEmitter::emitExtraBod
   }
 
   extraBodyVarEmitterScope_.emplace(bce_);
-  if (!extraBodyVarEmitterScope_->enterFunctionExtraBodyVar(bce_, funbox_)) {
+  if (!extraBodyVarEmitterScope_->enterFunctionExtraBodyVar(bce_, funbox_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -495,19 +495,19 @@ bool FunctionScriptEmitter::emitExtraBod
                name != TaggedParserAtomIndex::WellKnown::dotGenerator());
 
     NameOpEmitter noe(bce_, name, NameOpEmitter::Kind::Initialize);
-    if (!noe.prepareForRhs()) {
+    if (!noe.prepareForRhs()) {MOZ_RELEASE_ASSERT(0);
       //            [stack]
       return false;
     }
 
     NameLocation paramLoc =
         *bce_->locationOfNameBoundInScope(name, functionEmitterScope_.ptr());
-    if (!bce_->emitGetNameAtLocation(name, paramLoc)) {
+    if (!bce_->emitGetNameAtLocation(name, paramLoc)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] VAL
       return false;
     }
 
-    if (!noe.emitAssignment()) {
+    if (!noe.emitAssignment()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] VAL
       return false;
     }
@@ -531,62 +531,62 @@ bool FunctionScriptEmitter::emitEndBody(
       MOZ_ASSERT(!funbox_->needsPromiseResult());
       // Emit final yield bytecode for generators, for example:
       // function gen * () { ... }
-      if (!bce_->emitPrepareIteratorResult()) {
+      if (!bce_->emitPrepareIteratorResult()) {MOZ_RELEASE_ASSERT(0);
         //          [stack] RESULT
         return false;
       }
 
-      if (!bce_->emit1(JSOp::Undefined)) {
+      if (!bce_->emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] RESULT? UNDEF
         return false;
       }
 
-      if (!bce_->emitFinishIteratorResult(true)) {
+      if (!bce_->emitFinishIteratorResult(true)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] RESULT
         return false;
       }
 
-      if (!bce_->emit1(JSOp::SetRval)) {
+      if (!bce_->emit1(JSOp::SetRval)) {MOZ_RELEASE_ASSERT(0);
         //          [stack]
         return false;
       }
 
-      if (!bce_->emitGetDotGeneratorInInnermostScope()) {
+      if (!bce_->emitGetDotGeneratorInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
         //          [stack] GEN
         return false;
       }
 
       // No need to check for finally blocks, etc as in EmitReturn.
-      if (!bce_->emitYieldOp(JSOp::FinalYieldRval)) {
+      if (!bce_->emitYieldOp(JSOp::FinalYieldRval)) {MOZ_RELEASE_ASSERT(0);
         //          [stack]
         return false;
       }
     } else if (funbox_->needsPromiseResult()) {
       // Emit final yield bytecode for async functions, for example:
       // async function deferred() { ... }
-      if (!asyncEmitter_->emitEnd()) {
+      if (!asyncEmitter_->emitEnd()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
       // Emit final yield bytecode for async generators, for example:
       // async function asyncgen * () { ... }
-      if (!bce_->emit1(JSOp::Undefined)) {
+      if (!bce_->emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] RESULT? UNDEF
         return false;
       }
 
-      if (!bce_->emit1(JSOp::SetRval)) {
+      if (!bce_->emit1(JSOp::SetRval)) {MOZ_RELEASE_ASSERT(0);
         //          [stack]
         return false;
       }
 
-      if (!bce_->emitGetDotGeneratorInInnermostScope()) {
+      if (!bce_->emitGetDotGeneratorInInnermostScope()) {MOZ_RELEASE_ASSERT(0);
         //          [stack] GEN
         return false;
       }
 
       // No need to check for finally blocks, etc as in EmitReturn.
-      if (!bce_->emitYieldOp(JSOp::FinalYieldRval)) {
+      if (!bce_->emitYieldOp(JSOp::FinalYieldRval)) {MOZ_RELEASE_ASSERT(0);
         //          [stack]
         return false;
       }
@@ -598,11 +598,11 @@ bool FunctionScriptEmitter::emitEndBody(
     // value in the return value slot. Make sure the return value
     // is |undefined|.
     if (bce_->hasTryFinally) {
-      if (!bce_->emit1(JSOp::Undefined)) {
+      if (!bce_->emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] UNDEF
         return false;
       }
-      if (!bce_->emit1(JSOp::SetRval)) {
+      if (!bce_->emit1(JSOp::SetRval)) {MOZ_RELEASE_ASSERT(0);
         //          [stack]
         return false;
       }
@@ -610,28 +610,28 @@ bool FunctionScriptEmitter::emitEndBody(
   }
 
   if (funbox_->isDerivedClassConstructor()) {
-    if (!bce_->emitCheckDerivedClassConstructorReturn()) {
+    if (!bce_->emitCheckDerivedClassConstructorReturn()) {MOZ_RELEASE_ASSERT(0);
       //            [stack]
       return false;
     }
   }
 
   if (extraBodyVarEmitterScope_) {
-    if (!extraBodyVarEmitterScope_->leave(bce_)) {
+    if (!extraBodyVarEmitterScope_->leave(bce_)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     extraBodyVarEmitterScope_.reset();
   }
 
-  if (!functionEmitterScope_->leave(bce_)) {
+  if (!functionEmitterScope_->leave(bce_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   functionEmitterScope_.reset();
   tdzCache_.reset();
 
   if (bodyEnd_) {
-    if (!bce_->updateSourceCoordNotes(*bodyEnd_)) {
+    if (!bce_->updateSourceCoordNotes(*bodyEnd_)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -641,7 +641,7 @@ bool FunctionScriptEmitter::emitEndBody(
   // as a whole. Since arrow function single-expression bodies have no closing
   // curly bracket, we do not place a breakpoint at their end position.
   if (!funbox_->hasExprBody()) {
-    if (!bce_->markSimpleBreakpoint()) {
+    if (!bce_->markSimpleBreakpoint()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -649,7 +649,7 @@ bool FunctionScriptEmitter::emitEndBody(
   // Always end the script with a JSOp::RetRval. Some other parts of the
   // codebase depend on this opcode,
   // e.g. InterpreterRegs::setToEndOfScript.
-  if (!bce_->emitReturnRval()) {
+  if (!bce_->emitReturnRval()) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
@@ -693,7 +693,7 @@ bool FunctionParamsEmitter::emitSimple(T
   //                [stack]
 
   if (funbox_->hasParameterExprs) {
-    if (!bce_->emitArgOp(JSOp::GetArg, argSlot_)) {
+    if (!bce_->emitArgOp(JSOp::GetArg, argSlot_)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ARG
       return false;
     }
@@ -729,7 +729,7 @@ bool FunctionParamsEmitter::emitDefaultE
 
   //                [stack] DEFAULT
 
-  if (!emitInitializerEnd()) {
+  if (!emitInitializerEnd()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ARG/DEFAULT
     return false;
   }
@@ -835,7 +835,7 @@ bool FunctionParamsEmitter::emitRest(Tag
 
   //                [stack]
 
-  if (!emitRestArray()) {
+  if (!emitRestArray()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] REST
     return false;
   }
@@ -888,7 +888,7 @@ bool FunctionParamsEmitter::prepareForIn
   // If we have an initializer, emit the initializer and assign it
   // to the argument slot. TDZ is taken care of afterwards.
   MOZ_ASSERT(funbox_->hasParameterExprs);
-  if (!bce_->emitArgOp(JSOp::GetArg, argSlot_)) {
+  if (!bce_->emitArgOp(JSOp::GetArg, argSlot_)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ARG
     return false;
   }
@@ -934,12 +934,12 @@ bool FunctionParamsEmitter::emitAssignme
              paramLoc.kind() == NameLocation::Kind::EnvironmentCoordinate);
 
   NameOpEmitter noe(bce_, paramName, paramLoc, NameOpEmitter::Kind::Initialize);
-  if (!noe.prepareForRhs()) {
+  if (!noe.prepareForRhs()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ARG
     return false;
   }
 
-  if (!noe.emitAssignment()) {
+  if (!noe.emitAssignment()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ARG
     return false;
   }
diff --git a/js/src/frontend/IfEmitter.cpp b/js/src/frontend/IfEmitter.cpp
--- a/js/src/frontend/IfEmitter.cpp
+++ b/js/src/frontend/IfEmitter.cpp
@@ -33,7 +33,7 @@ bool BranchEmitterBase::emitThenInternal
   // Emit a jump around the then part.
   JSOp op = conditionKind == ConditionKind::Positive ? JSOp::JumpIfFalse
                                                      : JSOp::JumpIfTrue;
-  if (!bce_->emitJump(op, &jumpAroundThen_)) {
+  if (!bce_->emitJump(op, &jumpAroundThen_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -72,12 +72,12 @@ bool BranchEmitterBase::emitElseInternal
   // Emit a jump from the end of our then part around the else part. The
   // patchJumpsToTarget call at the bottom of this function will fix up
   // the offset with jumpsAroundElse value.
-  if (!bce_->emitJump(JSOp::Goto, &jumpsAroundElse_)) {
+  if (!bce_->emitJump(JSOp::Goto, &jumpsAroundElse_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Ensure the branch-if-false comes here, then emit the else.
-  if (!bce_->emitJumpTargetAndPatch(jumpAroundThen_)) {
+  if (!bce_->emitJumpTargetAndPatch(jumpAroundThen_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -107,7 +107,7 @@ bool BranchEmitterBase::emitEndInternal(
   if (jumpAroundThen_.offset.valid()) {
     // No else part for the last branch, fixup the branch-if-false to
     // come here.
-    if (!bce_->emitJumpTargetAndPatch(jumpAroundThen_)) {
+    if (!bce_->emitJumpTargetAndPatch(jumpAroundThen_)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -178,7 +178,7 @@ bool IfEmitter::emitThenElse(
 bool IfEmitter::emitElseIf(const Maybe<uint32_t>& ifPos) {
   MOZ_ASSERT(state_ == State::ThenElse);
 
-  if (!emitElseInternal()) {
+  if (!emitElseInternal()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/frontend/JumpList.cpp b/js/src/frontend/JumpList.cpp
--- a/js/src/frontend/JumpList.cpp
+++ b/js/src/frontend/JumpList.cpp
@@ -25,7 +25,7 @@ void JumpList::push(jsbytecode* code, By
 }
 
 void JumpList::patchAll(jsbytecode* code, JumpTarget target) {
-  if (!offset.valid()) {
+  if (!offset.valid()) {MOZ_RELEASE_ASSERT(0);
     // This list is not used. Nothing to do.
     return;
   }
diff --git a/js/src/frontend/NameFunctions.cpp b/js/src/frontend/NameFunctions.cpp
--- a/js/src/frontend/NameFunctions.cpp
+++ b/js/src/frontend/NameFunctions.cpp
@@ -238,7 +238,7 @@ class NameResolver : public ParseNodeVis
         return true;
       }
       if (!buf_.append(parserAtoms_, prefix_) || !buf_.append('/') ||
-          !buf_.append(parserAtoms_, funbox->displayAtom())) {
+          !buf_.append(parserAtoms_, funbox->displayAtom())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       *retId = buf_.finishParserAtom(parserAtoms_);
@@ -247,7 +247,7 @@ class NameResolver : public ParseNodeVis
 
     // If a prefix is specified, then it is a form of namespace.
     if (prefix_) {
-      if (!buf_.append(parserAtoms_, prefix_) || !buf_.append('/')) {
+      if (!buf_.append(parserAtoms_, prefix_) || !buf_.append('/')) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -263,7 +263,7 @@ class NameResolver : public ParseNodeVis
         assignment = assignment->as<AssignmentNode>().left();
       }
       bool foundName = false;
-      if (!nameExpression(assignment, &foundName)) {
+      if (!nameExpression(assignment, &foundName)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (!foundName) {
@@ -282,12 +282,12 @@ class NameResolver : public ParseNodeVis
         ParseNode* left = node->as<BinaryNode>().left();
         if (left->isKind(ParseNodeKind::ObjectPropertyName) ||
             left->isKind(ParseNodeKind::StringExpr)) {
-          if (!appendPropertyReference(left->as<NameNode>().atom())) {
+          if (!appendPropertyReference(left->as<NameNode>().atom())) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         } else if (left->isKind(ParseNodeKind::NumberExpr)) {
           if (!appendNumericPropertyReference(
-                  left->as<NumericLiteral>().value())) {
+                  left->as<NumericLiteral>().value())) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         } else {
@@ -298,7 +298,7 @@ class NameResolver : public ParseNodeVis
         // Don't have consecutive '<' characters, and also don't start
         // with a '<' character.
         if (!buf_.empty() && buf_.getChar(buf_.length() - 1) != '<' &&
-            !buf_.append('<')) {
+            !buf_.append('<')) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -308,7 +308,7 @@ class NameResolver : public ParseNodeVis
     // other namespace are rather considered as "contributing" to the outer
     // function, so give them a contribution symbol here.
     if (!buf_.empty() && buf_.getChar(buf_.length() - 1) == '/' &&
-        !buf_.append('<')) {
+        !buf_.append('<')) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -317,7 +317,7 @@ class NameResolver : public ParseNodeVis
     }
 
     *retId = buf_.finishParserAtom(parserAtoms_);
-    if (!*retId) {
+    if (!*retId) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -343,7 +343,7 @@ class NameResolver : public ParseNodeVis
   [[nodiscard]] bool visitFunction(FunctionNode* pn) {
     TaggedParserAtomIndex savedPrefix = prefix_;
     TaggedParserAtomIndex newPrefix;
-    if (!resolveFun(pn, &newPrefix)) {
+    if (!resolveFun(pn, &newPrefix)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -374,7 +374,7 @@ class NameResolver : public ParseNodeVis
 
     // The leading expression, e.g. |tag| in |tag`foo`|,
     // that might contain functions.
-    if (!visit(tag)) {
+    if (!visit(tag)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
diff --git a/js/src/frontend/NameOpEmitter.cpp b/js/src/frontend/NameOpEmitter.cpp
--- a/js/src/frontend/NameOpEmitter.cpp
+++ b/js/src/frontend/NameOpEmitter.cpp
@@ -202,11 +202,11 @@ bool NameOpEmitter::prepareForRhs() {
       //
       // GetBoundName uses the environment already pushed on the stack
       // from the earlier BindName.
-      if (!bce_->emit1(JSOp::Dup)) {
+      if (!bce_->emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ENV ENV
         return false;
       }
-      if (!bce_->emitAtomOp(JSOp::GetBoundName, name_)) {
+      if (!bce_->emitAtomOp(JSOp::GetBoundName, name_)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] ENV V
         return false;
       }
@@ -357,35 +357,35 @@ bool NameOpEmitter::emitIncDec() {
   MOZ_ASSERT(state_ == State::Start);
 
   JSOp incOp = isInc() ? JSOp::Inc : JSOp::Dec;
-  if (!prepareForRhs()) {
+  if (!prepareForRhs()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ENV? V
     return false;
   }
-  if (!bce_->emit1(JSOp::ToNumeric)) {
+  if (!bce_->emit1(JSOp::ToNumeric)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ENV? N
     return false;
   }
   if (isPostIncDec()) {
-    if (!bce_->emit1(JSOp::Dup)) {
+    if (!bce_->emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] ENV? N? N
       return false;
     }
   }
-  if (!bce_->emit1(incOp)) {
+  if (!bce_->emit1(incOp)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ENV? N? N+1
     return false;
   }
   if (isPostIncDec() && emittedBindOp()) {
-    if (!bce_->emit2(JSOp::Pick, 2)) {
+    if (!bce_->emit2(JSOp::Pick, 2)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] N? N+1 ENV?
       return false;
     }
-    if (!bce_->emit1(JSOp::Swap)) {
+    if (!bce_->emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] N? ENV? N+1
       return false;
     }
   }
-  if (!emitAssignment()) {
+  if (!emitAssignment()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] N? N+1
     return false;
   }
diff --git a/js/src/frontend/ObjLiteral.cpp b/js/src/frontend/ObjLiteral.cpp
--- a/js/src/frontend/ObjLiteral.cpp
+++ b/js/src/frontend/ObjLiteral.cpp
@@ -46,7 +46,7 @@ bool ObjLiteralWriter::checkForDuplicate
                    frontend::TaggedParserAtomIndexHasher>
       propNameSet;
 
-  if (!propNameSet.reserve(propertyCount_)) {
+  if (!propNameSet.reserve(propertyCount_)) {MOZ_RELEASE_ASSERT(0);
     js::ReportOutOfMemory(cx);
     return false;
   }
@@ -151,7 +151,7 @@ bool InterpretObjLiteralObj(JSContext* c
     }
 
     if (kind == PropertySetKind::UniqueNames) {
-      if (!AddDataPropertyNonPrototype(cx, obj, propId, propVal)) {
+      if (!AddDataPropertyNonPrototype(cx, obj, propId, propVal)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -180,13 +180,13 @@ static JSObject* InterpretObjLiteralObj(
 
   RootedPlainObject obj(
       cx, NewBuiltinClassInstance<PlainObject>(cx, allocKind, TenuredObject));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   if (!flags.contains(ObjLiteralFlag::HasIndexOrDuplicatePropName)) {
     if (!InterpretObjLiteralObj<PropertySetKind::UniqueNames>(
-            cx, obj, atomCache, literalInsns, flags)) {
+            cx, obj, atomCache, literalInsns, flags)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
@@ -206,7 +206,7 @@ static JSObject* InterpretObjLiteralArra
   ObjLiteralInsn insn;
 
   Rooted<ValueVector> elements(cx, ValueVector(cx));
-  if (!elements.reserve(propertyCount)) {
+  if (!elements.reserve(propertyCount)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/frontend/ObjectEmitter.cpp b/js/src/frontend/ObjectEmitter.cpp
--- a/js/src/frontend/ObjectEmitter.cpp
+++ b/js/src/frontend/ObjectEmitter.cpp
@@ -77,7 +77,7 @@ bool PropertyEmitter::prepareForSpreadOp
   //                [stack] OBJ
 
   if (spreadPos) {
-    if (!bce_->updateSourceCoordNotes(*spreadPos)) {
+    if (!bce_->updateSourceCoordNotes(*spreadPos)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -116,13 +116,13 @@ MOZ_ALWAYS_INLINE bool PropertyEmitter::
   //                [stack] CTOR? OBJ
 
   if (keyPos) {
-    if (!bce_->updateSourceCoordNotes(*keyPos)) {
+    if (!bce_->updateSourceCoordNotes(*keyPos)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   if (isStatic_) {
-    if (!bce_->emit1(JSOp::Dup2)) {
+    if (!bce_->emit1(JSOp::Dup2)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CTOR HOMEOBJ CTOR HOMEOBJ
       return false;
     }
@@ -239,14 +239,14 @@ bool PropertyEmitter::emitInitHomeObject
   //     (`super.foo` points the super prototype property)
   //   * the 2nd CTOR if isStatic_
   //     (`super.foo` points the super constructor property)
-  if (!bce_->emitDupAt(1 + isIndexOrComputed_)) {
+  if (!bce_->emitDupAt(1 + isIndexOrComputed_)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] # non-static method
     //              [stack] CTOR? HOMEOBJ CTOR KEY? FUN CTOR
     //              [stack] # static method
     //              [stack] CTOR? HOMEOBJ KEY? FUN HOMEOBJ
     return false;
   }
-  if (!bce_->emit1(JSOp::InitHomeObject)) {
+  if (!bce_->emit1(JSOp::InitHomeObject)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] CTOR? HOMEOBJ CTOR? KEY? FUN
     return false;
   }
@@ -305,7 +305,7 @@ bool PropertyEmitter::emitInit(JSOp op, 
 
   //                [stack] CTOR? OBJ CTOR? VAL
 
-  if (!bce_->emitAtomOp(op, key)) {
+  if (!bce_->emitAtomOp(op, key)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] CTOR? OBJ CTOR?
     return false;
   }
@@ -332,7 +332,7 @@ bool PropertyEmitter::emitInitIndexOrCom
 
   //                [stack] CTOR? OBJ CTOR? KEY VAL
 
-  if (!bce_->emit1(op)) {
+  if (!bce_->emit1(op)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] CTOR? OBJ CTOR?
     return false;
   }
@@ -510,62 +510,62 @@ bool ClassEmitter::emitDerivedClass(Tagg
   InternalIfEmitter ifThenElse(bce_);
 
   // Heritage must be null or a non-generator constructor
-  if (!bce_->emit1(JSOp::CheckClassHeritage)) {
+  if (!bce_->emit1(JSOp::CheckClassHeritage)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] HERITAGE
     return false;
   }
 
   // [IF] (heritage !== null)
-  if (!bce_->emit1(JSOp::Dup)) {
+  if (!bce_->emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] HERITAGE HERITAGE
     return false;
   }
-  if (!bce_->emit1(JSOp::Null)) {
+  if (!bce_->emit1(JSOp::Null)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] HERITAGE HERITAGE NULL
     return false;
   }
-  if (!bce_->emit1(JSOp::StrictNe)) {
+  if (!bce_->emit1(JSOp::StrictNe)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] HERITAGE NE
     return false;
   }
 
   // [THEN] funProto = heritage, objProto = heritage.prototype
-  if (!ifThenElse.emitThenElse()) {
+  if (!ifThenElse.emitThenElse()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!bce_->emit1(JSOp::Dup)) {
+  if (!bce_->emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] HERITAGE HERITAGE
     return false;
   }
   if (!bce_->emitAtomOp(JSOp::GetProp,
-                        TaggedParserAtomIndex::WellKnown::prototype())) {
+                        TaggedParserAtomIndex::WellKnown::prototype())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] HERITAGE PROTO
     return false;
   }
 
   // [ELSE] funProto = %FunctionPrototype%, objProto = null
-  if (!ifThenElse.emitElse()) {
+  if (!ifThenElse.emitElse()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!bce_->emit1(JSOp::Pop)) {
+  if (!bce_->emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
-  if (!bce_->emitBuiltinObject(BuiltinObjectKind::FunctionPrototype)) {
+  if (!bce_->emitBuiltinObject(BuiltinObjectKind::FunctionPrototype)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] PROTO
     return false;
   }
-  if (!bce_->emit1(JSOp::Null)) {
+  if (!bce_->emit1(JSOp::Null)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] PROTO NULL
     return false;
   }
 
   // [ENDIF]
-  if (!ifThenElse.emitEnd()) {
+  if (!ifThenElse.emitEnd()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!bce_->emit1(JSOp::ObjWithProto)) {
+  if (!bce_->emit1(JSOp::ObjWithProto)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] HERITAGE HOMEOBJ
     return false;
   }
@@ -588,11 +588,11 @@ bool ClassEmitter::emitInitConstructor(b
   //                [stack] HOMEOBJ CTOR
 
   if (needsHomeObject) {
-    if (!bce_->emitDupAt(1)) {
+    if (!bce_->emitDupAt(1)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HOMEOBJ CTOR HOMEOBJ
       return false;
     }
-    if (!bce_->emit1(JSOp::InitHomeObject)) {
+    if (!bce_->emit1(JSOp::InitHomeObject)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] HOMEOBJ CTOR
       return false;
     }
@@ -613,26 +613,26 @@ bool ClassEmitter::initProtoAndCtor() {
   //                [stack] NAME? HOMEOBJ CTOR
 
   if (hasNameOnStack_) {
-    if (!bce_->emitDupAt(2)) {
+    if (!bce_->emitDupAt(2)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NAME HOMEOBJ CTOR NAME
       return false;
     }
-    if (!bce_->emit2(JSOp::SetFunName, uint8_t(FunctionPrefixKind::None))) {
+    if (!bce_->emit2(JSOp::SetFunName, uint8_t(FunctionPrefixKind::None))) {MOZ_RELEASE_ASSERT(0);
       //            [stack] NAME HOMEOBJ CTOR
       return false;
     }
   }
 
-  if (!bce_->emit1(JSOp::Swap)) {
+  if (!bce_->emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NAME? CTOR HOMEOBJ
     return false;
   }
-  if (!bce_->emit1(JSOp::Dup2)) {
+  if (!bce_->emit1(JSOp::Dup2)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NAME? CTOR HOMEOBJ CTOR HOMEOBJ
     return false;
   }
   if (!bce_->emitAtomOp(JSOp::InitLockedProp,
-                        TaggedParserAtomIndex::WellKnown::prototype())) {
+                        TaggedParserAtomIndex::WellKnown::prototype())) {MOZ_RELEASE_ASSERT(0);
     //              [stack] NAME? CTOR HOMEOBJ CTOR
     return false;
   }
@@ -659,11 +659,11 @@ bool ClassEmitter::prepareForMemberIniti
                : TaggedParserAtomIndex::WellKnown::dotInitializers();
   initializersAssignment_.emplace(bce_, initializers,
                                   NameOpEmitter::Kind::Initialize);
-  if (!initializersAssignment_->prepareForRhs()) {
+  if (!initializersAssignment_->prepareForRhs()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!bce_->emitUint32Operand(JSOp::NewArray, numInitializers)) {
+  if (!bce_->emitUint32Operand(JSOp::NewArray, numInitializers)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ARRAY
     return false;
   }
@@ -698,12 +698,12 @@ bool ClassEmitter::emitMemberInitializer
   //                [stack] CTOR HOMEOBJ ARRAY METHOD
 
   if (isStatic) {
-    if (!bce_->emitDupAt(3)) {
+    if (!bce_->emitDupAt(3)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CTOR HOMEOBJ ARRAY METHOD CTOR
       return false;
     }
   } else {
-    if (!bce_->emitDupAt(isDerived_ ? 3 : 2)) {
+    if (!bce_->emitDupAt(isDerived_ ? 3 : 2)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] OBJ HERITAGE? ARRAY METHOD OBJ
       return false;
     }
@@ -753,7 +753,7 @@ bool ClassEmitter::emitMemberInitializer
   }
   initializersAssignment_.reset();
 
-  if (!bce_->emit1(JSOp::Pop)) {
+  if (!bce_->emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] HOMEOBJ HERITAGE?
     return false;
   }
@@ -776,7 +776,7 @@ bool ClassEmitter::emitBinding() {
              classState_ == ClassState::StaticMemberInitializersEnd);
   //                [stack] CTOR HOMEOBJ
 
-  if (!bce_->emit1(JSOp::Pop)) {
+  if (!bce_->emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] CTOR
     return false;
   }
@@ -805,7 +805,7 @@ bool ClassEmitter::emitEnd(Kind kind) {
   if (bodyScope_.isSome()) {
     MOZ_ASSERT(bodyTdzCache_.isSome());
 
-    if (!bodyScope_->leave(bce_)) {
+    if (!bodyScope_->leave(bce_)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     bodyScope_.reset();
@@ -815,7 +815,7 @@ bool ClassEmitter::emitEnd(Kind kind) {
   if (innerScope_.isSome()) {
     MOZ_ASSERT(tdzCache_.isSome());
 
-    if (!innerScope_->leave(bce_)) {
+    if (!innerScope_->leave(bce_)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     innerScope_.reset();
@@ -828,7 +828,7 @@ bool ClassEmitter::emitEnd(Kind kind) {
   if (kind == Kind::Declaration) {
     MOZ_ASSERT(name_);
 
-    if (!bce_->emitLexicalInitialization(name_)) {
+    if (!bce_->emitLexicalInitialization(name_)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] CTOR
       return false;
     }
diff --git a/js/src/frontend/OptionalEmitter.cpp b/js/src/frontend/OptionalEmitter.cpp
--- a/js/src/frontend/OptionalEmitter.cpp
+++ b/js/src/frontend/OptionalEmitter.cpp
@@ -23,21 +23,21 @@ bool OptionalEmitter::emitJumpShortCircu
              state_ == State::ShortCircuitForCall);
   MOZ_ASSERT(initialDepth_ + 1 == bce_->bytecodeSection().stackDepth());
   InternalIfEmitter ifEmitter(bce_);
-  if (!bce_->emitPushNotUndefinedOrNull()) {
+  if (!bce_->emitPushNotUndefinedOrNull()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ NOT-UNDEFINED-OR-NULL
     return false;
   }
 
-  if (!bce_->emit1(JSOp::Not)) {
+  if (!bce_->emit1(JSOp::Not)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] OBJ UNDEFINED-OR-NULL
     return false;
   }
 
-  if (!ifEmitter.emitThen()) {
+  if (!ifEmitter.emitThen()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!bce_->emitJump(JSOp::Goto, &jumpShortCircuit_)) {
+  if (!bce_->emitJump(JSOp::Goto, &jumpShortCircuit_)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] UNDEFINED-OR-NULL
     return false;
   }
@@ -56,37 +56,37 @@ bool OptionalEmitter::emitJumpShortCircu
              state_ == State::ShortCircuitForCall);
   int32_t depth = bce_->bytecodeSection().stackDepth();
   MOZ_ASSERT(initialDepth_ + 2 == depth);
-  if (!bce_->emit1(JSOp::Swap)) {
+  if (!bce_->emit1(JSOp::Swap)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] THIS CALLEE
     return false;
   }
 
   InternalIfEmitter ifEmitter(bce_);
-  if (!bce_->emitPushNotUndefinedOrNull()) {
+  if (!bce_->emitPushNotUndefinedOrNull()) {MOZ_RELEASE_ASSERT(0);
     //              [stack] THIS CALLEE NOT-UNDEFINED-OR-NULL
     return false;
   }
 
-  if (!bce_->emit1(JSOp::Not)) {
+  if (!bce_->emit1(JSOp::Not)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] THIS CALLEE UNDEFINED-OR-NULL
     return false;
   }
 
-  if (!ifEmitter.emitThen()) {
+  if (!ifEmitter.emitThen()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!bce_->emit1(JSOp::Pop)) {
+  if (!bce_->emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] THIS
     return false;
   }
 
-  if (!bce_->emitJump(JSOp::Goto, &jumpShortCircuit_)) {
+  if (!bce_->emitJump(JSOp::Goto, &jumpShortCircuit_)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] UNDEFINED-OR-NULL
     return false;
   }
 
-  if (!ifEmitter.emitEnd()) {
+  if (!ifEmitter.emitEnd()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -112,7 +112,7 @@ bool OptionalEmitter::emitOptionalJumpTa
 
   // if we get to this point, it means that the optional chain did not short
   // circuit, so we should skip the short circuiting bytecode.
-  if (!bce_->emitJump(JSOp::Goto, &jumpFinish_)) {
+  if (!bce_->emitJump(JSOp::Goto, &jumpFinish_)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] # if call
     //              [stack] CALLEE THIS
     //              [stack] # otherwise, if defined
@@ -122,7 +122,7 @@ bool OptionalEmitter::emitOptionalJumpTa
     return false;
   }
 
-  if (!bce_->emitJumpTargetAndPatch(jumpShortCircuit_)) {
+  if (!bce_->emitJumpTargetAndPatch(jumpShortCircuit_)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] UNDEFINED-OR-NULL
     return false;
   }
@@ -130,18 +130,18 @@ bool OptionalEmitter::emitOptionalJumpTa
   // reset stack depth to the depth when we jumped
   bce_->bytecodeSection().setStackDepth(initialDepth_ + 1);
 
-  if (!bce_->emit1(JSOp::Pop)) {
+  if (!bce_->emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
     //              [stack]
     return false;
   }
 
-  if (!bce_->emit1(op)) {
+  if (!bce_->emit1(op)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] JSOP
     return false;
   }
 
   if (kind == Kind::Reference) {
-    if (!bce_->emit1(op)) {
+    if (!bce_->emit1(op)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] JSOP JSOP
       return false;
     }
diff --git a/js/src/frontend/ParseContext.cpp b/js/src/frontend/ParseContext.cpp
--- a/js/src/frontend/ParseContext.cpp
+++ b/js/src/frontend/ParseContext.cpp
@@ -73,7 +73,7 @@ bool UsedNameTracker::noteUse(JSContext*
                               uint32_t scopeId,
                               mozilla::Maybe<TokenPos> tokenPosition) {
   if (UsedNameMap::AddPtr p = map_.lookupForAdd(name)) {
-    if (!p->value().noteUsedInScope(scriptId, scopeId)) {
+    if (!p->value().noteUsedInScope(scriptId, scopeId)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -88,7 +88,7 @@ bool UsedNameTracker::noteUse(JSContext*
 
     UsedNameInfo info(cx, visibility, tokenPosition);
 
-    if (!info.noteUsedInScope(scriptId, scopeId)) {
+    if (!info.noteUsedInScope(scriptId, scopeId)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!map_.add(p, name, std::move(info))) {
@@ -118,7 +118,7 @@ bool UsedNameTracker::getUnboundPrivateN
     }
 
     if (!unboundPrivateNames.emplaceBack(iter.get().key(),
-                                         *iter.get().value().pos())) {
+                                         *iter.get().value().pos())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -141,7 +141,7 @@ bool UsedNameTracker::hasUnboundPrivateN
   }
 
   Vector<UnboundPrivateName, 8> unboundPrivateNames(cx);
-  if (!getUnboundPrivateNames(unboundPrivateNames)) {
+  if (!getUnboundPrivateNames(unboundPrivateNames)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -156,7 +156,7 @@ bool UsedNameTracker::hasUnboundPrivateN
 
 void UsedNameTracker::UsedNameInfo::resetToScope(uint32_t scriptId,
                                                  uint32_t scopeId) {
-  while (!uses_.empty()) {
+  while (!uses_.empty()) {MOZ_RELEASE_ASSERT(0);
     Use& innermost = uses_.back();
     if (innermost.scopeId < scopeId) {
       break;
@@ -166,7 +166,7 @@ void UsedNameTracker::UsedNameInfo::rese
   }
 }
 
-void UsedNameTracker::rewind(RewindToken token) {
+void UsedNameTracker::rewind(RewindToken token) {MOZ_RELEASE_ASSERT(0);
   scriptCounter_ = token.scriptId;
   scopeCounter_ = token.scopeId;
 
@@ -175,13 +175,13 @@ void UsedNameTracker::rewind(RewindToken
   }
 }
 
-void ParseContext::Scope::dump(ParseContext* pc, ParserBase* parser) {
+void ParseContext::Scope::dump(ParseContext* pc, ParserBase* parser) {MOZ_RELEASE_ASSERT(0);
   JSContext* cx = pc->sc()->cx_;
 
   fprintf(stdout, "ParseScope %p", this);
 
   fprintf(stdout, "\n  decls:\n");
-  for (DeclaredNameMap::Range r = declared_->all(); !r.empty(); r.popFront()) {
+  for (DeclaredNameMap::Range r = declared_->all(); !r.empty(); r.popFront()) {MOZ_RELEASE_ASSERT(0);
     auto index = r.front().key();
     UniqueChars bytes = parser->parserAtoms().toPrintableString(cx, index);
     if (!bytes) {
@@ -222,14 +222,14 @@ bool ParseContext::Scope::propagateAndMa
     for (FunctionBox* funbox : *possibleAnnexBFunctionBoxes_) {
       bool annexBApplies;
       if (!pc->computeAnnexBAppliesToLexicalFunctionInInnermostScope(
-              funbox, parser, &annexBApplies)) {
+              funbox, parser, &annexBApplies)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (annexBApplies) {
         if (!pc->tryDeclareVar(funbox->explicitName(), parser,
                                DeclarationKind::VarForAnnexBLexicalFunction,
                                DeclaredNameInfo::npos, &redeclaredKind,
-                               &unused)) {
+                               &unused)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -243,7 +243,7 @@ bool ParseContext::Scope::propagateAndMa
     for (FunctionBox* funbox : *possibleAnnexBFunctionBoxes_) {
       bool annexBApplies;
       if (!pc->computeAnnexBAppliesToLexicalFunctionInInnermostScope(
-              funbox, parser, &annexBApplies)) {
+              funbox, parser, &annexBApplies)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (annexBApplies) {
@@ -264,7 +264,7 @@ static bool DeclarationKindIsCatchParame
 
 bool ParseContext::Scope::addCatchParameters(ParseContext* pc,
                                              Scope& catchParamScope) {
-  if (pc->useAsmOrInsideUseAsm()) {
+  if (pc->useAsmOrInsideUseAsm()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -286,7 +286,7 @@ bool ParseContext::Scope::addCatchParame
 
 void ParseContext::Scope::removeCatchParameters(ParseContext* pc,
                                                 Scope& catchParamScope) {
-  if (pc->useAsmOrInsideUseAsm()) {
+  if (pc->useAsmOrInsideUseAsm()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -334,7 +334,7 @@ ParseContext::ParseContext(JSContext* cx
 }
 
 bool ParseContext::init() {
-  if (scriptId_ == UINT32_MAX) {
+  if (scriptId_ == UINT32_MAX) {MOZ_RELEASE_ASSERT(0);
     errorReporter_.errorNoOffset(JSMSG_NEED_DIET, js_script_str);
     return false;
   }
@@ -347,7 +347,7 @@ bool ParseContext::init() {
     // finishFunctionScopes, the function box needs to be marked as
     // needing a dynamic DeclEnv object.
     if (functionBox()->isNamedLambda()) {
-      if (!namedLambdaScope_->init(this)) {
+      if (!namedLambdaScope_->init(this)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       AddDeclaredNamePtr p = namedLambdaScope_->lookupDeclaredNameForAdd(
@@ -355,16 +355,16 @@ bool ParseContext::init() {
       MOZ_ASSERT(!p);
       if (!namedLambdaScope_->addDeclaredName(
               this, p, functionBox()->explicitName(), DeclarationKind::Const,
-              DeclaredNameInfo::npos)) {
+              DeclaredNameInfo::npos)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
 
-    if (!functionScope_->init(this)) {
+    if (!functionScope_->init(this)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!positionalFormalParameterNames_.acquire(cx)) {
+    if (!positionalFormalParameterNames_.acquire(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -384,7 +384,7 @@ bool ParseContext::computeAnnexBAppliesT
   Maybe<DeclarationKind> redeclaredKind;
   if (!isVarRedeclaredInInnermostScope(
           name, parser, DeclarationKind::VarForAnnexBLexicalFunction,
-          &redeclaredKind)) {
+          &redeclaredKind)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -509,7 +509,7 @@ bool ParseContext::tryDeclareVarHelper(T
         return true;
       }
     } else if (dryRunOption == NotDryRun) {
-      if (!scope->addDeclaredName(this, p, name, kind, beginPos)) {
+      if (!scope->addDeclaredName(this, p, name, kind, beginPos)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -630,7 +630,7 @@ bool ParseContext::declareFunctionArgume
     if (!p) {
       if (!funScope.addDeclaredName(this, p, argumentsName,
                                     DeclarationKind::Var,
-                                    DeclaredNameInfo::npos)) {
+                                    DeclaredNameInfo::npos)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       funbox->setShouldDeclareArguments();
diff --git a/js/src/frontend/Parser.cpp b/js/src/frontend/Parser.cpp
--- a/js/src/frontend/Parser.cpp
+++ b/js/src/frontend/Parser.cpp
@@ -263,11 +263,11 @@ FunctionBox* PerHandlerParser<ParseHandl
   MOZ_ASSERT(funNode);
 
   ScriptIndex index = ScriptIndex(compilationState_.scriptData.length());
-  if (uint32_t(index) >= TaggedScriptThingIndex::IndexLimit) {
+  if (uint32_t(index) >= TaggedScriptThingIndex::IndexLimit) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx_);
     return nullptr;
   }
-  if (!compilationState_.appendScriptStencilAndData(cx_)) {
+  if (!compilationState_.appendScriptStencilAndData(cx_)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -311,14 +311,14 @@ bool ParserBase::setSourceMapInfo() {
   }
 
   if (anyChars.hasDisplayURL()) {
-    if (!ss->setDisplayURL(cx_, anyChars.displayURL())) {
+    if (!ss->setDisplayURL(cx_, anyChars.displayURL())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   if (anyChars.hasSourceMapURL()) {
     MOZ_ASSERT(!ss->hasSourceMapURL());
-    if (!ss->setSourceMapURL(cx_, anyChars.sourceMapURL())) {
+    if (!ss->setSourceMapURL(cx_, anyChars.sourceMapURL())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -331,7 +331,7 @@ bool ParserBase::setSourceMapInfo() {
     // Warn about the replacement, but use the new one.
     if (ss->hasSourceMapURL()) {
       if (!warningNoOffset(JSMSG_ALREADY_HAS_PRAGMA, ss->filename(),
-                           "//# sourceMappingURL")) {
+                           "//# sourceMappingURL")) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -357,12 +357,12 @@ typename ParseHandler::ListNodeType Gene
   GlobalSharedContext globalsc(cx_, ScopeKind::Global, options(), directives,
                                extent);
   SourceParseContext globalpc(this, &globalsc, /* newDirectives = */ nullptr);
-  if (!globalpc.init()) {
+  if (!globalpc.init()) {MOZ_RELEASE_ASSERT(0);
     return null();
   }
 
   ParseContext::VarScope varScope(this);
-  if (!varScope.init(pc_)) {
+  if (!varScope.init(pc_)) {MOZ_RELEASE_ASSERT(0);
     return null();
   }
 
@@ -372,7 +372,7 @@ typename ParseHandler::ListNodeType Gene
   }
 
   TokenKind tt;
-  if (!tokenStream.getToken(&tt, TokenStream::SlashIsRegExp)) {
+  if (!tokenStream.getToken(&tt, TokenStream::SlashIsRegExp)) {MOZ_RELEASE_ASSERT(0);
     return null();
   }
   if (tt != TokenKind::Eof) {
@@ -380,7 +380,7 @@ typename ParseHandler::ListNodeType Gene
     return null();
   }
 
-  if (!CheckParseTree(cx_, alloc_, stmtList)) {
+  if (!CheckParseTree(cx_, alloc_, stmtList)) {MOZ_RELEASE_ASSERT(0);
     return null();
   }
 
@@ -438,7 +438,7 @@ template <class ParseHandler, typename U
 void GeneralParser<ParseHandler, Unit>::reportMissingClosing(
     unsigned errorNumber, unsigned noteNumber, uint32_t openedPos) {
   auto notes = MakeUnique<JSErrorNotes>();
-  if (!notes) {
+  if (!notes) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(pc_->sc()->cx_);
     return;
   }
@@ -466,7 +466,7 @@ void GeneralParser<ParseHandler, Unit>::
     TaggedParserAtomIndex name, DeclarationKind prevKind, TokenPos pos,
     uint32_t prevPos) {
   UniqueChars bytes = this->parserAtoms().toPrintableString(cx_, name);
-  if (!bytes) {
+  if (!bytes) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -477,7 +477,7 @@ void GeneralParser<ParseHandler, Unit>::
   }
 
   auto notes = MakeUnique<JSErrorNotes>();
-  if (!notes) {
+  if (!notes) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(pc_->sc()->cx_);
     return;
   }
@@ -527,7 +527,7 @@ bool GeneralParser<ParseHandler, Unit>::
     // 'true'.
     if (pc_->sc()->strict()) {
       UniqueChars bytes = this->parserAtoms().toPrintableString(cx_, name);
-      if (!bytes) {
+      if (!bytes) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (!strictModeError(JSMSG_DUPLICATE_FORMAL, bytes.get())) {
@@ -538,13 +538,13 @@ bool GeneralParser<ParseHandler, Unit>::
     *duplicatedParam = true;
   } else {
     DeclarationKind kind = DeclarationKind::PositionalFormalParameter;
-    if (!pc_->functionScope().addDeclaredName(pc_, p, name, kind, beginPos)) {
+    if (!pc_->functionScope().addDeclaredName(pc_, p, name, kind, beginPos)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   if (!pc_->positionalFormalParameterNames().append(
-          TrivialTaggedParserAtomIndex::from(name))) {
+          TrivialTaggedParserAtomIndex::from(name))) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx_);
     return false;
   }
@@ -778,7 +778,7 @@ bool GeneralParser<ParseHandler, Unit>::
       kind = PrivateNameKind::None;
   }
 
-  if (p) {
+  if (p) {MOZ_RELEASE_ASSERT(0);
     PrivateNameKind prevKind = p->value()->privateNameKind();
     if ((prevKind == PrivateNameKind::Getter &&
          kind == PrivateNameKind::Setter) ||
@@ -835,7 +835,7 @@ bool PerHandlerParser<ParseHandler>::
     propagateFreeNamesAndMarkClosedOverBindings(ParseContext::Scope& scope) {
   // Now that we have all the declared names in the scope, check which
   // functions should exhibit Annex B semantics.
-  if (!scope.propagateAndMarkAnnexBFunctionBoxes(pc_, this)) {
+  if (!scope.propagateAndMarkAnnexBFunctionBoxes(pc_, this)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -851,7 +851,7 @@ bool PerHandlerParser<ParseHandler>::
       //   remove this.
       auto parserAtom = this->parserAtoms().internJSAtom(
           cx_, this->getCompilationState().input.atomCache, name);
-      if (!parserAtom) {
+      if (!parserAtom) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -881,7 +881,7 @@ bool PerHandlerParser<ParseHandler>::
 
         if constexpr (isSyntaxParser) {
           if (!pc_->closedOverBindingsForLazy().append(
-                  TrivialTaggedParserAtomIndex::from(bi.name()))) {
+                  TrivialTaggedParserAtomIndex::from(bi.name()))) {MOZ_RELEASE_ASSERT(0);
             ReportOutOfMemory(cx_);
             return false;
           }
@@ -921,7 +921,7 @@ bool Parser<FullParseHandler, Unit>::che
   // The statementList() call breaks on TokenKind::RightCurly, so make sure
   // we've reached EOF here.
   TokenKind tt;
-  if (!tokenStream.peekToken(&tt, TokenStream::SlashIsRegExp)) {
+  if (!tokenStream.peekToken(&tt, TokenStream::SlashIsRegExp)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (tt != TokenKind::Eof) {
@@ -999,7 +999,7 @@ static MOZ_ALWAYS_INLINE ParserBindingNa
 template <class Data, typename... Step>
 static MOZ_ALWAYS_INLINE void InitializeBindingData(
     Data* data, uint32_t count, const ParserBindingNameVector& firstBindings,
-    Step&&... step) {
+    Step&&... step) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(data->length == 0, "data shouldn't be filled yet");
 
   ParserBindingName* start = GetScopeDataTrailingNamesPointer(data);
diff --git a/js/src/frontend/ParserAtom.cpp b/js/src/frontend/ParserAtom.cpp
--- a/js/src/frontend/ParserAtom.cpp
+++ b/js/src/frontend/ParserAtom.cpp
@@ -97,7 +97,7 @@ JSAtom* ParserAtom::instantiate(JSContex
   } else {
     atom = AtomizeChars(cx, hash(), twoByteChars(), length());
   }
-  if (!atom) {
+  if (!atom) {MOZ_RELEASE_ASSERT(0);
     js::ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -224,11 +224,11 @@ TaggedParserAtomIndex ParserAtomsTable::
                                                  ParserAtom* entry) {
   MOZ_ASSERT(!addPtr);
   ParserAtomIndex index = ParserAtomIndex(entries_.length());
-  if (size_t(index) >= TaggedParserAtomIndex::IndexLimit) {
+  if (size_t(index) >= TaggedParserAtomIndex::IndexLimit) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return TaggedParserAtomIndex::null();
   }
-  if (!entries_.append(entry)) {
+  if (!entries_.append(entry)) {MOZ_RELEASE_ASSERT(0);
     js::ReportOutOfMemory(cx);
     return TaggedParserAtomIndex::null();
   }
@@ -326,7 +326,7 @@ TaggedParserAtomIndex ParserAtomsTable::
 
 bool ParserAtomsTable::addPlaceholder(JSContext* cx) {
   ParserAtomIndex index = ParserAtomIndex(entries_.length());
-  if (size_t(index) >= TaggedParserAtomIndex::IndexLimit) {
+  if (size_t(index) >= TaggedParserAtomIndex::IndexLimit) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return false;
   }
@@ -339,7 +339,7 @@ bool ParserAtomsTable::addPlaceholder(JS
 
 bool ParserAtomSpanBuilder::allocate(JSContext* cx, LifoAlloc& alloc,
                                      size_t count) {
-  if (count >= TaggedParserAtomIndex::IndexLimit) {
+  if (count >= TaggedParserAtomIndex::IndexLimit) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return false;
   }
@@ -435,14 +435,14 @@ TaggedParserAtomIndex ParserAtomsTable::
 TaggedParserAtomIndex ParserAtomsTable::internJSAtom(
     JSContext* cx, CompilationAtomCache& atomCache, JSAtom* atom) {
   TaggedParserAtomIndex parserAtom;
-  {
+  {MOZ_RELEASE_ASSERT(0);
     JS::AutoCheckCannotGC nogc;
 
     parserAtom =
         atom->hasLatin1Chars()
             ? internLatin1(cx, atom->latin1Chars(nogc), atom->length())
             : internChar16(cx, atom->twoByteChars(nogc), atom->length());
-    if (!parserAtom) {
+    if (!parserAtom) {MOZ_RELEASE_ASSERT(0);
       return TaggedParserAtomIndex::null();
     }
   }
@@ -475,7 +475,7 @@ void ParserAtomsTable::markUsedByStencil
 }
 
 bool ParserAtomsTable::isIdentifier(TaggedParserAtomIndex index) const {
-  if (index.isParserAtomIndex()) {
+  if (index.isParserAtomIndex()) {MOZ_RELEASE_ASSERT(0);
     const auto* atom = getParserAtom(index.toParserAtomIndex());
     return atom->hasLatin1Chars()
                ? IsIdentifier(atom->latin1Chars(), atom->length())
@@ -517,7 +517,7 @@ bool ParserAtomsTable::isExtendedUnclone
     TaggedParserAtomIndex index) const {
   if (index.isParserAtomIndex()) {
     const auto* atom = getParserAtom(index.toParserAtomIndex());
-    if (atom->length() < 2) {
+    if (atom->length() < 2) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -661,7 +661,7 @@ uint32_t ParserAtomsTable::length(Tagged
 
 bool ParserAtomsTable::toNumber(JSContext* cx, TaggedParserAtomIndex index,
                                 double* result) const {
-  if (index.isParserAtomIndex()) {
+  if (index.isParserAtomIndex()) {MOZ_RELEASE_ASSERT(0);
     const auto* atom = getParserAtom(index.toParserAtomIndex());
     size_t len = atom->length();
     return atom->hasLatin1Chars()
@@ -691,7 +691,7 @@ bool ParserAtomsTable::toNumber(JSContex
 
 UniqueChars ParserAtomsTable::toNewUTF8CharsZ(
     JSContext* cx, TaggedParserAtomIndex index) const {
-  if (index.isParserAtomIndex()) {
+  if (index.isParserAtomIndex()) {MOZ_RELEASE_ASSERT(0);
     const auto* atom = getParserAtom(index.toParserAtomIndex());
     return UniqueChars(
         atom->hasLatin1Chars()
@@ -731,7 +731,7 @@ template <typename CharT>
 UniqueChars ToPrintableStringImpl(JSContext* cx, mozilla::Range<CharT> str,
                                   char quote = '\0') {
   Sprinter sprinter(cx);
-  if (!sprinter.init()) {
+  if (!sprinter.init()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (!QuoteString<QuoteTarget::String>(&sprinter, str, quote)) {
@@ -742,7 +742,7 @@ UniqueChars ToPrintableStringImpl(JSCont
 
 UniqueChars ParserAtomsTable::toPrintableString(
     JSContext* cx, TaggedParserAtomIndex index) const {
-  if (index.isParserAtomIndex()) {
+  if (index.isParserAtomIndex()) {MOZ_RELEASE_ASSERT(0);
     const auto* atom = getParserAtom(index.toParserAtomIndex());
     return atom->hasLatin1Chars()
                ? ToPrintableStringImpl(cx, atom->latin1Range())
@@ -772,14 +772,14 @@ UniqueChars ParserAtomsTable::toPrintabl
 
 UniqueChars ParserAtomsTable::toQuotedString(
     JSContext* cx, TaggedParserAtomIndex index) const {
-  if (index.isParserAtomIndex()) {
+  if (index.isParserAtomIndex()) {MOZ_RELEASE_ASSERT(0);
     const auto* atom = getParserAtom(index.toParserAtomIndex());
     return atom->hasLatin1Chars()
                ? ToPrintableStringImpl(cx, atom->latin1Range(), '\"')
                : ToPrintableStringImpl(cx, atom->twoByteRange(), '\"');
   }
 
-  if (index.isWellKnownAtomId()) {
+  if (index.isWellKnownAtomId()) {MOZ_RELEASE_ASSERT(0);
     const auto& info = GetWellKnownAtomInfo(index.toWellKnownAtomId());
     return ToPrintableStringImpl(
         cx,
diff --git a/js/src/frontend/PropOpEmitter.cpp b/js/src/frontend/PropOpEmitter.cpp
--- a/js/src/frontend/PropOpEmitter.cpp
+++ b/js/src/frontend/PropOpEmitter.cpp
@@ -34,11 +34,11 @@ bool PropOpEmitter::prepareForObj() {
 bool PropOpEmitter::emitGet(TaggedParserAtomIndex prop) {
   MOZ_ASSERT(state_ == State::Obj);
 
-  if (!prepareAtomIndex(prop)) {
+  if (!prepareAtomIndex(prop)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (isCall()) {
-    if (!bce_->emit1(JSOp::Dup)) {
+    if (!bce_->emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] # if Super
       //            [stack] THIS THIS
       //            [stack] # otherwise
@@ -47,19 +47,19 @@ bool PropOpEmitter::emitGet(TaggedParser
     }
   }
   if (isSuper()) {
-    if (!bce_->emitSuperBase()) {
+    if (!bce_->emitSuperBase()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] THIS? THIS SUPERBASE
       return false;
     }
   }
   if (isIncDec() || isCompoundAssignment()) {
     if (isSuper()) {
-      if (!bce_->emit1(JSOp::Dup2)) {
+      if (!bce_->emit1(JSOp::Dup2)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] THIS SUPERBASE THIS SUPERBASE
         return false;
       }
     } else {
-      if (!bce_->emit1(JSOp::Dup)) {
+      if (!bce_->emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
         //          [stack] OBJ OBJ
         return false;
       }
@@ -67,7 +67,7 @@ bool PropOpEmitter::emitGet(TaggedParser
   }
 
   JSOp op = isSuper() ? JSOp::GetPropSuper : JSOp::GetProp;
-  if (!bce_->emitAtomOp(op, propAtomIndex_, ShouldInstrument::Yes)) {
+  if (!bce_->emitAtomOp(op, propAtomIndex_, ShouldInstrument::Yes)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] # if Get
     //              [stack] PROP
     //              [stack] # if Call
@@ -127,24 +127,24 @@ bool PropOpEmitter::emitDelete(TaggedPar
   MOZ_ASSERT_IF(isSuper(), state_ == State::Start);
   MOZ_ASSERT(isDelete());
 
-  if (!prepareAtomIndex(prop)) {
+  if (!prepareAtomIndex(prop)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (isSuper()) {
-    if (!bce_->emitSuperBase()) {
+    if (!bce_->emitSuperBase()) {MOZ_RELEASE_ASSERT(0);
       //            [stack] THIS SUPERBASE
       return false;
     }
 
     // Unconditionally throw when attempting to delete a super-reference.
-    if (!bce_->emit2(JSOp::ThrowMsg, uint8_t(ThrowMsgKind::CantDeleteSuper))) {
+    if (!bce_->emit2(JSOp::ThrowMsg, uint8_t(ThrowMsgKind::CantDeleteSuper))) {MOZ_RELEASE_ASSERT(0);
       //            [stack] THIS SUPERBASE
       return false;
     }
 
     // Another wrinkle: Balance the stack from the emitter's point of view.
     // Execution will not reach here, as the last bytecode threw.
-    if (!bce_->emit1(JSOp::Pop)) {
+    if (!bce_->emit1(JSOp::Pop)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] THIS
       return false;
     }
@@ -167,7 +167,7 @@ bool PropOpEmitter::emitAssignment(Tagge
   MOZ_ASSERT(state_ == State::Rhs);
 
   if (isSimpleAssignment() || isPropInit()) {
-    if (!prepareAtomIndex(prop)) {
+    if (!prepareAtomIndex(prop)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -193,7 +193,7 @@ bool PropOpEmitter::emitIncDec(TaggedPar
   MOZ_ASSERT(state_ == State::Obj);
   MOZ_ASSERT(isIncDec());
 
-  if (!emitGet(prop)) {
+  if (!emitGet(prop)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -201,22 +201,22 @@ bool PropOpEmitter::emitIncDec(TaggedPar
 
   JSOp incOp = isInc() ? JSOp::Inc : JSOp::Dec;
 
-  if (!bce_->emit1(JSOp::ToNumeric)) {
+  if (!bce_->emit1(JSOp::ToNumeric)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... N
     return false;
   }
   if (isPostIncDec()) {
     //              [stack] OBJ SUPERBASE? N
-    if (!bce_->emit1(JSOp::Dup)) {
+    if (!bce_->emit1(JSOp::Dup)) {MOZ_RELEASE_ASSERT(0);
       //            [stack] .. N N
       return false;
     }
-    if (!bce_->emit2(JSOp::Unpick, 2 + isSuper())) {
+    if (!bce_->emit2(JSOp::Unpick, 2 + isSuper())) {MOZ_RELEASE_ASSERT(0);
       //            [stack] N OBJ SUPERBASE? N
       return false;
     }
   }
-  if (!bce_->emit1(incOp)) {
+  if (!bce_->emit1(incOp)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] ... N+1
     return false;
   }
@@ -225,7 +225,7 @@ bool PropOpEmitter::emitIncDec(TaggedPar
                                               : JSOp::SetPropSuper
                : bce_->sc->strict() ? JSOp::StrictSetProp
                                     : JSOp::SetProp;
-  if (!bce_->emitAtomOp(setOp, propAtomIndex_, ShouldInstrument::Yes)) {
+  if (!bce_->emitAtomOp(setOp, propAtomIndex_, ShouldInstrument::Yes)) {MOZ_RELEASE_ASSERT(0);
     //              [stack] N? N+1
     return false;
   }
diff --git a/js/src/frontend/SharedContext.cpp b/js/src/frontend/SharedContext.cpp
--- a/js/src/frontend/SharedContext.cpp
+++ b/js/src/frontend/SharedContext.cpp
@@ -275,7 +275,7 @@ bool FunctionBox::setAsmJSModule(const J
 
   if (!compilationState_.asmJS) {
     compilationState_.asmJS = cx_->new_<StencilAsmJSContainer>();
-    if (!compilationState_.asmJS) {
+    if (!compilationState_.asmJS) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -332,7 +332,7 @@ void FunctionBox::copyFunctionFields(Scr
     script.functionAtom = atom_;
   }
   script.functionFlags = flags_;
-  if (enclosingScopeIndex_) {
+  if (enclosingScopeIndex_) {MOZ_RELEASE_ASSERT(0);
     script.setLazyFunctionEnclosingScopeIndex(*enclosingScopeIndex_);
   }
   if (wasEmittedByEnclosingScript_) {
diff --git a/js/src/frontend/Stencil.cpp b/js/src/frontend/Stencil.cpp
--- a/js/src/frontend/Stencil.cpp
+++ b/js/src/frontend/Stencil.cpp
@@ -81,7 +81,7 @@ bool ScopeContext::init(JSContext* cx, C
   cacheEnclosingScope(input.enclosingScope);
 
   if (input.target == CompilationInput::CompilationTarget::Eval) {
-    if (!cacheEnclosingScopeBindingForEval(cx, input, parserAtoms)) {
+    if (!cacheEnclosingScopeBindingForEval(cx, input, parserAtoms)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!cachePrivateFieldsForEval(cx, input, effectiveScope, parserAtoms)) {
@@ -301,7 +301,7 @@ bool ScopeContext::addToEnclosingLexical
     JSContext* cx, CompilationInput& input, ParserAtomsTable& parserAtoms,
     JSAtom* name, EnclosingLexicalBindingKind kind) {
   auto parserName = parserAtoms.internJSAtom(cx, input.atomCache, name);
-  if (!parserName) {
+  if (!parserName) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -355,7 +355,7 @@ bool ScopeContext::cachePrivateFieldsFor
       if (IsPrivateField(bi.name())) {
         auto parserName =
             parserAtoms.internJSAtom(cx, input.atomCache, bi.name());
-        if (!parserName) {
+        if (!parserName) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -424,7 +424,7 @@ NameLocation ScopeContext::searchInEnclo
   {
     AutoEnterOOMUnsafeRegion oomUnsafe;
     jsname = parserAtoms.toJSAtom(cx, name, input.atomCache);
-    if (!jsname) {
+    if (!jsname) {MOZ_RELEASE_ASSERT(0);
       oomUnsafe.crash("EmitterScope::searchAndCache");
     }
   }
@@ -729,14 +729,14 @@ static bool CreateLazyScript(JSContext* 
       cx, BaseScript::CreateRawLazy(cx, ngcthings, function, sourceObject,
                                     scriptExtra.extent,
                                     scriptExtra.immutableFlags));
-  if (!lazy) {
+  if (!lazy) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (ngcthings) {
     if (!EmitScriptThingsVector(cx, input, stencil, gcOutput,
                                 script.gcthings(stencil),
-                                lazy->gcthingsForInit())) {
+                                lazy->gcthingsForInit())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -814,7 +814,7 @@ static JSFunction* CreateFunction(JSCont
   // Determine the new function's proto. This must be done for singleton
   // functions.
   RootedObject proto(cx);
-  if (!GetFunctionPrototype(cx, generatorKind, asyncKind, &proto)) {
+  if (!GetFunctionPrototype(cx, generatorKind, asyncKind, &proto)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -834,7 +834,7 @@ static JSFunction* CreateFunction(JSCont
       cx, NewFunctionWithProto(cx, maybeNative, scriptExtra.nargs,
                                script.functionFlags, nullptr, displayAtom,
                                proto, allocKind, TenuredObject));
-  if (!fun) {
+  if (!fun) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -866,7 +866,7 @@ static bool InstantiateScriptSourceObjec
   MOZ_ASSERT(stencil.source);
 
   gcOutput.sourceObject = ScriptSourceObject::create(cx, stencil.source.get());
-  if (!gcOutput.sourceObject) {
+  if (!gcOutput.sourceObject) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -911,7 +911,7 @@ static bool InstantiateFunctions(JSConte
                                  CompilationGCOutput& gcOutput) {
   using ImmutableFlags = ImmutableScriptFlagsEnum;
 
-  if (!gcOutput.functions.resize(stencil.scriptData.size())) {
+  if (!gcOutput.functions.resize(stencil.scriptData.size())) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -921,14 +921,14 @@ static bool InstantiateFunctions(JSConte
   // path instead.
   RootedObject proto(cx,
                      GlobalObject::getOrCreatePrototype(cx, JSProto_Function));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedShape shape(
       cx, EmptyShape::getInitialShape(cx, &JSFunction::class_, cx->realm(),
                                       TaggedProto(proto),
                                       /* nfixed = */ 0, ObjectFlags()));
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1022,11 +1022,11 @@ static bool InstantiateScriptStencils(JS
 
       RootedScript script(
           cx, JSScript::fromStencil(cx, input, stencil, gcOutput, index));
-      if (!script) {
+      if (!script) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
-      if (scriptStencil.allowRelazify()) {
+      if (scriptStencil.allowRelazify()) {MOZ_RELEASE_ASSERT(0);
         MOZ_ASSERT(script->isRelazifiable());
         script->setAllowRelazify();
       }
@@ -1064,7 +1064,7 @@ static bool InstantiateTopLevel(JSContex
     MOZ_ASSERT(input.lazy);
     RootedScript script(cx, JSScript::CastFromLazy(input.lazy));
     if (!JSScript::fullyInitFromStencil(cx, input, stencil, gcOutput, script,
-                                        CompilationStencil::TopLevelIndex)) {
+                                        CompilationStencil::TopLevelIndex)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1079,11 +1079,11 @@ static bool InstantiateTopLevel(JSContex
 
   gcOutput.script = JSScript::fromStencil(cx, input, stencil, gcOutput,
                                           CompilationStencil::TopLevelIndex);
-  if (!gcOutput.script) {
+  if (!gcOutput.script) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (scriptStencil.allowRelazify()) {
+  if (scriptStencil.allowRelazify()) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(gcOutput.script->isRelazifiable());
     gcOutput.script->setAllowRelazify();
   }
@@ -1101,7 +1101,7 @@ static bool InstantiateTopLevel(JSContex
     module->initScriptSlots(script);
     module->initStatusSlot();
 
-    if (!ModuleObject::createEnvironment(cx, module)) {
+    if (!ModuleObject::createEnvironment(cx, module)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1173,7 +1173,7 @@ static void LinkEnclosingLazyScript(cons
        CompilationStencil::functionScriptStencils(stencil, gcOutput)) {
     auto& scriptStencil = item.script;
     auto& fun = item.function;
-    if (!scriptStencil.functionFlags.hasBaseScript()) {
+    if (!scriptStencil.functionFlags.hasBaseScript()) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
@@ -1192,7 +1192,7 @@ static void LinkEnclosingLazyScript(cons
 
       MOZ_ASSERT(innerFun->hasBaseScript(),
                  "inner function should have base script");
-      if (!innerFun->hasBaseScript()) {
+      if (!innerFun->hasBaseScript()) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
 
@@ -1284,7 +1284,7 @@ bool CompilationStencil::instantiateSten
   MOZ_ASSERT(stencil.isInitialStencil() == !input.lazy);
 
   // Phase 1: Instantate JSAtoms.
-  if (!InstantiateAtoms(cx, input, stencil)) {
+  if (!InstantiateAtoms(cx, input, stencil)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1302,12 +1302,12 @@ bool CompilationStencil::instantiateSten
       MOZ_ASSERT(input.enclosingScope->environmentChainLength() ==
                  ModuleScope::EnclosingEnvironmentChainLength);
 
-      if (!InstantiateModuleObject(cx, input, stencil, gcOutput)) {
+      if (!InstantiateModuleObject(cx, input, stencil, gcOutput)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
 
-    if (!InstantiateFunctions(cx, input, stencil, gcOutput)) {
+    if (!InstantiateFunctions(cx, input, stencil, gcOutput)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -1329,19 +1329,19 @@ bool CompilationStencil::instantiateSten
   }
 
   // Phase 3: Instantiate js::Scopes.
-  if (!InstantiateScopes(cx, input, stencil, gcOutput)) {
+  if (!InstantiateScopes(cx, input, stencil, gcOutput)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Phase 4: Instantiate (inner) BaseScripts.
   if (isInitialParse) {
-    if (!InstantiateScriptStencils(cx, input, stencil, gcOutput)) {
+    if (!InstantiateScriptStencils(cx, input, stencil, gcOutput)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // Phase 5: Finish top-level handling
-  if (!InstantiateTopLevel(cx, input, stencil, gcOutput)) {
+  if (!InstantiateTopLevel(cx, input, stencil, gcOutput)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1376,7 +1376,7 @@ bool CompilationStencil::serializeStenci
                                            CompilationInput& input,
                                            JS::TranscodeBuffer& buf,
                                            bool* succeededOut) const {
-  if (succeededOut) {
+  if (succeededOut) {MOZ_RELEASE_ASSERT(0);
     *succeededOut = false;
   }
   XDRStencilEncoder encoder(cx, buf);
@@ -1384,10 +1384,10 @@ bool CompilationStencil::serializeStenci
   XDRResult res =
       encoder.codeStencil(input, const_cast<CompilationStencil&>(*this));
   if (res.isErr()) {
-    if (JS::IsTranscodeFailureResult(res.unwrapErr())) {
+    if (JS::IsTranscodeFailureResult(res.unwrapErr())) {MOZ_RELEASE_ASSERT(0);
       buf.clear();
       return true;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(res.unwrapErr() == JS::TranscodeResult::Throw);
 
     return false;
@@ -1411,9 +1411,9 @@ bool CompilationStencil::deserializeSten
 
   XDRResult res = decoder.codeStencil(input, *this);
   if (res.isErr()) {
-    if (JS::IsTranscodeFailureResult(res.unwrapErr())) {
+    if (JS::IsTranscodeFailureResult(res.unwrapErr())) {MOZ_RELEASE_ASSERT(0);
       return true;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(res.unwrapErr() == JS::TranscodeResult::Throw);
 
     return false;
@@ -1530,15 +1530,15 @@ bool SharedDataContainer::prepareStorage
   constexpr size_t thresholdRatio = 8;
   bool useHashMap = nonLazyScriptCount < allScriptCount / thresholdRatio;
   if (useHashMap) {
-    if (!initMap(cx)) {
+    if (!initMap(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!asMap()->reserve(nonLazyScriptCount)) {
+    if (!asMap()->reserve(nonLazyScriptCount)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
   } else {
-    if (!initVector(cx)) {
+    if (!initVector(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!asVector()->resize(allScriptCount)) {
@@ -1555,7 +1555,7 @@ js::SharedImmutableScriptData* SharedDat
   if (isSingle()) {
     if (index == CompilationStencil::TopLevelIndex) {
       return asSingle();
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1563,7 +1563,7 @@ js::SharedImmutableScriptData* SharedDat
     auto& vec = *asVector();
     if (index.index < vec.length()) {
       return vec[index];
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1580,12 +1580,12 @@ js::SharedImmutableScriptData* SharedDat
   return asBorrow()->get(index);
 }
 
-bool SharedDataContainer::convertFromSingleToMap(JSContext* cx) {
+bool SharedDataContainer::convertFromSingleToMap(JSContext* cx) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(isSingle());
 
   // Use a temporary container so that on OOM we do not break the stencil.
   SharedDataContainer other;
-  if (!other.initMap(cx)) {
+  if (!other.initMap(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1605,7 +1605,7 @@ bool SharedDataContainer::addAndShare(JS
   if (isSingle()) {
     MOZ_ASSERT(index == CompilationStencil::TopLevelIndex);
     RefPtr<SharedImmutableScriptData> ref(data);
-    if (!SharedImmutableScriptData::shareScriptData(cx, ref)) {
+    if (!SharedImmutableScriptData::shareScriptData(cx, ref)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     setSingle(ref.forget());
@@ -1629,20 +1629,20 @@ bool SharedDataContainer::addAndShare(JS
 }
 
 bool SharedDataContainer::addExtraWithoutShare(
-    JSContext* cx, ScriptIndex index, js::SharedImmutableScriptData* data) {
+    JSContext* cx, ScriptIndex index, js::SharedImmutableScriptData* data) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(!isEmpty());
 
-  if (isSingle()) {
-    if (!convertFromSingleToMap(cx)) {
+  if (isSingle()) {MOZ_RELEASE_ASSERT(0);
+    if (!convertFromSingleToMap(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
-  if (isVector()) {
+  if (isVector()) {MOZ_RELEASE_ASSERT(0);
     // SharedDataContainer::prepareStorageFor allocates space for all scripts.
     (*asVector())[index] = data;
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MOZ_ASSERT(isMap());
   // SharedDataContainer::prepareStorageFor doesn't allocate space for
@@ -1735,36 +1735,36 @@ bool CompilationStencil::steal(JSContext
 
   functionKey = other.functionKey;
 
-  if (!CopyVectorToSpan(cx, alloc, regExpData, other.regExpData)) {
+  if (!CopyVectorToSpan(cx, alloc, regExpData, other.regExpData)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!CopyVectorToSpan(cx, alloc, bigIntData, other.bigIntData)) {
+  if (!CopyVectorToSpan(cx, alloc, bigIntData, other.bigIntData)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!CopyVectorToSpan(cx, alloc, objLiteralData, other.objLiteralData)) {
+  if (!CopyVectorToSpan(cx, alloc, objLiteralData, other.objLiteralData)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!CopyVectorToSpan(cx, alloc, scriptData, other.scriptData)) {
+  if (!CopyVectorToSpan(cx, alloc, scriptData, other.scriptData)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!CopyVectorToSpan(cx, alloc, scriptExtra, other.scriptExtra)) {
+  if (!CopyVectorToSpan(cx, alloc, scriptExtra, other.scriptExtra)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!CopyVectorToSpan(cx, alloc, scopeData, other.scopeData)) {
+  if (!CopyVectorToSpan(cx, alloc, scopeData, other.scopeData)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!CopyVectorToSpan(cx, alloc, scopeNames, other.scopeNames)) {
+  if (!CopyVectorToSpan(cx, alloc, scopeNames, other.scopeNames)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (!CopyVectorToSpan(cx, alloc, parserAtomData,
-                        other.parserAtoms.entries())) {
+                        other.parserAtoms.entries())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1822,7 +1822,7 @@ bool ExtensibleCompilationStencil::steal
                                          CompilationStencil&& other) {
   MOZ_ASSERT(alloc.isEmpty());
 
-  if (!other.hasExternalDependency) {
+  if (!other.hasExternalDependency) {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
     other.assertNoExternalDependency();
 #endif
@@ -1834,7 +1834,7 @@ bool ExtensibleCompilationStencil::steal
 
   functionKey = other.functionKey;
 
-  if (!CopySpanToVector(cx, regExpData, other.regExpData)) {
+  if (!CopySpanToVector(cx, regExpData, other.regExpData)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1842,31 +1842,31 @@ bool ExtensibleCompilationStencil::steal
     // If CompilationStencil has external dependency, peform deep copy.
 
     size_t bigIntSize = other.bigIntData.size();
-    if (!bigIntData.resize(bigIntSize)) {
+    if (!bigIntData.resize(bigIntSize)) {MOZ_RELEASE_ASSERT(0);
       js::ReportOutOfMemory(cx);
       return false;
     }
     for (size_t i = 0; i < bigIntSize; i++) {
-      if (!bigIntData[i].init(cx, alloc, other.bigIntData[i].source())) {
+      if (!bigIntData[i].init(cx, alloc, other.bigIntData[i].source())) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
   } else {
-    if (!CopySpanToVector(cx, bigIntData, other.bigIntData)) {
+    if (!CopySpanToVector(cx, bigIntData, other.bigIntData)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   if (other.hasExternalDependency) {
     size_t objLiteralSize = other.objLiteralData.size();
-    if (!objLiteralData.reserve(objLiteralSize)) {
+    if (!objLiteralData.reserve(objLiteralSize)) {MOZ_RELEASE_ASSERT(0);
       js::ReportOutOfMemory(cx);
       return false;
     }
     for (const auto& data : other.objLiteralData) {
       size_t length = data.code().size();
       auto* code = alloc.newArrayUninitialized<uint8_t>(length);
-      if (!code) {
+      if (!code) {MOZ_RELEASE_ASSERT(0);
         js::ReportOutOfMemory(cx);
         return false;
       }
@@ -1875,26 +1875,26 @@ bool ExtensibleCompilationStencil::steal
                                            data.propertyCount());
     }
   } else {
-    if (!CopySpanToVector(cx, objLiteralData, other.objLiteralData)) {
+    if (!CopySpanToVector(cx, objLiteralData, other.objLiteralData)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!CopySpanToVector(cx, scriptData, other.scriptData)) {
+  if (!CopySpanToVector(cx, scriptData, other.scriptData)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!CopySpanToVector(cx, scriptExtra, other.scriptExtra)) {
+  if (!CopySpanToVector(cx, scriptExtra, other.scriptExtra)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (other.hasExternalDependency) {
     size_t scopeSize = other.scopeData.size();
 
-    if (!CopySpanToVector(cx, scopeData, other.scopeData)) {
+    if (!CopySpanToVector(cx, scopeData, other.scopeData)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!scopeNames.reserve(scopeSize)) {
+    if (!scopeNames.reserve(scopeSize)) {MOZ_RELEASE_ASSERT(0);
       js::ReportOutOfMemory(cx);
       return false;
     }
@@ -1902,19 +1902,19 @@ bool ExtensibleCompilationStencil::steal
       if (other.scopeNames[i]) {
         BaseParserScopeData* data = CopyScopeData(
             cx, alloc, other.scopeData[i].kind(), other.scopeNames[i]);
-        if (!data) {
+        if (!data) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         scopeNames.infallibleEmplaceBack(data);
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         scopeNames.infallibleEmplaceBack(nullptr);
       }
     }
   } else {
-    if (!CopySpanToVector(cx, scopeData, other.scopeData)) {
+    if (!CopySpanToVector(cx, scopeData, other.scopeData)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!CopySpanToVector(cx, scopeNames, other.scopeNames)) {
+    if (!CopySpanToVector(cx, scopeNames, other.scopeNames)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1923,14 +1923,14 @@ bool ExtensibleCompilationStencil::steal
   // ParserAtoms should be interned, to populate internal HashMap.
   for (const auto* entry : other.parserAtomData) {
     if (!entry) {
-      if (!parserAtoms.addPlaceholder(cx)) {
+      if (!parserAtoms.addPlaceholder(cx)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       continue;
     }
 
     auto index = parserAtoms.internExternalParserAtom(cx, entry);
-    if (!index) {
+    if (!index) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (entry->isUsedByStencil()) {
@@ -2975,13 +2975,13 @@ bool CompilationState::allocateGCThingsU
 
   auto gcThingsOffset = CompilationGCThingIndex(gcThingData.length());
 
-  if (length > INDEX_LIMIT) {
+  if (length > INDEX_LIMIT) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return false;
   }
   uint32_t gcThingsLength = length;
 
-  if (!gcThingData.growByUninitialized(length)) {
+  if (!gcThingData.growByUninitialized(length)) {MOZ_RELEASE_ASSERT(0);
     js::ReportOutOfMemory(cx);
     return false;
   }
@@ -3000,7 +3000,7 @@ bool CompilationState::allocateGCThingsU
 }
 
 bool CompilationState::appendScriptStencilAndData(JSContext* cx) {
-  if (!scriptData.emplaceBack()) {
+  if (!scriptData.emplaceBack()) {MOZ_RELEASE_ASSERT(0);
     js::ReportOutOfMemory(cx);
     return false;
   }
@@ -3025,13 +3025,13 @@ bool CompilationState::appendGCThings(
 
   auto gcThingsOffset = CompilationGCThingIndex(gcThingData.length());
 
-  if (things.size() > INDEX_LIMIT) {
+  if (things.size() > INDEX_LIMIT) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return false;
   }
   uint32_t gcThingsLength = uint32_t(things.size());
 
-  if (!gcThingData.append(things.data(), things.size())) {
+  if (!gcThingData.append(things.data(), things.size())) {MOZ_RELEASE_ASSERT(0);
     js::ReportOutOfMemory(cx);
     return false;
   }
@@ -3068,7 +3068,7 @@ void CompilationState::rewind(const Comp
 
 bool CompilationStencilMerger::buildFunctionKeyToIndex(JSContext* cx) {
   if (!functionKeyToInitialScriptIndex_.reserve(initial_->scriptExtra.length() -
-                                                1)) {
+                                                1)) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -3102,15 +3102,15 @@ ScriptIndex CompilationStencilMerger::ge
 
 bool CompilationStencilMerger::buildAtomIndexMap(
     JSContext* cx, const CompilationStencil& delazification,
-    AtomIndexMap& atomIndexMap) {
+    AtomIndexMap& atomIndexMap) {MOZ_RELEASE_ASSERT(0);
   uint32_t atomCount = delazification.parserAtomData.size();
-  if (!atomIndexMap.reserve(atomCount)) {
+  if (!atomIndexMap.reserve(atomCount)) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
-  for (const auto& atom : delazification.parserAtomData) {
+  for (const auto& atom : delazification.parserAtomData) {MOZ_RELEASE_ASSERT(0);
     auto mappedIndex = initial_->parserAtoms.internExternalParserAtom(cx, atom);
-    if (!mappedIndex) {
+    if (!mappedIndex) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (atom->isUsedByStencil()) {
@@ -3136,36 +3136,36 @@ static void MergeScriptStencil(ScriptSte
                                GCThingIndexMapFunc mapGCThingIndex,
                                AtomIndexMapFunc mapAtomIndex,
                                ScopeIndexMapFunc mapScopeIndex,
-                               bool isTopLevel) {
+                               bool isTopLevel) {MOZ_RELEASE_ASSERT(0);
   // If this function was lazy, all inner functions should have been lazy.
   MOZ_ASSERT(!dest.hasSharedData());
 
   // If the inner lazy function is skipped, gcThingsLength is empty.
-  if (src.gcThingsLength) {
+  if (src.gcThingsLength) {MOZ_RELEASE_ASSERT(0);
     dest.gcThingsOffset = mapGCThingIndex(src.gcThingsOffset);
     dest.gcThingsLength = src.gcThingsLength;
   }
 
-  if (src.functionAtom) {
+  if (src.functionAtom) {MOZ_RELEASE_ASSERT(0);
     dest.functionAtom = mapAtomIndex(src.functionAtom);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   if (!dest.hasLazyFunctionEnclosingScopeIndex() &&
-      src.hasLazyFunctionEnclosingScopeIndex()) {
+      src.hasLazyFunctionEnclosingScopeIndex()) {MOZ_RELEASE_ASSERT(0);
     // Both enclosing function and this function were lazy, and
     // now enclosing function is non-lazy and this function is still lazy.
     dest.setLazyFunctionEnclosingScopeIndex(
         mapScopeIndex(src.lazyFunctionEnclosingScopeIndex()));
   } else if (dest.hasLazyFunctionEnclosingScopeIndex() &&
-             !src.hasLazyFunctionEnclosingScopeIndex()) {
+             !src.hasLazyFunctionEnclosingScopeIndex()) {MOZ_RELEASE_ASSERT(0);
     // The enclosing function was non-lazy and this function was lazy, and
     // now this function is non-lazy.
     dest.resetHasLazyFunctionEnclosingScopeIndexAfterStencilMerge();
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     // The enclosing function is still lazy.
     MOZ_ASSERT(!dest.hasLazyFunctionEnclosingScopeIndex());
     MOZ_ASSERT(!src.hasLazyFunctionEnclosingScopeIndex());
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
 #ifdef DEBUG
   uint16_t BASESCRIPT = uint16_t(FunctionFlags::Flags::BASESCRIPT);
@@ -3190,14 +3190,14 @@ static void MergeScriptStencil(ScriptSte
 
   // Other flags.
 
-  if (src.wasEmittedByEnclosingScript()) {
+  if (src.wasEmittedByEnclosingScript()) {MOZ_RELEASE_ASSERT(0);
     // NOTE: the top-level function of the delazification have
     //       src.wasEmittedByEnclosingScript() == false, and that shouldn't
     //       be copied.
     dest.setWasEmittedByEnclosingScript();
   }
 
-  if (src.allowRelazify()) {
+  if (src.allowRelazify()) {MOZ_RELEASE_ASSERT(0);
     dest.setAllowRelazify();
   }
 
@@ -3207,13 +3207,13 @@ static void MergeScriptStencil(ScriptSte
 }
 
 bool CompilationStencilMerger::addDelazification(
-    JSContext* cx, const CompilationStencil& delazification) {
+    JSContext* cx, const CompilationStencil& delazification) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(initial_);
 
   auto delazifiedFunctionIndex = getInitialScriptIndexFor(delazification);
   auto& destFun = initial_->scriptData[delazifiedFunctionIndex];
 
-  if (destFun.hasSharedData()) {
+  if (destFun.hasSharedData()) {MOZ_RELEASE_ASSERT(0);
     // If the function was already non-lazy, it means the following happened.
     //   1. this function is lazily parsed
     //   2. incremental encoding is started
@@ -3240,17 +3240,17 @@ bool CompilationStencilMerger::addDelazi
   auto failureCase = mozilla::MakeScopeExit([&] { initial_.reset(); });
 
   mozilla::Maybe<ScopeIndex> functionEnclosingScope;
-  if (destFun.hasLazyFunctionEnclosingScopeIndex()) {
+  if (destFun.hasLazyFunctionEnclosingScopeIndex()) {MOZ_RELEASE_ASSERT(0);
     // lazyFunctionEnclosingScopeIndex_ can be Nothing if this is
     // top-level function.
     functionEnclosingScope =
         mozilla::Some(destFun.lazyFunctionEnclosingScopeIndex());
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // A map from ParserAtomIndex in delazification to TaggedParserAtomIndex
   // in initial_.
   AtomIndexMap atomIndexMap;
-  if (!buildAtomIndexMap(cx, delazification, atomIndexMap)) {
+  if (!buildAtomIndexMap(cx, delazification, atomIndexMap)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   auto mapAtomIndex = [&](TaggedParserAtomIndex index) {
@@ -3303,70 +3303,70 @@ bool CompilationStencilMerger::addDelazi
 
   // Append gcThingData, with mapping TaggedScriptThingIndex.
   if (!initial_->gcThingData.append(delazification.gcThingData.data(),
-                                    delazification.gcThingData.size())) {
+                                    delazification.gcThingData.size())) {MOZ_RELEASE_ASSERT(0);
     js::ReportOutOfMemory(cx);
     return false;
   }
-  for (size_t i = gcThingOffset; i < initial_->gcThingData.length(); i++) {
+  for (size_t i = gcThingOffset; i < initial_->gcThingData.length(); i++) {MOZ_RELEASE_ASSERT(0);
     auto& index = initial_->gcThingData[i];
-    if (index.isNull()) {
+    if (index.isNull()) {MOZ_RELEASE_ASSERT(0);
       // Nothing to do.
-    } else if (index.isAtom()) {
+    } else if (index.isAtom()) {MOZ_RELEASE_ASSERT(0);
       index = TaggedScriptThingIndex(mapAtomIndex(index.toAtom()));
-    } else if (index.isBigInt()) {
+    } else if (index.isBigInt()) {MOZ_RELEASE_ASSERT(0);
       index = TaggedScriptThingIndex(mapBigIntIndex(index.toBigInt()));
-    } else if (index.isObjLiteral()) {
+    } else if (index.isObjLiteral()) {MOZ_RELEASE_ASSERT(0);
       index = TaggedScriptThingIndex(mapObjLiteralIndex(index.toObjLiteral()));
-    } else if (index.isRegExp()) {
+    } else if (index.isRegExp()) {MOZ_RELEASE_ASSERT(0);
       index = TaggedScriptThingIndex(mapRegExpIndex(index.toRegExp()));
-    } else if (index.isScope()) {
+    } else if (index.isScope()) {MOZ_RELEASE_ASSERT(0);
       index = TaggedScriptThingIndex(mapScopeIndex(index.toScope()));
-    } else if (index.isFunction()) {
+    } else if (index.isFunction()) {MOZ_RELEASE_ASSERT(0);
       index = TaggedScriptThingIndex(mapScriptIndex(index.toFunction()));
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(index.isEmptyGlobalScope());
       // Nothing to do
-    }
-  }
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
 
   // Append regExpData, with mapping RegExpStencil.atom_.
   if (!initial_->regExpData.append(delazification.regExpData.data(),
-                                   delazification.regExpData.size())) {
+                                   delazification.regExpData.size())) {MOZ_RELEASE_ASSERT(0);
     js::ReportOutOfMemory(cx);
     return false;
   }
-  for (size_t i = regExpOffset; i < initial_->regExpData.length(); i++) {
+  for (size_t i = regExpOffset; i < initial_->regExpData.length(); i++) {MOZ_RELEASE_ASSERT(0);
     auto& data = initial_->regExpData[i];
     data.atom_ = mapAtomIndex(data.atom_);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Append bigIntData, with copying BigIntStencil.source_.
   if (!initial_->bigIntData.reserve(bigIntOffset +
-                                    delazification.bigIntData.size())) {
+                                    delazification.bigIntData.size())) {MOZ_RELEASE_ASSERT(0);
     js::ReportOutOfMemory(cx);
     return false;
   }
-  for (const auto& data : delazification.bigIntData) {
+  for (const auto& data : delazification.bigIntData) {MOZ_RELEASE_ASSERT(0);
     initial_->bigIntData.infallibleEmplaceBack();
-    if (!initial_->bigIntData.back().init(cx, initial_->alloc, data.source())) {
+    if (!initial_->bigIntData.back().init(cx, initial_->alloc, data.source())) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
-  }
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
 
   // Append objLiteralData, with copying ObjLiteralStencil.code_, and mapping
   // TaggedParserAtomIndex in it.
   if (!initial_->objLiteralData.reserve(objLiteralOffset +
-                                        delazification.objLiteralData.size())) {
+                                        delazification.objLiteralData.size())) {MOZ_RELEASE_ASSERT(0);
     js::ReportOutOfMemory(cx);
     return false;
   }
-  for (const auto& data : delazification.objLiteralData) {
+  for (const auto& data : delazification.objLiteralData) {MOZ_RELEASE_ASSERT(0);
     size_t length = data.code().size();
     auto* code = initial_->alloc.newArrayUninitialized<uint8_t>(length);
-    if (!code) {
+    if (!code) {MOZ_RELEASE_ASSERT(0);
       js::ReportOutOfMemory(cx);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     memcpy(code, data.code().data(), length);
 
     ObjLiteralModifier modifier(mozilla::Span(code, length));
@@ -3374,46 +3374,46 @@ bool CompilationStencilMerger::addDelazi
 
     initial_->objLiteralData.infallibleEmplaceBack(code, length, data.flags(),
                                                    data.propertyCount());
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Append scopeData, with mapping indices in ScopeStencil fields.
   // And append scopeNames, with copying the entire data, and mapping
   // trailingNames.
   if (!initial_->scopeData.reserve(scopeOffset +
-                                   delazification.scopeData.size())) {
+                                   delazification.scopeData.size())) {MOZ_RELEASE_ASSERT(0);
+    js::ReportOutOfMemory(cx);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
+  if (!initial_->scopeNames.reserve(scopeOffset +
+                                    delazification.scopeNames.size())) {MOZ_RELEASE_ASSERT(0);
     js::ReportOutOfMemory(cx);
     return false;
   }
-  if (!initial_->scopeNames.reserve(scopeOffset +
-                                    delazification.scopeNames.size())) {
-    js::ReportOutOfMemory(cx);
-    return false;
-  }
-  for (size_t i = 0; i < delazification.scopeData.size(); i++) {
+  for (size_t i = 0; i < delazification.scopeData.size(); i++) {MOZ_RELEASE_ASSERT(0);
     const auto& srcData = delazification.scopeData[i];
     const auto* srcNames = delazification.scopeNames[i];
 
     mozilla::Maybe<ScriptIndex> functionIndex = mozilla::Nothing();
-    if (srcData.isFunction()) {
+    if (srcData.isFunction()) {MOZ_RELEASE_ASSERT(0);
       // Inner functions should be in the same order as initial, beginning from
       // the delazification's index.
       functionIndex = mozilla::Some(mapScriptIndex(srcData.functionIndex()));
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     BaseParserScopeData* destNames = nullptr;
-    if (srcNames) {
+    if (srcNames) {MOZ_RELEASE_ASSERT(0);
       destNames = CopyScopeData(cx, initial_->alloc, srcData.kind(), srcNames);
-      if (!destNames) {
+      if (!destNames) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       auto trailingNames =
           GetParserScopeDataTrailingNames(srcData.kind(), destNames);
-      for (auto& name : trailingNames) {
-        if (name.name()) {
+      for (auto& name : trailingNames) {MOZ_RELEASE_ASSERT(0);
+        if (name.name()) {MOZ_RELEASE_ASSERT(0);
           name.updateNameAfterStencilMerge(mapAtomIndex(name.name()));
-        }
-      }
-    }
+        }MOZ_RELEASE_ASSERT(0);
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
 
     initial_->scopeData.infallibleEmplaceBack(
         srcData.kind(),
@@ -3427,14 +3427,14 @@ bool CompilationStencilMerger::addDelazi
         functionIndex, srcData.isArrow());
 
     initial_->scopeNames.infallibleEmplaceBack(destNames);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Add delazified function's shared data.
   //
   // NOTE: Currently we don't delazify inner functions.
   if (!initial_->sharedData.addExtraWithoutShare(
           cx, delazifiedFunctionIndex,
-          delazification.sharedData.get(CompilationStencil::TopLevelIndex))) {
+          delazification.sharedData.get(CompilationStencil::TopLevelIndex))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3571,12 +3571,12 @@ JS::TranscodeResult JS::DecodeStencil(JS
                                       const JS::TranscodeRange& range,
                                       RefPtr<JS::Stencil>& stencilOut) {
   Rooted<CompilationInput> input(cx, CompilationInput(options));
-  if (!input.get().initForGlobal(cx)) {
+  if (!input.get().initForGlobal(cx)) {MOZ_RELEASE_ASSERT(0);
     return TranscodeResult::Throw;
   }
   UniquePtr<JS::Stencil> stencil(
       MakeUnique<CompilationStencil>(input.get().source));
-  if (!stencil) {
+  if (!stencil) {MOZ_RELEASE_ASSERT(0);
     return TranscodeResult::Throw;
   }
   XDRStencilDecoder decoder(cx, range);
diff --git a/js/src/frontend/StencilXdr.cpp b/js/src/frontend/StencilXdr.cpp
--- a/js/src/frontend/StencilXdr.cpp
+++ b/js/src/frontend/StencilXdr.cpp
@@ -38,14 +38,14 @@ template <XDRMode mode, typename T, size
 static XDRResult XDRVectorUninitialized(XDRState<mode>* xdr,
                                         Vector<T, N, AP>& vec,
                                         uint32_t& length) {
-  if (mode == XDR_ENCODE) {
+  if (mode == XDR_ENCODE) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(vec.length() <= UINT32_MAX);
     length = vec.length();
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MOZ_TRY(xdr->codeUint32(&length));
 
-  if (mode == XDR_DECODE) {
+  if (mode == XDR_DECODE) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(vec.empty());
     if (!vec.resizeUninitialized(length)) {
       js::ReportOutOfMemory(xdr->cx());
@@ -107,7 +107,7 @@ static XDRResult XDRSpanInitialized(XDRS
     MOZ_ASSERT(span.empty());
     if (size > 0) {
       auto* p = alloc.template newArrayUninitialized<T>(size);
-      if (!p) {
+      if (!p) {MOZ_RELEASE_ASSERT(0);
         js::ReportOutOfMemory(xdr->cx());
         return xdr->fail(JS::TranscodeResult::Throw);
       }
@@ -285,7 +285,7 @@ template <XDRMode mode>
       kind = uint8_t(Kind::Single);
     } else if (sharedData.isVector()) {
       kind = uint8_t(Kind::Vector);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(sharedData.isMap());
       kind = uint8_t(Kind::Map);
     }
@@ -443,7 +443,7 @@ template <XDRMode mode>
   MOZ_TRY(XDRAtomCount(xdr, &atomVectorLength));
 
   frontend::ParserAtomSpanBuilder builder(parserAtomData);
-  if (!builder.allocate(xdr->cx(), alloc, atomVectorLength)) {
+  if (!builder.allocate(xdr->cx(), alloc, atomVectorLength)) {MOZ_RELEASE_ASSERT(0);
     return xdr->fail(JS::TranscodeResult::Throw);
   }
 
@@ -468,7 +468,7 @@ template <XDRMode mode>
 
 template <XDRMode mode>
 /* static */ XDRResult StencilXDR::codeModuleMetadata(
-    XDRState<mode>* xdr, StencilModuleMetadata& stencil) {
+    XDRState<mode>* xdr, StencilModuleMetadata& stencil) {MOZ_RELEASE_ASSERT(0);
   MOZ_TRY(XDRVectorContent(xdr, stencil.requestedModules));
   MOZ_TRY(XDRVectorContent(xdr, stencil.importEntries));
   MOZ_TRY(XDRVectorContent(xdr, stencil.localExportEntries));
@@ -478,10 +478,10 @@ template <XDRMode mode>
 
   uint8_t isAsync = 0;
   if (mode == XDR_ENCODE) {
-    if (stencil.isAsync) {
+    if (stencil.isAsync) {MOZ_RELEASE_ASSERT(0);
       isAsync = stencil.isAsync ? 1 : 0;
     }
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MOZ_TRY(xdr->codeUint8(&isAsync));
 
@@ -680,7 +680,7 @@ template <XDRMode mode>
   MOZ_ASSERT(stencil.isInitialStencil());
 
   if (stencil.scriptExtra[CompilationStencil::TopLevelIndex].isModule()) {
-    if (mode == XDR_DECODE) {
+    if (mode == XDR_DECODE) {MOZ_RELEASE_ASSERT(0);
       stencil.moduleMetadata =
           xdr->cx()->template new_<StencilModuleMetadata>();
       if (!stencil.moduleMetadata) {
diff --git a/js/src/frontend/SwitchEmitter.cpp b/js/src/frontend/SwitchEmitter.cpp
--- a/js/src/frontend/SwitchEmitter.cpp
+++ b/js/src/frontend/SwitchEmitter.cpp
@@ -52,7 +52,7 @@ bool SwitchEmitter::TableGenerator::addN
   }
   if (caseValue >= intmapBitLength_) {
     size_t newLength = NumWordsForBitArrayOfLength(caseValue + 1);
-    if (!intmap_->resize(newLength)) {
+    if (!intmap_->resize(newLength)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(bce_->cx);
       return false;
     }
@@ -179,7 +179,7 @@ bool SwitchEmitter::emitTable(const Tabl
   controlInfo_.emplace(bce_, StatementKind::Switch);
   top_ = bce_->bytecodeSection().offset();
 
-  if (!caseOffsets_.resize(tableGen.tableLength())) {
+  if (!caseOffsets_.resize(tableGen.tableLength())) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(bce_->cx);
     return false;
   }
@@ -206,7 +206,7 @@ bool SwitchEmitter::emitCaseOrDefaultJum
   MOZ_ASSERT(kind_ == Kind::Cond);
 
   if (isDefault) {
-    if (!bce_->emitJump(JSOp::Default, &condSwitchDefaultOffset_)) {
+    if (!bce_->emitJump(JSOp::Default, &condSwitchDefaultOffset_)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     return true;
@@ -238,7 +238,7 @@ bool SwitchEmitter::emitCaseJump() {
   MOZ_ASSERT(kind_ == Kind::Cond);
   MOZ_ASSERT(state_ == State::CaseValue);
 
-  if (!bce_->emit1(JSOp::StrictEq)) {
+  if (!bce_->emit1(JSOp::StrictEq)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -273,14 +273,14 @@ bool SwitchEmitter::emitCaseBody() {
 
   if (state_ == State::Cond || state_ == State::Case) {
     // For cond switch, JSOp::Default is always emitted.
-    if (!emitImplicitDefault()) {
+    if (!emitImplicitDefault()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   JumpList caseJump;
   caseJump.offset = caseOffsets_[caseIndex_];
-  if (!bce_->emitJumpTargetAndPatch(caseJump)) {
+  if (!bce_->emitJumpTargetAndPatch(caseJump)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -325,7 +325,7 @@ bool SwitchEmitter::emitDefaultBody() {
 
   if (state_ == State::Cond || state_ == State::Case) {
     // For cond switch, JSOp::Default is always emitted.
-    if (!emitImplicitDefault()) {
+    if (!emitImplicitDefault()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -350,7 +350,7 @@ bool SwitchEmitter::emitEnd() {
 
   if (!hasDefault_) {
     // If no default case, offset for default is to end of switch.
-    if (!bce_->emitJumpTarget(&defaultJumpTargetOffset_)) {
+    if (!bce_->emitJumpTarget(&defaultJumpTargetOffset_)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -384,7 +384,7 @@ bool SwitchEmitter::emitEnd() {
     uint32_t firstResumeIndex = 0;
     mozilla::Span<BytecodeOffset> offsets =
         mozilla::Span(caseOffsets_.begin(), caseOffsets_.end());
-    if (!bce_->allocateResumeIndexRange(offsets, &firstResumeIndex)) {
+    if (!bce_->allocateResumeIndexRange(offsets, &firstResumeIndex)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     SET_RESUMEINDEX(pc, firstResumeIndex);
@@ -392,7 +392,7 @@ bool SwitchEmitter::emitEnd() {
 
   // Patch breaks before leaving the scope, as all breaks are under the
   // lexical scope if it exists.
-  if (!controlInfo_->patchBreaks(bce_)) {
+  if (!controlInfo_->patchBreaks(bce_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/frontend/TDZCheckCache.cpp b/js/src/frontend/TDZCheckCache.cpp
--- a/js/src/frontend/TDZCheckCache.cpp
+++ b/js/src/frontend/TDZCheckCache.cpp
@@ -25,7 +25,7 @@ bool TDZCheckCache::ensureCache(Bytecode
 
 Maybe<MaybeCheckTDZ> TDZCheckCache::needsTDZCheck(BytecodeEmitter* bce,
                                                   TaggedParserAtomIndex name) {
-  if (!ensureCache(bce)) {
+  if (!ensureCache(bce)) {MOZ_RELEASE_ASSERT(0);
     return Nothing();
   }
 
@@ -55,7 +55,7 @@ Maybe<MaybeCheckTDZ> TDZCheckCache::need
 bool TDZCheckCache::noteTDZCheck(BytecodeEmitter* bce,
                                  TaggedParserAtomIndex name,
                                  MaybeCheckTDZ check) {
-  if (!ensureCache(bce)) {
+  if (!ensureCache(bce)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/frontend/TokenStream.cpp b/js/src/frontend/TokenStream.cpp
--- a/js/src/frontend/TokenStream.cpp
+++ b/js/src/frontend/TokenStream.cpp
@@ -153,7 +153,7 @@ static uint32_t GetSingleCodePoint(const
   using namespace js;
 
   uint32_t codePoint;
-  if (MOZ_UNLIKELY(unicode::IsLeadSurrogate(**p)) && *p + 1 < end) {
+  if (MOZ_UNLIKELY(unicode::IsLeadSurrogate(**p)) && *p + 1 < end) {MOZ_RELEASE_ASSERT(0);
     char16_t lead = **p;
     char16_t maybeTrail = *(*p + 1);
     if (unicode::IsTrailSurrogate(maybeTrail)) {
@@ -201,7 +201,7 @@ bool IsIdentifier(JSLinearString* str) {
   return IsIdentifier(str->twoByteChars(nogc), str->length());
 }
 
-bool IsIdentifierNameOrPrivateName(JSLinearString* str) {
+bool IsIdentifierNameOrPrivateName(JSLinearString* str) {MOZ_RELEASE_ASSERT(0);
   JS::AutoCheckCannotGC nogc;
   MOZ_ASSERT(str);
   if (str->hasLatin1Chars()) {
@@ -236,7 +236,7 @@ bool IsIdentifierASCII(char c1, char c2)
          unicode::IsIdentifierPartASCII(c2);
 }
 
-bool IsIdentifierNameOrPrivateName(const Latin1Char* chars, size_t length) {
+bool IsIdentifierNameOrPrivateName(const Latin1Char* chars, size_t length) {MOZ_RELEASE_ASSERT(0);
   if (length == 0) {
     return false;
   }
@@ -251,7 +251,7 @@ bool IsIdentifierNameOrPrivateName(const
 }
 
 bool IsIdentifier(const char16_t* chars, size_t length) {
-  if (length == 0) {
+  if (length == 0) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -274,8 +274,8 @@ bool IsIdentifier(const char16_t* chars,
   return true;
 }
 
-bool IsIdentifierNameOrPrivateName(const char16_t* chars, size_t length) {
-  if (length == 0) {
+bool IsIdentifierNameOrPrivateName(const char16_t* chars, size_t length) {MOZ_RELEASE_ASSERT(0);
+  if (length == 0) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -288,14 +288,14 @@ bool IsIdentifierNameOrPrivateName(const
   // Skip over any private name marker.
   if (codePoint == '#') {
     // The identifier part of a private name mustn't be empty.
-    if (length == 1) {
+    if (length == 1) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     codePoint = GetSingleCodePoint(&p, end);
   }
 
-  if (!unicode::IsIdentifierStart(codePoint)) {
+  if (!unicode::IsIdentifierStart(codePoint)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -396,7 +396,7 @@ MOZ_ALWAYS_INLINE bool SourceCoords::add
     // only if lineStartOffsets_.append succeeds, to keep sentinel.
     // Otherwise return false to tell TokenStream about OOM.
     uint32_t maxPtr = MAX_PTR;
-    if (!lineStartOffsets_.append(maxPtr)) {
+    if (!lineStartOffsets_.append(maxPtr)) {MOZ_RELEASE_ASSERT(0);
       static_assert(std::is_same_v<decltype(lineStartOffsets_.allocPolicy()),
                                    TempAllocPolicy&>,
                     "this function's caller depends on it reporting an "
@@ -565,7 +565,7 @@ bool FillCharBufferFromSourceNormalizing
         }
       }
 
-      if (!charBuffer.append(ch)) {
+      if (!charBuffer.append(ch)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -817,7 +817,7 @@ uint32_t TokenStreamAnyChars::computePar
     if (!ptr) {
       // This could rehash and invalidate a cached vector pointer, but the outer
       // condition means we don't have a cached pointer.
-      if (!longLineColumnInfo_.add(ptr, line, Vector<ChunkInfo>(cx))) {
+      if (!longLineColumnInfo_.add(ptr, line, Vector<ChunkInfo>(cx))) {MOZ_RELEASE_ASSERT(0);
         // In case of OOM, just count columns from the start of the line.
         cx->recoverFromOutOfMemory();
         return ColumnFromPartial(start, 0, UnitsType::PossiblyMultiUnit);
@@ -886,7 +886,7 @@ uint32_t TokenStreamAnyChars::computePar
       partialColumn = 0;
     }
 
-    if (!lastChunkVectorForLine_->reserve(chunkIndex + 1)) {
+    if (!lastChunkVectorForLine_->reserve(chunkIndex + 1)) {MOZ_RELEASE_ASSERT(0);
       // As earlier, just start from the greatest offset/column in case of OOM.
       cx->recoverFromOutOfMemory();
       return ColumnFromPartial(partialOffset, partialColumn,
@@ -958,7 +958,7 @@ uint32_t GeneralTokenStreamChars<Unit, A
       anyChars.computePartialColumn(lineToken, offset, this->sourceUnits);
 
   if (lineToken.isFirstLine()) {
-    if (column > ColumnLimit) {
+    if (column > ColumnLimit) {MOZ_RELEASE_ASSERT(0);
       return ColumnLimit;
     }
 
@@ -1001,7 +1001,7 @@ MOZ_COLD void TokenStreamChars<Utf8Unit,
 
     bool canAddLineOfContext = fillExceptingContext(&err, offset);
     if (canAddLineOfContext) {
-      if (!internalComputeLineOfContext(&err, offset)) {
+      if (!internalComputeLineOfContext(&err, offset)) {MOZ_RELEASE_ASSERT(0);
         break;
       }
 
@@ -1013,7 +1013,7 @@ MOZ_COLD void TokenStreamChars<Utf8Unit,
     }
 
     auto notes = MakeUnique<JSErrorNotes>();
-    if (!notes) {
+    if (!notes) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(anyChars.cx);
       break;
     }
@@ -1195,7 +1195,7 @@ bool TokenStreamChars<char16_t, AnyChars
   if (MOZ_LIKELY(!unicode::IsLeadSurrogate(lead))) {
     if (MOZ_UNLIKELY(lead == unicode::LINE_SEPARATOR ||
                      lead == unicode::PARA_SEPARATOR)) {
-      if (!updateLineInfoForEOL()) {
+      if (!updateLineInfoForEOL()) {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
         *codePoint = EOF;  // sentinel value to hopefully cause errors
 #endif
@@ -1228,7 +1228,7 @@ bool TokenStreamChars<char16_t, AnyChars
 template <typename Unit, class AnyCharsAccess>
 bool TokenStreamSpecific<Unit, AnyCharsAccess>::getCodePoint(int32_t* cp) {
   int32_t unit = getCodeUnit();
-  if (unit == EOF) {
+  if (unit == EOF) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(anyCharsAccess().flags.isEOF,
                "flags.isEOF should have been set by getCodeUnit()");
     *cp = EOF;
@@ -1287,7 +1287,7 @@ bool TokenStreamChars<Utf8Unit, AnyChars
   char32_t cp = maybeCodePoint.value();
   if (MOZ_UNLIKELY(cp == unicode::LINE_SEPARATOR ||
                    cp == unicode::PARA_SEPARATOR)) {
-    if (!updateLineInfoForEOL()) {
+    if (!updateLineInfoForEOL()) {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
       *codePoint = EOF;  // sentinel value to hopefully cause errors
 #endif
@@ -1338,7 +1338,7 @@ size_t SourceUnits<char16_t>::findWindow
     // require this, and this behavior isn't currently imposed on
     // pre-context, but these facts might change someday.)
 
-    if (MOZ_UNLIKELY(unicode::IsLeadSurrogate(c))) {
+    if (MOZ_UNLIKELY(unicode::IsLeadSurrogate(c))) {MOZ_RELEASE_ASSERT(0);
       break;
     }
 
@@ -1348,7 +1348,7 @@ size_t SourceUnits<char16_t>::findWindow
     // If it's not a surrogate at all, keep going.
     if (MOZ_LIKELY(!unicode::IsTrailSurrogate(c))) {
       continue;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Stop if we don't have a usable surrogate pair.
     if (HalfWindowSize() >= WindowRadius ||
@@ -1703,19 +1703,19 @@ bool TokenStreamCharsBase<Unit>::addLine
 
   const Unit* encodedWindow = sourceUnits.codeUnitPtrAt(encodedWindowStart);
   if (!FillCharBufferFromSourceNormalizingAsciiLineBreaks(
-          lineOfContext, encodedWindow, encodedWindow + encodedWindowLength)) {
+          lineOfContext, encodedWindow, encodedWindow + encodedWindowLength)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   size_t utf16WindowLength = lineOfContext.length();
 
   // The windowed string is null-terminated.
-  if (!lineOfContext.append('\0')) {
+  if (!lineOfContext.append('\0')) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   err->lineOfContext.reset(lineOfContext.extractOrCopyRawBuffer());
-  if (!err->lineOfContext) {
+  if (!err->lineOfContext) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1992,7 +1992,7 @@ template <typename Unit, class AnyCharsA
   }
 
   if (shouldWarnDeprecated) {
-    if (!warning(JSMSG_DEPRECATED_PRAGMA, errorMsgPragma)) {
+    if (!warning(JSMSG_DEPRECATED_PRAGMA, errorMsgPragma)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2020,26 +2020,26 @@ template <typename Unit, class AnyCharsA
         break;
       }
 
-      if (!this->charBuffer.append(unit)) {
+      if (!this->charBuffer.append(unit)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       continue;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // This ignores encoding errors: subsequent caller-side code to
     // handle the remaining source text in the comment will do so.
     PeekedCodePoint<Unit> peeked = this->sourceUnits.peekCodePoint();
-    if (peeked.isNone() || unicode::IsSpace(peeked.codePoint())) {
+    if (peeked.isNone() || unicode::IsSpace(peeked.codePoint())) {MOZ_RELEASE_ASSERT(0);
       break;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     MOZ_ASSERT(!IsLineTerminator(peeked.codePoint()),
                "!IsSpace must imply !IsLineTerminator or else we'll fail to "
                "maintain line-info/flags for EOL");
     this->sourceUnits.consumeKnownCodePoint(peeked);
 
-    if (!AppendCodePointToCharBuffer(this->charBuffer, peeked.codePoint())) {
+    if (!AppendCodePointToCharBuffer(this->charBuffer, peeked.codePoint())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } while (true);
@@ -2137,7 +2137,7 @@ bool AppendCodePointToCharBuffer(CharBuf
   MOZ_ASSERT(numUnits == 1 || numUnits == 2,
              "UTF-16 code points are only encoded in one or two units");
 
-  if (!charBuffer.append(units[0])) {
+  if (!charBuffer.append(units[0])) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2168,7 +2168,7 @@ bool TokenStreamSpecific<Unit, AnyCharsA
     uint32_t codePoint;
     if (MOZ_LIKELY(isAsciiCodePoint(unit))) {
       if (unicode::IsIdentifierPart(char16_t(unit)) || unit == '#') {
-        if (!this->charBuffer.append(unit)) {
+        if (!this->charBuffer.append(unit)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -2182,7 +2182,7 @@ bool TokenStreamSpecific<Unit, AnyCharsA
       // |restoreNextRawCharAddress| undoes all gets, and this function
       // doesn't update line/column info.
       char32_t cp;
-      if (!getNonAsciiCodePointDontNormalize(toUnit(unit), &cp)) {
+      if (!getNonAsciiCodePointDontNormalize(toUnit(unit), &cp)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -2253,7 +2253,7 @@ template <typename Unit, class AnyCharsA
   if (MOZ_UNLIKELY(escaping == IdentifierEscapes::SawUnicodeEscape)) {
     // Identifiers containing Unicode escapes have to be converted into
     // tokenbuf before atomizing.
-    if (!putIdentInCharBuffer(identStart)) {
+    if (!putIdentInCharBuffer(identStart)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2275,7 +2275,7 @@ template <typename Unit, class AnyCharsA
 
     atom = atomizeSourceChars(Span(chars, length));
   }
-  if (!atom) {
+  if (!atom) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2398,7 +2398,7 @@ void SourceUnits<Utf8Unit>::consumeRestO
     }
 
     PeekedCodePoint<Utf8Unit> peeked = peekCodePoint();
-    if (peeked.isNone()) {
+    if (peeked.isNone()) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
@@ -2478,7 +2478,7 @@ template <typename Unit, class AnyCharsA
     // Most numbers are pure decimal integers without fractional component
     // or exponential notation.  Handle that with optimized code.
     if (!GetDecimalInteger(anyCharsAccess().cx, numStart,
-                           this->sourceUnits.addressOfNextCodeUnit(), &dval)) {
+                           this->sourceUnits.addressOfNextCodeUnit(), &dval)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else if (unit == 'n') {
@@ -2501,14 +2501,14 @@ template <typename Unit, class AnyCharsA
       }
 
       // Exponential notation must contain at least one digit.
-      if (!IsAsciiDigit(unit)) {
+      if (!IsAsciiDigit(unit)) {MOZ_RELEASE_ASSERT(0);
         ungetCodeUnit(unit);
         error(JSMSG_MISSING_EXPONENT);
         return false;
       }
 
       // Consume exponential digits.
-      if (!matchIntegerAfterFirstDigit(IsAsciiDigit, &unit)) {
+      if (!matchIntegerAfterFirstDigit(IsAsciiDigit, &unit)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2520,7 +2520,7 @@ template <typename Unit, class AnyCharsA
     // failures return 0.0, so we'll still get the right result.)
     if (!GetDecimalNonInteger(anyCharsAccess().cx, numStart,
                               this->sourceUnits.addressOfNextCodeUnit(),
-                              &dval)) {
+                              &dval)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2538,7 +2538,7 @@ template <typename Unit, class AnyCharsA
       // This ignores encoding errors: subsequent caller-side code to
       // handle source text after the number will do so.
       PeekedCodePoint<Unit> peeked = this->sourceUnits.peekCodePoint();
-      if (!peeked.isNone() && unicode::IsIdentifierStart(peeked.codePoint())) {
+      if (!peeked.isNone() && unicode::IsIdentifierStart(peeked.codePoint())) {MOZ_RELEASE_ASSERT(0);
         error(JSMSG_IDSTART_AFTER_NUMBER);
         return false;
       }
@@ -2603,7 +2603,7 @@ template <typename Unit, class AnyCharsA
     }
 
     if (unit == '\\') {
-      if (!this->charBuffer.append(unit)) {
+      if (!this->charBuffer.append(unit)) {MOZ_RELEASE_ASSERT(0);
         return badToken();
       }
 
@@ -2639,7 +2639,7 @@ template <typename Unit, class AnyCharsA
     }
 
     MOZ_ASSERT(!IsLineTerminator(AssertedCast<char32_t>(unit)));
-    if (!this->charBuffer.append(unit)) {
+    if (!this->charBuffer.append(unit)) {MOZ_RELEASE_ASSERT(0);
       return badToken();
     }
   } while (true);
@@ -2781,7 +2781,7 @@ template <typename Unit, class AnyCharsA
       if (unicode::IsSpace(cp)) {
         this->sourceUnits.consumeKnownCodePoint(peeked);
         if (IsLineTerminator(cp)) {
-          if (!updateLineInfoForEOL()) {
+          if (!updateLineInfoForEOL()) {MOZ_RELEASE_ASSERT(0);
             return badToken();
           }
 
@@ -3013,15 +3013,15 @@ template <typename Unit, class AnyCharsA
           error(JSMSG_IDSTART_AFTER_NUMBER);
           return badToken();
         }
-      } else if (MOZ_LIKELY(unit != EOF)) {
+      } else if (MOZ_LIKELY(unit != EOF)) {MOZ_RELEASE_ASSERT(0);
         // This ignores encoding errors: subsequent caller-side code to
         // handle source text after the number will do so.
         PeekedCodePoint<Unit> peeked = this->sourceUnits.peekCodePoint();
         if (!peeked.isNone() &&
-            unicode::IsIdentifierStart(peeked.codePoint())) {
+            unicode::IsIdentifierStart(peeked.codePoint())) {MOZ_RELEASE_ASSERT(0);
           error(JSMSG_IDSTART_AFTER_NUMBER);
           return badToken();
-        }
+        }MOZ_RELEASE_ASSERT(0);
       }
 
       if (isBigInt) {
@@ -3031,7 +3031,7 @@ template <typename Unit, class AnyCharsA
       double dval;
       if (!GetFullInteger(anyCharsAccess().cx, numStart,
                           this->sourceUnits.addressOfNextCodeUnit(), radix,
-                          IntegerSeparatorHandling::SkipUnderscore, &dval)) {
+                          IntegerSeparatorHandling::SkipUnderscore, &dval)) {MOZ_RELEASE_ASSERT(0);
         return badToken();
       }
       newNumberToken(dval, NoDecimal, start, modifier, ttp);
@@ -3390,13 +3390,13 @@ bool TokenStreamSpecific<Unit, AnyCharsA
     // the non-ASCII case early for readability.
     if (MOZ_UNLIKELY(!isAsciiCodePoint(unit))) {
       char32_t cp;
-      if (!getNonAsciiCodePointDontNormalize(toUnit(unit), &cp)) {
+      if (!getNonAsciiCodePointDontNormalize(toUnit(unit), &cp)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       if (MOZ_UNLIKELY(cp == unicode::LINE_SEPARATOR ||
                        cp == unicode::PARA_SEPARATOR)) {
-        if (!updateLineInfoForEOL()) {
+        if (!updateLineInfoForEOL()) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -3405,7 +3405,7 @@ bool TokenStreamSpecific<Unit, AnyCharsA
         MOZ_ASSERT(!IsLineTerminator(cp));
       }
 
-      if (!AppendCodePointToCharBuffer(this->charBuffer, cp)) {
+      if (!AppendCodePointToCharBuffer(this->charBuffer, cp)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -3426,7 +3426,7 @@ bool TokenStreamSpecific<Unit, AnyCharsA
       // an unlikely special-case to it and then continue.
       if (MOZ_UNLIKELY(!isAsciiCodePoint(unit))) {
         int32_t codePoint;
-        if (!getNonAsciiCodePoint(unit, &codePoint)) {
+        if (!getNonAsciiCodePoint(unit, &codePoint)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -3436,7 +3436,7 @@ bool TokenStreamSpecific<Unit, AnyCharsA
         // in this case.
         if (codePoint != '\n') {
           if (!AppendCodePointToCharBuffer(this->charBuffer,
-                                           AssertedCast<char32_t>(codePoint))) {
+                                           AssertedCast<char32_t>(codePoint))) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -3703,7 +3703,7 @@ bool TokenStreamSpecific<Unit, AnyCharsA
         }  // default
       }    // switch (AssertedCast<uint8_t>(CodeUnitValue(toUnit(unit))))
 
-      if (!this->charBuffer.append(unit)) {
+      if (!this->charBuffer.append(unit)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -3723,7 +3723,7 @@ bool TokenStreamSpecific<Unit, AnyCharsA
         matchLineTerminator('\n');
       }
 
-      if (!updateLineInfoForEOL()) {
+      if (!updateLineInfoForEOL()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -3733,7 +3733,7 @@ bool TokenStreamSpecific<Unit, AnyCharsA
       break;
     }
 
-    if (!this->charBuffer.append(unit)) {
+    if (!this->charBuffer.append(unit)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
diff --git a/js/src/frontend/TryEmitter.cpp b/js/src/frontend/TryEmitter.cpp
--- a/js/src/frontend/TryEmitter.cpp
+++ b/js/src/frontend/TryEmitter.cpp
@@ -64,13 +64,13 @@ bool TryEmitter::emitTryEnd() {
 
   // Gosub to finally, if present.
   if (hasFinally() && controlInfo_) {
-    if (!bce_->emitGoSub(&controlInfo_->gosubs)) {
+    if (!bce_->emitGoSub(&controlInfo_->gosubs)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // Emit jump over catch and/or finally.
-  if (!bce_->emitJump(JSOp::Goto, &catchAndFinallyJump_)) {
+  if (!bce_->emitJump(JSOp::Goto, &catchAndFinallyJump_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -83,7 +83,7 @@ bool TryEmitter::emitTryEnd() {
 
 bool TryEmitter::emitCatch() {
   MOZ_ASSERT(state_ == State::Try);
-  if (!emitTryEnd()) {
+  if (!emitTryEnd()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -94,15 +94,15 @@ bool TryEmitter::emitCatch() {
     // try block:
     //
     //   eval("try { 1; throw 2 } catch(e) {}"); // undefined, not 1
-    if (!bce_->emit1(JSOp::Undefined)) {
+    if (!bce_->emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!bce_->emit1(JSOp::SetRval)) {
+    if (!bce_->emit1(JSOp::SetRval)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!bce_->emit1(JSOp::Exception)) {
+  if (!bce_->emit1(JSOp::Exception)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -125,7 +125,7 @@ bool TryEmitter::emitCatchEnd() {
 
   // gosub <finally>, if required.
   if (hasFinally()) {
-    if (!bce_->emitGoSub(&controlInfo_->gosubs)) {
+    if (!bce_->emitGoSub(&controlInfo_->gosubs)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     MOZ_ASSERT(bce_->bytecodeSection().stackDepth() == depth_);
@@ -157,19 +157,19 @@ bool TryEmitter::emitFinally(
 
   if (!hasCatch()) {
     MOZ_ASSERT(state_ == State::Try);
-    if (!emitTryEnd()) {
+    if (!emitTryEnd()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
     MOZ_ASSERT(state_ == State::Catch);
-    if (!emitCatchEnd()) {
+    if (!emitCatchEnd()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   MOZ_ASSERT(bce_->bytecodeSection().stackDepth() == depth_);
 
-  if (!bce_->emitJumpTarget(&finallyStart_)) {
+  if (!bce_->emitJumpTarget(&finallyStart_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -182,16 +182,16 @@ bool TryEmitter::emitFinally(
     controlInfo_->setEmittingSubroutine();
   }
   if (finallyPos) {
-    if (!bce_->updateSourceCoordNotes(finallyPos.value())) {
+    if (!bce_->updateSourceCoordNotes(finallyPos.value())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
-  if (!bce_->emit1(JSOp::Finally)) {
+  if (!bce_->emit1(JSOp::Finally)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (controlKind_ == ControlKind::Syntactic) {
-    if (!bce_->emit1(JSOp::GetRval)) {
+    if (!bce_->emit1(JSOp::GetRval)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -199,10 +199,10 @@ bool TryEmitter::emitFinally(
     // correct value even if there's no other statement before them:
     //
     //   eval("x: try { 1 } finally { break x; }"); // undefined, not 1
-    if (!bce_->emit1(JSOp::Undefined)) {
+    if (!bce_->emit1(JSOp::Undefined)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!bce_->emit1(JSOp::SetRval)) {
+    if (!bce_->emit1(JSOp::SetRval)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -221,7 +221,7 @@ bool TryEmitter::emitFinallyEnd() {
   MOZ_ASSERT(state_ == State::Finally);
 
   if (controlKind_ == ControlKind::Syntactic) {
-    if (!bce_->emit1(JSOp::SetRval)) {
+    if (!bce_->emit1(JSOp::SetRval)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -237,12 +237,12 @@ bool TryEmitter::emitFinallyEnd() {
 bool TryEmitter::emitEnd() {
   if (!hasFinally()) {
     MOZ_ASSERT(state_ == State::Catch);
-    if (!emitCatchEnd()) {
+    if (!emitCatchEnd()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
     MOZ_ASSERT(state_ == State::Finally);
-    if (!emitFinallyEnd()) {
+    if (!emitFinallyEnd()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -250,7 +250,7 @@ bool TryEmitter::emitEnd() {
   MOZ_ASSERT(bce_->bytecodeSection().stackDepth() == depth_);
 
   // Fix up the end-of-try/catch jumps to come here.
-  if (!bce_->emitJumpTargetAndPatch(catchAndFinallyJump_)) {
+  if (!bce_->emitJumpTargetAndPatch(catchAndFinallyJump_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -258,7 +258,7 @@ bool TryEmitter::emitEnd() {
   // (first to last for a given nesting level, inner to outer by level).
   if (hasCatch()) {
     if (!bce_->addTryNote(TryNoteKind::Catch, depth_, offsetAfterTryOp(),
-                          tryEnd_.offset)) {
+                          tryEnd_.offset)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
diff --git a/js/src/frontend/WhileEmitter.cpp b/js/src/frontend/WhileEmitter.cpp
--- a/js/src/frontend/WhileEmitter.cpp
+++ b/js/src/frontend/WhileEmitter.cpp
@@ -32,11 +32,11 @@ bool WhileEmitter::emitCond(const Maybe<
   if (whilePos && endPos &&
       bce_->parser->errorReporter().lineAt(*whilePos) ==
           bce_->parser->errorReporter().lineAt(*endPos)) {
-    if (!bce_->updateSourceCoordNotes(*whilePos)) {
+    if (!bce_->updateSourceCoordNotes(*whilePos)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     // Emit a Nop to ensure the source position is not part of the loop.
-    if (!bce_->emit1(JSOp::Nop)) {
+    if (!bce_->emit1(JSOp::Nop)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -73,7 +73,7 @@ bool WhileEmitter::emitEnd() {
 
   tdzCacheForBody_.reset();
 
-  if (!loopInfo_->emitContinueTarget(bce_)) {
+  if (!loopInfo_->emitContinueTarget(bce_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/gc/Allocator.cpp b/js/src/gc/Allocator.cpp
--- a/js/src/gc/Allocator.cpp
+++ b/js/src/gc/Allocator.cpp
@@ -54,14 +54,14 @@ JSObject* js::AllocateObject(JSContext* 
   if (cx->isNurseryAllocSuppressed()) {
     JSObject* obj = GCRuntime::tryNewTenuredObject<NoGC>(cx, kind, thingSize,
                                                          nDynamicSlots);
-    if (MOZ_UNLIKELY(allowGC && !obj)) {
+    if (MOZ_UNLIKELY(allowGC && !obj)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
     }
     return obj;
   }
 
   JSRuntime* rt = cx->runtime();
-  if (!rt->gc.checkAllocatorState<allowGC>(cx, kind)) {
+  if (!rt->gc.checkAllocatorState<allowGC>(cx, kind)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -133,9 +133,9 @@ JSObject* GCRuntime::tryNewTenuredObject
     HeapSlot* allocation =
         cx->maybe_pod_malloc<HeapSlot>(ObjectSlots::allocCount(nDynamicSlots));
     if (MOZ_UNLIKELY(!allocation)) {
-      if (allowGC) {
+      if (allowGC) {MOZ_RELEASE_ASSERT(0);
         ReportOutOfMemory(cx);
-      }
+      }MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -201,14 +201,14 @@ StringAllocT* js::AllocateStringImpl(JSC
   if (cx->isNurseryAllocSuppressed()) {
     StringAllocT* str =
         GCRuntime::tryNewTenuredThing<StringAllocT, NoGC>(cx, kind, size);
-    if (MOZ_UNLIKELY(allowGC && !str)) {
+    if (MOZ_UNLIKELY(allowGC && !str)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
     }
     return str;
   }
 
   JSRuntime* rt = cx->runtime();
-  if (!rt->gc.checkAllocatorState<allowGC>(cx, kind)) {
+  if (!rt->gc.checkAllocatorState<allowGC>(cx, kind)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -269,17 +269,17 @@ JS::BigInt* js::AllocateBigInt(JSContext
   MOZ_ASSERT(size == Arena::thingSize(kind));
 
   // Off-thread alloc cannot trigger GC or make runtime assertions.
-  if (cx->isNurseryAllocSuppressed()) {
+  if (cx->isNurseryAllocSuppressed()) {MOZ_RELEASE_ASSERT(0);
     JS::BigInt* bi =
         GCRuntime::tryNewTenuredThing<JS::BigInt, NoGC>(cx, kind, size);
-    if (MOZ_UNLIKELY(allowGC && !bi)) {
+    if (MOZ_UNLIKELY(allowGC && !bi)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return bi;
   }
 
   JSRuntime* rt = cx->runtime();
-  if (!rt->gc.checkAllocatorState<allowGC>(cx, kind)) {
+  if (!rt->gc.checkAllocatorState<allowGC>(cx, kind)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -385,7 +385,7 @@ void GCRuntime::attemptLastDitchGC(JSCon
   // size limit. Try to perform an all-compartments, non-incremental, shrinking
   // GC and wait for it to finish.
 
-  if (cx->isHelperThreadContext()) {
+  if (cx->isHelperThreadContext()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -405,7 +405,7 @@ void GCRuntime::attemptLastDitchGC(JSCon
 template <AllowGC allowGC>
 bool GCRuntime::checkAllocatorState(JSContext* cx, AllocKind kind) {
   if (allowGC) {
-    if (!gcIfNeededAtAllocation(cx)) {
+    if (!gcIfNeededAtAllocation(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -574,7 +574,7 @@ TenuredCell* ArenaLists::refillFreeListA
   }
 
   TenuredChunk* chunk = rt->gc.pickChunk(maybeLock.ref());
-  if (!chunk) {
+  if (!chunk) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -792,7 +792,7 @@ TenuredChunk* GCRuntime::getOrAllocChunk
   TenuredChunk* chunk = emptyChunks(lock).pop();
   if (!chunk) {
     chunk = TenuredChunk::allocate(this);
-    if (!chunk) {
+    if (!chunk) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     MOZ_ASSERT(chunk->info.numArenasFreeCommitted == 0);
diff --git a/js/src/gc/AtomMarking.cpp b/js/src/gc/AtomMarking.cpp
--- a/js/src/gc/AtomMarking.cpp
+++ b/js/src/gc/AtomMarking.cpp
@@ -78,7 +78,7 @@ bool AtomMarkingRuntime::computeBitmapFr
   MOZ_ASSERT(CurrentThreadIsPerformingGC());
   MOZ_ASSERT(!runtime->hasHelperThreadZones());
 
-  if (!bitmap.ensureSpace(allocatedWords)) {
+  if (!bitmap.ensureSpace(allocatedWords)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -147,7 +147,7 @@ void AtomMarkingRuntime::markAtomsUsedBy
     }
     BitwiseOrIntoChunkMarkBits(runtime, markedUnion);
   } else {
-    for (ZonesIter zone(runtime, SkipAtoms); !zone.done(); zone.next()) {
+    for (ZonesIter zone(runtime, SkipAtoms); !zone.done(); zone.next()) {MOZ_RELEASE_ASSERT(0);
       if (!zone->isCollectingFromAnyThread()) {
         BitwiseOrIntoChunkMarkBits(runtime, zone->markedAtoms());
       }
diff --git a/js/src/gc/Barrier.cpp b/js/src/gc/Barrier.cpp
--- a/js/src/gc/Barrier.cpp
+++ b/js/src/gc/Barrier.cpp
@@ -129,7 +129,7 @@ static MOZ_ALWAYS_INLINE bool ValueIsPer
   return false;
 }
 
-void gc::ValueReadBarrier(const Value& v) {
+void gc::ValueReadBarrier(const Value& v) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(v.isGCThing());
 
   if (!ValueIsPermanent(v)) {
@@ -152,7 +152,7 @@ static MOZ_ALWAYS_INLINE bool IdIsPerman
     return cell->as<JSString>()->isPermanentAndMayBeShared();
   }
 
-  if (id.isSymbol()) {
+  if (id.isSymbol()) {MOZ_RELEASE_ASSERT(0);
     return cell->as<JS::Symbol>()->isPermanentAndMayBeShared();
   }
 
@@ -174,8 +174,8 @@ void gc::IdPreWriteBarrier(jsid id) {
   }
 }
 
-static MOZ_ALWAYS_INLINE bool CellPtrIsPermanent(JS::GCCellPtr thing) {
-  if (thing.mayBeOwnedByOtherRuntime()) {
+static MOZ_ALWAYS_INLINE bool CellPtrIsPermanent(JS::GCCellPtr thing) {MOZ_RELEASE_ASSERT(0);
+  if (thing.mayBeOwnedByOtherRuntime()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -188,7 +188,7 @@ static MOZ_ALWAYS_INLINE bool CellPtrIsP
   return false;
 }
 
-void gc::CellPtrPreWriteBarrier(JS::GCCellPtr thing) {
+void gc::CellPtrPreWriteBarrier(JS::GCCellPtr thing) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(thing);
 
   if (!CellPtrIsPermanent(thing)) {
@@ -235,10 +235,10 @@ template <typename T>
 template <typename T>
 /* static */ bool MovableCellHasher<T>::match(const Key& k, const Lookup& l) {
   // Return true if both are null or false if only one is null.
-  if (!k) {
+  if (!k) {MOZ_RELEASE_ASSERT(0);
     return !l;
   }
-  if (!l) {
+  if (!l) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -248,7 +248,7 @@ template <typename T>
              l->zoneFromAnyThread()->isSelfHostingZone());
 
   Zone* zone = k->zoneFromAnyThread();
-  if (zone != l->zoneFromAnyThread()) {
+  if (zone != l->zoneFromAnyThread()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/gc/FinalizationRegistry.cpp b/js/src/gc/FinalizationRegistry.cpp
--- a/js/src/gc/FinalizationRegistry.cpp
+++ b/js/src/gc/FinalizationRegistry.cpp
@@ -40,7 +40,7 @@ bool GCRuntime::registerWithFinalization
   auto& map = target->zone()->finalizationRecordMap();
   auto ptr = map.lookupForAdd(target);
   if (!ptr) {
-    if (!map.add(ptr, target, FinalizationRecordVector(target->zone()))) {
+    if (!map.add(ptr, target, FinalizationRecordVector(target->zone()))) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
diff --git a/js/src/gc/GC.cpp b/js/src/gc/GC.cpp
--- a/js/src/gc/GC.cpp
+++ b/js/src/gc/GC.cpp
@@ -849,7 +849,7 @@ inline void GCRuntime::prepareToFreeChun
 inline void GCRuntime::updateOnArenaFree() { ++numArenasFreeCommitted; }
 
 bool TenuredChunk::isPageFree(size_t pageIndex) const {
-  if (decommittedPages[pageIndex]) {
+  if (decommittedPages[pageIndex]) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -863,7 +863,7 @@ bool TenuredChunk::isPageFree(size_t pag
   return true;
 }
 
-bool TenuredChunk::isPageFree(const Arena* arena) const {
+bool TenuredChunk::isPageFree(const Arena* arena) const {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(arena);
   // arena must come from the freeArenasHead list.
   MOZ_ASSERT(!arena->allocated());
@@ -871,7 +871,7 @@ bool TenuredChunk::isPageFree(const Aren
   size_t expectedPage = pageIndex(arena);
 
   Arena* nextArena = arena->next;
-  while (nextArena && (pageIndex(nextArena) == expectedPage)) {
+  while (nextArena && (pageIndex(nextArena) == expectedPage)) {MOZ_RELEASE_ASSERT(0);
     count++;
     if (count == ArenasPerPage) {
       break;
@@ -977,7 +977,7 @@ void TenuredChunk::decommitFreeArenas(GC
     info.numArenasFree += ArenasPerPage;
     updateChunkListAfterFree(gc, ArenasPerPage, lock);
 
-    if (!ok) {
+    if (!ok) {MOZ_RELEASE_ASSERT(0);
       break;
     }
 
@@ -1054,7 +1054,7 @@ void TenuredChunk::decommitFreeArenasWit
     }
 
     if (!isPageFree(i) || js::oom::ShouldFailWithOOM() ||
-        !MarkPagesUnusedSoft(pageAddress(i), SystemPageSize())) {
+        !MarkPagesUnusedSoft(pageAddress(i), SystemPageSize())) {MOZ_RELEASE_ASSERT(0);
       // Find out the free arenas and add it to freeArenasHead.
       for (size_t j = 0; j < ArenasPerPage; j++) {
         size_t arenaIndex = i * ArenasPerPage + j;
@@ -1483,23 +1483,23 @@ bool GCRuntime::init(uint32_t maxbytes) 
     MOZ_ALWAYS_TRUE(tunables.setParameter(JSGC_MAX_BYTES, maxbytes, lock));
 
     const char* size = getenv("JSGC_MARK_STACK_LIMIT");
-    if (size) {
+    if (size) {MOZ_RELEASE_ASSERT(0);
       setMarkStackLimit(atoi(size), lock);
     }
 
-    if (!nursery().init(lock)) {
+    if (!nursery().init(lock)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     const char* pretenureThresholdStr = getenv("JSGC_PRETENURE_THRESHOLD");
-    if (pretenureThresholdStr && pretenureThresholdStr[0]) {
+    if (pretenureThresholdStr && pretenureThresholdStr[0]) {MOZ_RELEASE_ASSERT(0);
       char* last;
       long pretenureThreshold = strtol(pretenureThresholdStr, &last, 10);
       if (last[0] || !tunables.setParameter(JSGC_PRETENURE_THRESHOLD,
-                                            pretenureThreshold, lock)) {
+                                            pretenureThreshold, lock)) {MOZ_RELEASE_ASSERT(0);
         fprintf(stderr, "Invalid value for JSGC_PRETENURE_THRESHOLD: %s\n",
                 pretenureThresholdStr);
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
   }
 
@@ -1983,7 +1983,7 @@ JS::DoCycleCollectionCallback GCRuntime:
   return prior.op;
 }
 
-void GCRuntime::callDoCycleCollectionCallback(JSContext* cx) {
+void GCRuntime::callDoCycleCollectionCallback(JSContext* cx) {MOZ_RELEASE_ASSERT(0);
   const auto& callback = gcDoCycleCollectionCallback.ref();
   if (callback.op) {
     callback.op(cx);
@@ -2689,10 +2689,10 @@ void GCRuntime::updateRttValueObjects(Mo
 
   zone->rttValueObjects().sweep(nullptr);
 
-  for (auto r = zone->rttValueObjects().all(); !r.empty(); r.popFront()) {
+  for (auto r = zone->rttValueObjects().all(); !r.empty(); r.popFront()) {MOZ_RELEASE_ASSERT(0);
     RttValue* obj = &MaybeForwardedObjectAs<RttValue>(r.front());
     UpdateCellPointers(trc, obj);
-    for (size_t i = 0; i < RttValue::SlotCount; i++) {
+    for (size_t i = 0; i < RttValue::SlotCount; i++) {MOZ_RELEASE_ASSERT(0);
       Value value = obj->getSlot(i);
       if (value.isObject()) {
         UpdateCellPointers(trc, &value.toObject());
@@ -2924,8 +2924,8 @@ void GCRuntime::clearRelocatedArenasWith
   }
 }
 
-void GCRuntime::protectAndHoldArenas(Arena* arenaList) {
-  for (Arena* arena = arenaList; arena;) {
+void GCRuntime::protectAndHoldArenas(Arena* arenaList) {MOZ_RELEASE_ASSERT(0);
+  for (Arena* arena = arenaList; arena;) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(!arena->allocated());
     Arena* next = arena->next;
     if (!next) {
@@ -2938,7 +2938,7 @@ void GCRuntime::protectAndHoldArenas(Are
   }
 }
 
-void GCRuntime::unprotectHeldRelocatedArenas() {
+void GCRuntime::unprotectHeldRelocatedArenas() {MOZ_RELEASE_ASSERT(0);
   for (Arena* arena = relocatedArenasToRelease; arena; arena = arena->next) {
     UnprotectPages(arena, ArenaSize);
     MOZ_ASSERT(!arena->allocated());
@@ -3187,7 +3187,7 @@ SliceBudget::SliceBudget(WorkBudget work
 int SliceBudget::describe(char* buffer, size_t maxlen) const {
   if (isUnlimited()) {
     return snprintf(buffer, maxlen, "unlimited");
-  } else if (isWorkBudget()) {
+  } else if (isWorkBudget()) {MOZ_RELEASE_ASSERT(0);
     return snprintf(buffer, maxlen, "work(%" PRId64 ")", workBudget());
   } else {
     return snprintf(buffer, maxlen, "%" PRId64 "ms", timeBudget());
@@ -3238,7 +3238,7 @@ bool GCRuntime::triggerGC(JS::GCReason r
    * Don't trigger GCs if this is being called off the main thread from
    * onTooMuchMalloc().
    */
-  if (!CurrentThreadCanAccessRuntime(rt)) {
+  if (!CurrentThreadCanAccessRuntime(rt)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3339,7 +3339,7 @@ bool GCRuntime::triggerZoneGC(Zone* zone
   MOZ_ASSERT(CurrentThreadCanAccessRuntime(rt));
 
   /* GC is already running. */
-  if (JS::RuntimeHeapIsBusy()) {
+  if (JS::RuntimeHeapIsBusy()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3379,11 +3379,11 @@ void GCRuntime::maybeGC() {
   }
 #endif
 
-  if (gcIfRequested()) {
+  if (gcIfRequested()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
-  if (isIncrementalGCInProgress()) {
+  if (isIncrementalGCInProgress()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -3513,7 +3513,7 @@ void GCRuntime::decommitFreeArenas(const
   for (ChunkPool::Iter chunk(availableChunks(lock)); !chunk.done();
        chunk.next()) {
     if (chunk->info.numArenasFreeCommitted != 0 &&
-        !chunksToDecommit.append(chunk)) {
+        !chunksToDecommit.append(chunk)) {MOZ_RELEASE_ASSERT(0);
       onOutOfMallocMemory(lock);
       return;
     }
@@ -3561,7 +3561,7 @@ void GCRuntime::cancelRequestedGCAfterBa
 }
 
 void GCRuntime::sweepBackgroundThings(ZoneList& zones) {
-  if (zones.isEmpty()) {
+  if (zones.isEmpty()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -3993,7 +3993,7 @@ bool GCRuntime::shouldPreserveJITCode(Re
   if (cleanUpEverything) {
     return false;
   }
-  if (!canAllocateMoreCode) {
+  if (!canAllocateMoreCode) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4260,7 +4260,7 @@ void GCRuntime::unmarkWeakMaps() {
 bool GCRuntime::beginPreparePhase(JS::GCReason reason, AutoGCSession& session) {
   gcstats::AutoPhase ap(stats(), gcstats::PhaseKind::PREPARE);
 
-  if (!prepareZonesForCollection(reason, &isFull.ref())) {
+  if (!prepareZonesForCollection(reason, &isFull.ref())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4538,7 +4538,7 @@ void GCRuntime::findDeadCompartments() {
 
   for (CompartmentsIter comp(rt); !comp.done(); comp.next()) {
     if (comp->gcState.maybeAlive) {
-      if (!workList.append(comp)) {
+      if (!workList.append(comp)) {MOZ_RELEASE_ASSERT(0);
         return;
       }
     }
@@ -4551,7 +4551,7 @@ void GCRuntime::findDeadCompartments() {
       Compartment* dest = e.front();
       if (!dest->gcState.maybeAlive) {
         dest->gcState.maybeAlive = true;
-        if (!workList.append(dest)) {
+        if (!workList.append(dest)) {MOZ_RELEASE_ASSERT(0);
           return;
         }
       }
@@ -4596,14 +4596,14 @@ IncrementalProgress GCRuntime::markWeakR
     if (!marker.incrementalWeakMapMarkingEnabled) {
       for (ZoneIterT zone(this); !zone.done(); zone.next()) {
         AutoEnterOOMUnsafeRegion oomUnsafe;
-        if (!zone->gcWeakKeys().clear()) {
+        if (!zone->gcWeakKeys().clear()) {MOZ_RELEASE_ASSERT(0);
           oomUnsafe.crash("clearing weak keys when entering weak marking mode");
         }
       }
     }
 
     for (ZoneIterT zone(this); !zone.done(); zone.next()) {
-      if (zone->enterWeakMarkingMode(&marker, budget) == NotFinished) {
+      if (zone->enterWeakMarkingMode(&marker, budget) == NotFinished) {MOZ_RELEASE_ASSERT(0);
         MOZ_ASSERT(marker.incrementalWeakMapMarkingEnabled);
         marker.leaveWeakMarkingMode();
         return NotFinished;
@@ -4626,7 +4626,7 @@ IncrementalProgress GCRuntime::markWeakR
 
   bool markedAny = true;
   while (markedAny) {
-    if (!marker.markUntilBudgetExhausted(budget)) {
+    if (!marker.markUntilBudgetExhausted(budget)) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(marker.incrementalWeakMapMarkingEnabled);
       return NotFinished;
     }
@@ -4744,7 +4744,7 @@ bool Compartment::findSweepGroupEdges() 
 bool Zone::findSweepGroupEdges(Zone* atomsZone) {
   // Any zone may have a pointer to an atom in the atoms zone, and these aren't
   // in the cross compartment map.
-  if (atomsZone->wasGCStarted() && !addSweepGroupEdgeTo(atomsZone)) {
+  if (atomsZone->wasGCStarted() && !addSweepGroupEdgeTo(atomsZone)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4791,7 +4791,7 @@ static bool AddEdgesForMarkQueue(GCMarke
 
 bool GCRuntime::findSweepGroupEdges() {
   for (GCZonesIter zone(this); !zone.done(); zone.next()) {
-    if (!zone->findSweepGroupEdges(atomsZone)) {
+    if (!zone->findSweepGroupEdges(atomsZone)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -4817,7 +4817,7 @@ void GCRuntime::groupZonesForSweeping(JS
   }
 
   // Use one component for two-slice zeal modes.
-  if (useZeal && hasIncrementalTwoSliceZealMode()) {
+  if (useZeal && hasIncrementalTwoSliceZealMode()) {MOZ_RELEASE_ASSERT(0);
     finder.useOneComponent();
   }
 
@@ -4984,7 +4984,7 @@ void js::gc::DelayCrossCompartmentGrayMa
     SetProxyReservedSlot(src, slot,
                          ObjectOrNullValue(comp->gcIncomingGrayPointers));
     comp->gcIncomingGrayPointers = src;
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(GetProxyReservedSlot(src, slot).isObjectOrNull());
   }
 
@@ -5151,7 +5151,7 @@ void js::NotifyGCPostSwap(JSObject* a, J
    * Two objects in the same compartment have had their contents swapped.  If
    * either of them were in our gray pointer list, we re-add them again.
    */
-  if (removedFlags & JS_GC_SWAP_OBJECT_A_REMOVED) {
+  if (removedFlags & JS_GC_SWAP_OBJECT_A_REMOVED) {MOZ_RELEASE_ASSERT(0);
     DelayCrossCompartmentGrayMarking(b);
   }
   if (removedFlags & JS_GC_SWAP_OBJECT_B_REMOVED) {
@@ -5240,7 +5240,7 @@ IncrementalProgress GCRuntime::endMarkin
 
   gcstats::AutoPhase ap(stats(), gcstats::PhaseKind::SWEEP_MARK);
 
-  if (markWeakReferencesInCurrentGroup(budget) == NotFinished) {
+  if (markWeakReferencesInCurrentGroup(budget) == NotFinished) {MOZ_RELEASE_ASSERT(0);
     return NotFinished;
   }
 
@@ -5495,7 +5495,7 @@ template <typename Functor>
 static inline bool IterateWeakCaches(JSRuntime* rt, Functor f) {
   for (SweepGroupZonesIter zone(rt); !zone.done(); zone.next()) {
     for (JS::detail::WeakCacheBase* cache : zone->weakCaches()) {
-      if (!f(cache, zone.get())) {
+      if (!f(cache, zone.get())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -5538,10 +5538,10 @@ static bool PrepareWeakCacheTasks(JSRunt
   return ok;
 }
 
-static void SweepAllWeakCachesOnMainThread(JSRuntime* rt) {
+static void SweepAllWeakCachesOnMainThread(JSRuntime* rt) {MOZ_RELEASE_ASSERT(0);
   // If we ran out of memory, do all the work on the main thread.
   gcstats::AutoPhase ap(rt->gc.stats(), gcstats::PhaseKind::SWEEP_WEAK_CACHES);
-  IterateWeakCaches(rt, [&](JS::detail::WeakCacheBase* cache, Zone* zone) {
+  IterateWeakCaches(rt, [&](JS::detail::WeakCacheBase* cache, Zone* zone) {MOZ_RELEASE_ASSERT(0);
     if (cache->needsIncrementalBarrier()) {
       cache->setNeedsIncrementalBarrier(false);
     }
@@ -5651,7 +5651,7 @@ IncrementalProgress GCRuntime::beginSwee
       AutoUnlockHelperThreadState unlock(lock);
       sweepJitDataOnMainThread(fop);
 
-      if (!canSweepWeakCachesOffThread) {
+      if (!canSweepWeakCachesOffThread) {MOZ_RELEASE_ASSERT(0);
         MOZ_ASSERT(sweepCacheTasks.empty());
         SweepAllWeakCachesOnMainThread(rt);
       }
@@ -6028,7 +6028,7 @@ void WeakCacheSweepIterator::settle() {
 
 IncrementalProgress GCRuntime::sweepWeakCaches(JSFreeOp* fop,
                                                SliceBudget& budget) {
-  if (weakCachesToSweep.ref().isNothing()) {
+  if (weakCachesToSweep.ref().isNothing()) {MOZ_RELEASE_ASSERT(0);
     return Finished;
   }
 
@@ -6202,7 +6202,7 @@ class SweepActionMaybeYield final : publ
   {
   }
 
-  IncrementalProgress run(Args& args) override {
+  IncrementalProgress run(Args& args) override {MOZ_RELEASE_ASSERT(0);
 #ifdef JS_GC_ZEAL
     if (!isYielding && args.gc->shouldYieldForZeal(mode)) {
       isYielding = true;
@@ -6235,7 +6235,7 @@ class SweepActionSequence final : public
   bool init(UniquePtr<SweepAction>* acts, size_t count) {
     for (size_t i = 0; i < count; i++) {
       auto& action = acts[i];
-      if (!action) {
+      if (!action) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (action->shouldSkip()) {
@@ -6566,7 +6566,7 @@ IncrementalProgress GCRuntime::compactPh
 
   clearRelocatedArenas(relocatedArenas, reason);
 
-  if (ShouldProtectRelocatedArenas(reason)) {
+  if (ShouldProtectRelocatedArenas(reason)) {MOZ_RELEASE_ASSERT(0);
     protectAndHoldArenas(relocatedArenas);
   } else {
     releaseRelocatedArenas(relocatedArenas);
@@ -6939,7 +6939,7 @@ void GCRuntime::incrementalSlice(SliceBu
               DescribeBudget(budget));
 #endif
 
-  if (useZeal && hasIncrementalTwoSliceZealMode()) {
+  if (useZeal && hasIncrementalTwoSliceZealMode()) {MOZ_RELEASE_ASSERT(0);
     // Yields between slices occurs at predetermined points in these modes; the
     // budget is not used. |isIncremental| is still true.
     stats().log("Using unlimited budget for two-slice zeal mode");
@@ -7298,13 +7298,13 @@ GCRuntime::IncrementalResult GCRuntime::
     }
 
     if (zone->jitHeapSize.bytes() >=
-        zone->jitHeapThreshold.incrementalLimitBytes()) {
+        zone->jitHeapThreshold.incrementalLimitBytes()) {MOZ_RELEASE_ASSERT(0);
       checkZoneIsScheduled(zone, reason, "JIT code bytes");
       budget = SliceBudget::unlimited();
       stats().nonincremental(GCAbortReason::JitCodeBytesTrigger);
-      if (zone->wasGCStarted() && zone->gcState() > Zone::Sweep) {
+      if (zone->wasGCStarted() && zone->gcState() > Zone::Sweep) {MOZ_RELEASE_ASSERT(0);
         resetReason = GCAbortReason::JitCodeBytesTrigger;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
     if (isIncrementalGCInProgress() &&
@@ -7322,7 +7322,7 @@ GCRuntime::IncrementalResult GCRuntime::
 }
 
 void GCRuntime::maybeIncreaseSliceBudget(SliceBudget& budget) {
-  if (js::SupportDifferentialTesting()) {
+  if (js::SupportDifferentialTesting()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -7493,7 +7493,7 @@ MOZ_NEVER_INLINE GCRuntime::IncrementalR
   return result;
 }
 
-void GCRuntime::waitForBackgroundTasksBeforeSlice() {
+void GCRuntime::waitForBackgroundTasksBeforeSlice() {MOZ_RELEASE_ASSERT(0);
   gcstats::AutoPhase ap(stats(), gcstats::PhaseKind::WAIT_BACKGROUND_THREAD);
 
   // Background finalization and decommit are finished by definition before we
@@ -7972,7 +7972,7 @@ bool GCRuntime::gcIfRequested() {
 
   if (majorGCRequested()) {
     if (majorGCTriggerReason == JS::GCReason::DELAYED_ATOMS_GC &&
-        !rt->mainContextFromOwnThread()->canCollectAtoms()) {
+        !rt->mainContextFromOwnThread()->canCollectAtoms()) {MOZ_RELEASE_ASSERT(0);
       // A GC was requested to collect the atoms zone, but it's no longer
       // possible. Skip this collection.
       majorGCTriggerReason = JS::GCReason::NO_REASON;
@@ -8063,7 +8063,7 @@ Realm* js::NewRealm(JSContext* cx, JSPri
     }
 
     zoneHolder = MakeUnique<Zone>(cx->runtime(), kind);
-    if (!zoneHolder || !zoneHolder->init()) {
+    if (!zoneHolder || !zoneHolder->init()) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return nullptr;
     }
@@ -8078,7 +8078,7 @@ Realm* js::NewRealm(JSContext* cx, JSPri
     MOZ_ASSERT(comp->invisibleToDebugger() == invisibleToDebugger);
   } else {
     compHolder = cx->make_unique<JS::Compartment>(zone, invisibleToDebugger);
-    if (!compHolder) {
+    if (!compHolder) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -8086,7 +8086,7 @@ Realm* js::NewRealm(JSContext* cx, JSPri
   }
 
   UniquePtr<Realm> realm(cx->new_<Realm>(comp, options));
-  if (!realm || !realm->init(cx, principals)) {
+  if (!realm || !realm->init(cx, principals)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -8102,7 +8102,7 @@ Realm* js::NewRealm(JSContext* cx, JSPri
   if (!comp->realms().reserve(comp->realms().length() + 1) ||
       (compHolder &&
        !zone->compartments().reserve(zone->compartments().length() + 1)) ||
-      (zoneHolder && !rt->gc.zones().reserve(rt->gc.zones().length() + 1))) {
+      (zoneHolder && !rt->gc.zones().reserve(rt->gc.zones().length() + 1))) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -8247,7 +8247,7 @@ void GCRuntime::mergeRealms(Realm* sourc
   deleteEmptyZone(sourceZone);
 }
 
-void GCRuntime::runDebugGC() {
+void GCRuntime::runDebugGC() {MOZ_RELEASE_ASSERT(0);
 #ifdef JS_GC_ZEAL
   if (rt->mainContextFromOwnThread()->suppressGC) {
     return;
@@ -8493,7 +8493,7 @@ JS_FRIEND_API const char* JS::GCTraceKin
   }
 }
 
-JS_FRIEND_API size_t JS::GCTraceKindSize(JS::TraceKind kind) {
+JS_FRIEND_API size_t JS::GCTraceKindSize(JS::TraceKind kind) {MOZ_RELEASE_ASSERT(0);
   switch (kind) {
 #define MAP_SIZE(name, type, _0, _1) \
   case JS::TraceKind::name:          \
@@ -8579,7 +8579,7 @@ JS_PUBLIC_API void JS::PrepareForIncreme
   AssertHeapIsIdle();
   CHECK_THREAD(cx);
 
-  if (!JS::IsIncrementalGCInProgress(cx)) {
+  if (!JS::IsIncrementalGCInProgress(cx)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -8590,11 +8590,11 @@ JS_PUBLIC_API void JS::PrepareForIncreme
   }
 }
 
-JS_PUBLIC_API bool JS::IsGCScheduled(JSContext* cx) {
+JS_PUBLIC_API bool JS::IsGCScheduled(JSContext* cx) {MOZ_RELEASE_ASSERT(0);
   AssertHeapIsIdle();
   CHECK_THREAD(cx);
 
-  for (ZonesIter zone(cx->runtime(), WithAtoms); !zone.done(); zone.next()) {
+  for (ZonesIter zone(cx->runtime(), WithAtoms); !zone.done(); zone.next()) {MOZ_RELEASE_ASSERT(0);
     if (zone->isGCScheduled()) {
       return true;
     }
@@ -8768,7 +8768,7 @@ JS_PUBLIC_API bool JS::IsIncrementalGCIn
          !rt->gc.isVerifyPreBarriersEnabled();
 }
 
-JS_PUBLIC_API bool JS::IsIncrementalBarrierNeeded(JSContext* cx) {
+JS_PUBLIC_API bool JS::IsIncrementalBarrierNeeded(JSContext* cx) {MOZ_RELEASE_ASSERT(0);
   if (JS::RuntimeHeapIsBusy()) {
     return false;
   }
@@ -8777,7 +8777,7 @@ JS_PUBLIC_API bool JS::IsIncrementalBarr
   return state != gc::State::NotActive && state <= gc::State::Sweep;
 }
 
-JS_PUBLIC_API void JS::IncrementalPreWriteBarrier(JSObject* obj) {
+JS_PUBLIC_API void JS::IncrementalPreWriteBarrier(JSObject* obj) {MOZ_RELEASE_ASSERT(0);
   if (!obj) {
     return;
   }
@@ -8788,7 +8788,7 @@ JS_PUBLIC_API void JS::IncrementalPreWri
   PreWriteBarrier(obj);
 }
 
-JS_PUBLIC_API void JS::IncrementalPreWriteBarrier(GCCellPtr thing) {
+JS_PUBLIC_API void JS::IncrementalPreWriteBarrier(GCCellPtr thing) {MOZ_RELEASE_ASSERT(0);
   if (!thing) {
     return;
   }
@@ -8916,7 +8916,7 @@ static bool DummyGetter(JSContext* cx, u
 
 JSObject* NewMemoryInfoObject(JSContext* cx) {
   RootedObject obj(cx, JS_NewObject(cx, nullptr));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -8943,17 +8943,17 @@ JSObject* NewMemoryInfoObject(JSContext*
 #endif
 
     if (!JS_DefineProperty(cx, obj, pair.name, getter, nullptr,
-                           JSPROP_ENUMERATE)) {
+                           JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
 
   RootedObject zoneObj(cx, JS_NewObject(cx, nullptr));
-  if (!zoneObj) {
+  if (!zoneObj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!JS_DefineProperty(cx, obj, "zone", zoneObj, JSPROP_ENUMERATE)) {
+  if (!JS_DefineProperty(cx, obj, "zone", zoneObj, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/gc/Marking.cpp b/js/src/gc/Marking.cpp
--- a/js/src/gc/Marking.cpp
+++ b/js/src/gc/Marking.cpp
@@ -690,14 +690,14 @@ void js::TraceManuallyBarrieredGenericPo
 void js::TraceGCCellPtrRoot(JSTracer* trc, JS::GCCellPtr* thingp,
                             const char* name) {
   Cell* thing = thingp->asCell();
-  if (!thing) {
+  if (!thing) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
   Cell* traced =
       TraceGenericPointerRootAndType(trc, thing, thingp->kind(), name);
 
-  if (!traced) {
+  if (!traced) {MOZ_RELEASE_ASSERT(0);
     *thingp = JS::GCCellPtr();
   } else if (traced != thingp->asCell()) {
     *thingp = JS::GCCellPtr(traced, thingp->kind());
@@ -856,7 +856,7 @@ void GCMarker::forgetWeakMap(WeakMapBase
 // 'delegate' is no longer the delegate of 'key'.
 void GCMarker::severWeakDelegate(JSObject* key, JSObject* delegate) {
   JS::Zone* zone = delegate->zone();
-  if (!zone->needsIncrementalBarrier()) {
+  if (!zone->needsIncrementalBarrier()) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(!zone->gcWeakKeys(delegate).get(delegate),
                "non-collecting zone should not have populated gcWeakKeys");
     return;
@@ -876,11 +876,11 @@ void GCMarker::severWeakDelegate(JSObjec
   js::Vector<WeakMapBase*, 10, SystemAllocPolicy> severedKeyMaps;
   p->value.eraseIf(
       [key, &severedKeyMaps](const WeakMarkable& markable) -> bool {
-        if (markable.key != key) {
+        if (markable.key != key) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         AutoEnterOOMUnsafeRegion oomUnsafe;
-        if (!severedKeyMaps.append(markable.weakmap)) {
+        if (!severedKeyMaps.append(markable.weakmap)) {MOZ_RELEASE_ASSERT(0);
           oomUnsafe.crash("OOM while recording all weakmaps with severed key");
         }
         return true;
@@ -908,11 +908,11 @@ void GCMarker::restoreWeakDelegate(JSObj
 
   js::Vector<WeakMapBase*, 10, SystemAllocPolicy> maps;
   p->value.eraseIf([key, &maps](const WeakMarkable& markable) -> bool {
-    if (markable.key != key) {
+    if (markable.key != key) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     AutoEnterOOMUnsafeRegion oomUnsafe;
-    if (!maps.append(markable.weakmap)) {
+    if (!maps.append(markable.weakmap)) {MOZ_RELEASE_ASSERT(0);
       oomUnsafe.crash("OOM while recording all weakmaps with severed key");
     }
     return true;
@@ -1342,7 +1342,7 @@ inline void js::GCMarker::eagerlyMarkChi
   while (linearStr->hasBase()) {
     linearStr = linearStr->base();
     MOZ_ASSERT(linearStr->JSString::isLinear());
-    if (linearStr->isPermanentAtom()) {
+    if (linearStr->isPermanentAtom()) {MOZ_RELEASE_ASSERT(0);
       break;
     }
     AssertShouldMarkInZone(linearStr);
@@ -1391,7 +1391,7 @@ inline void js::GCMarker::eagerlyMarkChi
       } else {
         // When both children are ropes, set aside the right one to
         // scan it later.
-        if (next && !stack.pushTempRope(next)) {
+        if (next && !stack.pushTempRope(next)) {MOZ_RELEASE_ASSERT(0);
           delayMarkingChildren(next);
         }
         next = &left->asRope();
@@ -1425,7 +1425,7 @@ static inline void TraceNullableBindingN
     }
   }
 };
-void AbstractBindingName<JSAtom>::trace(JSTracer* trc) {
+void AbstractBindingName<JSAtom>::trace(JSTracer* trc) {MOZ_RELEASE_ASSERT(0);
   if (JSAtom* atom = name()) {
     TraceManuallyBarrieredEdge(trc, &atom, "binding name");
   }
@@ -1826,7 +1826,7 @@ static inline size_t NumUsedDynamicSlots
   return nslots - nfixed;
 }
 
-inline void GCMarker::processMarkStackTop(SliceBudget& budget) {
+inline void GCMarker::processMarkStackTop(SliceBudget& budget) {MOZ_RELEASE_ASSERT(0);
   /*
    * This function uses explicit goto and scans objects directly. This allows us
    * to eliminate tail recursion and significantly improve the marking
@@ -2363,7 +2363,7 @@ void GCMarker::stop() {
   MOZ_ASSERT(!delayedMarkingList);
   MOZ_ASSERT(markLaterArenas == 0);
 
-  if (state == MarkingState::NotActive) {
+  if (state == MarkingState::NotActive) {MOZ_RELEASE_ASSERT(0);
     return;
   }
   state = MarkingState::NotActive;
@@ -2374,7 +2374,7 @@ void GCMarker::stop() {
   setMainStackColor(MarkColor::Black);
   AutoEnterOOMUnsafeRegion oomUnsafe;
   for (GCZonesIter zone(runtime()); !zone.done(); zone.next()) {
-    if (!zone->gcWeakKeys().clear()) {
+    if (!zone->gcWeakKeys().clear()) {MOZ_RELEASE_ASSERT(0);
       oomUnsafe.crash("clearing weak keys in GCMarker::stop()");
     }
     if (!zone->gcNurseryWeakKeys().clear()) {
@@ -2468,7 +2468,7 @@ void GCMarker::repush(JSObject* obj) {
 bool GCMarker::enterWeakMarkingMode() {
   MOZ_ASSERT(weakMapAction() == JS::WeakMapTraceAction::Expand);
   MOZ_ASSERT(state != MarkingState::WeakMarking);
-  if (state == MarkingState::IterativeMarking) {
+  if (state == MarkingState::IterativeMarking) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2514,7 +2514,7 @@ IncrementalProgress JS::Zone::enterWeakM
   // values are marked if both their map and key are marked -- though note that
   // we may later leave weak marking mode, do some more marking, and then enter
   // back in.
-  if (!isGCMarking()) {
+  if (!isGCMarking()) {MOZ_RELEASE_ASSERT(0);
     return IncrementalProgress::Finished;
   }
 
@@ -2540,7 +2540,7 @@ IncrementalProgress JS::Zone::enterWeakM
         // over the ones from before weak marking mode was switched on.
         v.weakmap->markKey(marker, key, v.key);
         budget.step();
-        if (budget.isOverBudget()) {
+        if (budget.isOverBudget()) {MOZ_RELEASE_ASSERT(0);
           return NotFinished;
         }
       }
@@ -2551,7 +2551,7 @@ IncrementalProgress JS::Zone::enterWeakM
         if (end == markables.length()) {
           bool found;
           gcWeakKeys().remove(key, &found);
-        } else {
+        } else {MOZ_RELEASE_ASSERT(0);
           markables.erase(markables.begin(), &markables[end]);
         }
       }
@@ -2866,7 +2866,7 @@ void js::gc::StoreBuffer::SlotsEdge::tra
   MOZ_ASSERT(IsCellPointerValid(obj));
 
   // Beware JSObject::swap exchanging a native object for a non-native one.
-  if (!obj->is<NativeObject>()) {
+  if (!obj->is<NativeObject>()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -2949,7 +2949,7 @@ static inline void PreventDeduplicationO
                                ->savedNurseryBaseOrRelocOverlay();
     } else {
       JSLinearString* base = baseOrRelocOverlay;
-      if (base->isTenured()) {
+      if (base->isTenured()) {MOZ_RELEASE_ASSERT(0);
         break;
       }
       if (base->isDeduplicatable()) {
@@ -3441,7 +3441,7 @@ JSString* js::TenuringTracer::moveToTenu
 
     dst = allocTenuredString(src, zone, dstKind);
 
-    if (!nursery().stringDeDupSet->putNew(dst)) {
+    if (!nursery().stringDeDupSet->putNew(dst)) {MOZ_RELEASE_ASSERT(0);
       // When there is oom caused by the stringDeDupSet, stop deduplicating
       // strings.
       nursery().stringDeDupSet.reset();
@@ -3730,11 +3730,11 @@ bool js::gc::IsMarkedInternal(JSRuntime*
   MOZ_ASSERT(!CurrentThreadIsGCFinalizing());
 
   T* thing = *thingp;
-  if (IsOwnedByOtherRuntime(rt, thing)) {
+  if (IsOwnedByOtherRuntime(rt, thing)) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
-  if (!thing->isTenured()) {
+  if (!thing->isTenured()) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(CurrentThreadCanAccessRuntime(rt));
     auto** cellp = reinterpret_cast<Cell**>(thingp);
     return Nursery::getForwardedPointer(cellp);
@@ -3758,7 +3758,7 @@ bool js::gc::IsAboutToBeFinalizedInterna
   JSRuntime* rt = thing->runtimeFromAnyThread();
 
   /* Permanent atoms are never finalized by non-owning runtimes. */
-  if (thing->isPermanentAndMayBeShared() && TlsContext.get()->runtime() != rt) {
+  if (thing->isPermanentAndMayBeShared() && TlsContext.get()->runtime() != rt) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3781,7 +3781,7 @@ bool js::gc::IsAboutToBeFinalizedInterna
 }
 
 template <typename T>
-bool js::gc::IsAboutToBeFinalizedInternal(T* thingp) {
+bool js::gc::IsAboutToBeFinalizedInternal(T* thingp) {MOZ_RELEASE_ASSERT(0);
   bool dying = false;
   auto thing = MapGCThingTyped(*thingp, [&dying](auto t) {
     dying = IsAboutToBeFinalizedInternal(&t);
@@ -4241,13 +4241,13 @@ void GCMarker::traceBarrieredCell(JS::GC
 namespace js {
 namespace debug {
 
-MarkInfo GetMarkInfo(Cell* rawCell) {
-  if (!rawCell->isTenured()) {
+MarkInfo GetMarkInfo(Cell* rawCell) {MOZ_RELEASE_ASSERT(0);
+  if (!rawCell->isTenured()) {MOZ_RELEASE_ASSERT(0);
     return MarkInfo::NURSERY;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   TenuredCell* cell = &rawCell->asTenured();
-  if (cell->isMarkedGray()) {
+  if (cell->isMarkedGray()) {MOZ_RELEASE_ASSERT(0);
     return MarkInfo::GRAY;
   }
   if (cell->isMarkedBlack()) {
@@ -4256,7 +4256,7 @@ MarkInfo GetMarkInfo(Cell* rawCell) {
   return MarkInfo::UNMARKED;
 }
 
-uintptr_t* GetMarkWordAddress(Cell* cell) {
+uintptr_t* GetMarkWordAddress(Cell* cell) {MOZ_RELEASE_ASSERT(0);
   if (!cell->isTenured()) {
     return nullptr;
   }
@@ -4269,7 +4269,7 @@ uintptr_t* GetMarkWordAddress(Cell* cell
   return reinterpret_cast<uintptr_t*>(wordp);
 }
 
-uintptr_t GetMarkMask(Cell* cell, uint32_t colorBit) {
+uintptr_t GetMarkMask(Cell* cell, uint32_t colorBit) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(colorBit == 0 || colorBit == 1);
 
   if (!cell->isTenured()) {
diff --git a/js/src/gc/Memory.cpp b/js/src/gc/Memory.cpp
--- a/js/src/gc/Memory.cpp
+++ b/js/src/gc/Memory.cpp
@@ -235,7 +235,7 @@ static inline void* MapMemoryAt(void* de
   MOZ_ASSERT(length > 0);
 
   void* region = MapInternal<commit, prot>(desired, length);
-  if (!region) {
+  if (!region) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -297,13 +297,13 @@ static size_t FindAddressLimit() {
     low = mozilla::FloorLog2(highestSeen);
   }
   // If those didn't work, perform a modified binary search.
-  while (high - 1 > low) {
+  while (high - 1 > low) {MOZ_RELEASE_ASSERT(0);
     uint64_t middle = low + (high - low) / 2;
     highestSeen = std::max(FindAddressLimitInner(middle, 4), highestSeen);
     low = mozilla::FloorLog2(highestSeen);
-    if (highestSeen < (UINT64_C(1) << middle)) {
+    if (highestSeen < (UINT64_C(1) << middle)) {MOZ_RELEASE_ASSERT(0);
       high = middle;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
   // We can be sure of the lower bound, but check the upper bound again.
   do {
@@ -368,7 +368,7 @@ void InitMemorySubsystem() {
 #  endif
     // Sanity check the address to ensure we don't use more than 47 bits.
     uint64_t maxJSAddress = UINT64_C(0x00007fffffffffff) - allocGranularity;
-    if (maxValidAddress > maxJSAddress) {
+    if (maxValidAddress > maxJSAddress) {MOZ_RELEASE_ASSERT(0);
       maxValidAddress = maxJSAddress;
       hugeSplit = UINT64_C(0x00003fffffffffff) - allocGranularity;
     } else {
@@ -416,20 +416,20 @@ void* MapAlignedPages(size_t length, siz
     MOZ_ASSERT(OffsetFromAligned(region, alignment) == 0);
 
     return region;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 #endif
 
   // Try to allocate the region. If the returned address is aligned,
   // either we OOMed (region is nullptr) or we're done.
   void* region = MapMemory(length);
-  if (OffsetFromAligned(region, alignment) == 0) {
+  if (OffsetFromAligned(region, alignment) == 0) {MOZ_RELEASE_ASSERT(0);
     return region;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Try to align the region. On success, TryToAlignChunk() returns
   // true and we can return the aligned region immediately.
   void* retainedRegion;
-  if (TryToAlignChunk(&region, &retainedRegion, length, alignment)) {
+  if (TryToAlignChunk(&region, &retainedRegion, length, alignment)) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(region && OffsetFromAligned(region, alignment) == 0);
     MOZ_ASSERT(!retainedRegion);
     return region;
@@ -437,16 +437,16 @@ void* MapAlignedPages(size_t length, siz
 
   // On failure, the unaligned region is retained unless we OOMed. We don't
   // use the retained region on this path (see the last ditch allocator).
-  if (retainedRegion) {
+  if (retainedRegion) {MOZ_RELEASE_ASSERT(0);
     UnmapInternal(retainedRegion, length);
   }
 
   // If it fails to align the given region, TryToAlignChunk() returns the
   // next valid region that we might be able to align (unless we OOMed).
-  if (region) {
+  if (region) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(OffsetFromAligned(region, alignment) != 0);
     UnmapInternal(region, length);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Since we couldn't align the first region, fall back to allocating a
   // region large enough that we can definitely align it.
@@ -490,7 +490,7 @@ static void* MapAlignedPagesRandom(size_
     // Use the lower half of the range.
     minNum = (minValidAddress + alignment - 1) / alignment;
     maxNum = (hugeSplit - (length - 1)) / alignment;
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     // Use the upper half of the range.
     minNum = (hugeSplit + 1 + alignment - 1) / alignment;
     maxNum = (maxValidAddress - (length - 1)) / alignment;
@@ -505,14 +505,14 @@ static void* MapAlignedPagesRandom(size_
       if (!region) {
         continue;
       }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       // Check for OOM.
       region = MapMemory(length);
-      if (!region) {
+      if (!region) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
-    if (IsInvalidRegion(region, length)) {
+    if (IsInvalidRegion(region, length)) {MOZ_RELEASE_ASSERT(0);
       UnmapInternal(region, length);
       continue;
     }
@@ -529,13 +529,13 @@ static void* MapAlignedPagesRandom(size_
     UnmapInternal(region, length);
   }
 
-  if (numAddressBits < 48) {
+  if (numAddressBits < 48) {MOZ_RELEASE_ASSERT(0);
     // Try the reliable fallback of overallocating.
     // Note: This will not respect the address space split.
     region = MapAlignedPagesSlow(length, alignment);
-    if (region) {
+    if (region) {MOZ_RELEASE_ASSERT(0);
       return region;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
   if (length < HugeAllocationSize) {
     MOZ_CRASH("Couldn't allocate even after 1000 tries!");
@@ -546,9 +546,9 @@ static void* MapAlignedPagesRandom(size_
 
 #endif  // defined(JS_64BIT)
 
-static void* MapAlignedPagesSlow(size_t length, size_t alignment) {
+static void* MapAlignedPagesSlow(size_t length, size_t alignment) {MOZ_RELEASE_ASSERT(0);
   void* alignedRegion = nullptr;
-  do {
+  do {MOZ_RELEASE_ASSERT(0);
     size_t reserveLength = length + alignment - pageSize;
 #ifdef XP_WIN
     // Don't commit the requested pages as we won't use the region directly.
@@ -556,9 +556,9 @@ static void* MapAlignedPagesSlow(size_t 
 #else
     void* region = MapMemory(reserveLength);
 #endif
-    if (!region) {
+    if (!region) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     alignedRegion =
         reinterpret_cast<void*>(AlignBytes(uintptr_t(region), alignment));
 #ifdef XP_WIN
@@ -568,9 +568,9 @@ static void* MapAlignedPagesSlow(size_t 
     alignedRegion = MapMemoryAt(alignedRegion, length);
 #else
     // munmap allows us to simply unmap the pages that don't interest us.
-    if (alignedRegion != region) {
+    if (alignedRegion != region) {MOZ_RELEASE_ASSERT(0);
       UnmapInternal(region, uintptr_t(alignedRegion) - uintptr_t(region));
-    }
+    }MOZ_RELEASE_ASSERT(0);
     void* regionEnd =
         reinterpret_cast<void*>(uintptr_t(region) + reserveLength);
     void* alignedEnd =
@@ -593,24 +593,24 @@ static void* MapAlignedPagesSlow(size_t 
  * by temporarily holding onto the unaligned parts of each chunk until the
  * allocator gives us a chunk that either is, or can be aligned.
  */
-static void* MapAlignedPagesLastDitch(size_t length, size_t alignment) {
+static void* MapAlignedPagesLastDitch(size_t length, size_t alignment) {MOZ_RELEASE_ASSERT(0);
   void* tempMaps[MaxLastDitchAttempts];
   int attempt = 0;
   void* region = MapMemory(length);
-  if (OffsetFromAligned(region, alignment) == 0) {
+  if (OffsetFromAligned(region, alignment) == 0) {MOZ_RELEASE_ASSERT(0);
     return region;
   }
-  for (; attempt < MaxLastDitchAttempts; ++attempt) {
-    if (TryToAlignChunk(&region, tempMaps + attempt, length, alignment)) {
+  for (; attempt < MaxLastDitchAttempts; ++attempt) {MOZ_RELEASE_ASSERT(0);
+    if (TryToAlignChunk(&region, tempMaps + attempt, length, alignment)) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(region && OffsetFromAligned(region, alignment) == 0);
       MOZ_ASSERT(!tempMaps[attempt]);
       break;  // Success!
     }
-    if (!region || !tempMaps[attempt]) {
+    if (!region || !tempMaps[attempt]) {MOZ_RELEASE_ASSERT(0);
       break;  // We ran out of memory, so give up.
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
-  if (OffsetFromAligned(region, alignment)) {
+  if (OffsetFromAligned(region, alignment)) {MOZ_RELEASE_ASSERT(0);
     UnmapInternal(region, length);
     region = nullptr;
   }
@@ -629,18 +629,18 @@ static void* MapAlignedPagesLastDitch(si
  */
 template <bool>
 static bool TryToAlignChunk(void** aRegion, void** aRetainedRegion,
-                            size_t length, size_t alignment) {
+                            size_t length, size_t alignment) {MOZ_RELEASE_ASSERT(0);
   void* region = *aRegion;
   MOZ_ASSERT(region && OffsetFromAligned(region, alignment) != 0);
 
   size_t retainedLength = 0;
   void* retainedRegion = nullptr;
-  do {
+  do {MOZ_RELEASE_ASSERT(0);
     size_t offset = OffsetFromAligned(region, alignment);
-    if (offset == 0) {
+    if (offset == 0) {MOZ_RELEASE_ASSERT(0);
       // If the address is aligned, either we hit OOM or we're done.
       break;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     UnmapInternal(region, length);
     retainedLength = alignment - offset;
     retainedRegion = MapMemoryAt<Commit::No>(region, retainedLength);
@@ -684,11 +684,11 @@ static bool TryToAlignChunk(void** aRegi
           reinterpret_cast<void*>(uintptr_t(regionStart) + offsetUpper);
       void* regionEnd =
           reinterpret_cast<void*>(uintptr_t(regionStart) + length);
-      if (MapMemoryAt(regionEnd, offsetUpper)) {
+      if (MapMemoryAt(regionEnd, offsetUpper)) {MOZ_RELEASE_ASSERT(0);
         UnmapInternal(regionStart, offsetUpper);
-        if (directionUncertain) {
+        if (directionUncertain) {MOZ_RELEASE_ASSERT(0);
           ++growthDirection;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         regionStart = upperStart;
         break;
       }
@@ -706,7 +706,7 @@ static bool TryToAlignChunk(void** aRegi
       }
     }
     // If we're confident in the growth direction, don't try the other.
-    if (!directionUncertain) {
+    if (!directionUncertain) {MOZ_RELEASE_ASSERT(0);
       break;
     }
     addressesGrowUpward = !addressesGrowUpward;
@@ -714,7 +714,7 @@ static bool TryToAlignChunk(void** aRegi
 
   void* retainedRegion = nullptr;
   bool result = OffsetFromAligned(regionStart, alignment) == 0;
-  if (AlwaysGetNew && !result) {
+  if (AlwaysGetNew && !result) {MOZ_RELEASE_ASSERT(0);
     // If our current chunk cannot be aligned, just get a new one.
     retainedRegion = regionStart;
     regionStart = MapMemory(length);
@@ -811,7 +811,7 @@ void MarkPagesInUseSoft(void* region, si
 }
 
 bool MarkPagesInUseHard(void* region, size_t length) {
-  if (js::oom::ShouldFailWithOOM()) {
+  if (js::oom::ShouldFailWithOOM()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -834,7 +834,7 @@ bool MarkPagesInUseHard(void* region, si
 size_t GetPageFaultCount() {
 #ifdef XP_WIN
   PROCESS_MEMORY_COUNTERS pmc;
-  if (GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc)) == 0) {
+  if (GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc)) == 0) {MOZ_RELEASE_ASSERT(0);
     return 0;
   }
   return pmc.PageFaultCount;
@@ -872,7 +872,7 @@ void* AllocateMappedContent(int fd, size
 
   // This call will fail if the file does not exist.
   HANDLE hMap = CreateFileMapping(hFile, nullptr, PAGE_READONLY, 0, 0, nullptr);
-  if (!hMap) {
+  if (!hMap) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -884,7 +884,7 @@ void* AllocateMappedContent(int fd, size
     // The value of a pointer is technically only defined while the region
     // it points to is allocated, so explicitly treat this one as a number.
     uintptr_t region = uintptr_t(MapAlignedPages(mappedLength, alignment));
-    if (region == 0) {
+    if (region == 0) {MOZ_RELEASE_ASSERT(0);
       break;
     }
     UnmapInternal(reinterpret_cast<void*>(region), mappedLength);
@@ -915,7 +915,7 @@ void* AllocateMappedContent(int fd, size
   }
 
   void* region = MapAlignedPages(mappedLength, alignment);
-  if (!region) {
+  if (!region) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -924,7 +924,7 @@ void* AllocateMappedContent(int fd, size
   uint8_t* map =
       static_cast<uint8_t*>(mmap(region, alignedLength, PROT_READ | PROT_WRITE,
                                  MAP_PRIVATE | MAP_FIXED, fd, alignedOffset));
-  if (map == MAP_FAILED) {
+  if (map == MAP_FAILED) {MOZ_RELEASE_ASSERT(0);
     UnmapInternal(region, mappedLength);
     return nullptr;
   }
@@ -944,7 +944,7 @@ void* AllocateMappedContent(int fd, size
 }
 
 void DeallocateMappedContent(void* region, size_t length) {
-  if (!region) {
+  if (!region) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
diff --git a/js/src/gc/Nursery.cpp b/js/src/gc/Nursery.cpp
--- a/js/src/gc/Nursery.cpp
+++ b/js/src/gc/Nursery.cpp
@@ -204,7 +204,7 @@ js::Nursery::Nursery(GCRuntime* gc)
 #endif
 {
   const char* env = getenv("MOZ_NURSERY_STRINGS");
-  if (env && *env) {
+  if (env && *env) {MOZ_RELEASE_ASSERT(0);
     canAllocateStrings_ = (*env == '1');
   }
   env = getenv("MOZ_NURSERY_BIGINTS");
@@ -215,24 +215,24 @@ js::Nursery::Nursery(GCRuntime* gc)
 
 bool js::Nursery::init(AutoLockGCBgAlloc& lock) {
   if (char* env = getenv("JS_GC_PROFILE_NURSERY")) {
-    if (0 == strcmp(env, "help")) {
+    if (0 == strcmp(env, "help")) {MOZ_RELEASE_ASSERT(0);
       fprintf(stderr,
               "JS_GC_PROFILE_NURSERY=N\n"
               "\tReport minor GC's taking at least N microseconds.\n");
       exit(0);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     enableProfiling_ = true;
     profileThreshold_ = TimeDuration::FromMicroseconds(atoi(env));
   }
 
   if (char* env = getenv("JS_GC_REPORT_STATS")) {
-    if (0 == strcmp(env, "help")) {
+    if (0 == strcmp(env, "help")) {MOZ_RELEASE_ASSERT(0);
       fprintf(stderr,
               "JS_GC_REPORT_STATS=1\n"
               "\tAfter a minor GC, report how many strings were "
               "deduplicated.\n");
       exit(0);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     reportDeduplications_ = !!atoi(env);
   }
 
@@ -248,13 +248,13 @@ js::Nursery::~Nursery() { disable(); }
 void js::Nursery::enable() {
   MOZ_ASSERT(isEmpty());
   MOZ_ASSERT(!gc->isVerifyPreBarriersEnabled());
-  if (isEnabled()) {
+  if (isEnabled()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
   {
     AutoLockGCBgAlloc lock(gc);
-    if (!initFirstChunk(lock)) {
+    if (!initFirstChunk(lock)) {MOZ_RELEASE_ASSERT(0);
       // If we fail to allocate memory, the nursery will not be enabled.
       return;
     }
@@ -420,7 +420,7 @@ JSObject* js::Nursery::allocateObject(JS
     MOZ_ASSERT(clasp->isNativeObject());
     void* allocation =
         allocateBuffer(cx->zone(), ObjectSlots::allocSize(nDynamicSlots));
-    if (!allocation) {
+    if (!allocation) {MOZ_RELEASE_ASSERT(0);
       // It is safe to leave the allocated object uninitialized, since we
       // do not visit unallocated things in the nursery.
       return nullptr;
@@ -517,7 +517,7 @@ void* Nursery::moveToNextChunkAndAllocat
     mozilla::TimeStamp start = ReallyNow();
     {
       AutoLockGCBgAlloc lock(gc);
-      if (!allocateNextChunk(chunkno, lock)) {
+      if (!allocateNextChunk(chunkno, lock)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -730,7 +730,7 @@ void js::Nursery::forwardBufferPointer(u
 
   // The new location for this buffer is either stored inline with it or in
   // the forwardedBuffers table.
-  if (ForwardedBufferMap::Ptr p = forwardedBuffers.lookup(buffer)) {
+  if (ForwardedBufferMap::Ptr p = forwardedBuffers.lookup(buffer)) {MOZ_RELEASE_ASSERT(0);
     buffer = p->value();
     // It's not valid to assert IsWriteableAddress for indirect forwarding
     // pointers because the size of the allocation could be less than a word.
@@ -780,7 +780,7 @@ inline double js::Nursery::calcPromotion
 }
 
 void js::Nursery::renderProfileJSON(JSONPrinter& json) const {
-  if (!isEnabled()) {
+  if (!isEnabled()) {MOZ_RELEASE_ASSERT(0);
     json.beginObject();
     json.property("status", "nursery disabled");
     json.endObject();
@@ -838,7 +838,7 @@ void js::Nursery::renderProfileJSON(JSON
         "nursery_string_realms_disabled",
         stats().getStat(gcstats::STAT_NURSERY_STRING_REALMS_DISABLED));
   }
-  if (stats().getStat(gcstats::STAT_NURSERY_BIGINT_REALMS_DISABLED)) {
+  if (stats().getStat(gcstats::STAT_NURSERY_BIGINT_REALMS_DISABLED)) {MOZ_RELEASE_ASSERT(0);
     json.property(
         "nursery_bigint_realms_disabled",
         stats().getStat(gcstats::STAT_NURSERY_BIGINT_REALMS_DISABLED));
@@ -889,7 +889,7 @@ void js::Nursery::printProfileHeader() {
 }
 
 // static
-void js::Nursery::printProfileDurations(const ProfileDurations& times) {
+void js::Nursery::printProfileDurations(const ProfileDurations& times) {MOZ_RELEASE_ASSERT(0);
   for (auto time : times) {
     fprintf(stderr, " %6" PRIi64, static_cast<int64_t>(time.ToMicroseconds()));
   }
@@ -1017,7 +1017,7 @@ void js::Nursery::collect(JSGCInvocation
     gc->storeBuffer().clear();
   }
 
-  if (!isEnabled()) {
+  if (!isEnabled()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -1113,7 +1113,7 @@ void js::Nursery::collect(JSGCInvocation
   stats().setStat(
       gcstats::STAT_STRINGS_DEDUPLICATED,
       currStats.deduplicatedStrings - prevStats.deduplicatedStrings);
-  if (enableProfiling_ && totalTime >= profileThreshold_) {
+  if (enableProfiling_ && totalTime >= profileThreshold_) {MOZ_RELEASE_ASSERT(0);
     printCollectionProfile(reason, promotionRate);
   }
 
@@ -1325,7 +1325,7 @@ void js::Nursery::doPretenuring(JSRuntim
             jitRealm->setStringsCanBeInNursery(false);
             numNurseryStringRealmsDisabled++;
           }
-          if (disableNurseryBigInts) {
+          if (disableNurseryBigInts) {MOZ_RELEASE_ASSERT(0);
             numNurseryBigIntRealmsDisabled++;
           }
         }
@@ -1354,7 +1354,7 @@ void js::Nursery::doPretenuring(JSRuntim
 bool js::Nursery::registerMallocedBuffer(void* buffer, size_t nbytes) {
   MOZ_ASSERT(buffer);
   MOZ_ASSERT(nbytes > 0);
-  if (!mallocedBuffers.putNew(buffer)) {
+  if (!mallocedBuffers.putNew(buffer)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1395,7 +1395,7 @@ void js::Nursery::sweep(JSTracer* trc) {
 void js::Nursery::clear() {
   // Poison the nursery contents so touching a freed object will crash.
   unsigned firstClearChunk;
-  if (gc->hasZealMode(ZealMode::GenerationalGC)) {
+  if (gc->hasZealMode(ZealMode::GenerationalGC)) {MOZ_RELEASE_ASSERT(0);
     // Poison all the chunks used in this cycle. The new start chunk is
     // reposioned in Nursery::collect() but there's no point optimising that in
     // this case.
@@ -1414,7 +1414,7 @@ void js::Nursery::clear() {
   if (currentChunk_ >= firstClearChunk) {
     chunk(currentChunk_)
         .poisonAfterEvict(position() - chunk(currentChunk_).start());
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Reset the start chunk & position if we're not in this zeal mode, or we're
   // in it and close to the end of the nursery.
@@ -1502,7 +1502,7 @@ bool js::Nursery::allocateNextChunk(cons
   MOZ_ASSERT(chunkno == allocatedChunkCount());
   MOZ_ASSERT(chunkno < HowMany(capacity(), ChunkSize));
 
-  if (!chunks_.resize(newCount)) {
+  if (!chunks_.resize(newCount)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1579,7 +1579,7 @@ size_t js::Nursery::targetSize(JSGCInvoc
   if (gc::IsShutdownReason(reason)) {
     clearRecentGrowthData();
     return capacity();
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   TimeStamp now = ReallyNow();
 
@@ -1587,7 +1587,7 @@ size_t js::Nursery::targetSize(JSGCInvoc
   if (hasRecentGrowthData && previousGC.nurseryUsedBytes == 0 &&
       now - lastCollectionEndTime() >
           tunables().nurseryTimeoutForIdleCollection() &&
-      !js::SupportDifferentialTesting()) {
+      !js::SupportDifferentialTesting()) {MOZ_RELEASE_ASSERT(0);
     clearRecentGrowthData();
     return 0;
   }
@@ -1668,7 +1668,7 @@ void js::Nursery::growAllocableSpace(siz
   MOZ_ASSERT(newCapacity <= tunables().gcMaxNurseryBytes());
   MOZ_ASSERT(newCapacity > capacity());
 
-  if (!decommitTask.reserveSpaceForBytes(newCapacity)) {
+  if (!decommitTask.reserveSpaceForBytes(newCapacity)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -1705,7 +1705,7 @@ void js::Nursery::freeChunksFrom(const u
     // Part of the first chunk may be hard-decommitted, un-decommit it so that
     // the GC's normal chunk-handling doesn't segfault.
     MOZ_ASSERT(currentChunk_ == 0);
-    if (!chunk(0).markPagesInUseHard(ChunkSize)) {
+    if (!chunk(0).markPagesInUseHard(ChunkSize)) {MOZ_RELEASE_ASSERT(0);
       // Free the chunk if we can't allocate its pages.
       UnmapPages(static_cast<void*>(&chunk(0)), ChunkSize);
       firstChunkToDecommit = 1;
@@ -1734,7 +1734,7 @@ void js::Nursery::shrinkAllocableSpace(s
   // clamping in maybeResizeNursery().
   MOZ_ASSERT(newCapacity != 0);
   // Don't attempt to shrink it to the same size.
-  if (newCapacity == capacity_) {
+  if (newCapacity == capacity_) {MOZ_RELEASE_ASSERT(0);
     return;
   }
   MOZ_ASSERT(newCapacity < capacity_);
diff --git a/js/src/gc/PublicIterators.cpp b/js/src/gc/PublicIterators.cpp
--- a/js/src/gc/PublicIterators.cpp
+++ b/js/src/gc/PublicIterators.cpp
@@ -88,10 +88,10 @@ void js::IterateChunks(JSContext* cx, vo
 static void TraverseInnerLazyScriptsForLazyScript(
     JSContext* cx, void* data, BaseScript* enclosingScript,
     IterateScriptCallback lazyScriptCallback, const JS::AutoRequireNoGC& nogc) {
-  for (JS::GCCellPtr gcThing : enclosingScript->gcthings()) {
-    if (!gcThing.is<JSObject>()) {
+  for (JS::GCCellPtr gcThing : enclosingScript->gcthings()) {MOZ_RELEASE_ASSERT(0);
+    if (!gcThing.is<JSObject>()) {MOZ_RELEASE_ASSERT(0);
       continue;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     JSObject* obj = &gcThing.as<JSObject>();
 
     MOZ_ASSERT(obj->is<JSFunction>(),
@@ -163,15 +163,15 @@ void js::IterateScripts(JSContext* cx, R
 }
 
 void js::IterateGrayObjects(Zone* zone, IterateGCThingCallback cellCallback,
-                            void* data) {
+                            void* data) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(!JS::RuntimeHeapIsBusy());
 
   JSContext* cx = TlsContext.get();
   AutoPrepareForTracing prep(cx);
   JS::AutoSuppressGCAnalysis nogc(cx);
 
-  for (auto kind : ObjectAllocKinds()) {
-    for (GrayObjectIter obj(zone, kind); !obj.done(); obj.next()) {
+  for (auto kind : ObjectAllocKinds()) {MOZ_RELEASE_ASSERT(0);
+    for (GrayObjectIter obj(zone, kind); !obj.done(); obj.next()) {MOZ_RELEASE_ASSERT(0);
       if (obj->asTenured().isMarkedGray()) {
         cellCallback(data, JS::GCCellPtr(obj.get()), nogc);
       }
@@ -181,10 +181,10 @@ void js::IterateGrayObjects(Zone* zone, 
 
 JS_PUBLIC_API void JS_IterateCompartments(
     JSContext* cx, void* data,
-    JSIterateCompartmentCallback compartmentCallback) {
+    JSIterateCompartmentCallback compartmentCallback) {MOZ_RELEASE_ASSERT(0);
   AutoTraceSession session(cx->runtime());
 
-  for (CompartmentsIter c(cx->runtime()); !c.done(); c.next()) {
+  for (CompartmentsIter c(cx->runtime()); !c.done(); c.next()) {MOZ_RELEASE_ASSERT(0);
     if ((*compartmentCallback)(cx, data, c) ==
         JS::CompartmentIterResult::Stop) {
       break;
diff --git a/js/src/gc/RootMarking.cpp b/js/src/gc/RootMarking.cpp
--- a/js/src/gc/RootMarking.cpp
+++ b/js/src/gc/RootMarking.cpp
@@ -347,7 +347,7 @@ void js::gc::GCRuntime::traceRuntimeComm
     // Trace C stack roots.
     TraceExactStackRoots(cx, trc);
 
-    for (RootRange r = rootsHash.ref().all(); !r.empty(); r.popFront()) {
+    for (RootRange r = rootsHash.ref().all(); !r.empty(); r.popFront()) {MOZ_RELEASE_ASSERT(0);
       const RootEntry& entry = r.front();
       TraceRoot(trc, entry.key(), entry.value());
     }
@@ -553,7 +553,7 @@ void js::gc::GCRuntime::bufferGrayRoots(
       &grayBufferer, Compartment::GrayEdges);
 
   // Propagate the failure flag from the marker to the runtime.
-  if (grayBufferer.failed()) {
+  if (grayBufferer.failed()) {MOZ_RELEASE_ASSERT(0);
     grayBufferState = GrayBufferState::Failed;
     resetBufferedGrayRoots();
   } else {
diff --git a/js/src/gc/Statistics.cpp b/js/src/gc/Statistics.cpp
--- a/js/src/gc/Statistics.cpp
+++ b/js/src/gc/Statistics.cpp
@@ -54,9 +54,9 @@ static inline auto MajorGCPhaseKinds() {
                                       PhaseKind(size_t(PhaseKind::GC_END) + 1));
 }
 
-const char* js::gcstats::ExplainInvocationKind(JSGCInvocationKind gckind) {
+const char* js::gcstats::ExplainInvocationKind(JSGCInvocationKind gckind) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(gckind == GC_NORMAL || gckind == GC_SHRINK);
-  if (gckind == GC_NORMAL) {
+  if (gckind == GC_NORMAL) {MOZ_RELEASE_ASSERT(0);
     return "Normal";
   } else {
     return "Shrinking";
@@ -104,21 +104,21 @@ static FILE* MaybeOpenFileFromEnv(const 
     return nullptr;
   }
 
-  if (strcmp(value, "none") == 0) {
+  if (strcmp(value, "none") == 0) {MOZ_RELEASE_ASSERT(0);
     file = nullptr;
-  } else if (strcmp(value, "stdout") == 0) {
+  } else if (strcmp(value, "stdout") == 0) {MOZ_RELEASE_ASSERT(0);
     file = stdout;
-  } else if (strcmp(value, "stderr") == 0) {
+  } else if (strcmp(value, "stderr") == 0) {MOZ_RELEASE_ASSERT(0);
     file = stderr;
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     char path[300];
-    if (value[0] != '/') {
+    if (value[0] != '/') {MOZ_RELEASE_ASSERT(0);
       const char* dir = getenv("MOZ_UPLOAD_DIR");
-      if (dir) {
+      if (dir) {MOZ_RELEASE_ASSERT(0);
         SprintfLiteral(path, "%s/%s", dir, value);
         value = path;
-      }
-    }
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
 
     file = fopen(value, "a");
     if (!file) {
@@ -202,7 +202,7 @@ static Phase LookupPhaseWithParent(Phase
   return Phase::NONE;
 }
 
-static const char* PhaseKindName(PhaseKind kind) {
+static const char* PhaseKindName(PhaseKind kind) {MOZ_RELEASE_ASSERT(0);
   if (kind == PhaseKind::NONE) {
     return "NONE";
   }
@@ -273,7 +273,7 @@ static UniqueChars Join(const FragmentVe
   }
 
   char* joined = js_pod_malloc<char>(length + 1);
-  if (!joined) {
+  if (!joined) {MOZ_RELEASE_ASSERT(0);
     return UniqueChars();
   }
 
@@ -307,7 +307,7 @@ static TimeDuration SumChildTimes(Phase 
 
 UniqueChars Statistics::formatCompactSliceMessage() const {
   // Skip if we OOM'ed.
-  if (slices_.length() == 0) {
+  if (slices_.length() == 0) {MOZ_RELEASE_ASSERT(0);
     return UniqueChars(nullptr);
   }
 
@@ -338,7 +338,7 @@ UniqueChars Statistics::formatCompactSli
 
 UniqueChars Statistics::formatCompactSummaryMessage() const {
   FragmentVector fragments;
-  if (!fragments.append(DuplicateString("Summary - "))) {
+  if (!fragments.append(DuplicateString("Summary - "))) {MOZ_RELEASE_ASSERT(0);
     return UniqueChars(nullptr);
   }
 
@@ -349,7 +349,7 @@ UniqueChars Statistics::formatCompactSum
   const double mmu50 = computeMMU(TimeDuration::FromMilliseconds(50));
 
   char buffer[1024];
-  if (!nonincremental()) {
+  if (!nonincremental()) {MOZ_RELEASE_ASSERT(0);
     SprintfLiteral(buffer,
                    "Max Pause: %.3fms; MMU 20ms: %.1f%%; MMU 50ms: %.1f%%; "
                    "Total: %.3fms; ",
@@ -358,7 +358,7 @@ UniqueChars Statistics::formatCompactSum
     SprintfLiteral(buffer, "Non-Incremental: %.3fms (%s); ", t(total),
                    ExplainAbortReason(nonincrementalReason_));
   }
-  if (!fragments.append(DuplicateString(buffer))) {
+  if (!fragments.append(DuplicateString(buffer))) {MOZ_RELEASE_ASSERT(0);
     return UniqueChars(nullptr);
   }
 
@@ -372,12 +372,12 @@ UniqueChars Statistics::formatCompactSum
                  double(preTotalHeapBytes) / BYTES_PER_MB,
                  int32_t(counts[COUNT_NEW_CHUNK] - counts[COUNT_DESTROY_CHUNK]),
                  counts[COUNT_NEW_CHUNK] + counts[COUNT_DESTROY_CHUNK]);
-  if (!fragments.append(DuplicateString(buffer))) {
+  if (!fragments.append(DuplicateString(buffer))) {MOZ_RELEASE_ASSERT(0);
     return UniqueChars(nullptr);
   }
 
   MOZ_ASSERT_IF(counts[COUNT_ARENA_RELOCATED], gckind == GC_SHRINK);
-  if (gckind == GC_SHRINK) {
+  if (gckind == GC_SHRINK) {MOZ_RELEASE_ASSERT(0);
     SprintfLiteral(
         buffer, "Kind: %s; Relocated: %.3f MiB; ",
         ExplainInvocationKind(gckind),
@@ -405,7 +405,7 @@ UniqueChars Statistics::formatCompactSli
     TimeDuration childTime = SumChildTimes(phase, phaseTimes);
     if (ownTime > MaxUnaccountedTime) {
       SprintfLiteral(buffer, "%s: %.3fms", phases[phase].name, t(ownTime));
-      if (!fragments.append(DuplicateString(buffer))) {
+      if (!fragments.append(DuplicateString(buffer))) {MOZ_RELEASE_ASSERT(0);
         return UniqueChars(nullptr);
       }
 
@@ -421,24 +421,24 @@ UniqueChars Statistics::formatCompactSli
   return Join(fragments, ", ");
 }
 
-UniqueChars Statistics::formatDetailedMessage() const {
+UniqueChars Statistics::formatDetailedMessage() const {MOZ_RELEASE_ASSERT(0);
   FragmentVector fragments;
 
-  if (!fragments.append(formatDetailedDescription())) {
+  if (!fragments.append(formatDetailedDescription())) {MOZ_RELEASE_ASSERT(0);
     return UniqueChars(nullptr);
   }
 
-  if (!slices_.empty()) {
-    for (unsigned i = 0; i < slices_.length(); i++) {
-      if (!fragments.append(formatDetailedSliceDescription(i, slices_[i]))) {
+  if (!slices_.empty()) {MOZ_RELEASE_ASSERT(0);
+    for (unsigned i = 0; i < slices_.length(); i++) {MOZ_RELEASE_ASSERT(0);
+      if (!fragments.append(formatDetailedSliceDescription(i, slices_[i]))) {MOZ_RELEASE_ASSERT(0);
         return UniqueChars(nullptr);
       }
-      if (!fragments.append(formatDetailedPhaseTimes(slices_[i].phaseTimes))) {
+      if (!fragments.append(formatDetailedPhaseTimes(slices_[i].phaseTimes))) {MOZ_RELEASE_ASSERT(0);
         return UniqueChars(nullptr);
-      }
-    }
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
   }
-  if (!fragments.append(formatDetailedTotals())) {
+  if (!fragments.append(formatDetailedTotals())) {MOZ_RELEASE_ASSERT(0);
     return UniqueChars(nullptr);
   }
   if (!fragments.append(formatDetailedPhaseTimes(phaseTimes))) {
@@ -490,7 +490,7 @@ UniqueChars Statistics::formatDetailedDe
 }
 
 UniqueChars Statistics::formatDetailedSliceDescription(
-    unsigned i, const SliceData& slice) const {
+    unsigned i, const SliceData& slice) const {MOZ_RELEASE_ASSERT(0);
   char budgetDescription[200];
   slice.budget.describe(budgetDescription, sizeof(budgetDescription) - 1);
 
@@ -531,24 +531,24 @@ static bool IncludePhase(TimeDuration du
 }
 
 UniqueChars Statistics::formatDetailedPhaseTimes(
-    const PhaseTimes& phaseTimes) const {
+    const PhaseTimes& phaseTimes) const {MOZ_RELEASE_ASSERT(0);
   static const TimeDuration MaxUnaccountedChildTime =
       TimeDuration::FromMicroseconds(50);
 
   FragmentVector fragments;
   char buffer[128];
-  for (auto phase : AllPhases()) {
+  for (auto phase : AllPhases()) {MOZ_RELEASE_ASSERT(0);
     uint8_t level = phases[phase].depth;
     TimeDuration ownTime = phaseTimes[phase];
     TimeDuration childTime = SumChildTimes(phase, phaseTimes);
-    if (IncludePhase(ownTime)) {
+    if (IncludePhase(ownTime)) {MOZ_RELEASE_ASSERT(0);
       SprintfLiteral(buffer, "      %*s%s: %.3fms\n", level * 2, "",
                      phases[phase].name, t(ownTime));
-      if (!fragments.append(DuplicateString(buffer))) {
+      if (!fragments.append(DuplicateString(buffer))) {MOZ_RELEASE_ASSERT(0);
         return UniqueChars(nullptr);
       }
 
-      if (childTime && (ownTime - childTime) > MaxUnaccountedChildTime) {
+      if (childTime && (ownTime - childTime) > MaxUnaccountedChildTime) {MOZ_RELEASE_ASSERT(0);
         SprintfLiteral(buffer, "      %*s%s: %.3fms\n", (level + 1) * 2, "",
                        "Other", t(ownTime - childTime));
         if (!fragments.append(DuplicateString(buffer))) {
@@ -635,7 +635,7 @@ UniqueChars Statistics::renderJsonMessag
    * All the properties listed here are created within the timings property
    * of the GCMajor marker.
    */
-  if (aborted) {
+  if (aborted) {MOZ_RELEASE_ASSERT(0);
     return DuplicateString("{status:\"aborted\"}");  // May return nullptr
   }
 
@@ -810,7 +810,7 @@ Statistics::Statistics(GCRuntime* gc)
 }
 
 Statistics::~Statistics() {
-  if (gcTimerFile && gcTimerFile != stdout && gcTimerFile != stderr) {
+  if (gcTimerFile && gcTimerFile != stdout && gcTimerFile != stderr) {MOZ_RELEASE_ASSERT(0);
     fclose(gcTimerFile);
   }
   if (gcDebugFile && gcDebugFile != stdout && gcDebugFile != stderr) {
@@ -940,7 +940,7 @@ static PhaseKind LongestPhaseSelfTimeInM
 #ifndef XP_WIN
       MOZ_ASSERT(ok, "Inconsistent time data; see bug 1400153");
 #endif
-      if (!ok) {
+      if (!ok) {MOZ_RELEASE_ASSERT(0);
         return PhaseKind::NONE;
       }
 
@@ -957,12 +957,12 @@ static PhaseKind LongestPhaseSelfTimeInM
   return FindLongestPhaseKind(phaseKindTimes);
 }
 
-void Statistics::printStats() {
-  if (aborted) {
+void Statistics::printStats() {MOZ_RELEASE_ASSERT(0);
+  if (aborted) {MOZ_RELEASE_ASSERT(0);
     fprintf(gcTimerFile,
             "OOM during GC statistics collection. The report is unavailable "
             "for this GC.\n");
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     UniqueChars msg = formatDetailedMessage();
     if (msg) {
       double secSinceStart =
@@ -1157,7 +1157,7 @@ void Statistics::beginSlice(const ZoneGC
   recordedTrigger.reset();
 
   if (!slices_.emplaceBack(budget, trigger, reason, currentTime,
-                           GetPageFaultCount(), gc->state())) {
+                           GetPageFaultCount(), gc->state())) {MOZ_RELEASE_ASSERT(0);
     // If we are OOM, set a flag to indicate we have missing slice data.
     aborted = true;
     return;
@@ -1198,7 +1198,7 @@ void Statistics::endSlice() {
 
   bool last = !gc->isIncrementalGCInProgress();
   if (last) {
-    if (gcTimerFile) {
+    if (gcTimerFile) {MOZ_RELEASE_ASSERT(0);
       printStats();
     }
 
@@ -1208,7 +1208,7 @@ void Statistics::endSlice() {
   }
 
   if (enableProfiling_ && !aborted &&
-      slices_.back().duration() >= profileThreshold_) {
+      slices_.back().duration() >= profileThreshold_) {MOZ_RELEASE_ASSERT(0);
     printSliceProfile();
   }
 
@@ -1433,7 +1433,7 @@ void Statistics::recordPhaseEnd(Phase ph
   }
 #endif
 
-  if (now < phaseStartTimes[phase]) {
+  if (now < phaseStartTimes[phase]) {MOZ_RELEASE_ASSERT(0);
     now = phaseStartTimes[phase];
     aborted = true;
   }
@@ -1538,9 +1538,9 @@ double Statistics::computeMMU(TimeDurati
   return double((window - gcMax) / window);
 }
 
-void Statistics::maybePrintProfileHeaders() {
+void Statistics::maybePrintProfileHeaders() {MOZ_RELEASE_ASSERT(0);
   static int printedHeader = 0;
-  if ((printedHeader++ % 200) == 0) {
+  if ((printedHeader++ % 200) == 0) {MOZ_RELEASE_ASSERT(0);
     printProfileHeader();
     if (gc->nursery().enableProfiling()) {
       Nursery::printProfileHeader();
@@ -1548,7 +1548,7 @@ void Statistics::maybePrintProfileHeader
   }
 }
 
-void Statistics::printProfileHeader() {
+void Statistics::printProfileHeader() {MOZ_RELEASE_ASSERT(0);
   if (!enableProfiling_) {
     return;
   }
@@ -1563,14 +1563,14 @@ void Statistics::printProfileHeader() {
 }
 
 /* static */
-void Statistics::printProfileTimes(const ProfileDurations& times) {
+void Statistics::printProfileTimes(const ProfileDurations& times) {MOZ_RELEASE_ASSERT(0);
   for (auto time : times) {
     fprintf(stderr, " %6" PRIi64, static_cast<int64_t>(time.ToMilliseconds()));
   }
   fprintf(stderr, "\n");
 }
 
-void Statistics::printSliceProfile() {
+void Statistics::printSliceProfile() {MOZ_RELEASE_ASSERT(0);
   const SliceData& slice = slices_.back();
 
   maybePrintProfileHeaders();
@@ -1588,7 +1588,7 @@ void Statistics::printSliceProfile() {
           shrinking ? "S" : "", nonIncremental ? "N" : "", reset ? "R" : "");
 
   if (!nonIncremental && !slice.budget.isUnlimited() &&
-      slice.budget.isTimeBudget()) {
+      slice.budget.isTimeBudget()) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, " %6" PRIi64, slice.budget.timeBudget());
   } else {
     fprintf(stderr, "       ");
diff --git a/js/src/gc/StoreBuffer.cpp b/js/src/gc/StoreBuffer.cpp
--- a/js/src/gc/StoreBuffer.cpp
+++ b/js/src/gc/StoreBuffer.cpp
@@ -56,7 +56,7 @@ bool StoreBuffer::GenericBuffer::init() 
 void StoreBuffer::GenericBuffer::trace(JSTracer* trc) {
   mozilla::ReentrancyGuard g(*owner_);
   MOZ_ASSERT(owner_->isEnabled());
-  if (!storage_) {
+  if (!storage_) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -99,7 +99,7 @@ bool StoreBuffer::isEmpty() const {
 }
 
 bool StoreBuffer::enable() {
-  if (enabled_) {
+  if (enabled_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -193,7 +193,7 @@ ArenaCellSet* StoreBuffer::WholeCellBuff
   AutoEnterOOMUnsafeRegion oomUnsafe;
   ArenaCellSet*& head = isString ? stringHead_ : nonStringHead_;
   auto cells = storage_->new_<ArenaCellSet>(arena, head);
-  if (!cells) {
+  if (!cells) {MOZ_RELEASE_ASSERT(0);
     oomUnsafe.crash("Failed to allocate ArenaCellSet");
   }
 
diff --git a/js/src/gc/Tracer.cpp b/js/src/gc/Tracer.cpp
--- a/js/src/gc/Tracer.cpp
+++ b/js/src/gc/Tracer.cpp
@@ -154,7 +154,7 @@ void js::gc::GetTraceThingInfo(char* buf
   const char* name = nullptr; /* silence uninitialized warning */
   size_t n;
 
-  if (bufsize == 0) {
+  if (bufsize == 0) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -214,7 +214,7 @@ void js::gc::GetTraceThingInfo(char* buf
   }
 
   n = strlen(name);
-  if (n > bufsize - 1) {
+  if (n > bufsize - 1) {MOZ_RELEASE_ASSERT(0);
     n = bufsize - 1;
   }
   js_memcpy(buf, name, n + 1);
diff --git a/js/src/gc/WeakMap.cpp b/js/src/gc/WeakMap.cpp
--- a/js/src/gc/WeakMap.cpp
+++ b/js/src/gc/WeakMap.cpp
@@ -34,7 +34,7 @@ WeakMapBase::~WeakMapBase() {
 
 void WeakMapBase::unmarkZone(JS::Zone* zone) {
   AutoEnterOOMUnsafeRegion oomUnsafe;
-  if (!zone->gcWeakKeys().clear()) {
+  if (!zone->gcWeakKeys().clear()) {MOZ_RELEASE_ASSERT(0);
     oomUnsafe.crash("clearing weak keys table");
   }
   MOZ_ASSERT(zone->gcNurseryWeakKeys().count() == 0);
@@ -68,9 +68,9 @@ bool WeakMapBase::checkMarkingForZone(JS
 }
 #endif
 
-bool WeakMapBase::markZoneIteratively(JS::Zone* zone, GCMarker* marker) {
+bool WeakMapBase::markZoneIteratively(JS::Zone* zone, GCMarker* marker) {MOZ_RELEASE_ASSERT(0);
   bool markedAny = false;
-  for (WeakMapBase* m : zone->gcWeakMapList()) {
+  for (WeakMapBase* m : zone->gcWeakMapList()) {MOZ_RELEASE_ASSERT(0);
     if (m->mapColor && m->markEntries(marker)) {
       markedAny = true;
     }
@@ -119,7 +119,7 @@ void WeakMapBase::traceAllMappings(WeakM
 
 bool WeakMapBase::saveZoneMarkedWeakMaps(JS::Zone* zone,
                                          WeakMapColors& markedWeakMaps) {
-  for (WeakMapBase* m : zone->gcWeakMapList()) {
+  for (WeakMapBase* m : zone->gcWeakMapList()) {MOZ_RELEASE_ASSERT(0);
     if (m->mapColor && !markedWeakMaps.put(m, m->mapColor)) {
       return false;
     }
@@ -127,7 +127,7 @@ bool WeakMapBase::saveZoneMarkedWeakMaps
   return true;
 }
 
-void WeakMapBase::restoreMarkedWeakMaps(WeakMapColors& markedWeakMaps) {
+void WeakMapBase::restoreMarkedWeakMaps(WeakMapColors& markedWeakMaps) {MOZ_RELEASE_ASSERT(0);
   for (WeakMapColors::Range r = markedWeakMaps.all(); !r.empty();
        r.popFront()) {
     WeakMapBase* map = r.front().key();
diff --git a/js/src/gc/Zone.cpp b/js/src/gc/Zone.cpp
--- a/js/src/gc/Zone.cpp
+++ b/js/src/gc/Zone.cpp
@@ -92,7 +92,7 @@ bool ZoneAllocator::addSharedMemory(void
   auto ptr = sharedMemoryUseCounts.lookupForAdd(mem);
   MOZ_ASSERT_IF(ptr, ptr->value().use == use);
 
-  if (!ptr && !sharedMemoryUseCounts.add(ptr, mem, gc::SharedMemoryUse(use))) {
+  if (!ptr && !sharedMemoryUseCounts.add(ptr, mem, gc::SharedMemoryUse(use))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -243,12 +243,12 @@ void Zone::changeGCState(GCState prev, G
 }
 
 template <class Pred>
-static void EraseIf(js::gc::WeakEntryVector& entries, Pred pred) {
+static void EraseIf(js::gc::WeakEntryVector& entries, Pred pred) {MOZ_RELEASE_ASSERT(0);
   auto* begin = entries.begin();
   auto* const end = entries.end();
 
   auto* newEnd = begin;
-  for (auto* p = begin; p != end; p++) {
+  for (auto* p = begin; p != end; p++) {MOZ_RELEASE_ASSERT(0);
     if (!pred(*p)) {
       *newEnd++ = *p;
     }
@@ -272,7 +272,7 @@ void Zone::sweepAfterMinorGC(JSTracer* t
 
 void Zone::sweepWeakKeysAfterMinorGC() {
   for (WeakKeyTable::Range r = gcNurseryWeakKeys().all(); !r.empty();
-       r.popFront()) {
+       r.popFront()) {MOZ_RELEASE_ASSERT(0);
     // Sweep gcNurseryWeakKeys to move live (forwarded) keys to gcWeakKeys,
     // scanning through all the entries for such keys to update them.
     //
@@ -285,10 +285,10 @@ void Zone::sweepWeakKeysAfterMinorGC() {
     // associated with it.)
     gc::Cell* key = r.front().key;
     MOZ_ASSERT(!key->isTenured());
-    if (!Nursery::getForwardedPointer(&key)) {
+    if (!Nursery::getForwardedPointer(&key)) {MOZ_RELEASE_ASSERT(0);
       // Dead nursery cell => discard.
       continue;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Key been moved. The value is an array of <map,key> pairs; update all
     // keys in that array.
@@ -297,28 +297,28 @@ void Zone::sweepWeakKeysAfterMinorGC() {
 
     // Live (moved) nursery cell. Append entries to gcWeakKeys.
     auto entry = gcWeakKeys().get(key);
-    if (!entry) {
-      if (!gcWeakKeys().put(key, gc::WeakEntryVector())) {
+    if (!entry) {MOZ_RELEASE_ASSERT(0);
+      if (!gcWeakKeys().put(key, gc::WeakEntryVector())) {MOZ_RELEASE_ASSERT(0);
         AutoEnterOOMUnsafeRegion oomUnsafe;
         oomUnsafe.crash("Failed to tenure weak keys entry");
-      }
+      }MOZ_RELEASE_ASSERT(0);
       entry = gcWeakKeys().get(key);
     }
 
-    for (auto& markable : entries) {
-      if (!entry->value.append(markable)) {
+    for (auto& markable : entries) {MOZ_RELEASE_ASSERT(0);
+      if (!entry->value.append(markable)) {MOZ_RELEASE_ASSERT(0);
         AutoEnterOOMUnsafeRegion oomUnsafe;
         oomUnsafe.crash("Failed to tenure weak keys entry");
-      }
-    }
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
 
     // If the key has a delegate, then it will map to a WeakKeyEntryVector
     // containing the key that needs to be updated.
 
     JSObject* delegate = gc::detail::GetDelegate(key->as<JSObject>());
-    if (!delegate) {
+    if (!delegate) {MOZ_RELEASE_ASSERT(0);
       continue;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(delegate->isTenured());
 
     // If delegate was formerly nursery-allocated, we will sweep its
@@ -328,9 +328,9 @@ void Zone::sweepWeakKeysAfterMinorGC() {
     //
     // Otherwise, it will be in gcWeakKeys and we sweep it here.
     auto p = delegate->zone()->gcWeakKeys().get(delegate);
-    if (p) {
+    if (p) {MOZ_RELEASE_ASSERT(0);
       SweepWeakEntryVectorWhileMinorSweeping(p->value);
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   if (!gcNurseryWeakKeys().clear()) {
@@ -738,7 +738,7 @@ void ZoneList::append(Zone* zone) {
 void ZoneList::transferFrom(ZoneList& other) {
   check();
   other.check();
-  if (!other.head) {
+  if (!other.head) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -789,7 +789,7 @@ void Zone::traceScriptTableRoots(JSTrace
   // Performance optimization: the script-table keys are JSScripts, which
   // cannot be in the nursery, so we can skip this tracing if we are only in a
   // minor collection. We static-assert this fact above.
-  if (JS::RuntimeHeapIsMinorCollecting()) {
+  if (JS::RuntimeHeapIsMinorCollecting()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -840,22 +840,22 @@ void Zone::fixupScriptMapsAfterMovingGC(
   }
 
 #ifdef MOZ_VTUNE
-  if (scriptVTuneIdMap) {
+  if (scriptVTuneIdMap) {MOZ_RELEASE_ASSERT(0);
     for (ScriptVTuneIdMap::Enum e(*scriptVTuneIdMap); !e.empty();
-         e.popFront()) {
+         e.popFront()) {MOZ_RELEASE_ASSERT(0);
       BaseScript* script = e.front().key();
       if (!IsAboutToBeFinalizedUnbarriered(&script) &&
-          script != e.front().key()) {
+          script != e.front().key()) {MOZ_RELEASE_ASSERT(0);
         e.rekeyFront(script);
-      }
-    }
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
   }
 #endif
 
 #ifdef JS_CACHEIR_SPEW
-  if (scriptFinalWarmUpCountMap) {
+  if (scriptFinalWarmUpCountMap) {MOZ_RELEASE_ASSERT(0);
     for (ScriptFinalWarmUpCountMap::Enum e(*scriptFinalWarmUpCountMap);
-         !e.empty(); e.popFront()) {
+         !e.empty(); e.popFront()) {MOZ_RELEASE_ASSERT(0);
       BaseScript* script = e.front().key();
       if (!IsAboutToBeFinalizedUnbarriered(&script) &&
           script != e.front().key()) {
@@ -914,16 +914,16 @@ void Zone::checkScriptMapsAfterMovingGC(
 }
 #endif
 
-void Zone::clearScriptCounts(Realm* realm) {
-  if (!scriptCountsMap) {
+void Zone::clearScriptCounts(Realm* realm) {MOZ_RELEASE_ASSERT(0);
+  if (!scriptCountsMap) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
   // Clear all hasScriptCounts_ flags of BaseScript, in order to release all
   // ScriptCounts entries of the given realm.
-  for (auto i = scriptCountsMap->modIter(); !i.done(); i.next()) {
+  for (auto i = scriptCountsMap->modIter(); !i.done(); i.next()) {MOZ_RELEASE_ASSERT(0);
     BaseScript* script = i.get().key();
-    if (script->realm() != realm) {
+    if (script->realm() != realm) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
     // We can't destroy the ScriptCounts yet if the script has Baseline code,
@@ -937,12 +937,12 @@ void Zone::clearScriptCounts(Realm* real
   }
 }
 
-void Zone::clearScriptLCov(Realm* realm) {
-  if (!scriptLCovMap) {
+void Zone::clearScriptLCov(Realm* realm) {MOZ_RELEASE_ASSERT(0);
+  if (!scriptLCovMap) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
-  for (auto i = scriptLCovMap->modIter(); !i.done(); i.next()) {
+  for (auto i = scriptLCovMap->modIter(); !i.done(); i.next()) {MOZ_RELEASE_ASSERT(0);
     BaseScript* script = i.get().key();
     if (script->realm() == realm) {
       i.remove();
diff --git a/js/src/gdb/gdb-tests.cpp b/js/src/gdb/gdb-tests.cpp
--- a/js/src/gdb/gdb-tests.cpp
+++ b/js/src/gdb/gdb-tests.cpp
@@ -23,14 +23,14 @@ static volatile int dontOptimizeMeAway =
 void usePointer(const void* ptr) { dontOptimizeMeAway++; }
 
 template <typename T>
-static inline T* checkPtr(T* ptr) {
+static inline T* checkPtr(T* ptr) {MOZ_RELEASE_ASSERT(0);
   if (!ptr) {
     abort();
   }
   return ptr;
 }
 
-static void checkBool(bool success) {
+static void checkBool(bool success) {MOZ_RELEASE_ASSERT(0);
   if (!success) {
     abort();
   }
@@ -55,7 +55,7 @@ void breakpoint() {
 
 GDBFragment* GDBFragment::allFragments = nullptr;
 
-int main(int argc, const char** argv) {
+int main(int argc, const char** argv) {MOZ_RELEASE_ASSERT(0);
   if (!JS_Init()) return 1;
   JSContext* cx = checkPtr(JS_NewContext(1024 * 1024));
 
@@ -73,15 +73,15 @@ int main(int argc, const char** argv) {
   JSAutoRealm ar(cx, global);
 
   argv++;
-  while (*argv) {
+  while (*argv) {MOZ_RELEASE_ASSERT(0);
     const char* name = *argv++;
     GDBFragment* fragment;
     for (fragment = GDBFragment::allFragments; fragment;
-         fragment = fragment->next) {
-      if (strcmp(fragment->name(), name) == 0) {
+         fragment = fragment->next) {MOZ_RELEASE_ASSERT(0);
+      if (strcmp(fragment->name(), name) == 0) {MOZ_RELEASE_ASSERT(0);
         fragment->run(cx, argv);
         break;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
     if (!fragment) {
       fprintf(stderr, "Unrecognized fragment name: %s\n", name);
diff --git a/js/src/gdb/tests/test-ExecutableAllocator.cpp b/js/src/gdb/tests/test-ExecutableAllocator.cpp
--- a/js/src/gdb/tests/test-ExecutableAllocator.cpp
+++ b/js/src/gdb/tests/test-ExecutableAllocator.cpp
@@ -25,7 +25,7 @@ FRAGMENT(ExecutableAllocator, onepool) {
   use(execAlloc);
 }
 
-FRAGMENT(ExecutableAllocator, twopools) {
+FRAGMENT(ExecutableAllocator, twopools) {MOZ_RELEASE_ASSERT(0);
   using namespace js::jit;
   const size_t INIT_ALLOC_SIZE = 16 * 1024;
   const size_t ALLOC_SIZE = 32 * 1024;
diff --git a/js/src/gdb/tests/test-unwind.cpp b/js/src/gdb/tests/test-unwind.cpp
--- a/js/src/gdb/tests/test-unwind.cpp
+++ b/js/src/gdb/tests/test-unwind.cpp
@@ -31,20 +31,20 @@ static const JSFunctionSpecWithHelp unwi
 };
 // clang-format on
 
-FRAGMENT(unwind, simple) {
+FRAGMENT(unwind, simple) {MOZ_RELEASE_ASSERT(0);
   using namespace JS;
 
   JS::Rooted<JSObject*> global(cx, JS::CurrentGlobalOrNull(cx));
-  if (!JS_DefineFunctionsWithHelp(cx, global, unwind_functions)) {
+  if (!JS_DefineFunctionsWithHelp(cx, global, unwind_functions)) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Define an itercount property and use it to ensure Baseline compilation.
   uint32_t threshold = js::jit::JitOptions.baselineJitWarmUpThreshold;
   RootedValue val(cx, Int32Value(threshold + 10));
-  if (!JS_DefineProperty(cx, global, "itercount", val, 0)) {
+  if (!JS_DefineProperty(cx, global, "itercount", val, 0)) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   int line0 = __LINE__;
   const char* bytes =
diff --git a/js/src/irregexp/RegExpAPI.cpp b/js/src/irregexp/RegExpAPI.cpp
--- a/js/src/irregexp/RegExpAPI.cpp
+++ b/js/src/irregexp/RegExpAPI.cpp
@@ -238,13 +238,13 @@ static void ReportSyntaxError(TokenStrea
   // Create the windowed string, not including the potential line
   // terminator.
   StringBuffer windowBuf(ts.context());
-  if (!windowBuf.append(windowStart, windowEnd)) {
+  if (!windowBuf.append(windowStart, windowEnd)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
   // The line of context must be null-terminated, and StringBuffer doesn't
   // make that happen unless we force it to.
-  if (!windowBuf.append('\0')) {
+  if (!windowBuf.append('\0')) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -416,7 +416,7 @@ class RegExpDepthCheck final : public v8
                          void*) override {
     uint8_t padding[FRAME_PADDING];
     dummy_ = padding; /* Prevent padding from being optimized away.*/
-    if (!CheckRecursionLimitDontReport(cx_)) {
+    if (!CheckRecursionLimitDontReport(cx_)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     for (auto* child : *node->nodes()) {
@@ -430,7 +430,7 @@ class RegExpDepthCheck final : public v8
                          void*) override {
     uint8_t padding[FRAME_PADDING];
     dummy_ = padding; /* Prevent padding from being optimized away.*/
-    if (!CheckRecursionLimitDontReport(cx_)) {
+    if (!CheckRecursionLimitDontReport(cx_)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     for (auto* child : *node->alternatives()) {
@@ -479,7 +479,7 @@ enum class AssembleResult {
   } else {
     masm = MakeUnique<RegExpBytecodeGenerator>(cx->isolate, zone);
   }
-  if (!masm) {
+  if (!masm) {MOZ_RELEASE_ASSERT(0);
     return AssembleResult::OutOfMemory;
   }
 
@@ -532,7 +532,7 @@ enum class AssembleResult {
     MOZ_ASSERT(result.error == RegExpError::kTooLarge);
     return AssembleResult::TooLarge;
   }
-  if (result.code->value().isUndefined()) {
+  if (result.code->value().isUndefined()) {MOZ_RELEASE_ASSERT(0);
     // SMRegExpMacroAssembler::GetCode returns undefined on OOM.
     MOZ_ASSERT(useNativeCode);
     return AssembleResult::OutOfMemory;
@@ -545,7 +545,7 @@ enum class AssembleResult {
     SMRegExpMacroAssembler::TableVector& tables =
         static_cast<SMRegExpMacroAssembler*>(masm.get())->tables();
     for (uint32_t i = 0; i < tables.length(); i++) {
-      if (!re->addTable(std::move(tables[i]))) {
+      if (!re->addTable(std::move(tables[i]))) {MOZ_RELEASE_ASSERT(0);
         return AssembleResult::OutOfMemory;
       }
     }
@@ -604,7 +604,7 @@ bool CompilePattern(JSContext* cx, Mutab
         v8::internal::RegExpAtom* atom = data.tree->AsAtom();
         const char16_t* twoByteChars = atom->data().begin();
         searchAtom = AtomizeChars(cx, twoByteChars, atom->length());
-        if (!searchAtom) {
+        if (!searchAtom) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -616,7 +616,7 @@ bool CompilePattern(JSContext* cx, Mutab
     }
     if (!data.capture_name_map.is_null()) {
       RootedNativeObject namedCaptures(cx, data.capture_name_map->inner());
-      if (!RegExpShared::initializeNamedCaptures(cx, re, namedCaptures)) {
+      if (!RegExpShared::initializeNamedCaptures(cx, re, namedCaptures)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -736,7 +736,7 @@ RegExpRunStatus ExecuteForFuzzing(JSCont
                                   HandleLinearString input,
                                   JS::RegExpFlags flags, size_t startIndex,
                                   VectorMatchPairs* matches,
-                                  RegExpShared::CodeKind codeKind) {
+                                  RegExpShared::CodeKind codeKind) {MOZ_RELEASE_ASSERT(0);
   RootedRegExpShared re(cx, cx->zone()->regExps().get(cx, pattern, flags));
   if (!RegExpShared::compileIfNecessary(cx, &re, input, codeKind)) {
     return RegExpRunStatus_Error;
diff --git a/js/src/irregexp/RegExpNativeMacroAssembler.cpp b/js/src/irregexp/RegExpNativeMacroAssembler.cpp
--- a/js/src/irregexp/RegExpNativeMacroAssembler.cpp
+++ b/js/src/irregexp/RegExpNativeMacroAssembler.cpp
@@ -183,7 +183,7 @@ void SMRegExpMacroAssembler::CheckNotCha
 void SMRegExpMacroAssembler::CheckNotCharacterAfterMinusAnd(
     uc16 c, uc16 minus, uc16 mask, Label* on_not_equal) {
   masm_.computeEffectiveAddress(Address(current_character_, -minus), temp0_);
-  if (c == 0) {
+  if (c == 0) {MOZ_RELEASE_ASSERT(0);
     masm_.branchTest32(Assembler::NonZero, temp0_, Imm32(mask),
                        LabelOrBacktrack(on_not_equal));
   } else {
@@ -262,7 +262,7 @@ void SMRegExpMacroAssembler::CheckNotBac
   masm_.branchPtr(Assembler::Equal, temp0_, ImmWord(0), &fallthrough);
 
   // Check that there are sufficient characters left in the input.
-  if (read_backward) {
+  if (read_backward) {MOZ_RELEASE_ASSERT(0);
     // If start + len > current, there isn't enough room for a
     // lookbehind backreference.
     masm_.loadPtr(inputStart(), temp1_);
@@ -301,7 +301,7 @@ void SMRegExpMacroAssembler::CheckNotBac
 
     // Compute |current|
     masm_.addPtr(input_end_pointer_, current_position_);
-    if (read_backward) {
+    if (read_backward) {MOZ_RELEASE_ASSERT(0);
       // Offset by length when matching backwards.
       masm_.subPtr(temp0_, current_position_);
     }
@@ -312,7 +312,7 @@ void SMRegExpMacroAssembler::CheckNotBac
     masm_.passABIArg(current_position_);
     masm_.passABIArg(temp0_);
 
-    if (unicode) {
+    if (unicode) {MOZ_RELEASE_ASSERT(0);
       masm_.callWithABI<Fn, ::js::irregexp::CaseInsensitiveCompareUnicode>();
     } else {
       masm_.callWithABI<Fn, ::js::irregexp::CaseInsensitiveCompareNonUnicode>();
@@ -323,7 +323,7 @@ void SMRegExpMacroAssembler::CheckNotBac
                        LabelOrBacktrack(on_no_match));
 
     // On success, advance position by length of capture
-    if (read_backward) {
+    if (read_backward) {MOZ_RELEASE_ASSERT(0);
       masm_.subPtr(temp0_, current_position_);
     } else {
       masm_.addPtr(temp0_, current_position_);
@@ -341,7 +341,7 @@ void SMRegExpMacroAssembler::CheckNotBac
 
   // Compute start of match string
   masm_.addPtr(input_end_pointer_, current_position_);
-  if (read_backward) {
+  if (read_backward) {MOZ_RELEASE_ASSERT(0);
     // Offset by length when matching backwards.
     masm_.subPtr(temp0_, current_position_);
   }
@@ -791,7 +791,7 @@ void SMRegExpMacroAssembler::Pop(Registe
 }
 
 void SMRegExpMacroAssembler::JumpOrBacktrack(Label* to) {
-  if (to) {
+  if (to) {MOZ_RELEASE_ASSERT(0);
     masm_.jump(to->inner());
   } else {
     Backtrack();
@@ -824,7 +824,7 @@ static Handle<HeapObject> DummyCode() {
 // Finalize code. This is called last, so that we know how many
 // registers we need.
 Handle<HeapObject> SMRegExpMacroAssembler::GetCode(Handle<String> source) {
-  if (!cx_->realm()->ensureJitRealmExists(cx_)) {
+  if (!cx_->realm()->ensureJitRealmExists(cx_)) {MOZ_RELEASE_ASSERT(0);
     return DummyCode();
   }
 
@@ -842,7 +842,7 @@ Handle<HeapObject> SMRegExpMacroAssemble
 
   Linker linker(masm_);
   JitCode* code = linker.newCode(cx_, js::jit::CodeKind::RegExp);
-  if (!code) {
+  if (!code) {MOZ_RELEASE_ASSERT(0);
     return DummyCode();
   }
 
@@ -1054,7 +1054,7 @@ void SMRegExpMacroAssembler::successHand
 void SMRegExpMacroAssembler::exitHandler() {
   masm_.bind(&exit_label_);
 
-  if (temp0_ != js::jit::ReturnReg) {
+  if (temp0_ != js::jit::ReturnReg) {MOZ_RELEASE_ASSERT(0);
     masm_.movePtr(temp0_, js::jit::ReturnReg);
   }
 
@@ -1197,16 +1197,16 @@ uint32_t SMRegExpMacroAssembler::CaseIns
 // Compare two strings in `/iu` mode (ignoreCase and unicode).
 /*static */
 uint32_t SMRegExpMacroAssembler::CaseInsensitiveCompareUnicode(
-    const char16_t* substring1, const char16_t* substring2, size_t byteLength) {
+    const char16_t* substring1, const char16_t* substring2, size_t byteLength) {MOZ_RELEASE_ASSERT(0);
   js::AutoUnsafeCallWithABI unsafe;
 
   MOZ_ASSERT(byteLength % sizeof(char16_t) == 0);
   size_t length = byteLength / sizeof(char16_t);
 
-  for (size_t i = 0; i < length; i++) {
+  for (size_t i = 0; i < length; i++) {MOZ_RELEASE_ASSERT(0);
     char16_t c1 = substring1[i];
     char16_t c2 = substring2[i];
-    if (c1 != c2) {
+    if (c1 != c2) {MOZ_RELEASE_ASSERT(0);
       // Unicode regexps use the common and simple case-folding
       // mappings of the Unicode Character Database.
       c1 = js::unicode::FoldCase(c1);
diff --git a/js/src/irregexp/RegExpShim.cpp b/js/src/irregexp/RegExpShim.cpp
--- a/js/src/irregexp/RegExpShim.cpp
+++ b/js/src/irregexp/RegExpShim.cpp
@@ -58,7 +58,7 @@ std::ostream& operator<<(std::ostream& o
   SprintfLiteral(buf, format, v);
   return os << buf;
 }
-std::ostream& operator<<(std::ostream& os, const AsUC32& c) {
+std::ostream& operator<<(std::ostream& os, const AsUC32& c) {MOZ_RELEASE_ASSERT(0);
   int32_t v = c.value;
   if (v <= String::kMaxUtf16CodeUnit) {
     return os << AsUC16(v);
@@ -102,7 +102,7 @@ JS::Value* Isolate::getHandleLocation(co
 void* Isolate::allocatePseudoHandle(size_t bytes) {
   PseudoHandle<void> ptr;
   ptr.reset(js_malloc(bytes));
-  if (!ptr) {
+  if (!ptr) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (!uniquePtrArena_.Append(std::move(ptr))) {
@@ -131,7 +131,7 @@ PseudoHandle<ByteArrayData> ByteArray::t
   return result;
 }
 
-void Isolate::trace(JSTracer* trc) {
+void Isolate::trace(JSTracer* trc) {MOZ_RELEASE_ASSERT(0);
   js::gc::AssertRootMarkingPhase(trc);
 
   for (auto iter = handleArena_.Iter(); !iter.Done(); iter.Next()) {
@@ -157,9 +157,9 @@ size_t Isolate::sizeOfIncludingThis(mozi
 
 /*static*/ Handle<String> String::Flatten(Isolate* isolate,
                                           Handle<String> string) {
-  if (string->IsFlat()) {
+  if (string->IsFlat()) {MOZ_RELEASE_ASSERT(0);
     return string;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   js::AutoEnterOOMUnsafeRegion oomUnsafe;
   JSLinearString* linear = string->str()->ensureLinear(isolate->cx());
   if (!linear) {
@@ -171,7 +171,7 @@ size_t Isolate::sizeOfIncludingThis(mozi
 // This is only used for trace messages printing the source pattern of
 // a regular expression. We have to return a unique_ptr, but we don't
 // care about the contents, so we return an empty null-terminated string.
-std::unique_ptr<char[]> String::ToCString() {
+std::unique_ptr<char[]> String::ToCString() {MOZ_RELEASE_ASSERT(0);
   js::AutoEnterOOMUnsafeRegion oomUnsafe;
 
   std::unique_ptr<char[]> ptr;
diff --git a/js/src/irregexp/imported/regexp-ast.cc b/js/src/irregexp/imported/regexp-ast.cc
--- a/js/src/irregexp/imported/regexp-ast.cc
+++ b/js/src/irregexp/imported/regexp-ast.cc
@@ -148,7 +148,7 @@ class RegExpUnparser final : public RegE
 };
 
 
-void* RegExpUnparser::VisitDisjunction(RegExpDisjunction* that, void* data) {
+void* RegExpUnparser::VisitDisjunction(RegExpDisjunction* that, void* data) {MOZ_RELEASE_ASSERT(0);
   os_ << "(|";
   for (int i = 0; i < that->alternatives()->length(); i++) {
     os_ << " ";
@@ -159,7 +159,7 @@ void* RegExpUnparser::VisitDisjunction(R
 }
 
 
-void* RegExpUnparser::VisitAlternative(RegExpAlternative* that, void* data) {
+void* RegExpUnparser::VisitAlternative(RegExpAlternative* that, void* data) {MOZ_RELEASE_ASSERT(0);
   os_ << "(:";
   for (int i = 0; i < that->nodes()->length(); i++) {
     os_ << " ";
@@ -170,7 +170,7 @@ void* RegExpUnparser::VisitAlternative(R
 }
 
 
-void RegExpUnparser::VisitCharacterRange(CharacterRange that) {
+void RegExpUnparser::VisitCharacterRange(CharacterRange that) {MOZ_RELEASE_ASSERT(0);
   os_ << AsUC32(that.from());
   if (!that.IsSingleton()) {
     os_ << "-" << AsUC32(that.to());
@@ -179,7 +179,7 @@ void RegExpUnparser::VisitCharacterRange
 
 
 void* RegExpUnparser::VisitCharacterClass(RegExpCharacterClass* that,
-                                          void* data) {
+                                          void* data) {MOZ_RELEASE_ASSERT(0);
   if (that->is_negated()) os_ << "^";
   os_ << "[";
   for (int i = 0; i < that->ranges(zone_)->length(); i++) {
@@ -191,7 +191,7 @@ void* RegExpUnparser::VisitCharacterClas
 }
 
 
-void* RegExpUnparser::VisitAssertion(RegExpAssertion* that, void* data) {
+void* RegExpUnparser::VisitAssertion(RegExpAssertion* that, void* data) {MOZ_RELEASE_ASSERT(0);
   switch (that->assertion_type()) {
     case RegExpAssertion::START_OF_INPUT:
       os_ << "@^i";
@@ -216,7 +216,7 @@ void* RegExpUnparser::VisitAssertion(Reg
 }
 
 
-void* RegExpUnparser::VisitAtom(RegExpAtom* that, void* data) {
+void* RegExpUnparser::VisitAtom(RegExpAtom* that, void* data) {MOZ_RELEASE_ASSERT(0);
   os_ << "'";
   Vector<const uc16> chardata = that->data();
   for (int i = 0; i < chardata.length(); i++) {
@@ -227,10 +227,10 @@ void* RegExpUnparser::VisitAtom(RegExpAt
 }
 
 
-void* RegExpUnparser::VisitText(RegExpText* that, void* data) {
-  if (that->elements()->length() == 1) {
+void* RegExpUnparser::VisitText(RegExpText* that, void* data) {MOZ_RELEASE_ASSERT(0);
+  if (that->elements()->length() == 1) {MOZ_RELEASE_ASSERT(0);
     that->elements()->at(0).tree()->Accept(this, data);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     os_ << "(!";
     for (int i = 0; i < that->elements()->length(); i++) {
       os_ << " ";
@@ -242,9 +242,9 @@ void* RegExpUnparser::VisitText(RegExpTe
 }
 
 
-void* RegExpUnparser::VisitQuantifier(RegExpQuantifier* that, void* data) {
+void* RegExpUnparser::VisitQuantifier(RegExpQuantifier* that, void* data) {MOZ_RELEASE_ASSERT(0);
   os_ << "(# " << that->min() << " ";
-  if (that->max() == RegExpTree::kInfinity) {
+  if (that->max() == RegExpTree::kInfinity) {MOZ_RELEASE_ASSERT(0);
     os_ << "- ";
   } else {
     os_ << that->max() << " ";
diff --git a/js/src/irregexp/imported/regexp-bytecode-generator.cc b/js/src/irregexp/imported/regexp-bytecode-generator.cc
--- a/js/src/irregexp/imported/regexp-bytecode-generator.cc
+++ b/js/src/irregexp/imported/regexp-bytecode-generator.cc
@@ -196,18 +196,18 @@ void RegExpBytecodeGenerator::LoadCurren
   DCHECK_GE(kMaxCPOffset, cp_offset);
   int bytecode;
   if (check_bounds) {
-    if (characters == 4) {
+    if (characters == 4) {MOZ_RELEASE_ASSERT(0);
       bytecode = BC_LOAD_4_CURRENT_CHARS;
-    } else if (characters == 2) {
+    } else if (characters == 2) {MOZ_RELEASE_ASSERT(0);
       bytecode = BC_LOAD_2_CURRENT_CHARS;
     } else {
       DCHECK_EQ(1, characters);
       bytecode = BC_LOAD_CURRENT_CHAR;
     }
   } else {
-    if (characters == 4) {
+    if (characters == 4) {MOZ_RELEASE_ASSERT(0);
       bytecode = BC_LOAD_4_CURRENT_CHARS_UNCHECKED;
-    } else if (characters == 2) {
+    } else if (characters == 2) {MOZ_RELEASE_ASSERT(0);
       bytecode = BC_LOAD_2_CURRENT_CHARS_UNCHECKED;
     } else {
       DCHECK_EQ(1, characters);
@@ -229,7 +229,7 @@ void RegExpBytecodeGenerator::CheckChara
 }
 
 void RegExpBytecodeGenerator::CheckCharacter(uint32_t c, Label* on_equal) {
-  if (c > MAX_FIRST_ARG) {
+  if (c > MAX_FIRST_ARG) {MOZ_RELEASE_ASSERT(0);
     Emit(BC_CHECK_4_CHARS, 0);
     Emit32(c);
   } else {
@@ -251,7 +251,7 @@ void RegExpBytecodeGenerator::CheckNotAt
 
 void RegExpBytecodeGenerator::CheckNotCharacter(uint32_t c,
                                                 Label* on_not_equal) {
-  if (c > MAX_FIRST_ARG) {
+  if (c > MAX_FIRST_ARG) {MOZ_RELEASE_ASSERT(0);
     Emit(BC_CHECK_NOT_4_CHARS, 0);
     Emit32(c);
   } else {
@@ -262,7 +262,7 @@ void RegExpBytecodeGenerator::CheckNotCh
 
 void RegExpBytecodeGenerator::CheckCharacterAfterAnd(uint32_t c, uint32_t mask,
                                                      Label* on_equal) {
-  if (c > MAX_FIRST_ARG) {
+  if (c > MAX_FIRST_ARG) {MOZ_RELEASE_ASSERT(0);
     Emit(BC_AND_CHECK_4_CHARS, 0);
     Emit32(c);
   } else {
@@ -275,7 +275,7 @@ void RegExpBytecodeGenerator::CheckChara
 void RegExpBytecodeGenerator::CheckNotCharacterAfterAnd(uint32_t c,
                                                         uint32_t mask,
                                                         Label* on_not_equal) {
-  if (c > MAX_FIRST_ARG) {
+  if (c > MAX_FIRST_ARG) {MOZ_RELEASE_ASSERT(0);
     Emit(BC_AND_CHECK_NOT_4_CHARS, 0);
     Emit32(c);
   } else {
diff --git a/js/src/irregexp/imported/regexp-bytecode-peephole.cc b/js/src/irregexp/imported/regexp-bytecode-peephole.cc
--- a/js/src/irregexp/imported/regexp-bytecode-peephole.cc
+++ b/js/src/irregexp/imported/regexp-bytecode-peephole.cc
@@ -766,7 +766,7 @@ void RegExpBytecodePeephole::EmitOptimiz
              start_pc + last_node.SequenceLength();
          ++jump_iter) {
       int jump_destination = jump_iter->second;
-      if (jump_destination > start_pc && jump_destination < preserve_from) {
+      if (jump_destination > start_pc && jump_destination < preserve_from) {MOZ_RELEASE_ASSERT(0);
         preserve_from = jump_destination;
       }
     }
diff --git a/js/src/irregexp/imported/regexp-bytecodes.cc b/js/src/irregexp/imported/regexp-bytecodes.cc
--- a/js/src/irregexp/imported/regexp-bytecodes.cc
+++ b/js/src/irregexp/imported/regexp-bytecodes.cc
@@ -10,14 +10,14 @@
 namespace v8 {
 namespace internal {
 
-void RegExpBytecodeDisassembleSingle(const byte* code_base, const byte* pc) {
+void RegExpBytecodeDisassembleSingle(const byte* code_base, const byte* pc) {MOZ_RELEASE_ASSERT(0);
   int bytecode = *reinterpret_cast<const int32_t*>(pc) & BYTECODE_MASK;
   PrintF("%s", RegExpBytecodeName(bytecode));
 
   // Args and the bytecode as hex.
-  for (int i = 0; i < RegExpBytecodeLength(bytecode); i++) {
+  for (int i = 0; i < RegExpBytecodeLength(bytecode); i++) {MOZ_RELEASE_ASSERT(0);
     PrintF(", %02x", pc[i]);
-  }
+  }MOZ_RELEASE_ASSERT(0);
   PrintF(" ");
 
   // Args as ascii.
@@ -29,7 +29,7 @@ void RegExpBytecodeDisassembleSingle(con
 }
 
 void RegExpBytecodeDisassemble(const byte* code_base, int length,
-                               const char* pattern) {
+                               const char* pattern) {MOZ_RELEASE_ASSERT(0);
   PrintF("[generated bytecode for regexp pattern: '%s']\n", pattern);
 
   ptrdiff_t offset = 0;
diff --git a/js/src/irregexp/imported/regexp-compiler-tonode.cc b/js/src/irregexp/imported/regexp-compiler-tonode.cc
--- a/js/src/irregexp/imported/regexp-compiler-tonode.cc
+++ b/js/src/irregexp/imported/regexp-compiler-tonode.cc
@@ -423,7 +423,7 @@ RegExpNode* RegExpCharacterClass::ToNode
           zone->New<RegExpCharacterClass>(zone, ranges, default_flags);
       return zone->New<TextNode>(fail, compiler->read_backward(), on_success);
     }
-    if (standard_type() == '*') {
+    if (standard_type() == '*') {MOZ_RELEASE_ASSERT(0);
       return UnanchoredAdvance(compiler, on_success);
     } else {
       ChoiceNode* result = zone->New<ChoiceNode>(2, zone);
@@ -698,7 +698,7 @@ void RegExpDisjunction::FixSingleCharact
         ranges->Add(CharacterRange::Singleton(old_atom->data().at(0)), zone);
       }
       RegExpCharacterClass::CharacterClassFlags character_class_flags;
-      if (IsUnicode(flags) && contains_trail_surrogate) {
+      if (IsUnicode(flags) && contains_trail_surrogate) {MOZ_RELEASE_ASSERT(0);
         character_class_flags = RegExpCharacterClass::CONTAINS_SPLIT_SURROGATE;
       }
       alternatives->at(write_posn++) = zone->New<RegExpCharacterClass>(
@@ -1254,7 +1254,7 @@ void CharacterRange::AddCaseEquivalents(
 #endif  // V8_INTL_SUPPORT
 }
 
-bool CharacterRange::IsCanonical(ZoneList<CharacterRange>* ranges) {
+bool CharacterRange::IsCanonical(ZoneList<CharacterRange>* ranges) {MOZ_RELEASE_ASSERT(0);
   DCHECK_NOT_NULL(ranges);
   int n = ranges->length();
   if (n <= 1) return true;
diff --git a/js/src/irregexp/imported/regexp-compiler.cc b/js/src/irregexp/imported/regexp-compiler.cc
--- a/js/src/irregexp/imported/regexp-compiler.cc
+++ b/js/src/irregexp/imported/regexp-compiler.cc
@@ -294,7 +294,7 @@ bool Trace::DeferredAction::Mentions(int
   }
 }
 
-bool Trace::mentions_reg(int reg) {
+bool Trace::mentions_reg(int reg) {MOZ_RELEASE_ASSERT(0);
   for (DeferredAction* action = actions_; action != nullptr;
        action = action->next()) {
     if (action->Mentions(reg)) return true;
@@ -969,7 +969,7 @@ static void EmitUseLookupTable(RegExpMac
   Label* on_bit_set;
   Label* on_bit_clear;
   int bit;
-  if (even_label == fall_through) {
+  if (even_label == fall_through) {MOZ_RELEASE_ASSERT(0);
     on_bit_set = odd_label;
     on_bit_clear = even_label;
     bit = 1;
@@ -1222,12 +1222,12 @@ static void EmitCharClass(RegExpMacroAss
   }
 
   if (last_valid_range < 0) {
-    if (!cc->is_negated()) {
+    if (!cc->is_negated()) {MOZ_RELEASE_ASSERT(0);
       macro_assembler->GoTo(on_failure);
     }
-    if (check_offset) {
+    if (check_offset) {MOZ_RELEASE_ASSERT(0);
       macro_assembler->CheckPosition(cp_offset, on_failure);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -1339,7 +1339,7 @@ bool RegExpNode::KeepRecursing(RegExpCom
 
 void ActionNode::FillInBMInfo(Isolate* isolate, int offset, int budget,
                               BoyerMooreLookahead* bm, bool not_at_start) {
-  if (action_type_ == POSITIVE_SUBMATCH_SUCCESS) {
+  if (action_type_ == POSITIVE_SUBMATCH_SUCCESS) {MOZ_RELEASE_ASSERT(0);
     // Anything may follow a positive submatch success, thus we need to accept
     // all characters from this position onwards.
     bm->SetRest(offset);
@@ -1518,7 +1518,7 @@ bool RegExpNode::EmitQuickCheck(RegExpCo
     static const uint32_t kFourByteMask = 0xFFFFFFFF;
     if (details->characters() == 2 && compiler->one_byte()) {
       if ((mask & kTwoByteMask) == kTwoByteMask) need_mask = false;
-    } else if (details->characters() == 1 && !compiler->one_byte()) {
+    } else if (details->characters() == 1 && !compiler->one_byte()) {MOZ_RELEASE_ASSERT(0);
       if ((mask & kTwoByteMask) == kTwoByteMask) need_mask = false;
     } else {
       if (mask == kFourByteMask) need_mask = false;
@@ -1641,7 +1641,7 @@ void TextNode::GetQuickCheckDetails(Quic
         int first_range = 0;
         while (ranges->at(first_range).from() > char_mask) {
           first_range++;
-          if (first_range == ranges->length()) {
+          if (first_range == ranges->length()) {MOZ_RELEASE_ASSERT(0);
             details->set_cannot_match();
             pos->determines_perfectly = false;
             return;
@@ -1858,7 +1858,7 @@ RegExpNode* TextNode::FilterOneByte(int 
             ranges->at(0).to() >= String::kMaxOneByteCharCode) {
           // This will be handled in a later filter.
           if (IgnoreCase(cc->flags()) &&
-              RangesContainLatin1Equivalents(ranges)) {
+              RangesContainLatin1Equivalents(ranges)) {MOZ_RELEASE_ASSERT(0);
             continue;
           }
           return set_replacement(nullptr);
@@ -1996,7 +1996,7 @@ void LoopChoiceNode::GetQuickCheckDetail
 void LoopChoiceNode::GetQuickCheckDetailsFromLoopEntry(
     QuickCheckDetails* details, RegExpCompiler* compiler,
     int characters_filled_in, bool not_at_start) {
-  if (traversed_loop_initialization_node_) {
+  if (traversed_loop_initialization_node_) {MOZ_RELEASE_ASSERT(0);
     // We already entered this loop once, exited via its continuation node, and
     // followed an outer loop's back-edge to before the loop entry point. We
     // could try to reset the minimum iteration count to its starting value at
@@ -2128,7 +2128,7 @@ void AssertionNode::EmitBoundaryCheck(Re
       if (bm->at(0)->is_non_word()) next_is_word_character = Trace::FALSE_VALUE;
       if (bm->at(0)->is_word()) next_is_word_character = Trace::TRUE_VALUE;
     }
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     if (lookahead->at(0)->is_non_word())
       next_is_word_character = Trace::FALSE_VALUE;
     if (lookahead->at(0)->is_word()) next_is_word_character = Trace::TRUE_VALUE;
@@ -2523,7 +2523,7 @@ int ChoiceNode::GreedyLoopTextLengthForA
   // so we have to limit the max number.
   int recursion_depth = 0;
   while (node != this) {
-    if (recursion_depth++ > RegExpCompiler::kMaxRecursion) {
+    if (recursion_depth++ > RegExpCompiler::kMaxRecursion) {MOZ_RELEASE_ASSERT(0);
       return kNodeIsTooComplexForGreedyLoops;
     }
     int node_length = node->GreedyLoopTextLength();
diff --git a/js/src/irregexp/imported/regexp-interpreter.cc b/js/src/irregexp/imported/regexp-interpreter.cc
--- a/js/src/irregexp/imported/regexp-interpreter.cc
+++ b/js/src/irregexp/imported/regexp-interpreter.cc
@@ -210,7 +210,7 @@ IrregexpInterpreter::Result ThrowStackOv
 // status code.
 IrregexpInterpreter::Result MaybeThrowStackOverflow(
     Isolate* isolate, RegExp::CallOrigin call_origin) {
-  if (call_origin == RegExp::CallOrigin::kFromRuntime) {
+  if (call_origin == RegExp::CallOrigin::kFromRuntime) {MOZ_RELEASE_ASSERT(0);
     return ThrowStackOverflow(isolate, call_origin);
   } else {
     return IrregexpInterpreter::EXCEPTION;
@@ -222,7 +222,7 @@ void UpdateCodeAndSubjectReferences(
     Isolate* isolate, Handle<ByteArray> code_array,
     Handle<String> subject_string, ByteArray* code_array_out,
     const byte** code_base_out, const byte** pc_out, String* subject_string_out,
-    Vector<const Char>* subject_string_vector_out) {
+    Vector<const Char>* subject_string_vector_out) {MOZ_RELEASE_ASSERT(0);
   DisallowGarbageCollection no_gc;
 
   if (*code_base_out != code_array->GetDataStartAddress()) {
@@ -256,9 +256,9 @@ IrregexpInterpreter::Result HandleInterr
     //    exception.
     // 2. The stack guard was used to interrupt execution for another purpose,
     //    forcing the call through the runtime system.
-    if (js_has_overflowed) {
+    if (js_has_overflowed) {MOZ_RELEASE_ASSERT(0);
       return IrregexpInterpreter::EXCEPTION;
-    } else if (check.InterruptRequested()) {
+    } else if (check.InterruptRequested()) {MOZ_RELEASE_ASSERT(0);
       return IrregexpInterpreter::RETRY;
     }
   } else {
@@ -280,7 +280,7 @@ IrregexpInterpreter::Result HandleInterr
       }
       if (result.IsException(isolate)) {
         return IrregexpInterpreter::EXCEPTION;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       // If we changed between a LATIN1 and a UC16 string, we need to restart
       // regexp matching with the appropriate template instantiation of
diff --git a/js/src/irregexp/imported/regexp-macro-assembler-tracer.cc b/js/src/irregexp/imported/regexp-macro-assembler-tracer.cc
--- a/js/src/irregexp/imported/regexp-macro-assembler-tracer.cc
+++ b/js/src/irregexp/imported/regexp-macro-assembler-tracer.cc
@@ -177,8 +177,8 @@ class PrintablePrinter {
  public:
   explicit PrintablePrinter(uc16 character) : character_(character) { }
 
-  const char* operator*() {
-    if (character_ >= ' ' && character_ <= '~') {
+  const char* operator*() {MOZ_RELEASE_ASSERT(0);
+    if (character_ >= ' ' && character_ <= '~') {MOZ_RELEASE_ASSERT(0);
       buffer_[0] = '(';
       buffer_[1] = static_cast<char>(character_);
       buffer_[2] = ')';
@@ -328,9 +328,9 @@ void RegExpMacroAssemblerTracer::CheckCh
 
 
 void RegExpMacroAssemblerTracer::CheckBitInTable(
-    Handle<ByteArray> table, Label* on_bit_set) {
+    Handle<ByteArray> table, Label* on_bit_set) {MOZ_RELEASE_ASSERT(0);
   PrintF(" CheckBitInTable(label[%08x] ", LabelToInt(on_bit_set));
-  for (int i = 0; i < kTableSize; i++) {
+  for (int i = 0; i < kTableSize; i++) {MOZ_RELEASE_ASSERT(0);
     PrintF("%c", table->get(i) != 0 ? 'X' : '.');
     if (i % 32 == 31 && i != kTableMask) {
       PrintF("\n                                 ");
diff --git a/js/src/irregexp/imported/regexp-macro-assembler.cc b/js/src/irregexp/imported/regexp-macro-assembler.cc
--- a/js/src/irregexp/imported/regexp-macro-assembler.cc
+++ b/js/src/irregexp/imported/regexp-macro-assembler.cc
@@ -54,7 +54,7 @@ int RegExpMacroAssembler::CaseInsensitiv
 int RegExpMacroAssembler::CaseInsensitiveCompareUnicode(Address byte_offset1,
                                                         Address byte_offset2,
                                                         size_t byte_length,
-                                                        Isolate* isolate) {
+                                                        Isolate* isolate) {MOZ_RELEASE_ASSERT(0);
   // This function is not allowed to cause a garbage collection.
   // A GC might move the calling generated code and invalidate the
   // return address on the stack.
@@ -137,14 +137,14 @@ NativeRegExpMacroAssembler::~NativeRegEx
 
 void NativeRegExpMacroAssembler::LoadCurrentCharacterImpl(
     int cp_offset, Label* on_end_of_input, bool check_bounds, int characters,
-    int eats_at_least) {
+    int eats_at_least) {MOZ_RELEASE_ASSERT(0);
   // It's possible to preload a small number of characters when each success
   // path requires a large number of characters, but not the reverse.
   DCHECK_GE(eats_at_least, characters);
 
   DCHECK(base::IsInRange(cp_offset, kMinCPOffset, kMaxCPOffset));
-  if (check_bounds) {
-    if (cp_offset >= 0) {
+  if (check_bounds) {MOZ_RELEASE_ASSERT(0);
+    if (cp_offset >= 0) {MOZ_RELEASE_ASSERT(0);
       CheckPosition(cp_offset + eats_at_least - 1, on_end_of_input);
     } else {
       CheckPosition(cp_offset, on_end_of_input);
@@ -374,7 +374,7 @@ const byte NativeRegExpMacroAssembler::w
 
 Address NativeRegExpMacroAssembler::GrowStack(Address stack_pointer,
                                               Address* stack_base,
-                                              Isolate* isolate) {
+                                              Isolate* isolate) {MOZ_RELEASE_ASSERT(0);
   RegExpStack* regexp_stack = isolate->regexp_stack();
   size_t size = regexp_stack->stack_capacity();
   Address old_stack_base = regexp_stack->stack_base();
diff --git a/js/src/irregexp/imported/regexp-parser.cc b/js/src/irregexp/imported/regexp-parser.cc
--- a/js/src/irregexp/imported/regexp-parser.cc
+++ b/js/src/irregexp/imported/regexp-parser.cc
@@ -77,7 +77,7 @@ void RegExpParser::Advance() {
     } else if (zone()->excess_allocation()) {
       if (FLAG_correctness_fuzzer_suppressions) {
         FATAL("Aborting on excess zone allocation");
-      }
+      }MOZ_RELEASE_ASSERT(0);
       ReportError(RegExpError::kTooLarge);
     } else {
       current_ = ReadNext<true>();
@@ -1737,7 +1737,7 @@ RegExpTree* RegExpParser::ParseCharacter
                      &is_class_1 CHECK_FAILED);
     if (current() == '-') {
       Advance();
-      if (current() == kEndMarker) {
+      if (current() == kEndMarker) {MOZ_RELEASE_ASSERT(0);
         // If we reach the end we break out of the loop and let the
         // following code report an error.
         break;
@@ -1977,7 +1977,7 @@ void RegExpBuilder::AddCharacterClassFor
 
 
 void RegExpBuilder::AddAtom(RegExpTree* term) {
-  if (term->IsEmpty()) {
+  if (term->IsEmpty()) {MOZ_RELEASE_ASSERT(0);
     AddEmpty();
     return;
   }
diff --git a/js/src/irregexp/imported/regexp-stack.cc b/js/src/irregexp/imported/regexp-stack.cc
--- a/js/src/irregexp/imported/regexp-stack.cc
+++ b/js/src/irregexp/imported/regexp-stack.cc
@@ -30,7 +30,7 @@ RegExpStack::RegExpStack() : thread_loca
 
 RegExpStack::~RegExpStack() { thread_local_.FreeAndInvalidate(); }
 
-char* RegExpStack::ArchiveStack(char* to) {
+char* RegExpStack::ArchiveStack(char* to) {MOZ_RELEASE_ASSERT(0);
   if (!thread_local_.owns_memory_) {
     // Force dynamic stacks prior to archiving. Any growth will do. A dynamic
     // stack is needed because stack archival & restoration rely on `memory_`
diff --git a/js/src/jit/AliasAnalysis.cpp b/js/src/jit/AliasAnalysis.cpp
--- a/js/src/jit/AliasAnalysis.cpp
+++ b/js/src/jit/AliasAnalysis.cpp
@@ -159,10 +159,10 @@ bool AliasAnalysis::analyze() {
   MInstruction* firstIns = *graph_.entryBlock()->begin();
   for (unsigned i = 0; i < AliasSet::NumCategories; i++) {
     MInstructionVector defs(alloc());
-    if (!defs.append(firstIns)) {
+    if (!defs.append(firstIns)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!stores.append(std::move(defs))) {
+    if (!stores.append(std::move(defs))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -180,7 +180,7 @@ bool AliasAnalysis::analyze() {
     if (block->isLoopHeader()) {
       JitSpew(JitSpew_Alias, "Processing loop header %u", block->id());
       loop_ = new (alloc().fallible()) LoopAliasInfo(alloc(), loop_, *block);
-      if (!loop_) {
+      if (!loop_) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -209,7 +209,7 @@ bool AliasAnalysis::analyze() {
 
       if (set.isStore()) {
         for (AliasSetIterator iter(set); iter; iter++) {
-          if (!stores[*iter].append(*def)) {
+          if (!stores[*iter].append(*def)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -248,7 +248,7 @@ bool AliasAnalysis::analyze() {
         // is loop invariant. If a later instruction writes to the same
         // location, we will fix this at the end of the loop.
         if (loop_ && lastStore->id() < loop_->firstInstruction()->id()) {
-          if (!loop_->addInvariantLoad(*def)) {
+          if (!loop_->addInvariantLoad(*def)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
diff --git a/js/src/jit/AlignmentMaskAnalysis.cpp b/js/src/jit/AlignmentMaskAnalysis.cpp
--- a/js/src/jit/AlignmentMaskAnalysis.cpp
+++ b/js/src/jit/AlignmentMaskAnalysis.cpp
@@ -79,7 +79,7 @@ bool AlignmentMaskAnalysis::analyze() {
   for (ReversePostorderIterator block(graph_.rpoBegin());
        block != graph_.rpoEnd(); block++) {
     for (MInstructionIterator i = block->begin(); i != block->end(); i++) {
-      if (!graph_.alloc().ensureBallast()) {
+      if (!graph_.alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
diff --git a/js/src/jit/BacktrackingAllocator.cpp b/js/src/jit/BacktrackingAllocator.cpp
--- a/js/src/jit/BacktrackingAllocator.cpp
+++ b/js/src/jit/BacktrackingAllocator.cpp
@@ -323,7 +323,7 @@ bool VirtualRegister::addInitialRange(Te
   if (!merged) {
     // The new range does not overlap any existing range for the vreg.
     LiveRange* range = LiveRange::FallibleNew(alloc, vreg(), from, to);
-    if (!range) {
+    if (!range) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -389,17 +389,17 @@ void VirtualRegister::removeRange(LiveRa
 // This function pre-allocates and initializes as much global state as possible
 // to avoid littering the algorithms with memory management cruft.
 bool BacktrackingAllocator::init() {
-  if (!RegisterAllocator::init()) {
+  if (!RegisterAllocator::init()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   liveIn = mir->allocate<BitSet>(graph.numBlockIds());
-  if (!liveIn) {
+  if (!liveIn) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   size_t numVregs = graph.numVirtualRegisters();
-  if (!vregs.init(mir->alloc(), numVregs)) {
+  if (!vregs.init(mir->alloc(), numVregs)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (uint32_t i = 0; i < numVregs; i++) {
@@ -543,7 +543,7 @@ bool BacktrackingAllocator::buildLivenes
 
   Vector<MBasicBlock*, 1, SystemAllocPolicy> loopWorkList;
   BitSet loopDone(graph.numBlockIds());
-  if (!loopDone.init(alloc())) {
+  if (!loopDone.init(alloc())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -559,7 +559,7 @@ bool BacktrackingAllocator::buildLivenes
 
     BitSet& live = liveIn[mblock->id()];
     new (&live) BitSet(graph.numVirtualRegisters());
-    if (!live.init(alloc())) {
+    if (!live.init(alloc())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -586,7 +586,7 @@ bool BacktrackingAllocator::buildLivenes
 
     // Registers are assumed alive for the entire block, a define shortens
     // the range to the point of definition.
-    for (BitSet::Iterator liveRegId(live); liveRegId; ++liveRegId) {
+    for (BitSet::Iterator liveRegId(live); liveRegId; ++liveRegId) {MOZ_RELEASE_ASSERT(0);
       if (!vregs[*liveRegId].addInitialRange(alloc(), entryOf(block),
                                              exitOf(block).next(), &numRanges))
         return false;
@@ -614,7 +614,7 @@ bool BacktrackingAllocator::buildLivenes
           // call-preserved.
           if (!found && !ins->isCallPreserved(*iter)) {
             if (!addInitialFixedRange(*iter, outputOf(*ins),
-                                      outputOf(*ins).next())) {
+                                      outputOf(*ins).next())) {MOZ_RELEASE_ASSERT(0);
               return false;
             }
           }
@@ -622,12 +622,12 @@ bool BacktrackingAllocator::buildLivenes
 
         CallRange* callRange = new (alloc().fallible())
             CallRange(outputOf(*ins), outputOf(*ins).next());
-        if (!callRange) {
+        if (!callRange) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         callRangesList.pushFront(callRange);
-        if (!callRanges.insert(callRange)) {
+        if (!callRanges.insert(callRange)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -654,7 +654,7 @@ bool BacktrackingAllocator::buildLivenes
         }
 
         if (!vreg(def).addInitialRange(alloc(), from, from.next(),
-                                       &numRanges)) {
+                                       &numRanges)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         vreg(def).setInitialDefinition(from);
@@ -699,7 +699,7 @@ bool BacktrackingAllocator::buildLivenes
         CodePosition to =
             ins->isCall() ? outputOf(*ins) : outputOf(*ins).next();
 
-        if (!vreg(temp).addInitialRange(alloc(), from, to, &numRanges)) {
+        if (!vreg(temp).addInitialRange(alloc(), from, to, &numRanges)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         vreg(temp).setInitialDefinition(from);
@@ -752,12 +752,12 @@ bool BacktrackingAllocator::buildLivenes
           }
 
           if (!vreg(use).addInitialRange(alloc(), entryOf(block), to.next(),
-                                         &numRanges)) {
+                                         &numRanges)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
           UsePosition* usePosition =
               new (alloc().fallible()) UsePosition(use, to);
-          if (!usePosition) {
+          if (!usePosition) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
           vreg(use).addInitialUse(usePosition);
@@ -778,7 +778,7 @@ bool BacktrackingAllocator::buildLivenes
         // can go away if we have an earlier dead code elimination pass.
         CodePosition entryPos = entryOf(block);
         if (!vreg(def).addInitialRange(alloc(), entryPos, entryPos.next(),
-                                       &numRanges)) {
+                                       &numRanges)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -801,7 +801,7 @@ bool BacktrackingAllocator::buildLivenes
 
         for (BitSet::Iterator liveRegId(live); liveRegId; ++liveRegId) {
           if (!vregs[*liveRegId].addInitialRange(alloc(), from, to,
-                                                 &numRanges)) {
+                                                 &numRanges)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -821,7 +821,7 @@ bool BacktrackingAllocator::buildLivenes
             if (loopDone.contains(pred->id())) {
               continue;
             }
-            if (!loopWorkList.append(pred)) {
+            if (!loopWorkList.append(pred)) {MOZ_RELEASE_ASSERT(0);
               return false;
             }
           }
@@ -877,16 +877,16 @@ bool BacktrackingAllocator::go() {
     return false;
   }
 
-  if (!allocationQueue.reserve(graph.numVirtualRegisters() * 3 / 2)) {
+  if (!allocationQueue.reserve(graph.numVirtualRegisters() * 3 / 2)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JitSpew(JitSpew_RegAlloc, "Beginning grouping and queueing registers");
-  if (!mergeAndQueueRegisters()) {
+  if (!mergeAndQueueRegisters()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (JitSpewEnabled(JitSpew_RegAlloc)) {
+  if (JitSpewEnabled(JitSpew_RegAlloc)) {MOZ_RELEASE_ASSERT(0);
     dumpVregs("after grouping/queueing regs");
   }
 
@@ -915,7 +915,7 @@ bool BacktrackingAllocator::go() {
     return false;
   }
 
-  if (JitSpewEnabled(JitSpew_RegAlloc)) {
+  if (JitSpewEnabled(JitSpew_RegAlloc)) {MOZ_RELEASE_ASSERT(0);
     JitSpewCont(JitSpew_RegAlloc, "\n");
     dumpAllocations();
   }
@@ -928,7 +928,7 @@ bool BacktrackingAllocator::go() {
     return false;
   }
 
-  if (!populateSafepoints()) {
+  if (!populateSafepoints()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1038,7 +1038,7 @@ bool BacktrackingAllocator::tryMergeBund
 
 static inline LDefinition* FindReusingDefOrTemp(LNode* node,
                                                 LAllocation* alloc) {
-  if (node->isPhi()) {
+  if (node->isPhi()) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(node->toPhi()->numDefs() == 1);
     MOZ_ASSERT(node->toPhi()->getDef(0)->policy() !=
                LDefinition::MUST_REUSE_INPUT);
@@ -1121,7 +1121,7 @@ bool BacktrackingAllocator::tryMergeReus
 
   // If we already split the input for some other register, don't make a
   // third bundle.
-  if (inputRange->bundle() != input.firstRange()->bundle()) {
+  if (inputRange->bundle() != input.firstRange()->bundle()) {MOZ_RELEASE_ASSERT(0);
     def.setMustCopyInput();
     return true;
   }
@@ -1153,7 +1153,7 @@ bool BacktrackingAllocator::tryMergeReus
 
   LiveRange* preRange = LiveRange::FallibleNew(
       alloc(), input.vreg(), inputRange->from(), outputOf(def.ins()));
-  if (!preRange) {
+  if (!preRange) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1162,7 +1162,7 @@ bool BacktrackingAllocator::tryMergeReus
   // need to copy the input before the instruction.
   LiveRange* postRange = LiveRange::FallibleNew(
       alloc(), input.vreg(), inputOf(def.ins()), inputRange->to());
-  if (!postRange) {
+  if (!postRange) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1215,12 +1215,12 @@ bool BacktrackingAllocator::mergeAndQueu
   // Create a bundle for each register containing all its ranges.
   for (size_t i = 1; i < graph.numVirtualRegisters(); i++) {
     VirtualRegister& reg = vregs[i];
-    if (!reg.hasRanges()) {
+    if (!reg.hasRanges()) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
     LiveBundle* bundle = LiveBundle::FallibleNew(alloc(), nullptr, nullptr);
-    if (!bundle) {
+    if (!bundle) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     for (LiveRange::RegisterLinkIterator iter = reg.rangesBegin(); iter;
@@ -1245,7 +1245,7 @@ bool BacktrackingAllocator::mergeAndQueu
             if (*originalVreg.def()->output() == *iter->getDef(i)->output()) {
               MOZ_ASSERT(originalVreg.ins()->isParameter());
               if (!tryMergeBundles(originalVreg.firstBundle(),
-                                   paramVreg.firstBundle())) {
+                                   paramVreg.firstBundle())) {MOZ_RELEASE_ASSERT(0);
                 return false;
               }
               found = true;
@@ -1261,7 +1261,7 @@ bool BacktrackingAllocator::mergeAndQueu
   // Try to merge registers with their reused inputs.
   for (size_t i = 1; i < graph.numVirtualRegisters(); i++) {
     VirtualRegister& reg = vregs[i];
-    if (!reg.hasRanges()) {
+    if (!reg.hasRanges()) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
@@ -1270,7 +1270,7 @@ bool BacktrackingAllocator::mergeAndQueu
                       ->toInstruction()
                       ->getOperand(reg.def()->getReusedInput())
                       ->toUse();
-      if (!tryMergeReusedRegister(reg, vreg(use))) {
+      if (!tryMergeReusedRegister(reg, vreg(use))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1285,7 +1285,7 @@ bool BacktrackingAllocator::mergeAndQueu
       for (size_t k = 0, kend = phi->numOperands(); k < kend; k++) {
         VirtualRegister& inputVreg = vreg(phi->getOperand(k)->toUse());
         if (!tryMergeBundles(inputVreg.firstBundle(),
-                             outputVreg.firstBundle())) {
+                             outputVreg.firstBundle())) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -1306,12 +1306,12 @@ bool BacktrackingAllocator::mergeAndQueu
       LiveRange* range = LiveRange::get(*iter);
       LiveBundle* bundle = range->bundle();
       if (range == bundle->firstRange()) {
-        if (!alloc().ensureBallast()) {
+        if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         SpillSet* spill = SpillSet::New(alloc());
-        if (!spill) {
+        if (!spill) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         bundle->setSpillSet(spill);
@@ -1356,15 +1356,15 @@ bool BacktrackingAllocator::tryAllocateN
   // not available. Picking a separate register may be even worse than
   // spilling, as it will still necessitate moves and will tie up more
   // registers than if we spilled.
-  if (hint.kind() == Requirement::FIXED) {
+  if (hint.kind() == Requirement::FIXED) {MOZ_RELEASE_ASSERT(0);
     AnyRegister reg = hint.allocation().toRegister();
     if (!tryAllocateRegister(registers[reg.code()], bundle, success, pfixed,
-                             conflicting)) {
+                             conflicting)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (*success) {
+    if (*success) {MOZ_RELEASE_ASSERT(0);
       return true;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   // Spill bundles which have no hint or register requirement.
@@ -1372,7 +1372,7 @@ bool BacktrackingAllocator::tryAllocateN
       hint.kind() != Requirement::REGISTER) {
     JitSpew(JitSpew_RegAlloc,
             "  postponed spill (no hint or register requirement)");
-    if (!spilledBundles.append(bundle)) {
+    if (!spilledBundles.append(bundle)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     *success = true;
@@ -1384,7 +1384,7 @@ bool BacktrackingAllocator::tryAllocateN
     // allocated to.
     for (size_t i = 0; i < AnyRegister::Total; i++) {
       if (!tryAllocateRegister(registers[i], bundle, success, pfixed,
-                               conflicting)) {
+                               conflicting)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (*success) {
@@ -1456,12 +1456,12 @@ bool BacktrackingAllocator::processBundl
       // Ok, let's try allocating for this bundle.
       if (requirement.kind() == Requirement::FIXED) {
         if (!tryAllocateFixed(bundle, requirement, &success, &fixed,
-                              conflicting)) {
+                              conflicting)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
         if (!tryAllocateNonFixed(bundle, requirement, hint, &success, &fixed,
-                                 conflicting)) {
+                                 conflicting)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -1607,7 +1607,7 @@ bool BacktrackingAllocator::tryAllocateR
             break;
           }
         }
-        if (!duplicate && !aliasedConflicting.append(existing->bundle())) {
+        if (!duplicate && !aliasedConflicting.append(existing->bundle())) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
@@ -1661,7 +1661,7 @@ bool BacktrackingAllocator::tryAllocateR
   for (LiveRange::BundleLinkIterator iter = bundle->rangesBegin(); iter;
        iter++) {
     LiveRange* range = LiveRange::get(*iter);
-    if (!alloc().ensureBallast()) {
+    if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!r.allocations.insert(range)) {
@@ -1727,12 +1727,12 @@ bool BacktrackingAllocator::splitAndRequ
   }
 #endif
 
-  if (JitSpewEnabled(JitSpew_RegAlloc)) {
+  if (JitSpewEnabled(JitSpew_RegAlloc)) {MOZ_RELEASE_ASSERT(0);
     JitSpew(JitSpew_RegAlloc,
             "    splitting bundle %s into:", bundle->toString().get());
-    for (size_t i = 0; i < newBundles.length(); i++) {
+    for (size_t i = 0; i < newBundles.length(); i++) {MOZ_RELEASE_ASSERT(0);
       JitSpew(JitSpew_RegAlloc, "      %s", newBundles[i]->toString().get());
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   // Remove all ranges in the old bundle from their register's list.
@@ -1768,7 +1768,7 @@ bool BacktrackingAllocator::spill(LiveBu
   JitSpew(JitSpew_RegAlloc, "  Spilling bundle");
   MOZ_ASSERT(bundle->allocation().isBogus());
 
-  if (LiveBundle* spillParent = bundle->spillParent()) {
+  if (LiveBundle* spillParent = bundle->spillParent()) {MOZ_RELEASE_ASSERT(0);
     JitSpew(JitSpew_RegAlloc, "    Using existing spill bundle");
     for (LiveRange::BundleLinkIterator iter = bundle->rangesBegin(); iter;
          iter++) {
@@ -1804,7 +1804,7 @@ bool BacktrackingAllocator::tryAllocatin
     // allocated to.
     for (size_t i = 0; i < AnyRegister::Total; i++) {
       if (!tryAllocateRegister(registers[i], bundle, &success, &fixed,
-                               conflicting)) {
+                               conflicting)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (success) {
@@ -1857,14 +1857,14 @@ bool BacktrackingAllocator::pickStackSlo
     for (LiveRange::BundleLinkIterator iter = bundle->rangesBegin(); iter;
          iter++) {
       LiveRange* range = LiveRange::get(*iter);
-      if (range->hasDefinition()) {
+      if (range->hasDefinition()) {MOZ_RELEASE_ASSERT(0);
         LDefinition* def = vregs[range->vreg()].def();
-        if (def->policy() == LDefinition::FIXED) {
+        if (def->policy() == LDefinition::FIXED) {MOZ_RELEASE_ASSERT(0);
           MOZ_ASSERT(!def->output()->isRegister());
           MOZ_ASSERT(!def->output()->isStackSlot());
           spillSet->setAllocation(*def->output());
           return true;
-        }
+        }MOZ_RELEASE_ASSERT(0);
       }
     }
   }
@@ -1923,7 +1923,7 @@ bool BacktrackingAllocator::pickStackSlo
       // Update the allocated ranges for the slot.
       for (size_t i = 0; i < spillSet->numSpilledBundles(); i++) {
         LiveBundle* bundle = spillSet->spilledBundle(i);
-        if (!insertAllRanges(spillSlot->allocated, bundle)) {
+        if (!insertAllRanges(spillSlot->allocated, bundle)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -1947,7 +1947,7 @@ bool BacktrackingAllocator::pickStackSlo
 
   SpillSlot* spillSlot =
       new (alloc().fallible()) SpillSlot(stackSlot, alloc().lifoAlloc());
-  if (!spillSlot) {
+  if (!spillSlot) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1969,7 +1969,7 @@ bool BacktrackingAllocator::insertAllRan
   for (LiveRange::BundleLinkIterator iter = bundle->rangesBegin(); iter;
        iter++) {
     LiveRange* range = LiveRange::get(*iter);
-    if (!alloc().ensureBallast()) {
+    if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!set.insert(range)) {
@@ -2081,17 +2081,17 @@ bool BacktrackingAllocator::resolveContr
            prevIter != iter; prevIter++) {
         LiveRange* prevRange = LiveRange::get(*prevIter);
         if (prevRange->covers(start) && prevRange->bundle()->allocation() ==
-                                            range->bundle()->allocation()) {
+                                            range->bundle()->allocation()) {MOZ_RELEASE_ASSERT(0);
           skip = true;
           break;
         }
       }
-      if (skip) {
+      if (skip) {MOZ_RELEASE_ASSERT(0);
         iter++;
         continue;
       }
 
-      if (!alloc().ensureBallast()) {
+      if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -2099,12 +2099,12 @@ bool BacktrackingAllocator::resolveContr
           reg.rangeFor(start.previous(), /* preferRegister = */ true);
       if (start.subpos() == CodePosition::INPUT) {
         if (!moveInput(ins->toInstruction(), predecessorRange, range,
-                       reg.type())) {
+                       reg.type())) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         if (!moveAfter(ins->toInstruction(), predecessorRange, range,
-                       reg.type())) {
+                       reg.type())) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -2144,13 +2144,13 @@ bool BacktrackingAllocator::resolveContr
                                                /* preferRegister = */ true);
         MOZ_ASSERT(from);
 
-        if (!alloc().ensureBallast()) {
+        if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         // Note: we have to use moveAtEdge both here and below (for edge
         // resolution) to avoid conflicting moves. See bug 1493900.
-        if (!moveAtEdge(predecessor, successor, from, to, def->type())) {
+        if (!moveAtEdge(predecessor, successor, from, to, def->type())) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -2186,7 +2186,7 @@ bool BacktrackingAllocator::resolveContr
             continue;
           }
 
-          if (!alloc().ensureBallast()) {
+          if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
           LiveRange* from = reg.rangeFor(exitOf(predecessor), true);
@@ -2231,7 +2231,7 @@ bool BacktrackingAllocator::isRegisterDe
   }
 
   VirtualRegister& reg = vregs[range->vreg()];
-  if (reg.ins()->isPhi()) {
+  if (reg.ins()->isPhi()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2285,15 +2285,15 @@ bool BacktrackingAllocator::reifyAllocat
           LAllocation sourceAlloc = range->bundle()->allocation();
 
           if (res != *alloc) {
-            if (!this->alloc().ensureBallast()) {
+            if (!this->alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
               return false;
             }
             if (NumReusingDefs(ins->toInstruction()) <= 1) {
               LMoveGroup* group = getInputMoveGroup(ins->toInstruction());
-              if (!group->addAfter(sourceAlloc, res, reg.type())) {
+              if (!group->addAfter(sourceAlloc, res, reg.type())) {MOZ_RELEASE_ASSERT(0);
                 return false;
               }
-            } else {
+            } else {MOZ_RELEASE_ASSERT(0);
               LMoveGroup* group = getFixReuseMoveGroup(ins->toInstruction());
               if (!group->add(sourceAlloc, res, reg.type())) {
                 return false;
@@ -2452,7 +2452,7 @@ bool BacktrackingAllocator::populateSafe
         // Include temps but not instruction outputs. Also make sure
         // MUST_REUSE_INPUT is not used with gcthings or nunboxes, or
         // we would have to add the input reg to this safepoint.
-        if (ins == reg.ins() && !reg.isTemp()) {
+        if (ins == reg.ins() && !reg.isTemp()) {MOZ_RELEASE_ASSERT(0);
           DebugOnly<LDefinition*> def = reg.def();
           MOZ_ASSERT_IF(def->policy() == LDefinition::MUST_REUSE_INPUT,
                         def->type() == LDefinition::GENERAL ||
@@ -2663,7 +2663,7 @@ UniqueChars LiveBundle::toString() const
 
 #endif  // JS_JITSPEW
 
-void BacktrackingAllocator::dumpVregs(const char* who) {
+void BacktrackingAllocator::dumpVregs(const char* who) {MOZ_RELEASE_ASSERT(0);
 #ifdef JS_JITSPEW
   MOZ_ASSERT(!vregs[0u].hasRanges());
 
@@ -2729,7 +2729,7 @@ struct BacktrackingAllocator::PrintLiveR
 };
 #endif
 
-void BacktrackingAllocator::dumpAllocations() {
+void BacktrackingAllocator::dumpAllocations() {MOZ_RELEASE_ASSERT(0);
 #ifdef JS_JITSPEW
   JitSpew(JitSpew_RegAlloc, "Allocations:");
 
@@ -2790,7 +2790,7 @@ bool BacktrackingAllocator::minimalBundl
   LiveRange::BundleLinkIterator iter = bundle->rangesBegin();
   LiveRange* range = LiveRange::get(*iter);
 
-  if (!range->hasVreg()) {
+  if (!range->hasVreg()) {MOZ_RELEASE_ASSERT(0);
     *pfixed = true;
     return true;
   }
@@ -2950,7 +2950,7 @@ bool BacktrackingAllocator::trySplitAcro
   if (compilingWasm()) {
     SplitPositionVector splitPositions;
     if (!splitPositions.append(hotRange->from()) ||
-        !splitPositions.append(hotRange->to())) {
+        !splitPositions.append(hotRange->to())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     *success = true;
@@ -2959,19 +2959,19 @@ bool BacktrackingAllocator::trySplitAcro
 
   LiveBundle* hotBundle = LiveBundle::FallibleNew(alloc(), bundle->spillSet(),
                                                   bundle->spillParent());
-  if (!hotBundle) {
+  if (!hotBundle) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   LiveBundle* preBundle = nullptr;
   LiveBundle* postBundle = nullptr;
   LiveBundle* coldBundle = nullptr;
 
-  if (testbed) {
+  if (testbed) {MOZ_RELEASE_ASSERT(0);
     coldBundle = LiveBundle::FallibleNew(alloc(), bundle->spillSet(),
                                          bundle->spillParent());
-    if (!coldBundle) {
+    if (!coldBundle) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   // Accumulate the ranges of hot and cold code in the bundle. Note that
@@ -2985,48 +2985,48 @@ bool BacktrackingAllocator::trySplitAcro
 
     if (!hot.empty()) {
       if (!hotBundle->addRangeAndDistributeUses(alloc(), range, hot.from,
-                                                hot.to)) {
+                                                hot.to)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
 
     if (!coldPre.empty()) {
-      if (testbed) {
+      if (testbed) {MOZ_RELEASE_ASSERT(0);
         if (!coldBundle->addRangeAndDistributeUses(alloc(), range, coldPre.from,
-                                                   coldPre.to)) {
+                                                   coldPre.to)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
         if (!preBundle) {
           preBundle = LiveBundle::FallibleNew(alloc(), bundle->spillSet(),
                                               bundle->spillParent());
-          if (!preBundle) {
+          if (!preBundle) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
         if (!preBundle->addRangeAndDistributeUses(alloc(), range, coldPre.from,
-                                                  coldPre.to)) {
+                                                  coldPre.to)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
     }
 
     if (!coldPost.empty()) {
-      if (testbed) {
+      if (testbed) {MOZ_RELEASE_ASSERT(0);
         if (!coldBundle->addRangeAndDistributeUses(
-                alloc(), range, coldPost.from, coldPost.to)) {
+                alloc(), range, coldPost.from, coldPost.to)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
         if (!postBundle) {
           postBundle = LiveBundle::FallibleNew(alloc(), bundle->spillSet(),
                                                bundle->spillParent());
-          if (!postBundle) {
+          if (!postBundle) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
         if (!postBundle->addRangeAndDistributeUses(
-                alloc(), range, coldPost.from, coldPost.to)) {
+                alloc(), range, coldPost.from, coldPost.to)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -3036,18 +3036,18 @@ bool BacktrackingAllocator::trySplitAcro
   MOZ_ASSERT(hotBundle->numRanges() != 0);
 
   LiveBundleVector newBundles;
-  if (!newBundles.append(hotBundle)) {
+  if (!newBundles.append(hotBundle)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (testbed) {
+  if (testbed) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(coldBundle->numRanges() != 0);
-    if (!newBundles.append(coldBundle)) {
+    if (!newBundles.append(coldBundle)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
     MOZ_ASSERT(preBundle || postBundle);
-    if (preBundle && !newBundles.append(preBundle)) {
+    if (preBundle && !newBundles.append(preBundle)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (postBundle && !newBundles.append(postBundle)) {
@@ -3138,14 +3138,14 @@ bool BacktrackingAllocator::trySplitBefo
   CodePosition firstRegisterFrom;
 
   CodePosition conflictEnd;
-  if (conflict) {
+  if (conflict) {MOZ_RELEASE_ASSERT(0);
     for (LiveRange::BundleLinkIterator iter = conflict->rangesBegin(); iter;
-         iter++) {
+         iter++) {MOZ_RELEASE_ASSERT(0);
       LiveRange* range = LiveRange::get(*iter);
-      if (range->to() > conflictEnd) {
+      if (range->to() > conflictEnd) {MOZ_RELEASE_ASSERT(0);
         conflictEnd = range->to();
-      }
-    }
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   for (LiveRange::BundleLinkIterator iter = bundle->rangesBegin(); iter;
@@ -3174,7 +3174,7 @@ bool BacktrackingAllocator::trySplitBefo
     }
   }
 
-  if (!firstRegisterFrom.bits()) {
+  if (!firstRegisterFrom.bits()) {MOZ_RELEASE_ASSERT(0);
     // Can't trim non-register uses off the beginning by splitting.
     JitSpew(JitSpew_RegAlloc, "  bundle has no register uses");
     return true;
@@ -3273,7 +3273,7 @@ bool BacktrackingAllocator::splitAt(Live
   LiveBundle* spillBundle = bundle->spillParent();
   if (!spillBundle) {
     spillBundle = LiveBundle::FallibleNew(alloc(), bundle->spillSet(), nullptr);
-    if (!spillBundle) {
+    if (!spillBundle) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     spillBundleIsNew = true;
@@ -3288,7 +3288,7 @@ bool BacktrackingAllocator::splitAt(Live
       }
 
       if (from < range->to()) {
-        if (!spillBundle->addRange(alloc(), range->vreg(), from, range->to())) {
+        if (!spillBundle->addRange(alloc(), range->vreg(), from, range->to())) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -3304,7 +3304,7 @@ bool BacktrackingAllocator::splitAt(Live
   // The bundle which ranges are currently being added to.
   LiveBundle* activeBundle =
       LiveBundle::FallibleNew(alloc(), bundle->spillSet(), spillBundle);
-  if (!activeBundle || !newBundles.append(activeBundle)) {
+  if (!activeBundle || !newBundles.append(activeBundle)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3320,14 +3320,14 @@ bool BacktrackingAllocator::splitAt(Live
     if (UseNewBundle(splitPositions, range->from(), &activeSplitPosition)) {
       activeBundle =
           LiveBundle::FallibleNew(alloc(), bundle->spillSet(), spillBundle);
-      if (!activeBundle || !newBundles.append(activeBundle)) {
+      if (!activeBundle || !newBundles.append(activeBundle)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
 
     LiveRange* activeRange = LiveRange::FallibleNew(alloc(), range->vreg(),
                                                     range->from(), range->to());
-    if (!activeRange) {
+    if (!activeRange) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     activeBundle->addRange(activeRange);
@@ -3360,12 +3360,12 @@ bool BacktrackingAllocator::splitAt(Live
              use->usePolicy() == LUse::FIXED)) {
           activeBundle =
               LiveBundle::FallibleNew(alloc(), bundle->spillSet(), spillBundle);
-          if (!activeBundle || !newBundles.append(activeBundle)) {
+          if (!activeBundle || !newBundles.append(activeBundle)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
           activeRange = LiveRange::FallibleNew(alloc(), range->vreg(),
                                                range->from(), range->to());
-          if (!activeRange) {
+          if (!activeRange) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
           activeBundle->addRange(activeRange);
@@ -3416,7 +3416,7 @@ bool BacktrackingAllocator::splitAt(Live
       iter++;
     }
 
-    if (bundle->hasRanges() && !filteredBundles.append(bundle)) {
+    if (bundle->hasRanges() && !filteredBundles.append(bundle)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -3470,7 +3470,7 @@ bool BacktrackingAllocator::splitAcrossC
       // to do.
       if (range->covers(pos.previous())) {
         MOZ_ASSERT_IF(callPositions.length(), pos > callPositions.back());
-        if (!callPositions.append(pos)) {
+        if (!callPositions.append(pos)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -3494,7 +3494,7 @@ bool BacktrackingAllocator::chooseBundle
                                               LiveBundle* conflict) {
   bool success = false;
 
-  if (!trySplitAcrossHotcode(bundle, &success)) {
+  if (!trySplitAcrossHotcode(bundle, &success)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (success) {
@@ -3505,14 +3505,14 @@ bool BacktrackingAllocator::chooseBundle
     return splitAcrossCalls(bundle);
   }
 
-  if (!trySplitBeforeFirstRegisterUse(bundle, conflict, &success)) {
+  if (!trySplitBeforeFirstRegisterUse(bundle, conflict, &success)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (success) {
     return true;
   }
 
-  if (!trySplitAfterLastRegisterUse(bundle, conflict, &success)) {
+  if (!trySplitAfterLastRegisterUse(bundle, conflict, &success)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (success) {
diff --git a/js/src/jit/Bailouts.cpp b/js/src/jit/Bailouts.cpp
--- a/js/src/jit/Bailouts.cpp
+++ b/js/src/jit/Bailouts.cpp
@@ -87,7 +87,7 @@ bool jit::Bailout(BailoutStack* sp, Base
   // invalidated (see InvalidateActivation), we remove references to it and
   // increment the reference counter for each activation that appear on the
   // stack. As the bailed frame is one of them, we have to decrement it now.
-  if (frame.ionScript()->invalidated()) {
+  if (frame.ionScript()->invalidated()) {MOZ_RELEASE_ASSERT(0);
     frame.ionScript()->decrementInvalidationCount(
         cx->runtime()->defaultFreeOp());
   }
diff --git a/js/src/jit/BaselineBailouts.cpp b/js/src/jit/BaselineBailouts.cpp
--- a/js/src/jit/BaselineBailouts.cpp
+++ b/js/src/jit/BaselineBailouts.cpp
@@ -229,7 +229,7 @@ class MOZ_STACK_CLASS BaselineStackBuild
 
   [[nodiscard]] bool enlarge() {
     MOZ_ASSERT(header_ != nullptr);
-    if (bufferTotal_ & mozilla::tl::MulOverflowMask<2>::value) {
+    if (bufferTotal_ & mozilla::tl::MulOverflowMask<2>::value) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx_);
       return false;
     }
@@ -275,7 +275,7 @@ class MOZ_STACK_CLASS BaselineStackBuild
   [[nodiscard]] bool subtract(size_t size, const char* info = nullptr) {
     // enlarge the buffer if need be.
     while (size > bufferAvail_) {
-      if (!enlarge()) {
+      if (!enlarge()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -307,7 +307,7 @@ class MOZ_STACK_CLASS BaselineStackBuild
 
   template <typename T>
   [[nodiscard]] bool writePtr(T* t, const char* info) {
-    if (!write<T*>(t)) {
+    if (!write<T*>(t)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (info) {
@@ -319,7 +319,7 @@ class MOZ_STACK_CLASS BaselineStackBuild
   }
 
   [[nodiscard]] bool writeWord(size_t w, const char* info) {
-    if (!write<size_t>(w)) {
+    if (!write<size_t>(w)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (info) {
@@ -337,7 +337,7 @@ class MOZ_STACK_CLASS BaselineStackBuild
   }
 
   [[nodiscard]] bool writeValue(const Value& val, const char* info) {
-    if (!write<Value>(val)) {
+    if (!write<Value>(val)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (info) {
@@ -587,7 +587,7 @@ void BaselineStackBuilder::nextFrame() {
 
 // Build the BaselineFrame struct
 bool BaselineStackBuilder::buildBaselineFrame() {
-  if (!subtract(BaselineFrame::Size(), "BaselineFrame")) {
+  if (!subtract(BaselineFrame::Size(), "BaselineFrame")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   blFrame_.reset();
@@ -715,7 +715,7 @@ bool BaselineStackBuilder::buildArgument
     // original Value. To avoid this problem, store the formals in a
     // Vector until we are done.
     MOZ_ASSERT(outermostFrameFormals().empty());
-    if (!outermostFrameFormals().resize(fun_->nargs())) {
+    if (!outermostFrameFormals().resize(fun_->nargs())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -770,7 +770,7 @@ bool BaselineStackBuilder::fixUpCallerAr
     // The first argument to an inlined FunCall becomes |this|,
     // if it exists. The rest are passed normally.
     inlinedArgs += GET_ARGC(pc_) > 0 ? GET_ARGC(pc_) - 1 : 0;
-  } else if (op_ == JSOp::FunApply) {
+  } else if (op_ == JSOp::FunApply) {MOZ_RELEASE_ASSERT(0);
     // We currently only support FunApplyArgs. The number of arguments
     // passed to the inlined function is the number of arguments to the
     // current frame.
@@ -793,7 +793,7 @@ bool BaselineStackBuilder::fixUpCallerAr
           liveStackSlots);
   for (uint32_t i = 0; i < liveStackSlots; i++) {
     Value v = iter_.read();
-    if (!writeValue(v, "StackValue")) {
+    if (!writeValue(v, "StackValue")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -809,7 +809,7 @@ bool BaselineStackBuilder::fixUpCallerAr
     // by the remaining arguments.
     JitSpew(JitSpew_BaselineBailouts,
             "      pushing undefined to fixup funcall");
-    if (!writeValue(UndefinedValue(), "StackValue")) {
+    if (!writeValue(UndefinedValue(), "StackValue")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (GET_ARGC(pc_) > 0) {
@@ -817,23 +817,23 @@ bool BaselineStackBuilder::fixUpCallerAr
               "      pushing %u expression stack slots", inlinedArgs);
       for (uint32_t i = 0; i < inlinedArgs; i++) {
         Value arg = iter_.read();
-        if (!writeValue(arg, "StackValue")) {
+        if (!writeValue(arg, "StackValue")) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       // When we inline FunCall with no arguments, we push an extra
       // |undefined| value for |this|. That value should not appear
       // in the rebuilt baseline frame.
       JitSpew(JitSpew_BaselineBailouts, "      pushing target of funcall");
       Value target = iter_.read();
-      if (!writeValue(target, "StackValue")) {
+      if (!writeValue(target, "StackValue")) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       // Skip |this|.
       iter_.skip();
     }
-  } else if (op_ == JSOp::FunApply) {
+  } else if (op_ == JSOp::FunApply) {MOZ_RELEASE_ASSERT(0);
     // We currently only support FunApplyArgs. We must transform the
     // stack from |target, this, arg1, ...| to |js_fun_apply, target,
     // this, argObject|. These values will never be observed, so we
@@ -843,14 +843,14 @@ bool BaselineStackBuilder::fixUpCallerAr
     if (!writeValue(UndefinedValue(), "StackValue") ||
         !writeValue(UndefinedValue(), "StackValue") ||
         !writeValue(UndefinedValue(), "StackValue") ||
-        !writeValue(UndefinedValue(), "StackValue")) {
+        !writeValue(UndefinedValue(), "StackValue")) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   if (needToSaveCallerArgs()) {
     // Save the actual arguments. They are needed to rebuild the callee frame.
-    if (!savedCallerArgs.resize(inlinedArgs)) {
+    if (!savedCallerArgs.resize(inlinedArgs)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     for (uint32_t i = 0; i < inlinedArgs; i++) {
@@ -978,12 +978,12 @@ bool BaselineStackBuilder::buildStubFram
   uint32_t pcOff = script_->pcToOffset(pc_);
   ICEntry& icEntry = script_->jitScript()->icEntryFromPCOffset(pcOff);
   MOZ_ASSERT(IsInlinableFallback(icEntry.fallbackStub()));
-  if (!writePtr(icEntry.fallbackStub(), "StubPtr")) {
+  if (!writePtr(icEntry.fallbackStub(), "StubPtr")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Write previous frame pointer (saved earlier).
-  if (!writePtr(prevFramePtr(), "PrevFramePtr")) {
+  if (!writePtr(prevFramePtr(), "PrevFramePtr")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   prevFramePtr_ = virtualPointerAtStackOffset(0);
@@ -998,7 +998,7 @@ bool BaselineStackBuilder::buildStubFram
   if (needToSaveCallerArgs()) {
     // For FunApply or an accessor, the arguments are not on the stack anymore,
     // but they are copied in a vector and are written here.
-    if (op_ == JSOp::FunApply) {
+    if (op_ == JSOp::FunApply) {MOZ_RELEASE_ASSERT(0);
       actualArgc = blFrame()->numActualArgs();
     } else {
       actualArgc = IsSetPropOp(op_);
@@ -1008,7 +1008,7 @@ bool BaselineStackBuilder::buildStubFram
     // Align the stack based on the number of arguments.
     size_t afterFrameSize =
         (actualArgc + 1) * sizeof(Value) + JitFrameLayout::Size();
-    if (!maybeWritePadding(JitStackAlignment, afterFrameSize, "Padding")) {
+    if (!maybeWritePadding(JitStackAlignment, afterFrameSize, "Padding")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1017,24 +1017,24 @@ bool BaselineStackBuilder::buildStubFram
     MOZ_ASSERT(savedCallerArgs.length() == actualArgc + 2);
     for (unsigned i = 0; i < actualArgc + 1; i++) {
       size_t arg = savedCallerArgs.length() - (i + 1);
-      if (!writeValue(savedCallerArgs[arg], "ArgVal")) {
+      if (!writeValue(savedCallerArgs[arg], "ArgVal")) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
-  } else if (op_ == JSOp::FunCall && GET_ARGC(pc_) == 0) {
+  } else if (op_ == JSOp::FunCall && GET_ARGC(pc_) == 0) {MOZ_RELEASE_ASSERT(0);
     // When calling FunCall with 0 arguments, we push |undefined|
     // for this. See BaselineCacheIRCompiler::pushFunCallArguments.
     MOZ_ASSERT(!pushedNewTarget);
     actualArgc = 0;
     // Align the stack based on pushing |this| and 0 arguments.
     size_t afterFrameSize = sizeof(Value) + JitFrameLayout::Size();
-    if (!maybeWritePadding(JitStackAlignment, afterFrameSize, "Padding")) {
+    if (!maybeWritePadding(JitStackAlignment, afterFrameSize, "Padding")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     // Push an undefined value for |this|.
-    if (!writeValue(UndefinedValue(), "ThisValue")) {
+    if (!writeValue(UndefinedValue(), "ThisValue")) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     size_t calleeSlot = blFrame()->numValueSlots(frameSize) - 1;
     callee = *blFrame()->valueSlot(calleeSlot);
 
@@ -1053,7 +1053,7 @@ bool BaselineStackBuilder::buildStubFram
     // Align the stack based on the number of arguments.
     size_t afterFrameSize =
         numArguments * sizeof(Value) + JitFrameLayout::Size();
-    if (!maybeWritePadding(JitStackAlignment, afterFrameSize, "Padding")) {
+    if (!maybeWritePadding(JitStackAlignment, afterFrameSize, "Padding")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1063,7 +1063,7 @@ bool BaselineStackBuilder::buildStubFram
 
     for (size_t i = valueSlot; i > calleeSlot; i--) {
       Value v = *blFrame()->valueSlot(i);
-      if (!writeValue(v, "ArgVal")) {
+      if (!writeValue(v, "ArgVal")) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1083,7 +1083,7 @@ bool BaselineStackBuilder::buildStubFram
                           FrameType::BaselineStub, JitFrameLayout::Size());
 
   // Push actual argc
-  if (!writeWord(actualArgc, "ActualArgc")) {
+  if (!writeWord(actualArgc, "ActualArgc")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1092,20 +1092,20 @@ bool BaselineStackBuilder::buildStubFram
           callee.asRawBits());
 
   JSFunction* calleeFun = &callee.toObject().as<JSFunction>();
-  if (!writePtr(CalleeToToken(calleeFun, pushedNewTarget), "CalleeToken")) {
+  if (!writePtr(CalleeToToken(calleeFun, pushedNewTarget), "CalleeToken")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   setNextCallee(calleeFun);
 
   // Push BaselineStub frame descriptor
-  if (!writeWord(baselineStubFrameDescr, "Descriptor")) {
+  if (!writeWord(baselineStubFrameDescr, "Descriptor")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Push return address into ICCall_Scripted stub, immediately after the call.
   void* baselineCallReturnAddr = getStubReturnAddress();
   MOZ_ASSERT(baselineCallReturnAddr);
-  if (!writePtr(baselineCallReturnAddr, "ReturnAddr")) {
+  if (!writePtr(baselineCallReturnAddr, "ReturnAddr")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(framePushed() % JitStackAlignment == 0);
@@ -1169,7 +1169,7 @@ bool BaselineStackBuilder::buildRectifie
   size_t afterFrameSize =
       (nextCallee()->nargs() + 1 + pushedNewTarget) * sizeof(Value) +
       RectifierFrameLayout::Size();
-  if (!maybeWritePadding(JitStackAlignment, afterFrameSize, "Padding")) {
+  if (!maybeWritePadding(JitStackAlignment, afterFrameSize, "Padding")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1178,20 +1178,20 @@ bool BaselineStackBuilder::buildRectifie
     size_t newTargetOffset = (framePushed() - endOfBaselineStubArgs) +
                              (actualArgc + 1) * sizeof(Value);
     Value newTargetValue = *valuePointerAtStackOffset(newTargetOffset);
-    if (!writeValue(newTargetValue, "CopiedNewTarget")) {
+    if (!writeValue(newTargetValue, "CopiedNewTarget")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // Push undefined for missing arguments.
   for (unsigned i = 0; i < (nextCallee()->nargs() - actualArgc); i++) {
-    if (!writeValue(UndefinedValue(), "FillerVal")) {
+    if (!writeValue(UndefinedValue(), "FillerVal")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // Copy arguments + thisv from BaselineStub frame.
-  if (!subtract((actualArgc + 1) * sizeof(Value), "CopiedArgs")) {
+  if (!subtract((actualArgc + 1) * sizeof(Value), "CopiedArgs")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   BufferPointer<uint8_t> stubArgsEnd =
@@ -1207,17 +1207,17 @@ bool BaselineStackBuilder::buildRectifie
                           JitFrameLayout::Size());
 
   // Push actualArgc
-  if (!writeWord(actualArgc, "ActualArgc")) {
+  if (!writeWord(actualArgc, "ActualArgc")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Push calleeToken again.
-  if (!writePtr(CalleeToToken(nextCallee(), pushedNewTarget), "CalleeToken")) {
+  if (!writePtr(CalleeToToken(nextCallee(), pushedNewTarget), "CalleeToken")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Push rectifier frame descriptor
-  if (!writeWord(rectifierFrameDescr, "Descriptor")) {
+  if (!writeWord(rectifierFrameDescr, "Descriptor")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1268,7 +1268,7 @@ bool BaselineStackBuilder::finishLastFra
   if (cx_->runtime()->geckoProfiler().enabled()) {
     // Register bailout with profiler.
     const char* filename = script_->filename();
-    if (filename == nullptr) {
+    if (filename == nullptr) {MOZ_RELEASE_ASSERT(0);
       filename = "<unknown>";
     }
     unsigned len = strlen(filename) + 200;
@@ -1366,7 +1366,7 @@ void* BaselineStackBuilder::getStubRetur
   if (IsSetPropOp(op_)) {
     return code.bailoutReturnAddr(BailoutReturnKind::SetProp);
   }
-  if (IsGetElemOp(op_)) {
+  if (IsGetElemOp(op_)) {MOZ_RELEASE_ASSERT(0);
     return code.bailoutReturnAddr(BailoutReturnKind::GetElem);
   }
 
@@ -1487,29 +1487,29 @@ bool BaselineStackBuilder::buildOneFrame
   // |  ReturnAddr   |     this frame and the inlined frame.
   // +===============+     See: prepareForNextFrame()
 
-  if (!initFrame()) {
+  if (!initFrame()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!buildBaselineFrame()) {
+  if (!buildBaselineFrame()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (fun_ && !buildArguments()) {
+  if (fun_ && !buildArguments()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!buildFixedSlots()) {
+  if (!buildFixedSlots()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   bool fixedUp = false;
   RootedValueVector savedCallerArgs(cx_);
-  if (iter_.moreFrames() && !fixUpCallerArgs(&savedCallerArgs, &fixedUp)) {
+  if (iter_.moreFrames() && !fixUpCallerArgs(&savedCallerArgs, &fixedUp)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!fixedUp && !buildExpressionStack()) {
+  if (!fixedUp && !buildExpressionStack()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1647,7 +1647,7 @@ bool jit::BailoutIonToBaseline(JSContext
 #endif
 
   BaselineStackBuilder builder(cx, iter, snapIter, excInfo);
-  if (!builder.init()) {
+  if (!builder.init()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1783,7 +1783,7 @@ static bool CopyFromRematerializedFrame(
 
   // We might not have rematerialized a frame if the user never requested a
   // Debugger.Frame for it.
-  if (!rematFrame) {
+  if (!rematFrame) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -1852,7 +1852,7 @@ bool jit::FinishBailoutToBaseline(Baseli
       });
 
   // Ensure the frame has a call object if it needs one.
-  if (!EnsureHasEnvironmentObjects(cx, topFrame)) {
+  if (!EnsureHasEnvironmentObjects(cx, topFrame)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1893,7 +1893,7 @@ bool jit::FinishBailoutToBaseline(Baseli
           argsObj = &frame->argsObj();
         } else {
           argsObj = ArgumentsObject::createExpected(cx, frame);
-          if (!argsObj) {
+          if (!argsObj) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -1941,14 +1941,14 @@ bool jit::FinishBailoutToBaseline(Baseli
         // even if earlier ones failed, to invoke the proper frame
         // cleanup in the Debugger.
         if (!CopyFromRematerializedFrame(cx, act, outerFp, --inlineDepth,
-                                         iter.baselineFrame())) {
+                                         iter.baselineFrame())) {MOZ_RELEASE_ASSERT(0);
           ok = false;
         }
       }
       ++iter;
     }
 
-    if (!ok) {
+    if (!ok) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1968,7 +1968,7 @@ bool jit::FinishBailoutToBaseline(Baseli
   // Check for interrupts now because we might miss an interrupt check in JIT
   // code when resuming in the prologue, after the stack/interrupt check.
   if (!cx->isExceptionPending()) {
-    if (!CheckForInterrupt(cx)) {
+    if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
diff --git a/js/src/jit/BaselineCacheIRCompiler.cpp b/js/src/jit/BaselineCacheIRCompiler.cpp
--- a/js/src/jit/BaselineCacheIRCompiler.cpp
+++ b/js/src/jit/BaselineCacheIRCompiler.cpp
@@ -170,7 +170,7 @@ JitCode* BaselineCacheIRCompiler::compil
 
   // Done emitting the main IC code. Now emit the failure paths.
   for (size_t i = 0; i < failurePaths.length(); i++) {
-    if (!emitFailurePath(i)) {
+    if (!emitFailurePath(i)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     EmitStubGuardFailure(masm);
@@ -200,7 +200,7 @@ bool BaselineCacheIRCompiler::emitGuardS
   }
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -267,7 +267,7 @@ bool BaselineCacheIRCompiler::emitGuardA
   AutoScratchRegister scratch(allocator, masm);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -460,7 +460,7 @@ bool BaselineCacheIRCompiler::emitCallSc
   masm.loadPtr(getterAddr, callee);
   if (isInlined) {
     FailurePath* failure;
-    if (!addFailurePath(&failure)) {
+    if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     masm.loadBaselineJitCodeRaw(callee, code, failure->label());
@@ -624,7 +624,7 @@ bool BaselineCacheIRCompiler::emitProxyG
   return true;
 }
 
-bool BaselineCacheIRCompiler::emitGuardFrameHasNoArgumentsObject() {
+bool BaselineCacheIRCompiler::emitGuardFrameHasNoArgumentsObject() {MOZ_RELEASE_ASSERT(0);
   JitSpew(JitSpew_Codegen, "%s", __FUNCTION__);
   FailurePath* failure;
   if (!addFailurePath(&failure)) {
@@ -661,7 +661,7 @@ bool BaselineCacheIRCompiler::emitLoadFr
 }
 
 bool BaselineCacheIRCompiler::emitLoadFrameArgumentResult(
-    Int32OperandId indexId) {
+    Int32OperandId indexId) {MOZ_RELEASE_ASSERT(0);
   JitSpew(JitSpew_Codegen, "%s", __FUNCTION__);
   AutoOutputRegister output(*this);
   Register index = allocator.useRegister(masm, indexId);
@@ -880,7 +880,7 @@ bool BaselineCacheIRCompiler::emitAddAnd
     Address numNewSlotsAddr = stubAddress(*numNewSlotsOffset);
 
     FailurePath* failure;
-    if (!addFailurePath(&failure)) {
+    if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1172,7 +1172,7 @@ bool BaselineCacheIRCompiler::emitLoadSt
   AutoScratchRegister scratch2(allocator, masm);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1223,7 +1223,7 @@ bool BaselineCacheIRCompiler::emitString
 
   FailurePath* failure = nullptr;
   if (stringCode == StringCode::CodePoint) {
-    if (!addFailurePath(&failure)) {
+    if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1420,7 +1420,7 @@ bool BaselineCacheIRCompiler::emitCallSc
     // If we are calling a trial-inlined setter, guard that the
     // target has a BaselineScript.
     FailurePath* failure;
-    if (!addFailurePath(&failure)) {
+    if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     masm.loadBaselineJitCodeRaw(callee, code, failure->label());
@@ -1850,7 +1850,7 @@ bool BaselineCacheIRCompiler::emitLoadDO
 }
 
 bool BaselineCacheIRCompiler::init(CacheKind kind) {
-  if (!allocator.init()) {
+  if (!allocator.init()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1983,7 +1983,7 @@ ICCacheIRStub* js::jit::AttachBaselineCa
     // We have to generate stub code.
     JitContext jctx(cx, nullptr);
     BaselineCacheIRCompiler comp(cx, writer, stubDataOffset);
-    if (!comp.init(kind)) {
+    if (!comp.init(kind)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -2000,12 +2000,12 @@ ICCacheIRStub* js::jit::AttachBaselineCa
     stubInfo =
         CacheIRStubInfo::New(kind, ICStubEngine::Baseline, comp.makesGCCalls(),
                              stubDataOffset, writer);
-    if (!stubInfo) {
+    if (!stubInfo) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     CacheIRStubKey key(stubInfo);
-    if (!jitZone->putBaselineCacheIRStubCode(lookup, key, code)) {
+    if (!jitZone->putBaselineCacheIRStubCode(lookup, key, code)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -2044,7 +2044,7 @@ ICCacheIRStub* js::jit::AttachBaselineCa
   ICStubSpace* stubSpace =
       StubSpaceForStub(stubInfo->makesGCCalls(), outerScript, icScript);
   void* newStubMem = stubSpace->alloc(bytesNeeded);
-  if (!newStubMem) {
+  if (!newStubMem) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2121,7 +2121,7 @@ bool BaselineCacheIRCompiler::updateArgc
 
   // We need to guard the length of the arguments.
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2355,7 +2355,7 @@ void BaselineCacheIRCompiler::pushFunApp
                                                     Register calleeReg,
                                                     Register scratch,
                                                     Register scratch2,
-                                                    bool isJitCall) {
+                                                    bool isJitCall) {MOZ_RELEASE_ASSERT(0);
   // Push the caller's arguments onto the stack.
 
   // Find the start of the caller's arguments.
@@ -2363,9 +2363,9 @@ void BaselineCacheIRCompiler::pushFunApp
   masm.loadPtr(Address(BaselineFrameReg, 0), startReg);
   masm.addPtr(Imm32(BaselineFrame::offsetOfArg(0)), startReg);
 
-  if (isJitCall) {
+  if (isJitCall) {MOZ_RELEASE_ASSERT(0);
     masm.alignJitStackBasedOnNArgs(argcReg, /*countIncludesThis =*/false);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   Register endReg = scratch2;
   BaseValueIndex endAddr(startReg, argcReg);
@@ -2460,7 +2460,7 @@ bool BaselineCacheIRCompiler::emitCallNa
   bool isConstructing = flags.isConstructing();
   bool isSameRealm = flags.isSameRealm();
 
-  if (!updateArgc(flags, argcReg, scratch)) {
+  if (!updateArgc(flags, argcReg, scratch)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2760,7 +2760,7 @@ bool BaselineCacheIRCompiler::emitCallSc
   bool isConstructing = flags.isConstructing();
   bool isSameRealm = flags.isSameRealm();
 
-  if (!updateArgc(flags, argcReg, scratch)) {
+  if (!updateArgc(flags, argcReg, scratch)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2849,13 +2849,13 @@ bool BaselineCacheIRCompiler::emitCallIn
   bool isSameRealm = flags.isSameRealm();
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   masm.loadBaselineJitCodeRaw(calleeReg, codeReg, failure->label());
 
-  if (!updateArgc(flags, argcReg, scratch)) {
+  if (!updateArgc(flags, argcReg, scratch)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/jit/BaselineCodeGen.cpp b/js/src/jit/BaselineCodeGen.cpp
--- a/js/src/jit/BaselineCodeGen.cpp
+++ b/js/src/jit/BaselineCodeGen.cpp
@@ -108,13 +108,13 @@ BaselineInterpreterGenerator::BaselineIn
     : BaselineCodeGen(cx /* no handlerArgs */) {}
 
 bool BaselineCompilerHandler::init(JSContext* cx) {
-  if (!analysis_.init(alloc_)) {
+  if (!analysis_.init(alloc_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   uint32_t len = script_->length();
 
-  if (!labels_.init(alloc_, len)) {
+  if (!labels_.init(alloc_, len)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -210,14 +210,14 @@ MethodStatus BaselineCompiler::compile()
   AutoTraceLog logCompile(logger, TraceLogger_BaselineCompilation);
 
   AutoKeepJitScripts keepJitScript(cx);
-  if (!script->ensureHasJitScript(cx, keepJitScript)) {
+  if (!script->ensureHasJitScript(cx, keepJitScript)) {MOZ_RELEASE_ASSERT(0);
     return Method_Error;
   }
 
   // When code coverage is enabled, we have to create the ScriptCounts if they
   // do not exist.
   if (!script->hasScriptCounts() && cx->realm()->collectCoverageForDebug()) {
-    if (!script->initScriptCounts(cx)) {
+    if (!script->initScriptCounts(cx)) {MOZ_RELEASE_ASSERT(0);
       return Method_Error;
     }
   }
@@ -227,7 +227,7 @@ MethodStatus BaselineCompiler::compile()
 
   MOZ_ASSERT(!script->hasBaselineScript());
 
-  if (!emitPrologue()) {
+  if (!emitPrologue()) {MOZ_RELEASE_ASSERT(0);
     return Method_Error;
   }
 
@@ -236,16 +236,16 @@ MethodStatus BaselineCompiler::compile()
     return status;
   }
 
-  if (!emitEpilogue()) {
+  if (!emitEpilogue()) {MOZ_RELEASE_ASSERT(0);
     return Method_Error;
   }
 
-  if (!emitOutOfLinePostBarrierSlot()) {
+  if (!emitOutOfLinePostBarrierSlot()) {MOZ_RELEASE_ASSERT(0);
     return Method_Error;
   }
 
   Linker linker(masm);
-  if (masm.oom()) {
+  if (masm.oom()) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return Method_Error;
   }
@@ -264,7 +264,7 @@ MethodStatus BaselineCompiler::compile()
           debugTrapEntries_.length(), script->resumeOffsets().size(),
           traceLoggerToggleOffsets_.length()),
       JS::DeletePolicy<BaselineScript>(cx->runtime()));
-  if (!baselineScript) {
+  if (!baselineScript) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return Method_Error;
   }
@@ -288,7 +288,7 @@ MethodStatus BaselineCompiler::compile()
 
 #ifdef JS_TRACE_LOGGING
   // Initialize the tracelogger instrumentation.
-  if (JS::TraceLoggerSupported()) {
+  if (JS::TraceLoggerSupported()) {MOZ_RELEASE_ASSERT(0);
     baselineScript->initTraceLogger(script, traceLoggerToggleOffsets_);
   }
 #endif
@@ -311,7 +311,7 @@ MethodStatus BaselineCompiler::compile()
 
     // Generate profiling string.
     UniqueChars str = GeckoProfilerRuntime::allocProfileString(cx, script);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return Method_Error;
     }
 
@@ -1258,7 +1258,7 @@ bool BaselineCompilerCodeGen::emitWarmUp
   if (JSOp(*pc) == JSOp::LoopHead) {
     uint32_t pcOffset = script->pcToOffset(pc);
     uint32_t nativeOffset = masm.currentOffset();
-    if (!handler.osrEntries().emplaceBack(pcOffset, nativeOffset)) {
+    if (!handler.osrEntries().emplaceBack(pcOffset, nativeOffset)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
@@ -1296,7 +1296,7 @@ bool BaselineCompilerCodeGen::emitWarmUp
     masm.PushBaselineFramePtr(BaselineFrameReg, R0.scratchReg());
 
     using Fn = bool (*)(JSContext*, BaselineFrame*);
-    if (!callVMNonOp<Fn, DoTrialInlining>()) {
+    if (!callVMNonOp<Fn, DoTrialInlining>()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     // Reload registers potentially clobbered by the call.
@@ -1351,7 +1351,7 @@ bool BaselineCompilerCodeGen::emitWarmUp
 
     using Fn = bool (*)(JSContext*, BaselineFrame*, uint32_t, jsbytecode*,
                         IonOsrTempData**);
-    if (!callVM<Fn, IonCompileScriptForBaselineOSR>()) {
+    if (!callVM<Fn, IonCompileScriptForBaselineOSR>()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1492,7 +1492,7 @@ bool BaselineCompiler::emitDebugTrap() {
   // Emit patchable call to debug trap handler.
   JitCode* handlerCode = cx->runtime()->jitRuntime()->debugTrapHandler(
       cx, DebugTrapHandlerKind::Compiler);
-  if (!handlerCode) {
+  if (!handlerCode) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1511,7 +1511,7 @@ bool BaselineCompiler::emitDebugTrap() {
 
 #ifdef JS_TRACE_LOGGING
 template <>
-bool BaselineCompilerCodeGen::emitTraceLoggerEnter() {
+bool BaselineCompilerCodeGen::emitTraceLoggerEnter() {MOZ_RELEASE_ASSERT(0);
   AllocatableRegisterSet regs(RegisterSet::Volatile());
   Register loggerReg = regs.takeAnyGeneral();
   Register scriptReg = regs.takeAnyGeneral();
@@ -1547,7 +1547,7 @@ bool BaselineCompilerCodeGen::emitTraceL
 }
 
 template <>
-bool BaselineInterpreterCodeGen::emitTraceLoggerEnter() {
+bool BaselineInterpreterCodeGen::emitTraceLoggerEnter() {MOZ_RELEASE_ASSERT(0);
   if (JS::TraceLoggerSupported()) {
     MOZ_CRASH("NYI: interpreter emitTraceLoggerEnter");
   }
@@ -1555,7 +1555,7 @@ bool BaselineInterpreterCodeGen::emitTra
 }
 
 template <typename Handler>
-bool BaselineCodeGen<Handler>::emitTraceLoggerExit() {
+bool BaselineCodeGen<Handler>::emitTraceLoggerExit() {MOZ_RELEASE_ASSERT(0);
   AllocatableRegisterSet regs(RegisterSet::Volatile());
   Register loggerReg = regs.takeAnyGeneral();
 
@@ -1579,7 +1579,7 @@ bool BaselineCodeGen<Handler>::emitTrace
 
 template <typename Handler>
 bool BaselineCodeGen<Handler>::emitTraceLoggerResume(
-    Register baselineScript, AllocatableGeneralRegisterSet& regs) {
+    Register baselineScript, AllocatableGeneralRegisterSet& regs) {MOZ_RELEASE_ASSERT(0);
   Register scriptId = regs.takeAny();
   Register loggerReg = regs.takeAny();
 
@@ -1921,7 +1921,7 @@ template <typename F1, typename F2>
                     Address(scratch, JSScript::offsetOfImmutableFlags()),
                     Imm32(uint32_t(flag)), &flagNotSet);
   {
-    if (!ifSet()) {
+    if (!ifSet()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     masm.jump(&done);
@@ -2117,10 +2117,10 @@ bool BaselineCodeGen<Handler>::emit_ToNu
 
 template <typename Handler>
 bool BaselineCodeGen<Handler>::emit_LoopHead() {
-  if (!emit_JumpTarget()) {
+  if (!emit_JumpTarget()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!emitInterruptCheck()) {
+  if (!emitInterruptCheck()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!emitWarmUpCounterIncrement()) {
@@ -2205,7 +2205,7 @@ bool BaselineCodeGen<Handler>::emitCheck
 
   if (reinit) {
     using Fn = bool (*)(JSContext*);
-    if (!callVM<Fn, ThrowInitializedThis>()) {
+    if (!callVM<Fn, ThrowInitializedThis>()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -2236,7 +2236,7 @@ bool BaselineCodeGen<Handler>::emit_Chec
   pushArg(R1);
 
   using Fn = bool (*)(JSContext*, HandleValue);
-  if (!callVM<Fn, ThrowBadDerivedReturn>()) {
+  if (!callVM<Fn, ThrowBadDerivedReturn>()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   masm.assumeUnreachable("Should throw on bad derived constructor return");
@@ -3137,7 +3137,7 @@ bool BaselineCodeGen<Handler>::emitDelEl
 
   using Fn = bool (*)(JSContext*, HandleValue, HandleValue, bool*);
   if (strict) {
-    if (!callVM<Fn, DelElemOperation<true>>()) {
+    if (!callVM<Fn, DelElemOperation<true>>()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -3431,7 +3431,7 @@ bool BaselineCodeGen<Handler>::emitDelPr
 
   using Fn = bool (*)(JSContext*, HandleValue, HandlePropertyName, bool*);
   if (strict) {
-    if (!callVM<Fn, DelPropOperation<true>>()) {
+    if (!callVM<Fn, DelPropOperation<true>>()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -3698,13 +3698,13 @@ bool BaselineCodeGen<Handler>::emitBindN
   };
 
   if (op == JSOp::BindName) {
-    if (!loadFrameEnv()) {
+    if (!loadFrameEnv()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
     MOZ_ASSERT(op == JSOp::BindGName);
     if (!emitTestScriptFlag(JSScript::ImmutableFlags::HasNonSyntacticScope,
-                            loadFrameEnv, loadGlobalLexical, R2.scratchReg())) {
+                            loadFrameEnv, loadGlobalLexical, R2.scratchReg())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -3763,7 +3763,7 @@ bool BaselineCompilerCodeGen::emit_GetIm
   if (slot < targetEnv->numFixedSlots()) {
     masm.loadValue(Address(scratch, NativeObject::getFixedSlotOffset(slot)),
                    R0);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     masm.loadPtr(Address(scratch, NativeObject::offsetOfSlots()), scratch);
     masm.loadValue(
         Address(scratch, (slot - targetEnv->numFixedSlots()) * sizeof(Value)),
@@ -4040,15 +4040,15 @@ bool BaselineCompilerCodeGen::emitFormal
   // Else, we *may* have an arguments object (because we can't invalidate
   // when needsArgsObj becomes |true|), so we have to test HAS_ARGS_OBJ.
   Label done;
-  if (!handler.script()->needsArgsObj()) {
+  if (!handler.script()->needsArgsObj()) {MOZ_RELEASE_ASSERT(0);
     Label hasArgsObj;
     masm.branchTest32(Assembler::NonZero, frame.addressOfFlags(),
                       Imm32(BaselineFrame::HAS_ARGS_OBJ), &hasArgsObj);
-    if (op == JSOp::GetArg) {
+    if (op == JSOp::GetArg) {MOZ_RELEASE_ASSERT(0);
       masm.loadValue(frame.addressOfArg(arg), R0);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       frame.storeStackValue(-1, frame.addressOfArg(arg), R0);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     masm.jump(&done);
     masm.bind(&hasArgsObj);
   }
@@ -4697,14 +4697,14 @@ template <typename F1, typename F2>
   Label isNotDebuggee, done;
 
   CodeOffset toggleOffset = masm.toggledJump(&isNotDebuggee);
-  if (!handler.addDebugInstrumentationOffset(cx, toggleOffset)) {
+  if (!handler.addDebugInstrumentationOffset(cx, toggleOffset)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   masm.branchTest32(Assembler::Zero, frame.addressOfFlags(),
                     Imm32(BaselineFrame::DEBUGGEE), &isNotDebuggee);
 
-  if (!ifDebuggee()) {
+  if (!ifDebuggee()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4925,7 +4925,7 @@ bool BaselineCodeGen<Handler>::emitDebug
 template <typename Handler>
 bool BaselineCodeGen<Handler>::emitReturn() {
   if (handler.shouldEmitDebugEpilogueAtReturnOp()) {
-    if (!emitDebugEpilogue()) {
+    if (!emitDebugEpilogue()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -5637,7 +5637,7 @@ bool BaselineCodeGen<Handler>::emitSuspe
 
     using Fn = bool (*)(JSContext*, HandleObject, BaselineFrame*, uint32_t,
                         jsbytecode*);
-    if (!callVM<Fn, jit::NormalSuspend>()) {
+    if (!callVM<Fn, jit::NormalSuspend>()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -5688,7 +5688,7 @@ bool BaselineInterpreterCodeGen::emitAft
   // If the current Realm is not a debuggee we're done.
   Label done;
   CodeOffset toggleOffset = masm.toggledJump(&done);
-  if (!handler.addDebugInstrumentationOffset(cx, toggleOffset)) {
+  if (!handler.addDebugInstrumentationOffset(cx, toggleOffset)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   masm.loadPtr(AbsoluteAddress(cx->addressOfRealm()), scratch);
@@ -5706,7 +5706,7 @@ bool BaselineInterpreterCodeGen::emitAft
 
 template <typename Handler>
 bool BaselineCodeGen<Handler>::emit_AfterYield() {
-  if (!emit_JumpTarget()) {
+  if (!emit_JumpTarget()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5838,15 +5838,15 @@ bool BaselineCodeGen<Handler>::emit_Resu
   masm.branchIfScriptHasNoJitScript(scratch1, &interpret);
 
 #ifdef JS_TRACE_LOGGING
-  if (JS::TraceLoggerSupported()) {
+  if (JS::TraceLoggerSupported()) {MOZ_RELEASE_ASSERT(0);
     // TODO (bug 1565788): add Baseline Interpreter support.
     MOZ_CRASH("Unimplemented Baseline Interpreter TraceLogger support");
     masm.loadJitScript(scratch1, scratch1);
     Address baselineAddr(scratch1, JitScript::offsetOfBaselineScript());
     masm.loadPtr(baselineAddr, scratch1);
-    if (!emitTraceLoggerResume(scratch1, regs)) {
+    if (!emitTraceLoggerResume(scratch1, regs)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 #endif
 
@@ -5927,7 +5927,7 @@ bool BaselineCodeGen<Handler>::emit_Resu
 
   // Record the return address so the return offset -> pc mapping works.
   if (!handler.recordCallRetAddr(cx, RetAddrEntry::Kind::IC,
-                                 masm.currentOffset())) {
+                                 masm.currentOffset())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6025,7 +6025,7 @@ bool BaselineCodeGen<Handler>::emit_Resu
   masm.storeValue(Int32Value(AbstractGeneratorObject::RESUME_INDEX_RUNNING),
                   resumeIndexSlot);
 
-  if (!emitEnterGeneratorCode(scratch1, scratch2, regs.getAny())) {
+  if (!emitEnterGeneratorCode(scratch1, scratch2, regs.getAny())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6039,7 +6039,7 @@ bool BaselineCodeGen<Handler>::emit_Resu
   pushArg(genObj);
 
   using Fn = bool (*)(JSContext*, HandleObject, Value*, MutableHandleValue);
-  if (!callVM<Fn, jit::InterpretResume>()) {
+  if (!callVM<Fn, jit::InterpretResume>()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6474,25 +6474,25 @@ bool BaselineCodeGen<Handler>::emitProlo
 
   // When compiling with Debugger instrumentation, set the debuggeeness of
   // the frame before any operation that can call into the VM.
-  if (!emitIsDebuggeeCheck()) {
+  if (!emitIsDebuggeeCheck()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Initialize the env chain before any operation that may call into the VM and
   // trigger a GC.
-  if (!initEnvironmentChain()) {
+  if (!initEnvironmentChain()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Check for overrecursion before initializing locals.
-  if (!emitStackCheck()) {
+  if (!emitStackCheck()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   emitInitializeLocals();
 
 #ifdef JS_TRACE_LOGGING
-  if (JS::TraceLoggerSupported() && !emitTraceLoggerEnter()) {
+  if (JS::TraceLoggerSupported() && !emitTraceLoggerEnter()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 #endif
@@ -6506,11 +6506,11 @@ bool BaselineCodeGen<Handler>::emitProlo
     masm.debugAssertContextRealm(script->realm(), R1.scratchReg());
   }
 
-  if (!emitDebugPrologue()) {
+  if (!emitDebugPrologue()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!emitHandleCodeCoverageAtPrologue()) {
+  if (!emitHandleCodeCoverageAtPrologue()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6528,7 +6528,7 @@ bool BaselineCodeGen<Handler>::emitEpilo
   masm.bind(&return_);
 
   if (!handler.shouldEmitDebugEpilogueAtReturnOp()) {
-    if (!emitDebugEpilogue()) {
+    if (!emitDebugEpilogue()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -6597,14 +6597,14 @@ MethodStatus BaselineCompiler::emitBody(
       frame.assertSyncedStack();
       uint32_t pcOffset = script->pcToOffset(handler.pc());
       uint32_t nativeOffset = masm.currentOffset();
-      if (!resumeOffsetEntries_.emplaceBack(pcOffset, nativeOffset)) {
+      if (!resumeOffsetEntries_.emplaceBack(pcOffset, nativeOffset)) {MOZ_RELEASE_ASSERT(0);
         ReportOutOfMemory(cx);
         return Method_Error;
       }
     }
 
     // Emit traps for breakpoints and step mode.
-    if (MOZ_UNLIKELY(compileDebugInstrumentation()) && !emitDebugTrap()) {
+    if (MOZ_UNLIKELY(compileDebugInstrumentation()) && !emitDebugTrap()) {MOZ_RELEASE_ASSERT(0);
       return Method_Error;
     }
 
@@ -6662,7 +6662,7 @@ bool BaselineInterpreterGenerator::emitI
   masm.bind(handler.interpretOpWithPCRegLabel());
 
   // Emit a patchable call for debugger breakpoints/stepping.
-  if (!emitDebugTrap()) {
+  if (!emitDebugTrap()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   Label interpretOpAfterDebugTrap;
@@ -6675,7 +6675,7 @@ bool BaselineInterpreterGenerator::emitI
   // Jump to table[op].
   {
     CodeOffset label = masm.moveNearAddressWithPatch(scratch2);
-    if (!tableLabels_.append(label)) {
+    if (!tableLabels_.append(label)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     BaseIndex pointer(scratch2, scratch1, ScalePointer);
@@ -6766,7 +6766,7 @@ bool BaselineInterpreterGenerator::emitI
     JitRuntime* jrt = cx->runtime()->jitRuntime();
     JitCode* handlerCode =
         jrt->debugTrapHandler(cx, DebugTrapHandlerKind::Interpreter);
-    if (!handlerCode) {
+    if (!handlerCode) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -6833,19 +6833,19 @@ void BaselineInterpreterGenerator::emitO
 }
 
 bool BaselineInterpreterGenerator::generate(BaselineInterpreter& interpreter) {
-  if (!emitPrologue()) {
+  if (!emitPrologue()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!emitInterpreterLoop()) {
+  if (!emitInterpreterLoop()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!emitEpilogue()) {
+  if (!emitEpilogue()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!emitOutOfLinePostBarrierSlot()) {
+  if (!emitOutOfLinePostBarrierSlot()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6853,13 +6853,13 @@ bool BaselineInterpreterGenerator::gener
 
   {
     Linker linker(masm);
-    if (masm.oom()) {
+    if (masm.oom()) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
 
     JitCode* code = linker.newCode(cx, CodeKind::Other);
-    if (!code) {
+    if (!code) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -6870,7 +6870,7 @@ bool BaselineInterpreterGenerator::gener
 
       JitcodeGlobalTable* globalTable =
           cx->runtime()->jitRuntime()->getJitcodeGlobalTable();
-      if (!globalTable->addEntry(entry)) {
+      if (!globalTable->addEntry(entry)) {MOZ_RELEASE_ASSERT(0);
         ReportOutOfMemory(cx);
         return false;
       }
diff --git a/js/src/jit/BaselineDebugModeOSR.cpp b/js/src/jit/BaselineDebugModeOSR.cpp
--- a/js/src/jit/BaselineDebugModeOSR.cpp
+++ b/js/src/jit/BaselineDebugModeOSR.cpp
@@ -447,7 +447,7 @@ static bool InvalidateScriptsInZone(JSCo
     }
 
     if (script->hasIonScript()) {
-      if (!invalid.emplaceBack(script, script->ionScript()->compilationId())) {
+      if (!invalid.emplaceBack(script, script->ionScript()->compilationId())) {MOZ_RELEASE_ASSERT(0);
         ReportOutOfMemory(cx);
         return false;
       }
@@ -473,7 +473,7 @@ static void UndoRecompileBaselineScripts
     JSContext* cx, const DebugModeOSREntryVector& entries) {
   // In case of failure, roll back the entire set of active scripts so that
   // we don't have to patch return addresses on the stack.
-  for (UniqueScriptOSREntryIter iter(entries); !iter.done(); ++iter) {
+  for (UniqueScriptOSREntryIter iter(entries); !iter.done(); ++iter) {MOZ_RELEASE_ASSERT(0);
     const DebugModeOSREntry& entry = iter.entry();
     JSScript* script = entry.script;
     BaselineScript* baselineScript = script->baselineScript();
@@ -493,11 +493,11 @@ bool jit::RecompileOnStackBaselineScript
 
   for (ActivationIterator iter(cx); !iter.done(); ++iter) {
     if (iter->isJit()) {
-      if (!CollectJitStackScripts(cx, obs, iter, entries)) {
+      if (!CollectJitStackScripts(cx, obs, iter, entries)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (iter->isInterpreter()) {
-      if (!CollectInterpreterStackScripts(cx, obs, iter, entries)) {
+      if (!CollectInterpreterStackScripts(cx, obs, iter, entries)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -513,13 +513,13 @@ bool jit::RecompileOnStackBaselineScript
 
   // Invalidate all scripts we are recompiling.
   if (Zone* zone = obs.singleZone()) {
-    if (!InvalidateScriptsInZone(cx, zone, entries)) {
+    if (!InvalidateScriptsInZone(cx, zone, entries)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
     using ZoneRange = DebugAPI::ExecutionObservableSet::ZoneRange;
     for (ZoneRange r = obs.zones()->all(); !r.empty(); r.popFront()) {
-      if (!InvalidateScriptsInZone(cx, r.front(), entries)) {
+      if (!InvalidateScriptsInZone(cx, r.front(), entries)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -531,7 +531,7 @@ bool jit::RecompileOnStackBaselineScript
   for (size_t i = 0; i < entries.length(); i++) {
     JSScript* script = entries[i].script;
     AutoRealm ar(cx, script);
-    if (!RecompileBaselineScriptForDebugMode(cx, script, observing)) {
+    if (!RecompileBaselineScriptForDebugMode(cx, script, observing)) {MOZ_RELEASE_ASSERT(0);
       UndoRecompileBaselineScriptsForDebugMode(cx, entries);
       return false;
     }
diff --git a/js/src/jit/BaselineFrameInfo.cpp b/js/src/jit/BaselineFrameInfo.cpp
--- a/js/src/jit/BaselineFrameInfo.cpp
+++ b/js/src/jit/BaselineFrameInfo.cpp
@@ -76,10 +76,10 @@ void CompilerFrameInfo::syncStack(uint32
   }
 }
 
-uint32_t CompilerFrameInfo::numUnsyncedSlots() {
+uint32_t CompilerFrameInfo::numUnsyncedSlots() {MOZ_RELEASE_ASSERT(0);
   // Start at the bottom, find the first value that's not synced.
   uint32_t i = 0;
-  for (; i < stackDepth(); i++) {
+  for (; i < stackDepth(); i++) {MOZ_RELEASE_ASSERT(0);
     if (peek(-int32_t(i + 1))->kind() == StackValue::Stack) {
       break;
     }
diff --git a/js/src/jit/BaselineIC.cpp b/js/src/jit/BaselineIC.cpp
--- a/js/src/jit/BaselineIC.cpp
+++ b/js/src/jit/BaselineIC.cpp
@@ -869,7 +869,7 @@ bool DoGetElemFallback(JSContext* cx, Ba
   RootedValue lhsCopy(cx, lhs);
 
   bool isOptimizedArgs = false;
-  if (lhs.isMagic(JS_OPTIMIZED_ARGUMENTS)) {
+  if (lhs.isMagic(JS_OPTIMIZED_ARGUMENTS)) {MOZ_RELEASE_ASSERT(0);
     // Handle optimized arguments[i] access.
     isOptimizedArgs =
         MaybeGetElemOptimizedArguments(cx, frame, &lhsCopy, rhs, res);
@@ -936,7 +936,7 @@ bool FallbackICCodeCompiler::emitGetElem
     using Fn =
         bool (*)(JSContext*, BaselineFrame*, ICGetElem_Fallback*, HandleValue,
                  HandleValue, HandleValue, MutableHandleValue);
-    if (!tailCallVM<Fn, DoGetElemSuperFallback>(masm)) {
+    if (!tailCallVM<Fn, DoGetElemSuperFallback>(masm)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -952,7 +952,7 @@ bool FallbackICCodeCompiler::emitGetElem
 
     using Fn = bool (*)(JSContext*, BaselineFrame*, ICGetElem_Fallback*,
                         HandleValue, HandleValue, MutableHandleValue);
-    if (!tailCallVM<Fn, DoGetElemFallback>(masm)) {
+    if (!tailCallVM<Fn, DoGetElemFallback>(masm)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1051,7 +1051,7 @@ bool DoSetElemFallback(JSContext* cx, Ba
     }
   } else if (op == JSOp::InitElemInc) {
     if (!InitElemIncOperation(cx, obj.as<ArrayObject>(), index.toInt32(),
-                              rhs)) {
+                              rhs)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -1311,7 +1311,7 @@ bool DoGetNameFallback(JSContext* cx, Ba
   static_assert(JSOpLength_GetGName == JSOpLength_GetName,
                 "Otherwise our check for JSOp::Typeof isn't ok");
   if (JSOp(pc[JSOpLength_GetGName]) == JSOp::Typeof) {
-    if (!GetEnvironmentName<GetNameMode::TypeOf>(cx, envChain, name, res)) {
+    if (!GetEnvironmentName<GetNameMode::TypeOf>(cx, envChain, name, res)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -1429,9 +1429,9 @@ static bool ComputeGetPropResult(JSConte
   // Handle arguments.length and arguments.callee on optimized arguments, as
   // it is not an object.
   if (val.isMagic(JS_OPTIMIZED_ARGUMENTS) && IsOptimizedArguments(frame, val)) {
-    if (name == cx->names().length) {
+    if (name == cx->names().length) {MOZ_RELEASE_ASSERT(0);
       res.setInt32(frame->numActualArgs());
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(name == cx->names().callee);
       MOZ_ASSERT(frame->script()->hasMappedArgsObj());
       res.setObject(*frame->callee());
@@ -1440,7 +1440,7 @@ static bool ComputeGetPropResult(JSConte
     if (op == JSOp::GetBoundName) {
       RootedObject env(cx, &val.toObject());
       RootedId id(cx, NameToId(name));
-      if (!GetNameBoundInEnvironment(cx, env, id, res)) {
+      if (!GetNameBoundInEnvironment(cx, env, id, res)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -1518,7 +1518,7 @@ bool FallbackICCodeCompiler::emitGetProp
 
     using Fn = bool (*)(JSContext*, BaselineFrame*, ICGetProp_Fallback*,
                         HandleValue, MutableHandleValue, MutableHandleValue);
-    if (!tailCallVM<Fn, DoGetPropSuperFallback>(masm)) {
+    if (!tailCallVM<Fn, DoGetPropSuperFallback>(masm)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -1532,7 +1532,7 @@ bool FallbackICCodeCompiler::emitGetProp
 
     using Fn = bool (*)(JSContext*, BaselineFrame*, ICGetProp_Fallback*,
                         MutableHandleValue, MutableHandleValue);
-    if (!tailCallVM<Fn, DoGetPropFallback>(masm)) {
+    if (!tailCallVM<Fn, DoGetPropFallback>(masm)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1629,7 +1629,7 @@ bool DoSetPropFallback(JSContext* cx, Ba
 
   if (op == JSOp::InitProp || op == JSOp::InitLockedProp ||
       op == JSOp::InitHiddenProp) {
-    if (!InitPropertyOperation(cx, op, obj, name, rhs)) {
+    if (!InitPropertyOperation(cx, op, obj, name, rhs)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else if (op == JSOp::SetName || op == JSOp::StrictSetName ||
@@ -1777,7 +1777,7 @@ bool DoCallFallback(JSContext* cx, Basel
 
   // Handle funapply with JSOp::Arguments
   if (op == JSOp::FunApply && argc == 2 &&
-      callArgs[1].isMagic(JS_OPTIMIZED_ARGUMENTS)) {
+      callArgs[1].isMagic(JS_OPTIMIZED_ARGUMENTS)) {MOZ_RELEASE_ASSERT(0);
     GuardFunApplyArgumentsOptimization(cx, frame, callArgs);
   }
 
@@ -2000,7 +2000,7 @@ bool FallbackICCodeCompiler::emitCall(bo
 
     using Fn = bool (*)(JSContext*, BaselineFrame*, ICCall_Fallback*, Value*,
                         MutableHandleValue);
-    if (!callVM<Fn, DoSpreadCallFallback>(masm)) {
+    if (!callVM<Fn, DoSpreadCallFallback>(masm)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2027,7 +2027,7 @@ bool FallbackICCodeCompiler::emitCall(bo
 
   using Fn = bool (*)(JSContext*, BaselineFrame*, ICCall_Fallback*, uint32_t,
                       Value*, MutableHandleValue);
-  if (!callVM<Fn, DoCallFallback>(masm)) {
+  if (!callVM<Fn, DoCallFallback>(masm)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2623,7 +2623,7 @@ bool DoNewArrayFallback(JSContext* cx, B
 
   if (!stub->templateObject()) {
     ArrayObject* templateObject = NewArrayOperation(cx, length, TenuredObject);
-    if (!templateObject) {
+    if (!templateObject) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     stub->setTemplateObject(templateObject);
@@ -2671,7 +2671,7 @@ bool DoNewObjectFallback(JSContext* cx, 
 
     if (obj) {
       templateObject = NewObjectOperation(cx, script, pc, TenuredObject);
-      if (!templateObject) {
+      if (!templateObject) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
diff --git a/js/src/jit/BaselineJIT.cpp b/js/src/jit/BaselineJIT.cpp
--- a/js/src/jit/BaselineJIT.cpp
+++ b/js/src/jit/BaselineJIT.cpp
@@ -110,7 +110,7 @@ static JitExecStatus EnterBaseline(JSCon
   uint32_t extra =
       BaselineFrame::Size() + (data.osrNumStackValues * sizeof(Value));
   uint8_t* checkSp = (&spDummy) - extra;
-  if (!CheckRecursionLimitWithStackPointer(cx, checkSp)) {
+  if (!CheckRecursionLimitWithStackPointer(cx, checkSp)) {MOZ_RELEASE_ASSERT(0);
     return JitExec_Aborted;
   }
 
@@ -237,7 +237,7 @@ MethodStatus jit::BaselineCompile(JSCont
   JitContext jctx(cx, nullptr);
 
   BaselineCompiler compiler(cx, temp, script);
-  if (!compiler.init()) {
+  if (!compiler.init()) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return Method_Error;
   }
@@ -291,11 +291,11 @@ static MethodStatus CanEnterBaselineJIT(
   // code. This is incorrect as h's baseline script does not have debug
   // instrumentation.
   if (osrSourceFrame && osrSourceFrame.isDebuggee() &&
-      !DebugAPI::ensureExecutionObservabilityOfOsrFrame(cx, osrSourceFrame)) {
+      !DebugAPI::ensureExecutionObservabilityOfOsrFrame(cx, osrSourceFrame)) {MOZ_RELEASE_ASSERT(0);
     return Method_Error;
   }
 
-  if (script->length() > BaselineMaxScriptLength) {
+  if (script->length() > BaselineMaxScriptLength) {MOZ_RELEASE_ASSERT(0);
     script->disableBaselineCompile();
     return Method_CantCompile;
   }
@@ -316,11 +316,11 @@ static MethodStatus CanEnterBaselineJIT(
 
   // Check this before calling ensureJitRealmExists, so we're less
   // likely to report OOM in JSRuntime::createJitRuntime.
-  if (!CanLikelyAllocateMoreExecutableMemory()) {
+  if (!CanLikelyAllocateMoreExecutableMemory()) {MOZ_RELEASE_ASSERT(0);
     return Method_Skipped;
   }
 
-  if (!cx->realm()->ensureJitRealmExists(cx)) {
+  if (!cx->realm()->ensureJitRealmExists(cx)) {MOZ_RELEASE_ASSERT(0);
     return Method_Error;
   }
 
@@ -372,7 +372,7 @@ static MethodStatus CanEnterBaselineInte
     return Method_Skipped;
   }
 
-  if (!cx->realm()->ensureJitRealmExists(cx)) {
+  if (!cx->realm()->ensureJitRealmExists(cx)) {MOZ_RELEASE_ASSERT(0);
     return Method_Error;
   }
 
@@ -484,7 +484,7 @@ BaselineScript* BaselineScript::New(
   size += CheckedInt<Offset>(debugTrapEntries) * sizeof(DebugTrapEntry);
   size += CheckedInt<Offset>(traceLoggerToggleOffsetEntries) * sizeof(uint32_t);
 
-  if (!size.isValid()) {
+  if (!size.isValid()) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return nullptr;
   }
diff --git a/js/src/jit/BitSet.cpp b/js/src/jit/BitSet.cpp
--- a/js/src/jit/BitSet.cpp
+++ b/js/src/jit/BitSet.cpp
@@ -26,10 +26,10 @@ bool BitSet::init(TempAllocator& alloc) 
   return true;
 }
 
-bool BitSet::empty() const {
+bool BitSet::empty() const {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(bits_);
   const uint32_t* bits = bits_;
-  for (unsigned int i = 0, e = numWords(); i < e; i++) {
+  for (unsigned int i = 0, e = numWords(); i < e; i++) {MOZ_RELEASE_ASSERT(0);
     if (bits[i]) {
       return false;
     }
@@ -49,7 +49,7 @@ void BitSet::insertAll(const BitSet& oth
   }
 }
 
-void BitSet::removeAll(const BitSet& other) {
+void BitSet::removeAll(const BitSet& other) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(bits_);
   MOZ_ASSERT(other.numBits_ == numBits_);
   MOZ_ASSERT(other.bits_);
@@ -61,7 +61,7 @@ void BitSet::removeAll(const BitSet& oth
   }
 }
 
-void BitSet::intersect(const BitSet& other) {
+void BitSet::intersect(const BitSet& other) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(bits_);
   MOZ_ASSERT(other.numBits_ == numBits_);
   MOZ_ASSERT(other.bits_);
@@ -74,7 +74,7 @@ void BitSet::intersect(const BitSet& oth
 }
 
 // returns true if the intersection caused the contents of the set to change.
-bool BitSet::fixedPointIntersect(const BitSet& other) {
+bool BitSet::fixedPointIntersect(const BitSet& other) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(bits_);
   MOZ_ASSERT(other.numBits_ == numBits_);
   MOZ_ASSERT(other.bits_);
@@ -83,7 +83,7 @@ bool BitSet::fixedPointIntersect(const B
 
   uint32_t* bits = bits_;
   const uint32_t* otherBits = other.bits_;
-  for (unsigned int i = 0, e = numWords(); i < e; i++) {
+  for (unsigned int i = 0, e = numWords(); i < e; i++) {MOZ_RELEASE_ASSERT(0);
     uint32_t old = bits[i];
     bits[i] &= otherBits[i];
 
@@ -94,7 +94,7 @@ bool BitSet::fixedPointIntersect(const B
   return changed;
 }
 
-void BitSet::complement() {
+void BitSet::complement() {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(bits_);
   uint32_t* bits = bits_;
   for (unsigned int i = 0, e = numWords(); i < e; i++) {
diff --git a/js/src/jit/BytecodeAnalysis.cpp b/js/src/jit/BytecodeAnalysis.cpp
--- a/js/src/jit/BytecodeAnalysis.cpp
+++ b/js/src/jit/BytecodeAnalysis.cpp
@@ -24,7 +24,7 @@ BytecodeAnalysis::BytecodeAnalysis(TempA
     : script_(script), infos_(alloc) {}
 
 bool BytecodeAnalysis::init(TempAllocator& alloc) {
-  if (!infos_.growByUninitialized(script_->length())) {
+  if (!infos_.growByUninitialized(script_->length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/jit/CacheIR.cpp b/js/src/jit/CacheIR.cpp
--- a/js/src/jit/CacheIR.cpp
+++ b/js/src/jit/CacheIR.cpp
@@ -303,7 +303,7 @@ static ProxyStubType GetProxyStubType(JS
   }
 
   DOMProxyShadowsResult shadows = GetDOMProxyShadowsCheck()(cx, proxy, id);
-  if (shadows == DOMProxyShadowsResult::ShadowCheckFailed) {
+  if (shadows == DOMProxyShadowsResult::ShadowCheckFailed) {MOZ_RELEASE_ASSERT(0);
     cx->clearPendingException();
     return ProxyStubType::None;
   }
@@ -330,7 +330,7 @@ static bool ValueToNameOrSymbolId(JSCont
     return true;
   }
 
-  if (!PrimitiveValueToId<CanGC>(cx, idVal, id)) {
+  if (!PrimitiveValueToId<CanGC>(cx, idVal, id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -366,7 +366,7 @@ AttachDecision GetPropIRGenerator::tryAt
 
   RootedId id(cx_);
   bool nameOrSymbol;
-  if (!ValueToNameOrSymbolId(cx_, idVal_, &id, &nameOrSymbol)) {
+  if (!ValueToNameOrSymbolId(cx_, idVal_, &id, &nameOrSymbol)) {MOZ_RELEASE_ASSERT(0);
     cx_->clearPendingException();
     return AttachDecision::NoAction;
   }
@@ -1230,7 +1230,7 @@ AttachDecision GetPropIRGenerator::tryAt
   // this-compartment wrapper. This is what will be stored in the IC
   // keep the compartment alive.
   RootedObject wrappedTargetGlobal(cx_, &unwrapped->nonCCWGlobal());
-  if (!cx_->compartment()->wrap(cx_, &wrappedTargetGlobal)) {
+  if (!cx_->compartment()->wrap(cx_, &wrappedTargetGlobal)) {MOZ_RELEASE_ASSERT(0);
     cx_->clearPendingException();
     return AttachDecision::NoAction;
   }
@@ -1308,7 +1308,7 @@ AttachDecision GetPropIRGenerator::tryAt
   RootedObject target(cx_, UncheckedUnwrap(obj));
 
   RootedObject expandoShapeWrapper(cx_);
-  if (!GetXrayExpandoShapeWrapper(cx_, obj, &expandoShapeWrapper)) {
+  if (!GetXrayExpandoShapeWrapper(cx_, obj, &expandoShapeWrapper)) {MOZ_RELEASE_ASSERT(0);
     cx_->recoverFromOutOfMemory();
     return AttachDecision::NoAction;
   }
@@ -1319,14 +1319,14 @@ AttachDecision GetPropIRGenerator::tryAt
   RootedObjectVector prototypes(cx_);
   RootedObjectVector prototypeExpandoShapeWrappers(cx_);
   while (true) {
-    if (!GetOwnPropertyDescriptor(cx_, holder, id, &desc)) {
+    if (!GetOwnPropertyDescriptor(cx_, holder, id, &desc)) {MOZ_RELEASE_ASSERT(0);
       cx_->clearPendingException();
       return AttachDecision::NoAction;
     }
     if (desc.object()) {
       break;
     }
-    if (!GetPrototype(cx_, holder, &holder)) {
+    if (!GetPrototype(cx_, holder, &holder)) {MOZ_RELEASE_ASSERT(0);
       cx_->clearPendingException();
       return AttachDecision::NoAction;
     }
@@ -1338,7 +1338,7 @@ AttachDecision GetPropIRGenerator::tryAt
     if (!GetXrayExpandoShapeWrapper(cx_, holder,
                                     &prototypeExpandoShapeWrapper) ||
         !prototypes.append(holder) ||
-        !prototypeExpandoShapeWrappers.append(prototypeExpandoShapeWrapper)) {
+        !prototypeExpandoShapeWrappers.append(prototypeExpandoShapeWrapper)) {MOZ_RELEASE_ASSERT(0);
       cx_->recoverFromOutOfMemory();
       return AttachDecision::NoAction;
     }
@@ -1349,7 +1349,7 @@ AttachDecision GetPropIRGenerator::tryAt
 
   RootedObject getter(cx_, desc.getterObject());
   if (!getter || !getter->is<JSFunction>() ||
-      !getter->as<JSFunction>().isNativeWithoutJitEntry()) {
+      !getter->as<JSFunction>().isNativeWithoutJitEntry()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -1382,7 +1382,7 @@ AttachDecision GetPropIRGenerator::tryAt
   for (size_t i = 0; i < prototypes.length(); i++) {
     JSObject* proto = prototypes[i];
     ObjOperandId protoId = writer.loadObject(proto);
-    if (JSObject* protoShapeWrapper = prototypeExpandoShapeWrappers[i]) {
+    if (JSObject* protoShapeWrapper = prototypeExpandoShapeWrappers[i]) {MOZ_RELEASE_ASSERT(0);
       writer.guardXrayExpandoShapeAndDefaultProto(protoId, protoShapeWrapper);
     } else {
       writer.guardXrayNoExpando(protoId);
@@ -1505,10 +1505,10 @@ AttachDecision GetPropIRGenerator::tryAt
   Shape* propShape = nullptr;
   NativeGetPropCacheability canCache =
       CanAttachNativeGetProp(cx_, expandoObj, id, &holder, &propShape, pc_);
-  if (canCache == CanAttachNone) {
-    return AttachDecision::NoAction;
-  }
-  if (!holder) {
+  if (canCache == CanAttachNone) {MOZ_RELEASE_ASSERT(0);
+    return AttachDecision::NoAction;
+  }
+  if (!holder) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
   auto* nativeExpandoObj = &expandoObj->as<NativeObject>();
@@ -1594,7 +1594,7 @@ AttachDecision GetPropIRGenerator::tryAt
   MOZ_ASSERT(IsCacheableDOMProxy(obj));
 
   JSObject* checkObj = obj->staticPrototype();
-  if (!checkObj) {
+  if (!checkObj) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -1742,7 +1742,7 @@ AttachDecision GetPropIRGenerator::tryAt
   }
 
   // Receiver should be the object.
-  if (isSuper()) {
+  if (isSuper()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -1762,15 +1762,15 @@ AttachDecision GetPropIRGenerator::tryAt
 
   JSFunction& fun = holder->getGetter(shape)->as<JSFunction>();
   if (isLength) {
-    if (!TypedArrayObject::isOriginalLengthGetter(fun.native())) {
+    if (!TypedArrayObject::isOriginalLengthGetter(fun.native())) {MOZ_RELEASE_ASSERT(0);
       return AttachDecision::NoAction;
     }
   } else if (isByteOffset) {
-    if (!TypedArrayObject::isOriginalByteOffsetGetter(fun.native())) {
+    if (!TypedArrayObject::isOriginalByteOffsetGetter(fun.native())) {MOZ_RELEASE_ASSERT(0);
       return AttachDecision::NoAction;
     }
   } else {
-    if (!TypedArrayObject::isOriginalByteLengthGetter(fun.native())) {
+    if (!TypedArrayObject::isOriginalByteLengthGetter(fun.native())) {MOZ_RELEASE_ASSERT(0);
       return AttachDecision::NoAction;
     }
   }
@@ -1821,7 +1821,7 @@ AttachDecision GetPropIRGenerator::tryAt
   }
 
   // Receiver should be the object.
-  if (isSuper()) {
+  if (isSuper()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -1839,17 +1839,17 @@ AttachDecision GetPropIRGenerator::tryAt
   Shape* shape = nullptr;
   NativeGetPropCacheability type =
       CanAttachNativeGetProp(cx_, obj, id, &holder, &shape, pc_);
-  if (type != CanAttachNativeGetter) {
+  if (type != CanAttachNativeGetter) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
   auto& fun = holder->getGetter(shape)->as<JSFunction>();
   if (isByteOffset) {
-    if (!DataViewObject::isOriginalByteOffsetGetter(fun.native())) {
+    if (!DataViewObject::isOriginalByteOffsetGetter(fun.native())) {MOZ_RELEASE_ASSERT(0);
       return AttachDecision::NoAction;
     }
   } else {
-    if (!DataViewObject::isOriginalByteLengthGetter(fun.native())) {
+    if (!DataViewObject::isOriginalByteLengthGetter(fun.native())) {MOZ_RELEASE_ASSERT(0);
       return AttachDecision::NoAction;
     }
   }
@@ -1891,7 +1891,7 @@ AttachDecision GetPropIRGenerator::tryAt
   }
 
   // Receiver should be the object.
-  if (isSuper()) {
+  if (isSuper()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -1903,17 +1903,17 @@ AttachDecision GetPropIRGenerator::tryAt
   Shape* shape = nullptr;
   NativeGetPropCacheability type =
       CanAttachNativeGetProp(cx_, obj, id, &holder, &shape, pc_);
-  if (type != CanAttachNativeGetter) {
+  if (type != CanAttachNativeGetter) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
   auto& fun = holder->getGetter(shape)->as<JSFunction>();
   if (buf->is<ArrayBufferObject>()) {
-    if (!ArrayBufferObject::isOriginalByteLengthGetter(fun.native())) {
+    if (!ArrayBufferObject::isOriginalByteLengthGetter(fun.native())) {MOZ_RELEASE_ASSERT(0);
       return AttachDecision::NoAction;
     }
   } else {
-    if (!SharedArrayBufferObject::isOriginalByteLengthGetter(fun.native())) {
+    if (!SharedArrayBufferObject::isOriginalByteLengthGetter(fun.native())) {MOZ_RELEASE_ASSERT(0);
       return AttachDecision::NoAction;
     }
   }
@@ -1946,7 +1946,7 @@ AttachDecision GetPropIRGenerator::tryAt
   }
 
   // Receiver should be the object.
-  if (isSuper()) {
+  if (isSuper()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -2062,7 +2062,7 @@ AttachDecision GetPropIRGenerator::tryAt
   }
 
   RootedValue iterator(cx_);
-  if (!ArgumentsObject::getArgumentsIterator(cx_, &iterator)) {
+  if (!ArgumentsObject::getArgumentsIterator(cx_, &iterator)) {MOZ_RELEASE_ASSERT(0);
     cx_->recoverFromOutOfMemory();
     return AttachDecision::NoAction;
   }
@@ -2277,15 +2277,15 @@ AttachDecision GetPropIRGenerator::tryAt
     return AttachDecision::NoAction;
   }
 
-  if (!id.isAtom(cx_->names().length) && !id.isAtom(cx_->names().callee)) {
-    return AttachDecision::NoAction;
-  }
+  if (!id.isAtom(cx_->names().length) && !id.isAtom(cx_->names().callee)) {MOZ_RELEASE_ASSERT(0);
+    return AttachDecision::NoAction;
+  }MOZ_RELEASE_ASSERT(0);
 
   maybeEmitIdGuard(id);
   writer.guardMagicValue(valId, JS_OPTIMIZED_ARGUMENTS);
   writer.guardFrameHasNoArgumentsObject();
 
-  if (id.isAtom(cx_->names().length)) {
+  if (id.isAtom(cx_->names().length)) {MOZ_RELEASE_ASSERT(0);
     writer.loadFrameNumActualArgsResult();
   } else {
     MOZ_ASSERT(id.isAtom(cx_->names().callee));
@@ -2436,7 +2436,7 @@ static bool CanAttachDenseElementHole(Na
       break;
     }
 
-    if (!proto->is<NativeObject>()) {
+    if (!proto->is<NativeObject>()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2459,7 +2459,7 @@ AttachDecision GetPropIRGenerator::tryAt
   }
 
   NativeObject* nobj = &obj->as<NativeObject>();
-  if (nobj->containsDenseElement(index)) {
+  if (nobj->containsDenseElement(index)) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
   if (!CanAttachDenseElementHole(nobj, false)) {
@@ -2486,7 +2486,7 @@ AttachDecision GetPropIRGenerator::tryAt
   NativeObject* nobj = &obj->as<NativeObject>();
 
   // Stub doesn't handle negative indices.
-  if (index > INT_MAX) {
+  if (index > INT_MAX) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -2795,7 +2795,7 @@ AttachDecision GetNameIRGenerator::tryAt
     // prototype. Ignore the global lexical scope as it doesn't figure
     // into the prototype chain. We guard on the global lexical
     // scope's shape independently.
-    if (!IsCacheableGetPropReadSlot(&globalLexical->global(), holder, shape)) {
+    if (!IsCacheableGetPropReadSlot(&globalLexical->global(), holder, shape)) {MOZ_RELEASE_ASSERT(0);
       return AttachDecision::NoAction;
     }
 
@@ -3056,7 +3056,7 @@ AttachDecision BindNameIRGenerator::tryA
   JSObject* env = env_;
   Shape* shape = nullptr;
   while (true) {
-    if (!env->is<GlobalObject>() && !env->is<EnvironmentObject>()) {
+    if (!env->is<GlobalObject>() && !env->is<EnvironmentObject>()) {MOZ_RELEASE_ASSERT(0);
       return AttachDecision::NoAction;
     }
     if (env->is<WithEnvironmentObject>()) {
@@ -3128,7 +3128,7 @@ AttachDecision HasPropIRGenerator::tryAt
                                                   ObjOperandId objId,
                                                   uint32_t index,
                                                   Int32OperandId indexId) {
-  if (!obj->is<NativeObject>()) {
+  if (!obj->is<NativeObject>()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -3152,12 +3152,12 @@ AttachDecision HasPropIRGenerator::tryAt
                                                       Int32OperandId indexId) {
   bool hasOwn = (cacheKind_ == CacheKind::HasOwn);
 
-  if (!obj->is<NativeObject>()) {
+  if (!obj->is<NativeObject>()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
   NativeObject* nobj = &obj->as<NativeObject>();
-  if (nobj->containsDenseElement(index)) {
+  if (nobj->containsDenseElement(index)) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
   if (!CanAttachDenseElementHole(nobj, hasOwn)) {
@@ -3188,7 +3188,7 @@ AttachDecision HasPropIRGenerator::tryAt
                                                    Int32OperandId indexId) {
   bool hasOwn = (cacheKind_ == CacheKind::HasOwn);
 
-  if (!obj->is<NativeObject>()) {
+  if (!obj->is<NativeObject>()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
   auto* nobj = &obj->as<NativeObject>();
@@ -3390,7 +3390,7 @@ AttachDecision HasPropIRGenerator::tryAt
 
   RootedId id(cx_);
   bool nameOrSymbol;
-  if (!ValueToNameOrSymbolId(cx_, idVal_, &id, &nameOrSymbol)) {
+  if (!ValueToNameOrSymbolId(cx_, idVal_, &id, &nameOrSymbol)) {MOZ_RELEASE_ASSERT(0);
     cx_->clearPendingException();
     return AttachDecision::NoAction;
   }
@@ -3562,7 +3562,7 @@ AttachDecision SetPropIRGenerator::tryAt
 
   RootedId id(cx_);
   bool nameOrSymbol;
-  if (!ValueToNameOrSymbolId(cx_, idVal_, &id, &nameOrSymbol)) {
+  if (!ValueToNameOrSymbolId(cx_, idVal_, &id, &nameOrSymbol)) {MOZ_RELEASE_ASSERT(0);
     cx_->clearPendingException();
     return AttachDecision::NoAction;
   }
@@ -3769,7 +3769,7 @@ static bool IsCacheableSetPropCallNative
     return false;
   }
 
-  if (setter.isClassConstructor()) {
+  if (setter.isClassConstructor()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3991,7 +3991,7 @@ static bool CanAttachAddElement(NativeOb
       break;
     }
 
-    if (!proto->is<NativeObject>()) {
+    if (!proto->is<NativeObject>()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -4091,7 +4091,7 @@ AttachDecision SetPropIRGenerator::tryAt
     return AttachDecision::NoAction;
   }
 
-  if (!obj->is<NativeObject>()) {
+  if (!obj->is<NativeObject>()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
   NativeObject* nobj = &obj->as<NativeObject>();
@@ -4102,7 +4102,7 @@ AttachDecision SetPropIRGenerator::tryAt
   }
 
   // Stub doesn't handle negative indices.
-  if (index > INT_MAX) {
+  if (index > INT_MAX) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -4260,7 +4260,7 @@ AttachDecision SetPropIRGenerator::tryAt
   MOZ_ASSERT(IsCacheableDOMProxy(obj));
 
   JSObject* proto = obj->staticPrototype();
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -4490,7 +4490,7 @@ bool SetPropIRGenerator::canAttachAddSlo
     MOZ_ASSERT(fun->needsPrototypeProperty());
 
     // If property exists this isn't an "add".
-    if (fun->lookupPure(id)) {
+    if (fun->lookupPure(id)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -4561,26 +4561,26 @@ AttachDecision SetPropIRGenerator::tryAt
 
   RootedId id(cx_);
   bool nameOrSymbol;
-  if (!ValueToNameOrSymbolId(cx_, idVal_, &id, &nameOrSymbol)) {
+  if (!ValueToNameOrSymbolId(cx_, idVal_, &id, &nameOrSymbol)) {MOZ_RELEASE_ASSERT(0);
     cx_->clearPendingException();
     return AttachDecision::NoAction;
   }
 
-  if (!lhsVal_.isObject() || !nameOrSymbol) {
+  if (!lhsVal_.isObject() || !nameOrSymbol) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
   JSObject* obj = &lhsVal_.toObject();
 
   PropertyResult prop;
-  if (!LookupOwnPropertyPure(cx_, obj, id, &prop)) {
+  if (!LookupOwnPropertyPure(cx_, obj, id, &prop)) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
   if (prop.isNotFound()) {
     return AttachDecision::NoAction;
   }
 
-  if (!obj->is<NativeObject>()) {
+  if (!obj->is<NativeObject>()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
   auto* nobj = &obj->as<NativeObject>();
@@ -4709,7 +4709,7 @@ AttachDecision InstanceOfIRGenerator::tr
   uint32_t slot = shape->slot();
 
   MOZ_ASSERT(fun->numFixedSlots() == 0, "Stub code relies on this");
-  if (!fun->getSlot(slot).isObject()) {
+  if (!fun->getSlot(slot).isObject()) {MOZ_RELEASE_ASSERT(0);
     trackAttached(IRGenerator::NotAttached);
     return AttachDecision::NoAction;
   }
@@ -4919,7 +4919,7 @@ static bool IsArrayPrototypeOptimizable(
 
   // Ensure that Array.prototype's @@iterator slot is unchanged.
   Shape* shape = proto->lookupPure(iteratorKey);
-  if (!shape || !shape->isDataProperty()) {
+  if (!shape || !shape->isDataProperty()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4947,7 +4947,7 @@ static bool IsArrayIteratorPrototypeOpti
 
   // Ensure that %ArrayIteratorPrototype%'s "next" slot is unchanged.
   Shape* shape = proto->lookupPure(cx->names().next);
-  if (!shape || !shape->isDataProperty()) {
+  if (!shape || !shape->isDataProperty()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5211,7 +5211,7 @@ AttachDecision CallIRGenerator::tryAttac
 
 AttachDecision CallIRGenerator::tryAttachArrayJoin(HandleFunction callee) {
   // Only handle argc <= 1.
-  if (argc_ > 1) {
+  if (argc_ > 1) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -5260,7 +5260,7 @@ AttachDecision CallIRGenerator::tryAttac
 
 AttachDecision CallIRGenerator::tryAttachArraySlice(HandleFunction callee) {
   // Only handle argc <= 2.
-  if (argc_ > 2) {
+  if (argc_ > 2) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -5281,7 +5281,7 @@ AttachDecision CallIRGenerator::tryAttac
 
   JSObject* templateObj =
       NewDenseFullyAllocatedArray(cx_, 0, /* proto = */ nullptr, TenuredObject);
-  if (!templateObj) {
+  if (!templateObj) {MOZ_RELEASE_ASSERT(0);
     cx_->recoverFromOutOfMemory();
     return AttachDecision::NoAction;
   }
@@ -5351,11 +5351,11 @@ AttachDecision CallIRGenerator::tryAttac
   }
 
   // Expected arguments: offset (number), optional littleEndian (boolean).
-  if (argc_ < 1 || argc_ > 2) {
+  if (argc_ < 1 || argc_ > 2) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
   int64_t offsetInt64;
-  if (!ValueIsInt64Index(args_[0], &offsetInt64)) {
+  if (!ValueIsInt64Index(args_[0], &offsetInt64)) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
   if (argc_ > 1 && !args_[1].isBoolean()) {
@@ -5422,11 +5422,11 @@ AttachDecision CallIRGenerator::tryAttac
   }
 
   // Expected arguments: offset (number), value, optional littleEndian (boolean)
-  if (argc_ < 2 || argc_ > 3) {
+  if (argc_ < 2 || argc_ > 3) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
   int64_t offsetInt64;
-  if (!ValueIsInt64Index(args_[0], &offsetInt64)) {
+  if (!ValueIsInt64Index(args_[0], &offsetInt64)) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
   if (!ValueIsNumeric(type, args_[1])) {
@@ -5493,7 +5493,7 @@ AttachDecision CallIRGenerator::tryAttac
   MOZ_ASSERT(args_[1].toInt32() >= 0);
 
   uint32_t slot = uint32_t(args_[1].toInt32());
-  if (slot >= NativeObject::MAX_FIXED_SLOTS) {
+  if (slot >= NativeObject::MAX_FIXED_SLOTS) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
   size_t offset = NativeObject::getFixedSlotOffset(slot);
@@ -5843,7 +5843,7 @@ AttachDecision CallIRGenerator::tryAttac
   MOZ_ASSERT(args_[0].isObject());
 
   // Only optimize when the object isn't a proxy.
-  if (isPossiblyWrapped && args_[0].toObject().is<ProxyObject>()) {
+  if (isPossiblyWrapped && args_[0].toObject().is<ProxyObject>()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -5876,7 +5876,7 @@ AttachDecision CallIRGenerator::tryAttac
   MOZ_ASSERT(args_[2].isNumber());
 
   // It's not guaranteed that the JITs have typed |lastIndex| as an Int32.
-  if (!args_[2].isInt32()) {
+  if (!args_[2].isInt32()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -6306,7 +6306,7 @@ AttachDecision CallIRGenerator::tryAttac
 AttachDecision CallIRGenerator::tryAttachStringToLowerCase(
     HandleFunction callee) {
   // Expecting no arguments.
-  if (argc_ != 0) {
+  if (argc_ != 0) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -6337,7 +6337,7 @@ AttachDecision CallIRGenerator::tryAttac
 AttachDecision CallIRGenerator::tryAttachStringToUpperCase(
     HandleFunction callee) {
   // Expecting no arguments.
-  if (argc_ != 0) {
+  if (argc_ != 0) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -6426,7 +6426,7 @@ AttachDecision CallIRGenerator::tryAttac
 
 AttachDecision CallIRGenerator::tryAttachMathClz32(HandleFunction callee) {
   // Need one (number) argument.
-  if (argc_ != 1 || !args_[0].isNumber()) {
+  if (argc_ != 1 || !args_[0].isNumber()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -6614,7 +6614,7 @@ AttachDecision CallIRGenerator::tryAttac
 
 AttachDecision CallIRGenerator::tryAttachMathTrunc(HandleFunction callee) {
   // Need one (number) argument.
-  if (argc_ != 1 || !args_[0].isNumber()) {
+  if (argc_ != 1 || !args_[0].isNumber()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -7044,7 +7044,7 @@ AttachDecision CallIRGenerator::tryAttac
 AttachDecision CallIRGenerator::tryAttachReflectGetPrototypeOf(
     HandleFunction callee) {
   // Need one argument.
-  if (argc_ != 1) {
+  if (argc_ != 1) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -7096,7 +7096,7 @@ static bool AtomicsMeetsPreconditions(Ty
 
   // Bounds check the index argument.
   int64_t indexInt64;
-  if (!ValueIsInt64Index(index, &indexInt64)) {
+  if (!ValueIsInt64Index(index, &indexInt64)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (indexInt64 < 0 || uint64_t(indexInt64) >= typedArray->length().get()) {
@@ -7108,7 +7108,7 @@ static bool AtomicsMeetsPreconditions(Ty
 
 AttachDecision CallIRGenerator::tryAttachAtomicsCompareExchange(
     HandleFunction callee) {
-  if (!JitSupportsAtomics()) {
+  if (!JitSupportsAtomics()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -7173,7 +7173,7 @@ AttachDecision CallIRGenerator::tryAttac
 }
 
 bool CallIRGenerator::canAttachAtomicsReadWriteModify() {
-  if (!JitSupportsAtomics()) {
+  if (!JitSupportsAtomics()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -7186,12 +7186,12 @@ bool CallIRGenerator::canAttachAtomicsRe
   if (!args_[0].isObject() || !args_[0].toObject().is<TypedArrayObject>()) {
     return false;
   }
-  if (!args_[1].isNumber()) {
+  if (!args_[1].isNumber()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   auto* typedArray = &args_[0].toObject().as<TypedArrayObject>();
-  if (!AtomicsMeetsPreconditions(typedArray, args_[1])) {
+  if (!AtomicsMeetsPreconditions(typedArray, args_[1])) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!ValueIsNumeric(typedArray->type(), args_[2])) {
@@ -7345,12 +7345,12 @@ AttachDecision CallIRGenerator::tryAttac
 }
 
 AttachDecision CallIRGenerator::tryAttachAtomicsLoad(HandleFunction callee) {
-  if (!JitSupportsAtomics()) {
+  if (!JitSupportsAtomics()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
   // Need two arguments.
-  if (argc_ != 2) {
+  if (argc_ != 2) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -7391,12 +7391,12 @@ AttachDecision CallIRGenerator::tryAttac
 }
 
 AttachDecision CallIRGenerator::tryAttachAtomicsStore(HandleFunction callee) {
-  if (!JitSupportsAtomics()) {
+  if (!JitSupportsAtomics()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
   // Need three arguments.
-  if (argc_ != 3) {
+  if (argc_ != 3) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -7413,12 +7413,12 @@ AttachDecision CallIRGenerator::tryAttac
   if (!args_[0].isObject() || !args_[0].toObject().is<TypedArrayObject>()) {
     return AttachDecision::NoAction;
   }
-  if (!args_[1].isNumber()) {
+  if (!args_[1].isNumber()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
   auto* typedArray = &args_[0].toObject().as<TypedArrayObject>();
-  if (!AtomicsMeetsPreconditions(typedArray, args_[1])) {
+  if (!AtomicsMeetsPreconditions(typedArray, args_[1])) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -7471,7 +7471,7 @@ AttachDecision CallIRGenerator::tryAttac
 AttachDecision CallIRGenerator::tryAttachAtomicsIsLockFree(
     HandleFunction callee) {
   // Need one argument.
-  if (argc_ != 1) {
+  if (argc_ != 1) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -7693,7 +7693,7 @@ AttachDecision CallIRGenerator::tryAttac
 AttachDecision CallIRGenerator::tryAttachObjectIsPrototypeOf(
     HandleFunction callee) {
   // Ensure |this| is an object.
-  if (!thisval_.isObject()) {
+  if (!thisval_.isObject()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -7758,7 +7758,7 @@ AttachDecision CallIRGenerator::tryAttac
 
 AttachDecision CallIRGenerator::tryAttachBigIntAsIntN(HandleFunction callee) {
   // Need two arguments (Int32, BigInt).
-  if (argc_ != 2 || !args_[0].isInt32() || !args_[1].isBigInt()) {
+  if (argc_ != 2 || !args_[0].isInt32() || !args_[1].isBigInt()) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -8257,7 +8257,7 @@ AttachDecision CallIRGenerator::tryAttac
 
   RootedObject proto(cx_, args_[0].toObjectOrNull());
   JSObject* templateObj = ObjectCreateImpl(cx_, proto, TenuredObject);
-  if (!templateObj) {
+  if (!templateObj) {MOZ_RELEASE_ASSERT(0);
     cx_->recoverFromOutOfMemory();
     return AttachDecision::NoAction;
   }
@@ -8307,7 +8307,7 @@ AttachDecision CallIRGenerator::tryAttac
     AutoRealm ar(cx_, callee);
     templateObj = NewDenseFullyAllocatedArray(
         cx_, length, /* proto = */ nullptr, TenuredObject);
-    if (!templateObj) {
+    if (!templateObj) {MOZ_RELEASE_ASSERT(0);
       cx_->recoverFromOutOfMemory();
       return AttachDecision::NoAction;
     }
@@ -8369,12 +8369,12 @@ AttachDecision CallIRGenerator::tryAttac
 
   RootedObject templateObj(cx_);
   if (!TypedArrayObject::GetTemplateObjectForNative(cx_, callee->native(),
-                                                    args_, &templateObj)) {
+                                                    args_, &templateObj)) {MOZ_RELEASE_ASSERT(0);
     cx_->recoverFromOutOfMemory();
     return AttachDecision::NoAction;
   }
 
-  if (!templateObj) {
+  if (!templateObj) {MOZ_RELEASE_ASSERT(0);
     // This can happen for large length values.
     MOZ_ASSERT(args_[0].isInt32());
     return AttachDecision::NoAction;
@@ -8468,7 +8468,7 @@ AttachDecision CallIRGenerator::tryAttac
     }
     format = CallFlags::FunApplyArgsObj;
   } else if (args_[1].isMagic(JS_OPTIMIZED_ARGUMENTS) &&
-             !script_->needsArgsObj()) {
+             !script_->needsArgsObj()) {MOZ_RELEASE_ASSERT(0);
     format = CallFlags::FunApplyMagicArgs;
   } else if (args_[1].isObject() && args_[1].toObject().is<ArrayObject>() &&
              args_[1].toObject().as<ArrayObject>().length() <=
@@ -8505,7 +8505,7 @@ AttachDecision CallIRGenerator::tryAttac
     uint8_t flags = ArgumentsObject::ELEMENT_OVERRIDDEN_BIT |
                     ArgumentsObject::FORWARDED_ARGUMENTS_BIT;
     writer.guardArgumentsObjectFlags(argObjId, flags);
-  } else if (format == CallFlags::FunApplyMagicArgs) {
+  } else if (format == CallFlags::FunApplyMagicArgs) {MOZ_RELEASE_ASSERT(0);
     writer.guardMagicValue(argValId, JS_OPTIMIZED_ARGUMENTS);
     writer.guardFrameHasNoArgumentsObject();
   } else {
@@ -8568,7 +8568,7 @@ AttachDecision CallIRGenerator::tryAttac
 
   MOZ_ASSERT(calleeFunc->isWasmWithJitEntry());
 
-  if (!JitOptions.enableWasmIonFastCalls) {
+  if (!JitOptions.enableWasmIonFastCalls) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
   if (!isFirstStub_) {
@@ -8603,7 +8603,7 @@ AttachDecision CallIRGenerator::tryAttac
 
   // If there are too many results, don't optimize as Warp currently doesn't
   // have code to handle this.
-  if (sig.results().length() > wasm::MaxResultsForJitInlineCall) {
+  if (sig.results().length() > wasm::MaxResultsForJitInlineCall) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -9114,7 +9114,7 @@ ScriptedThisResult CallIRGenerator::getT
   }
 
   if (!GetProperty(cx_, newTarget, newTarget, cx_->names().prototype,
-                   &protov)) {
+                   &protov)) {MOZ_RELEASE_ASSERT(0);
     cx_->clearPendingException();
     return ScriptedThisResult::NoAction;
   }
@@ -9142,7 +9142,7 @@ AttachDecision CallIRGenerator::tryAttac
 
   // Never attach optimized scripted call stubs for JSOp::FunApply.
   // MagicArguments may escape the frame through them.
-  if (op_ == JSOp::FunApply) {
+  if (op_ == JSOp::FunApply) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
@@ -9433,13 +9433,13 @@ AttachDecision CallIRGenerator::tryAttac
 
 void CallIRGenerator::trackAttached(const char* name) {
 #ifdef JS_CACHEIR_SPEW
-  if (const CacheIRSpewer::Guard& sp = CacheIRSpewer::Guard(*this, name)) {
+  if (const CacheIRSpewer::Guard& sp = CacheIRSpewer::Guard(*this, name)) {MOZ_RELEASE_ASSERT(0);
     sp.valueProperty("callee", callee_);
     sp.valueProperty("thisval", thisval_);
     sp.valueProperty("argc", Int32Value(argc_));
 
     // Try to log the first two arguments.
-    if (args_.length() >= 1) {
+    if (args_.length() >= 1) {MOZ_RELEASE_ASSERT(0);
       sp.valueProperty("arg0", args_[0]);
     }
     if (args_.length() >= 2) {
@@ -9464,7 +9464,7 @@ JSObject* jit::NewWrapperWithObjectShape
   {
     AutoRealm ar(cx, obj);
     wrapper = NewBuiltinClassInstance(cx, &shapeContainerClass);
-    if (!wrapper) {
+    if (!wrapper) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     wrapper->as<NativeObject>().setSlot(
@@ -11057,13 +11057,13 @@ void NewObjectIRGenerator::trackAttached
 #endif
 }
 
-AttachDecision NewObjectIRGenerator::tryAttachPlainObject() {
+AttachDecision NewObjectIRGenerator::tryAttachPlainObject() {MOZ_RELEASE_ASSERT(0);
   NativeObject* nativeObj = &templateObject_->as<NativeObject>();
   MOZ_ASSERT(nativeObj->is<PlainObject>());
 
   // We use an unrolled loop when initializing slots. To avoid generating
   // too much code, put a limit on the number of dynamic slots.
-  if (nativeObj->numDynamicSlots() > NativeObject::MAX_FIXED_SLOTS) {
+  if (nativeObj->numDynamicSlots() > NativeObject::MAX_FIXED_SLOTS) {MOZ_RELEASE_ASSERT(0);
     return AttachDecision::NoAction;
   }
 
diff --git a/js/src/jit/CacheIRCompiler.cpp b/js/src/jit/CacheIRCompiler.cpp
--- a/js/src/jit/CacheIRCompiler.cpp
+++ b/js/src/jit/CacheIRCompiler.cpp
@@ -203,7 +203,7 @@ void CacheRegisterAllocator::ensureDoubl
 
 void CacheRegisterAllocator::copyToScratchRegister(MacroAssembler& masm,
                                                    TypedOperandId typedId,
-                                                   Register dest) const {
+                                                   Register dest) const {MOZ_RELEASE_ASSERT(0);
   // If AutoScratchFloatRegister is active, we have to add sizeof(double) to
   // any stack slot offsets below.
   int32_t stackOffset = hasAutoScratchFloatRegisterSpill() ? sizeof(double) : 0;
@@ -250,7 +250,7 @@ void CacheRegisterAllocator::copyToScrat
 
 ValueOperand CacheRegisterAllocator::useFixedValueRegister(MacroAssembler& masm,
                                                            ValOperandId valId,
-                                                           ValueOperand reg) {
+                                                           ValueOperand reg) {MOZ_RELEASE_ASSERT(0);
   allocateFixedValueRegister(masm, reg);
 
   OperandLocation& loc = operandLocations_[valId.id()];
@@ -559,7 +559,7 @@ void CacheRegisterAllocator::allocateFix
   }
 
   // Register may be available only after spilling contents.
-  if (availableRegsAfterSpill_.has(reg)) {
+  if (availableRegsAfterSpill_.has(reg)) {MOZ_RELEASE_ASSERT(0);
     availableRegsAfterSpill_.take(reg);
     masm.push(reg);
     stackPushed_ += sizeof(uintptr_t);
@@ -626,7 +626,7 @@ ValueOperand CacheRegisterAllocator::all
 }
 
 bool CacheRegisterAllocator::init() {
-  if (!origInputLocations_.resize(writer_.numInputOperands())) {
+  if (!origInputLocations_.resize(writer_.numInputOperands())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!operandLocations_.resize(writer_.numOperandIds())) {
@@ -1006,7 +1006,7 @@ void CacheRegisterAllocator::restoreInpu
                dest.kind() == OperandLocation::DoubleReg) {
       // Nothing to do.
       continue;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     MOZ_CRASH("Invalid kind");
   }
@@ -1259,15 +1259,15 @@ HashNumber CacheIRStubKey::hash(const Ca
 
 bool CacheIRStubKey::match(const CacheIRStubKey& entry,
                            const CacheIRStubKey::Lookup& l) {
-  if (entry.stubInfo->kind() != l.kind) {
-    return false;
-  }
-
-  if (entry.stubInfo->engine() != l.engine) {
-    return false;
-  }
-
-  if (entry.stubInfo->codeLength() != l.length) {
+  if (entry.stubInfo->kind() != l.kind) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (entry.stubInfo->engine() != l.engine) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (entry.stubInfo->codeLength() != l.length) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1291,7 +1291,7 @@ CacheIRStubInfo* CacheIRStubInfo::New(Ca
       sizeof(CacheIRStubInfo) + writer.codeLength() +
       (numStubFields + 1);  // +1 for the GCType::Limit terminator.
   uint8_t* p = js_pod_malloc<uint8_t>(bytesNeeded);
-  if (!p) {
+  if (!p) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1369,7 +1369,7 @@ bool FailurePath::canShareFailurePath(co
   }
 
   for (size_t i = 0; i < spilledRegs_.length(); i++) {
-    if (spilledRegs_[i] != other.spilledRegs_[i]) {
+    if (spilledRegs_[i] != other.spilledRegs_[i]) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1392,11 +1392,11 @@ bool CacheIRCompiler::addFailurePath(Fai
 
   FailurePath newFailure;
   for (size_t i = 0; i < writer_.numInputOperands(); i++) {
-    if (!newFailure.appendInput(allocator.operandLocation(i))) {
+    if (!newFailure.appendInput(allocator.operandLocation(i))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
-  if (!newFailure.setSpilledRegs(allocator.spilledRegs())) {
+  if (!newFailure.setSpilledRegs(allocator.spilledRegs())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   newFailure.setStackPushed(allocator.stackPushed());
@@ -1473,7 +1473,7 @@ bool CacheIRCompiler::emitGuardToObject(
 bool CacheIRCompiler::emitGuardIsNullOrUndefined(ValOperandId inputId) {
   JitSpew(JitSpew_Codegen, "%s", __FUNCTION__);
   JSValueType knownType = allocator.knownType(inputId);
-  if (knownType == JSVAL_TYPE_UNDEFINED || knownType == JSVAL_TYPE_NULL) {
+  if (knownType == JSVAL_TYPE_UNDEFINED || knownType == JSVAL_TYPE_NULL) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -1494,7 +1494,7 @@ bool CacheIRCompiler::emitGuardIsNullOrU
 bool CacheIRCompiler::emitGuardIsNull(ValOperandId inputId) {
   JitSpew(JitSpew_Codegen, "%s", __FUNCTION__);
   JSValueType knownType = allocator.knownType(inputId);
-  if (knownType == JSVAL_TYPE_NULL) {
+  if (knownType == JSVAL_TYPE_NULL) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -1512,7 +1512,7 @@ bool CacheIRCompiler::emitGuardIsNull(Va
 bool CacheIRCompiler::emitGuardIsUndefined(ValOperandId inputId) {
   JitSpew(JitSpew_Codegen, "%s", __FUNCTION__);
   JSValueType knownType = allocator.knownType(inputId);
-  if (knownType == JSVAL_TYPE_UNDEFINED) {
+  if (knownType == JSVAL_TYPE_UNDEFINED) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -1531,7 +1531,7 @@ bool CacheIRCompiler::emitGuardBooleanTo
   JitSpew(JitSpew_Codegen, "%s", __FUNCTION__);
   Register output = allocator.defineRegister(masm, resultId);
 
-  if (allocator.knownType(inputId) == JSVAL_TYPE_BOOLEAN) {
+  if (allocator.knownType(inputId) == JSVAL_TYPE_BOOLEAN) {MOZ_RELEASE_ASSERT(0);
     Register input =
         allocator.useRegister(masm, BooleanOperandId(inputId.id()));
     masm.move32(input, output);
@@ -1596,7 +1596,7 @@ bool CacheIRCompiler::emitGuardToBigInt(
 bool CacheIRCompiler::emitGuardToBoolean(ValOperandId inputId) {
   JitSpew(JitSpew_Codegen, "%s", __FUNCTION__);
 
-  if (allocator.knownType(inputId) == JSVAL_TYPE_BOOLEAN) {
+  if (allocator.knownType(inputId) == JSVAL_TYPE_BOOLEAN) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -1703,7 +1703,7 @@ bool CacheIRCompiler::emitGuardToInt32In
   ValueOperand input = allocator.useValueRegister(masm, inputId);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1740,7 +1740,7 @@ bool CacheIRCompiler::emitGuardNumberToI
 
   FailurePath* failure = nullptr;
   if (!supportOOB) {
-    if (!addFailurePath(&failure)) {
+    if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1775,7 +1775,7 @@ bool CacheIRCompiler::emitGuardToInt32Mo
     ConstantOrRegister input = allocator.useConstantOrRegister(masm, inputId);
     if (input.constant()) {
       masm.move32(Imm32(input.value().toInt32()), output);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(input.reg().type() == MIRType::Int32);
       masm.move32(input.reg().typedReg().gpr(), output);
     }
@@ -1785,7 +1785,7 @@ bool CacheIRCompiler::emitGuardToInt32Mo
   ValueOperand input = allocator.useValueRegister(masm, inputId);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1806,22 +1806,22 @@ bool CacheIRCompiler::emitGuardToUint8Cl
   JitSpew(JitSpew_Codegen, "%s", __FUNCTION__);
   Register output = allocator.defineRegister(masm, resultId);
 
-  if (allocator.knownType(inputId) == JSVAL_TYPE_INT32) {
+  if (allocator.knownType(inputId) == JSVAL_TYPE_INT32) {MOZ_RELEASE_ASSERT(0);
     ConstantOrRegister input = allocator.useConstantOrRegister(masm, inputId);
-    if (input.constant()) {
+    if (input.constant()) {MOZ_RELEASE_ASSERT(0);
       masm.move32(Imm32(ClampDoubleToUint8(input.value().toInt32())), output);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(input.reg().type() == MIRType::Int32);
       masm.move32(input.reg().typedReg().gpr(), output);
       masm.clampIntToUint8(output);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   ValueOperand input = allocator.useValueRegister(masm, inputId);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1842,14 +1842,14 @@ bool CacheIRCompiler::emitGuardNonDouble
                                              ValueType type) {
   JitSpew(JitSpew_Codegen, "%s", __FUNCTION__);
 
-  if (allocator.knownType(inputId) == JSValueType(type)) {
+  if (allocator.knownType(inputId) == JSValueType(type)) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   ValueOperand input = allocator.useValueRegister(masm, inputId);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1891,7 +1891,7 @@ bool CacheIRCompiler::emitGuardClass(Obj
   AutoScratchRegister scratch(allocator, masm);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2146,7 +2146,7 @@ bool CacheIRCompiler::emitGuardIsNotDOMP
 }
 
 bool CacheIRCompiler::emitGuardMagicValue(ValOperandId valId,
-                                          JSWhyMagic magic) {
+                                          JSWhyMagic magic) {MOZ_RELEASE_ASSERT(0);
   JitSpew(JitSpew_Codegen, "%s", __FUNCTION__);
   ValueOperand val = allocator.useValueRegister(masm, valId);
 
@@ -2204,7 +2204,7 @@ bool CacheIRCompiler::emitGuardStringToN
   AutoScratchRegister scratch(allocator, masm);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2280,7 +2280,7 @@ bool CacheIRCompiler::emitGuardStringToI
   Register output = allocator.defineRegister(masm, resultId);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2440,7 +2440,7 @@ static void EmitStoreResult(MacroAssembl
     masm.tagValue(type, reg, output.valueReg());
     return;
   }
-  if (type == JSVAL_TYPE_INT32 && output.typedReg().isFloat()) {
+  if (type == JSVAL_TYPE_INT32 && output.typedReg().isFloat()) {MOZ_RELEASE_ASSERT(0);
     masm.convertInt32ToDouble(reg, output.typedReg().fpu());
     return;
   }
@@ -2877,7 +2877,7 @@ bool CacheIRCompiler::emitInt32URightShi
   AutoScratchRegisterMaybeOutput scratch(allocator, masm, output);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2987,7 +2987,7 @@ bool CacheIRCompiler::emitDoubleIncDecRe
   ValueOperand val = allocator.useValueRegister(masm, inputId);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4946,7 +4946,7 @@ bool CacheIRCompiler::emitStoreDenseElem
   AutoScratchRegister scratch(allocator, masm);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5162,7 +5162,7 @@ bool CacheIRCompiler::emitStoreTypedArra
   }
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5256,7 +5256,7 @@ bool CacheIRCompiler::emitLoadTypedArray
 #endif
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5357,7 +5357,7 @@ bool CacheIRCompiler::emitLoadDataViewVa
   Register outputScratch = outputReg64.scratchReg();
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5571,7 +5571,7 @@ bool CacheIRCompiler::emitStoreDataViewV
 #endif
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5645,7 +5645,7 @@ bool CacheIRCompiler::emitStoreDataViewV
 
   // Swap the bytes in the loaded value.
   Label skip;
-  if (pushedLittleEndian) {
+  if (pushedLittleEndian) {MOZ_RELEASE_ASSERT(0);
     masm.branch32(MOZ_LITTLE_ENDIAN() ? Assembler::NotEqual : Assembler::Equal,
                   Address(masm.getStackPointer(), 0), Imm32(0), &skip);
   } else {
@@ -6104,7 +6104,7 @@ bool CacheIRCompiler::emitLoadNewObjectF
 bool CacheIRCompiler::emitNewPlainObjectResult(uint32_t numFixedSlots,
                                                uint32_t numDynamicSlots,
                                                gc::AllocKind allocKind,
-                                               uint32_t shapeOffset) {
+                                               uint32_t shapeOffset) {MOZ_RELEASE_ASSERT(0);
   JitSpew(JitSpew_Codegen, "%s", __FUNCTION__);
   AutoOutputRegister output(*this);
   AutoScratchRegister obj(allocator, masm);
@@ -6452,7 +6452,7 @@ bool CacheIRCompiler::emitCompareNullUnd
   }
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6658,7 +6658,7 @@ bool CacheIRCompiler::emitMegamorphicLoa
   AutoScratchRegisterMaybeOutput scratch(allocator, masm, output);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6717,7 +6717,7 @@ bool CacheIRCompiler::emitMegamorphicHas
   AutoScratchRegisterMaybeOutput scratch(allocator, masm, output);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6902,7 +6902,7 @@ bool CacheIRCompiler::emitLoadInstanceOf
   AutoScratchRegisterMaybeOutput scratch(allocator, masm, output);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6951,7 +6951,7 @@ bool CacheIRCompiler::emitMegamorphicLoa
   AutoScratchRegister scratch3(allocator, masm);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -7097,7 +7097,7 @@ bool CacheIRCompiler::emitGuardWasmArg(V
   ValueOperand arg = allocator.useValueRegister(masm, argId);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -7719,7 +7719,7 @@ bool CacheIRCompiler::emitAtomicsCompare
   Register spectreTemp = Register::Invalid();
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -7794,7 +7794,7 @@ bool CacheIRCompiler::emitAtomicsReadMod
   Register spectreTemp = Register::Invalid();
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -7978,7 +7978,7 @@ bool CacheIRCompiler::emitAtomicsLoadRes
   AutoAvailableFloatRegister floatReg(*this, FloatReg0);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -8055,7 +8055,7 @@ bool CacheIRCompiler::emitAtomicsStoreRe
   Register spectreTemp = Register::Invalid();
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/jit/CacheIRHealth.cpp b/js/src/jit/CacheIRHealth.cpp
--- a/js/src/jit/CacheIRHealth.cpp
+++ b/js/src/jit/CacheIRHealth.cpp
@@ -19,11 +19,11 @@ using namespace js::jit;
 // TODO: Refine how we assign happiness based on total health score.
 CacheIRHealth::Happiness CacheIRHealth::determineStubHappiness(
     uint32_t stubHealthScore) {
-  if (stubHealthScore >= 30) {
+  if (stubHealthScore >= 30) {MOZ_RELEASE_ASSERT(0);
     return Sad;
   }
 
-  if (stubHealthScore >= 20) {
+  if (stubHealthScore >= 20) {MOZ_RELEASE_ASSERT(0);
     return MediumSad;
   }
 
@@ -35,20 +35,20 @@ CacheIRHealth::Happiness CacheIRHealth::
 }
 
 CacheIRHealth::Happiness CacheIRHealth::spewStubHealth(
-    AutoStructuredSpewer& spew, ICCacheIRStub* stub) {
+    AutoStructuredSpewer& spew, ICCacheIRStub* stub) {MOZ_RELEASE_ASSERT(0);
   const CacheIRStubInfo* stubInfo = stub->stubInfo();
   CacheIRReader stubReader(stubInfo);
   uint32_t totalStubHealth = 0;
 
   spew->beginListProperty("cacheIROps");
-  while (stubReader.more()) {
+  while (stubReader.more()) {MOZ_RELEASE_ASSERT(0);
     CacheOp op = stubReader.readOp();
     uint32_t opHealth = CacheIROpHealth[size_t(op)];
     uint32_t argLength = CacheIROpInfos[size_t(op)].argLength;
     const char* opName = CacheIROpNames[size_t(op)];
 
     spew->beginObject();
-    if (opHealth == UINT32_MAX) {
+    if (opHealth == UINT32_MAX) {MOZ_RELEASE_ASSERT(0);
       spew->property("unscoredOp", opName);
     } else {
       spew->property("cacheIROp", opName);
@@ -71,7 +71,7 @@ CacheIRHealth::Happiness CacheIRHealth::
 
 bool CacheIRHealth::spewNonFallbackICInformation(AutoStructuredSpewer& spew,
                                                  ICStub* firstStub,
-                                                 Happiness* entryHappiness) {
+                                                 Happiness* entryHappiness) {MOZ_RELEASE_ASSERT(0);
   const CacheIRStubInfo* stubInfo = firstStub->toCacheIRStub()->stubInfo();
   Vector<bool, 8, SystemAllocPolicy> sawDistinctValueAtFieldIndex;
 
@@ -80,50 +80,50 @@ bool CacheIRHealth::spewNonFallbackICInf
   ICStub* stub = firstStub;
 
   spew->beginListProperty("stubs");
-  while (stub && !stub->isFallback()) {
+  while (stub && !stub->isFallback()) {MOZ_RELEASE_ASSERT(0);
     spew->beginObject();
-    {
+    {MOZ_RELEASE_ASSERT(0);
       Happiness stubHappiness = spewStubHealth(spew, stub->toCacheIRStub());
-      if (stubHappiness < *entryHappiness) {
+      if (stubHappiness < *entryHappiness) {MOZ_RELEASE_ASSERT(0);
         *entryHappiness = stubHappiness;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       ICStub* nextStub = stub->toCacheIRStub()->next();
-      if (!nextStub->isFallback()) {
-        if (nextStub->enteredCount() > 0) {
+      if (!nextStub->isFallback()) {MOZ_RELEASE_ASSERT(0);
+        if (nextStub->enteredCount() > 0) {MOZ_RELEASE_ASSERT(0);
           // More than one stub has a hit count greater than zero.
           // This is sad because we do not Warp transpile in this case.
           *entryHappiness = Sad;
           sawNonZeroCount = true;
         }
 
-        if (nextStub->toCacheIRStub()->stubInfo() != stubInfo) {
+        if (nextStub->toCacheIRStub()->stubInfo() != stubInfo) {MOZ_RELEASE_ASSERT(0);
           sawDifferentCacheIRStubs = true;
         }
 
         // If there are multiple stubs with non zero hit counts and if all
         // of the stubs have equivalent CacheIR, then keep track of how many
         // distinct stub field values are seen for each field index.
-        if (sawNonZeroCount && !sawDifferentCacheIRStubs) {
+        if (sawNonZeroCount && !sawDifferentCacheIRStubs) {MOZ_RELEASE_ASSERT(0);
           uint32_t fieldIndex = 0;
           size_t offset = 0;
 
-          while (stubInfo->fieldType(fieldIndex) != StubField::Type::Limit) {
-            if (sawDistinctValueAtFieldIndex.length() <= fieldIndex) {
-              if (!sawDistinctValueAtFieldIndex.append(false)) {
+          while (stubInfo->fieldType(fieldIndex) != StubField::Type::Limit) {MOZ_RELEASE_ASSERT(0);
+            if (sawDistinctValueAtFieldIndex.length() <= fieldIndex) {MOZ_RELEASE_ASSERT(0);
+              if (!sawDistinctValueAtFieldIndex.append(false)) {MOZ_RELEASE_ASSERT(0);
                 return false;
-              }
+              }MOZ_RELEASE_ASSERT(0);
             }
 
-            if (StubField::sizeIsWord(stubInfo->fieldType(fieldIndex))) {
+            if (StubField::sizeIsWord(stubInfo->fieldType(fieldIndex))) {MOZ_RELEASE_ASSERT(0);
               uintptr_t firstRaw =
                   stubInfo->getStubRawWord(firstStub->toCacheIRStub(), offset);
               uintptr_t nextRaw =
                   stubInfo->getStubRawWord(nextStub->toCacheIRStub(), offset);
-              if (firstRaw != nextRaw) {
+              if (firstRaw != nextRaw) {MOZ_RELEASE_ASSERT(0);
                 sawDistinctValueAtFieldIndex[fieldIndex] = true;
               }
-            } else {
+            } else {MOZ_RELEASE_ASSERT(0);
               MOZ_ASSERT(
                   StubField::sizeIsInt64(stubInfo->fieldType(fieldIndex)));
               int64_t firstRaw =
@@ -131,30 +131,30 @@ bool CacheIRHealth::spewNonFallbackICInf
               int64_t nextRaw =
                   stubInfo->getStubRawInt64(nextStub->toCacheIRStub(), offset);
 
-              if (firstRaw != nextRaw) {
+              if (firstRaw != nextRaw) {MOZ_RELEASE_ASSERT(0);
                 sawDistinctValueAtFieldIndex[fieldIndex] = true;
-              }
-            }
+              }MOZ_RELEASE_ASSERT(0);
+            }MOZ_RELEASE_ASSERT(0);
 
             offset += StubField::sizeInBytes(stubInfo->fieldType(fieldIndex));
             fieldIndex++;
-          }
-        }
-      }
+          }MOZ_RELEASE_ASSERT(0);
+        }MOZ_RELEASE_ASSERT(0);
+      }MOZ_RELEASE_ASSERT(0);
 
       spew->property("hitCount", stub->enteredCount());
       stub = nextStub;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     spew->endObject();
-  }
+  }MOZ_RELEASE_ASSERT(0);
   spew->endList();  // stubs
 
   // If more than one CacheIR stub has an entered count greater than
   // zero and all the stubs have equivalent CacheIR, then spew
   // the information collected about the stub fields across the IC.
-  if (sawNonZeroCount && !sawDifferentCacheIRStubs) {
+  if (sawNonZeroCount && !sawDifferentCacheIRStubs) {MOZ_RELEASE_ASSERT(0);
     spew->beginListProperty("stubFields");
-    for (size_t i = 0; i < sawDistinctValueAtFieldIndex.length(); i++) {
+    for (size_t i = 0; i < sawDistinctValueAtFieldIndex.length(); i++) {MOZ_RELEASE_ASSERT(0);
       spew->beginObject();
       {
         spew->property("fieldType", uint8_t(stubInfo->fieldType(i)));
@@ -172,7 +172,7 @@ bool CacheIRHealth::spewNonFallbackICInf
 bool CacheIRHealth::spewICEntryHealth(AutoStructuredSpewer& spew,
                                       HandleScript script, ICEntry* entry,
                                       jsbytecode* pc, JSOp op,
-                                      Happiness* entryHappiness) {
+                                      Happiness* entryHappiness) {MOZ_RELEASE_ASSERT(0);
   spew->property("op", CodeName(op));
 
   // TODO: If a perf issue arises, look into improving the SrcNotes
@@ -182,10 +182,10 @@ bool CacheIRHealth::spewICEntryHealth(Au
   spew->property("column", column);
 
   ICStub* firstStub = entry->firstStub();
-  if (!firstStub->isFallback()) {
-    if (!spewNonFallbackICInformation(spew, firstStub, entryHappiness)) {
+  if (!firstStub->isFallback()) {MOZ_RELEASE_ASSERT(0);
+    if (!spewNonFallbackICInformation(spew, firstStub, entryHappiness)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   if (entry->fallbackStub()->state().mode() != ICState::Mode::Specialized) {
@@ -204,7 +204,7 @@ bool CacheIRHealth::spewICEntryHealth(Au
 void CacheIRHealth::spewScriptFinalWarmUpCount(JSContext* cx,
                                                const char* filename,
                                                JSScript* script,
-                                               uint32_t warmUpCount) {
+                                               uint32_t warmUpCount) {MOZ_RELEASE_ASSERT(0);
   AutoStructuredSpewer spew(cx, SpewChannel::RateMyCacheIR, nullptr);
   if (!spew) {
     return;
@@ -216,22 +216,22 @@ void CacheIRHealth::spewScriptFinalWarmU
   spew->property("finalWarmUpCount", warmUpCount);
 }
 
-static bool addScriptToFinalWarmUpCountMap(JSContext* cx, HandleScript script) {
+static bool addScriptToFinalWarmUpCountMap(JSContext* cx, HandleScript script) {MOZ_RELEASE_ASSERT(0);
   // Create Zone::scriptFilenameMap if necessary.
   JS::Zone* zone = script->zone();
-  if (!zone->scriptFinalWarmUpCountMap) {
+  if (!zone->scriptFinalWarmUpCountMap) {MOZ_RELEASE_ASSERT(0);
     auto map = MakeUnique<ScriptFinalWarmUpCountMap>();
-    if (!map) {
+    if (!map) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     zone->scriptFinalWarmUpCountMap = std::move(map);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   auto* filename = js_pod_malloc<char>(strlen(script->filename()) + 1);
-  if (!filename) {
+  if (!filename) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   strcpy(filename, script->filename());
 
   if (!zone->scriptFinalWarmUpCountMap->put(
@@ -245,16 +245,16 @@ static bool addScriptToFinalWarmUpCountM
 }
 
 void CacheIRHealth::rateIC(JSContext* cx, ICEntry* entry, HandleScript script,
-                           SpewContext context) {
+                           SpewContext context) {MOZ_RELEASE_ASSERT(0);
   AutoStructuredSpewer spew(cx, SpewChannel::RateMyCacheIR, script);
-  if (!spew) {
+  if (!spew) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
-  if (!addScriptToFinalWarmUpCountMap(cx, script)) {
+  if (!addScriptToFinalWarmUpCountMap(cx, script)) {MOZ_RELEASE_ASSERT(0);
     cx->recoverFromOutOfMemory();
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   spew->property("spewContext", uint8_t(context));
 
   jsbytecode* op = entry->pc(script);
@@ -269,21 +269,21 @@ void CacheIRHealth::rateIC(JSContext* cx
 }
 
 void CacheIRHealth::rateScript(JSContext* cx, HandleScript script,
-                               SpewContext context) {
+                               SpewContext context) {MOZ_RELEASE_ASSERT(0);
   jit::JitScript* jitScript = script->maybeJitScript();
-  if (!jitScript) {
+  if (!jitScript) {MOZ_RELEASE_ASSERT(0);
+    return;
+  }MOZ_RELEASE_ASSERT(0);
+
+  AutoStructuredSpewer spew(cx, SpewChannel::RateMyCacheIR, script);
+  if (!spew) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
-  AutoStructuredSpewer spew(cx, SpewChannel::RateMyCacheIR, script);
-  if (!spew) {
-    return;
-  }
-
-  if (!addScriptToFinalWarmUpCountMap(cx, script)) {
+  if (!addScriptToFinalWarmUpCountMap(cx, script)) {MOZ_RELEASE_ASSERT(0);
     cx->recoverFromOutOfMemory();
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   spew->property("spewContext", uint8_t(context));
 
@@ -293,25 +293,25 @@ void CacheIRHealth::rateScript(JSContext
   spew->beginListProperty("entries");
   ICEntry* prevEntry = nullptr;
   Happiness scriptHappiness = Happy;
-  while (next < end) {
+  while (next < end) {MOZ_RELEASE_ASSERT(0);
     uint32_t len = 0;
     uint32_t pcOffset = script->pcToOffset(next);
 
     jit::ICEntry* entry =
         jitScript->maybeICEntryFromPCOffset(pcOffset, prevEntry);
-    if (entry) {
+    if (entry) {MOZ_RELEASE_ASSERT(0);
       prevEntry = entry;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     JSOp op = JSOp(*next);
     const JSCodeSpec& cs = CodeSpec(op);
     len = cs.length;
     MOZ_ASSERT(len);
 
-    if (entry) {
+    if (entry) {MOZ_RELEASE_ASSERT(0);
       spew->beginObject();
       Happiness entryHappiness = Happy;
-      if (!spewICEntryHealth(spew, script, entry, next, op, &entryHappiness)) {
+      if (!spewICEntryHealth(spew, script, entry, next, op, &entryHappiness)) {MOZ_RELEASE_ASSERT(0);
         cx->recoverFromOutOfMemory();
         return;
       }
diff --git a/js/src/jit/CacheIRSpewer.cpp b/js/src/jit/CacheIRSpewer.cpp
--- a/js/src/jit/CacheIRSpewer.cpp
+++ b/js/src/jit/CacheIRSpewer.cpp
@@ -115,8 +115,8 @@ class MOZ_RAII CacheIROpsJitSpewer {
   CacheIROpsJitSpewer(GenericPrinter& out, const char* prefix)
       : out_(out), prefix_(prefix) {}
 
-  void spew(CacheIRReader& reader) {
-    do {
+  void spew(CacheIRReader& reader) {MOZ_RELEASE_ASSERT(0);
+    do {MOZ_RELEASE_ASSERT(0);
       switch (reader.readOp()) {
 #  define SPEW_OP(op, ...) \
     case CacheOp::op:      \
@@ -252,8 +252,8 @@ class MOZ_RAII CacheIROpsJSONSpewer {
  public:
   explicit CacheIROpsJSONSpewer(JSONPrinter& j) : j_(j) {}
 
-  void spew(CacheIRReader& reader) {
-    do {
+  void spew(CacheIRReader& reader) {MOZ_RELEASE_ASSERT(0);
+    do {MOZ_RELEASE_ASSERT(0);
       switch (reader.readOp()) {
 #  define SPEW_OP(op, ...) \
     case CacheOp::op:      \
@@ -301,17 +301,17 @@ CacheIRSpewer::~CacheIRSpewer() {
 #    endif
 #  endif
 
-bool CacheIRSpewer::init(const char* filename) {
-  if (enabled()) {
+bool CacheIRSpewer::init(const char* filename) {MOZ_RELEASE_ASSERT(0);
+  if (enabled()) {MOZ_RELEASE_ASSERT(0);
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   char name[256];
   uint32_t pid = getpid();
   // Default to JIT_SPEW_DIR/cacheir${pid}.json
-  if (filename[0] == '1') {
+  if (filename[0] == '1') {MOZ_RELEASE_ASSERT(0);
     SprintfLiteral(name, JIT_SPEW_DIR "/cacheir%" PRIu32 ".json", pid);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     SprintfLiteral(name, "%s%" PRIu32 ".json", filename, pid);
   }
 
@@ -324,7 +324,7 @@ bool CacheIRSpewer::init(const char* fil
   return true;
 }
 
-void CacheIRSpewer::beginCache(const IRGenerator& gen) {
+void CacheIRSpewer::beginCache(const IRGenerator& gen) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(enabled());
   JSONPrinter& j = json_.ref();
   const char* filename = gen.script_->filename();
@@ -341,16 +341,16 @@ void CacheIRSpewer::beginCache(const IRG
 }
 
 template <typename CharT>
-static void QuoteString(GenericPrinter& out, const CharT* s, size_t length) {
+static void QuoteString(GenericPrinter& out, const CharT* s, size_t length) {MOZ_RELEASE_ASSERT(0);
   const CharT* end = s + length;
-  for (const CharT* t = s; t < end; s = ++t) {
+  for (const CharT* t = s; t < end; s = ++t) {MOZ_RELEASE_ASSERT(0);
     // This quote implementation is probably correct,
     // but uses \u even when not strictly necessary.
     char16_t c = *t;
-    if (c == '"' || c == '\\') {
+    if (c == '"' || c == '\\') {MOZ_RELEASE_ASSERT(0);
       out.printf("\\");
       out.printf("%c", char(c));
-    } else if (!IsAsciiPrintable(c)) {
+    } else if (!IsAsciiPrintable(c)) {MOZ_RELEASE_ASSERT(0);
       out.printf("\\u%04x", c);
     } else {
       out.printf("%c", char(c));
@@ -358,66 +358,66 @@ static void QuoteString(GenericPrinter& 
   }
 }
 
-static void QuoteString(GenericPrinter& out, JSLinearString* str) {
+static void QuoteString(GenericPrinter& out, JSLinearString* str) {MOZ_RELEASE_ASSERT(0);
   JS::AutoCheckCannotGC nogc;
 
   // Limit the string length to reduce the JSON file size.
   size_t length = std::min(str->length(), size_t(128));
-  if (str->hasLatin1Chars()) {
+  if (str->hasLatin1Chars()) {MOZ_RELEASE_ASSERT(0);
     QuoteString(out, str->latin1Chars(nogc), length);
   } else {
     QuoteString(out, str->twoByteChars(nogc), length);
   }
 }
 
-void CacheIRSpewer::valueProperty(const char* name, const Value& v) {
+void CacheIRSpewer::valueProperty(const char* name, const Value& v) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(enabled());
   JSONPrinter& j = json_.ref();
 
   j.beginObjectProperty(name);
 
   const char* type = InformalValueTypeName(v);
-  if (v.isInt32()) {
+  if (v.isInt32()) {MOZ_RELEASE_ASSERT(0);
     type = "int32";
-  }
+  }MOZ_RELEASE_ASSERT(0);
   j.property("type", type);
 
-  if (v.isInt32()) {
+  if (v.isInt32()) {MOZ_RELEASE_ASSERT(0);
     j.property("value", v.toInt32());
-  } else if (v.isDouble()) {
+  } else if (v.isDouble()) {MOZ_RELEASE_ASSERT(0);
     j.floatProperty("value", v.toDouble(), 3);
-  } else if (v.isString() || v.isSymbol()) {
+  } else if (v.isString() || v.isSymbol()) {MOZ_RELEASE_ASSERT(0);
     JSString* str = v.isString() ? v.toString() : v.toSymbol()->description();
-    if (str && str->isLinear()) {
+    if (str && str->isLinear()) {MOZ_RELEASE_ASSERT(0);
       j.beginStringProperty("value");
       QuoteString(output_, &str->asLinear());
       j.endStringProperty();
     }
-  } else if (v.isObject()) {
+  } else if (v.isObject()) {MOZ_RELEASE_ASSERT(0);
     JSObject& object = v.toObject();
     j.formatProperty("value", "%p (shape: %p)", &object, object.shape());
 
-    if (object.is<JSFunction>()) {
-      if (JSAtom* name = object.as<JSFunction>().displayAtom()) {
+    if (object.is<JSFunction>()) {MOZ_RELEASE_ASSERT(0);
+      if (JSAtom* name = object.as<JSFunction>().displayAtom()) {MOZ_RELEASE_ASSERT(0);
         j.beginStringProperty("funName");
         QuoteString(output_, name);
         j.endStringProperty();
-      }
-    }
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
 
     if (NativeObject* nobj =
-            object.is<NativeObject>() ? &object.as<NativeObject>() : nullptr) {
+            object.is<NativeObject>() ? &object.as<NativeObject>() : nullptr) {MOZ_RELEASE_ASSERT(0);
       j.beginListProperty("flags");
       {
-        if (nobj->isIndexed()) {
+        if (nobj->isIndexed()) {MOZ_RELEASE_ASSERT(0);
           j.value("indexed");
         }
-        if (nobj->inDictionaryMode()) {
+        if (nobj->inDictionaryMode()) {MOZ_RELEASE_ASSERT(0);
           j.value("dictionaryMode");
         }
-      }
+      }MOZ_RELEASE_ASSERT(0);
       j.endList();
-      if (nobj->isIndexed()) {
+      if (nobj->isIndexed()) {MOZ_RELEASE_ASSERT(0);
         j.beginObjectProperty("indexed");
         {
           j.property("denseInitializedLength",
diff --git a/js/src/jit/CodeGenerator.cpp b/js/src/jit/CodeGenerator.cpp
--- a/js/src/jit/CodeGenerator.cpp
+++ b/js/src/jit/CodeGenerator.cpp
@@ -992,7 +992,7 @@ void CodeGenerator::visitValueToInt32(LV
                               oolDouble->entry(), stringReg, temp, output,
                               &fails);
     masm.bind(oolDouble->rejoin());
-  } else if (lir->mode() == LValueToInt32::TRUNCATE_NOWRAP) {
+  } else if (lir->mode() == LValueToInt32::TRUNCATE_NOWRAP) {MOZ_RELEASE_ASSERT(0);
     auto* ool = new (alloc()) OutOfLineZeroIfNaN(lir, temp, output);
     addOutOfLineCode(ool, lir->mir());
 
@@ -1008,7 +1008,7 @@ void CodeGenerator::visitValueToInt32(LV
   bailoutFrom(&fails, lir->snapshot());
 }
 
-void CodeGenerator::visitOutOfLineZeroIfNaN(OutOfLineZeroIfNaN* ool) {
+void CodeGenerator::visitOutOfLineZeroIfNaN(OutOfLineZeroIfNaN* ool) {MOZ_RELEASE_ASSERT(0);
   FloatRegister input = ool->input();
   Register output = ool->output();
 
@@ -1016,7 +1016,7 @@ void CodeGenerator::visitOutOfLineZeroIf
   // x64, and ARM64, so handle it here. In all other cases bail out.
 
   Label fails;
-  if (input.isSingle()) {
+  if (input.isSingle()) {MOZ_RELEASE_ASSERT(0);
     masm.branchFloat(Assembler::DoubleOrdered, input, input, &fails);
   } else {
     masm.branchDouble(Assembler::DoubleOrdered, input, input, &fails);
@@ -1451,7 +1451,7 @@ void CodeGenerator::testValueTruthyKerne
     }
 
     masm.bind(&notObject);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     masm.branchTestObject(Assembler::Equal, tag, ifTruthy);
   }
 
@@ -1673,7 +1673,7 @@ void CodeGenerator::visitValueToString(L
     // Object
     if (lir->mir()->supportSideEffects()) {
       masm.branchTestObject(Assembler::Equal, tag, ool->entry());
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       // Bail.
       MOZ_ASSERT(lir->mir()->needsSnapshot());
       Label bail;
@@ -1684,7 +1684,7 @@ void CodeGenerator::visitValueToString(L
     // Symbol
     if (lir->mir()->supportSideEffects()) {
       masm.branchTestSymbol(Assembler::Equal, tag, ool->entry());
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       // Bail.
       MOZ_ASSERT(lir->mir()->needsSnapshot());
       Label bail;
@@ -1728,7 +1728,7 @@ static void EmitStoreBufferMutation(Macr
   masm.computeEffectiveAddress(Address(holder, offset), addrReg);
 
   bool needExtraReg = !regs.hasAny<GeneralRegisterSet::DefaultType>();
-  if (needExtraReg) {
+  if (needExtraReg) {MOZ_RELEASE_ASSERT(0);
     masm.push(holder);
     masm.setupUnalignedABICall(holder);
   } else {
@@ -2135,7 +2135,7 @@ static bool PrepareAndExecuteRegExp(JSCo
   }
 
 #ifdef JS_TRACE_LOGGING
-  if (TraceLogTextIdEnabled(TraceLogger_IrregexpExecute)) {
+  if (TraceLogTextIdEnabled(TraceLogger_IrregexpExecute)) {MOZ_RELEASE_ASSERT(0);
     masm.loadTraceLogger(temp2);
     masm.tracelogStartId(temp2, TraceLogger_IrregexpExecute);
   }
@@ -2152,7 +2152,7 @@ static bool PrepareAndExecuteRegExp(JSCo
   masm.PopRegsInMask(volatileRegs);
 
 #ifdef JS_TRACE_LOGGING
-  if (TraceLogTextIdEnabled(TraceLogger_IrregexpExecute)) {
+  if (TraceLogTextIdEnabled(TraceLogger_IrregexpExecute)) {MOZ_RELEASE_ASSERT(0);
     masm.loadTraceLogger(temp2);
     masm.tracelogStopId(temp2, TraceLogger_IrregexpExecute);
   }
@@ -2495,7 +2495,7 @@ JitCode* JitRealm::generateRegExpMatcher
 
   ArrayObject* templateObject =
       cx->realm()->regExps.getOrCreateMatchResultTemplateObject(cx);
-  if (!templateObject) {
+  if (!templateObject) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   TemplateObject templateObj(templateObject);
@@ -2519,7 +2519,7 @@ JitCode* JitRealm::generateRegExpMatcher
   Label notFound, oolEntry;
   if (!PrepareAndExecuteRegExp(cx, masm, regexp, input, lastIndex, temp1, temp2,
                                temp3, inputOutputDataStartOffset,
-                               stringsCanBeInNursery, &notFound, &oolEntry)) {
+                               stringsCanBeInNursery, &notFound, &oolEntry)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2628,7 +2628,7 @@ JitCode* JitRealm::generateRegExpMatcher
                            pairsVectorStartOffset + offsetof(MatchPair, limit));
 
   Register temp5;
-  if (maybeTemp5 == InvalidReg) {
+  if (maybeTemp5 == InvalidReg) {MOZ_RELEASE_ASSERT(0);
     // We don't have enough registers for a fifth temporary. Reuse
     // |lastIndex| as a temporary. We don't need to restore its value,
     // because |lastIndex| is no longer used after a successful match.
@@ -2858,7 +2858,7 @@ JitCode* JitRealm::generateRegExpSearche
   Label notFound, oolEntry;
   if (!PrepareAndExecuteRegExp(cx, masm, regexp, input, lastIndex, temp1, temp2,
                                temp3, inputOutputDataStartOffset,
-                               stringsCanBeInNursery, &notFound, &oolEntry)) {
+                               stringsCanBeInNursery, &notFound, &oolEntry)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3032,7 +3032,7 @@ JitCode* JitRealm::generateRegExpTesterS
   Label notFound, oolEntry;
   if (!PrepareAndExecuteRegExp(cx, masm, regexp, input, lastIndex, temp1, temp2,
                                temp3, 0, stringsCanBeInNursery, &notFound,
-                               &oolEntry)) {
+                               &oolEntry)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3305,13 +3305,13 @@ void CodeGenerator::visitStringReplace(L
     pushArg(ToRegister(lir->replacement()));
   }
 
-  if (lir->pattern()->isConstant()) {
+  if (lir->pattern()->isConstant()) {MOZ_RELEASE_ASSERT(0);
     pushArg(ImmGCPtr(lir->pattern()->toConstant()->toString()));
   } else {
     pushArg(ToRegister(lir->pattern()));
   }
 
-  if (lir->string()->isConstant()) {
+  if (lir->string()->isConstant()) {MOZ_RELEASE_ASSERT(0);
     pushArg(ImmGCPtr(lir->string()->toConstant()->toString()));
   } else {
     pushArg(ToRegister(lir->string()));
@@ -3319,7 +3319,7 @@ void CodeGenerator::visitStringReplace(L
 
   using Fn =
       JSString* (*)(JSContext*, HandleString, HandleString, HandleString);
-  if (lir->mir()->isFlatReplacement()) {
+  if (lir->mir()->isFlatReplacement()) {MOZ_RELEASE_ASSERT(0);
     callVM<Fn, StringFlatReplaceString>(lir);
   } else {
     callVM<Fn, StringReplace>(lir);
@@ -3666,7 +3666,7 @@ void CodeGenerator::visitOsrEntry(LOsrEn
   setOsrEntryOffset(masm.size());
 
 #ifdef JS_TRACE_LOGGING
-  if (JS::TraceLoggerSupported()) {
+  if (JS::TraceLoggerSupported()) {MOZ_RELEASE_ASSERT(0);
     emitTracelogStopEvent(TraceLogger_Baseline);
     emitTracelogStartEvent(TraceLogger_IonMonkey);
   }
@@ -3764,7 +3764,7 @@ void CodeGenerator::visitStackArgV(LStac
 }
 
 void CodeGenerator::visitMoveGroup(LMoveGroup* group) {
-  if (!group->numMoves()) {
+  if (!group->numMoves()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -3815,7 +3815,7 @@ void CodeGenerator::visitMoveGroup(LMove
   }
 
   masm.propagateOOM(resolver.resolve());
-  if (masm.oom()) {
+  if (masm.oom()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -4479,7 +4479,7 @@ void CodeGenerator::visitStringToInt64(L
   emitStringToInt64(lir, input, output);
 }
 
-void CodeGenerator::visitValueToInt64(LValueToInt64* lir) {
+void CodeGenerator::visitValueToInt64(LValueToInt64* lir) {MOZ_RELEASE_ASSERT(0);
   ValueOperand input = ToValue(lir, LValueToInt64::Input);
   Register temp = ToRegister(lir->temp());
   Register64 output = ToOutRegister64(lir);
@@ -4507,14 +4507,14 @@ void CodeGenerator::visitValueToInt64(LV
   Register tag = masm.extractTag(input, temp);
 
   // BigInt.
-  emitTestAndUnbox([&](Label* target) {
+  emitTestAndUnbox([&](Label* target) {MOZ_RELEASE_ASSERT(0);
     masm.branchTestBigInt(Assembler::NotEqual, tag, target);
     masm.unboxBigInt(input, temp);
     masm.loadBigInt64(temp, output);
   });
 
   // Boolean
-  emitTestAndUnbox([&](Label* target) {
+  emitTestAndUnbox([&](Label* target) {MOZ_RELEASE_ASSERT(0);
     masm.branchTestBoolean(Assembler::NotEqual, tag, target);
     masm.unboxBoolean(input, temp);
     masm.move32To64ZeroExtend(temp, output);
@@ -4936,7 +4936,7 @@ void CodeGenerator::visitOutOfLineCallPo
   AllocatableGeneralRegisterSet regs(GeneralRegisterSet::Volatile());
   regs.takeUnchecked(indexreg);
 
-  if (obj->isConstant()) {
+  if (obj->isConstant()) {MOZ_RELEASE_ASSERT(0);
     objreg = regs.takeAny();
     masm.movePtr(ImmGCPtr(&obj->toConstant()->toObject()), objreg);
   } else {
@@ -5041,7 +5041,7 @@ void CodeGenerator::visitCallNative(LCal
 
   markSafepointAt(safepointOffset, call);
 
-  if (JS::TraceLoggerSupported()) {
+  if (JS::TraceLoggerSupported()) {MOZ_RELEASE_ASSERT(0);
     emitTracelogStartEvent(TraceLogger_Call);
   }
 
@@ -5060,7 +5060,7 @@ void CodeGenerator::visitCallNative(LCal
   masm.callWithABI(DynamicFunction<JSNative>(native), MoveOp::GENERAL,
                    CheckUnsafeCallWithABI::DontCheckHasExitFrame);
 
-  if (JS::TraceLoggerSupported()) {
+  if (JS::TraceLoggerSupported()) {MOZ_RELEASE_ASSERT(0);
     emitTracelogStopEvent(TraceLogger_Call);
   }
 
@@ -5100,7 +5100,7 @@ static void LoadDOMPrivate(MacroAssemble
 
   // Check if it's a proxy.
   Label isProxy, done;
-  if (kind == DOMObjectKind::Unknown) {
+  if (kind == DOMObjectKind::Unknown) {MOZ_RELEASE_ASSERT(0);
     masm.branchTestObjectIsProxy(true, obj, priv, &isProxy);
   }
 
@@ -5108,7 +5108,7 @@ static void LoadDOMPrivate(MacroAssemble
     // If it's a native object, the value must be in a fixed slot.
     masm.debugAssertObjHasFixedSlots(obj, priv);
     masm.loadPrivate(Address(obj, NativeObject::getFixedSlotOffset(0)), priv);
-    if (kind == DOMObjectKind::Unknown) {
+    if (kind == DOMObjectKind::Unknown) {MOZ_RELEASE_ASSERT(0);
       masm.jump(&done);
     }
   }
@@ -5197,7 +5197,7 @@ void CodeGenerator::visitCallDOMNative(L
   masm.Push(argObj);
   masm.moveStackPtrTo(argObj);
 
-  if (call->mir()->maybeCrossRealm()) {
+  if (call->mir()->maybeCrossRealm()) {MOZ_RELEASE_ASSERT(0);
     // We use argJSContext as scratch register here.
     masm.movePtr(ImmGCPtr(target->rawNativeJSFunction()), argJSContext);
     masm.switchToObjectRealm(argJSContext, argJSContext);
@@ -5238,7 +5238,7 @@ void CodeGenerator::visitCallDOMNative(L
 
   // Switch back to the current realm if needed. Note: if the DOM method threw
   // an exception, the exception handler will do this.
-  if (call->mir()->maybeCrossRealm()) {
+  if (call->mir()->maybeCrossRealm()) {MOZ_RELEASE_ASSERT(0);
     static_assert(!JSReturnOperand.aliases(ReturnReg),
                   "Clobbering ReturnReg should not affect the return value");
     masm.switchToRealm(gen->realm->realmPtr(), ReturnReg);
@@ -5427,7 +5427,7 @@ void CodeGenerator::visitCallKnown(LCall
 
   masm.checkStackAlignment();
 
-  if (target->isClassConstructor() && !call->isConstructing()) {
+  if (target->isClassConstructor() && !call->isConstructing()) {MOZ_RELEASE_ASSERT(0);
     emitCallInvokeFunction(call, calleereg, call->isConstructing(),
                            call->ignoresReturnValue(), call->numActualArgs(),
                            unusedStack);
@@ -6156,12 +6156,12 @@ IonScriptCounts* CodeGenerator::maybeCre
   // addresses, (2) wasm code does not have a JSScript with which to associate
   // code coverage data.
   JSScript* script = gen->outerInfo().script();
-  if (!script) {
+  if (!script) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   auto counts = MakeUnique<IonScriptCounts>();
-  if (!counts || !counts->init(graph.numBlocks())) {
+  if (!counts || !counts->init(graph.numBlocks())) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -6192,7 +6192,7 @@ IonScriptCounts* CodeGenerator::maybeCre
     }
 
     if (!counts->block(i).init(block->id(), offset, description,
-                               block->numSuccessors())) {
+                               block->numSuccessors())) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -6513,7 +6513,7 @@ bool CodeGenerator::generateBody() {
     mozilla::Maybe<ScriptCountBlockState> blockCounts;
     if (counts) {
       blockCounts.emplace(&counts->block(i), &masm);
-      if (!blockCounts->init()) {
+      if (!blockCounts->init()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -6526,7 +6526,7 @@ bool CodeGenerator::generateBody() {
 
     for (LInstructionIterator iter = current->begin(); iter != current->end();
          iter++) {
-      if (!alloc().ensureBallast()) {
+      if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -6550,7 +6550,7 @@ bool CodeGenerator::generateBody() {
 
       if (!compilingWasm) {
         if (MDefinition* mir = iter->mirRaw()) {
-          if (!addNativeToBytecodeEntry(mir->trackedSite())) {
+          if (!addNativeToBytecodeEntry(mir->trackedSite())) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -6932,7 +6932,7 @@ void CodeGenerator::visitNewObjectVMCall
 }
 
 static bool ShouldInitFixedSlots(LInstruction* lir, const TemplateObject& obj) {
-  if (!obj.isNativeObject()) {
+  if (!obj.isNativeObject()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
   const TemplateNativeObject& templateObj = obj.asTemplateNativeObject();
@@ -6981,7 +6981,7 @@ static bool ShouldInitFixedSlots(LInstru
 
       if (iter->isStoreFixedSlot()) {
         MStoreFixedSlot* store = iter->toStoreFixedSlot();
-        if (store->object() != allocMir) {
+        if (store->object() != allocMir) {MOZ_RELEASE_ASSERT(0);
           return true;
         }
 
@@ -7392,7 +7392,7 @@ void CodeGenerator::visitGuardArgumentsO
   bailoutFrom(&bail, lir->snapshot());
 }
 
-void CodeGenerator::visitReturnFromCtor(LReturnFromCtor* lir) {
+void CodeGenerator::visitReturnFromCtor(LReturnFromCtor* lir) {MOZ_RELEASE_ASSERT(0);
   ValueOperand value = ToValue(lir, LReturnFromCtor::ValueIndex);
   Register obj = ToRegister(lir->getObject());
   Register output = ToRegister(lir->output());
@@ -8244,7 +8244,7 @@ void CodeGenerator::visitMathFunctionD(L
                    MoveOp::DOUBLE);
 }
 
-void CodeGenerator::visitMathFunctionF(LMathFunctionF* ins) {
+void CodeGenerator::visitMathFunctionF(LMathFunctionF* ins) {MOZ_RELEASE_ASSERT(0);
   Register temp = ToRegister(ins->temp());
   FloatRegister input = ToFloatRegister(ins->input());
   MOZ_ASSERT(ToFloatRegister(ins->output()) == ReturnFloat32Reg);
@@ -10201,26 +10201,26 @@ bool JitRuntime::generateTLEventVM(Macro
   bool vmEventEnabled = TraceLogTextIdEnabled(TraceLogger_VM);
   bool vmSpecificEventEnabled = TraceLogTextIdEnabled(TraceLogger_VMSpecific);
 
-  if (vmEventEnabled || vmSpecificEventEnabled) {
+  if (vmEventEnabled || vmSpecificEventEnabled) {MOZ_RELEASE_ASSERT(0);
     AllocatableRegisterSet regs(RegisterSet::Volatile());
     Register loggerReg = regs.takeAnyGeneral();
     masm.Push(loggerReg);
     masm.loadTraceLogger(loggerReg);
 
-    if (vmEventEnabled) {
-      if (enter) {
+    if (vmEventEnabled) {MOZ_RELEASE_ASSERT(0);
+      if (enter) {MOZ_RELEASE_ASSERT(0);
         masm.tracelogStartId(loggerReg, TraceLogger_VM, /* force = */ true);
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         masm.tracelogStopId(loggerReg, TraceLogger_VM, /* force = */ true);
-      }
-    }
-    if (vmSpecificEventEnabled) {
+      }MOZ_RELEASE_ASSERT(0);
+    }
+    if (vmSpecificEventEnabled) {MOZ_RELEASE_ASSERT(0);
       TraceLoggerEvent event(f.name());
-      if (!event.hasTextId()) {
+      if (!event.hasTextId()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
-      if (enter) {
+      if (enter) {MOZ_RELEASE_ASSERT(0);
         masm.tracelogStartId(loggerReg, event.textId(), /* force = */ true);
       } else {
         masm.tracelogStopId(loggerReg, event.textId(), /* force = */ true);
@@ -10478,7 +10478,7 @@ void CodeGenerator::visitBoundsCheck(LBo
       uint32_t len = ToInt32(lir->length());
       if (idx < len) {
         return;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       bailout(snapshot);
       return;
     }
@@ -10541,7 +10541,7 @@ void CodeGenerator::visitBoundsCheckRang
         bailoutCmpConstant(Assembler::BelowOrEqual, ToAddress(length), nmax);
       }
       return;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     masm.mov(ImmWord(index), temp);
   } else {
     masm.mov(ToRegister(lir->index()), temp);
@@ -10568,9 +10568,9 @@ void CodeGenerator::visitBoundsCheckRang
       if (SafeSub(max, min, &diff)) {
         max = diff;
       } else {
-        if (type == MIRType::Int32) {
+        if (type == MIRType::Int32) {MOZ_RELEASE_ASSERT(0);
           masm.sub32(Imm32(min), temp);
-        } else {
+        } else {MOZ_RELEASE_ASSERT(0);
           masm.subPtr(Imm32(min), temp);
         }
       }
@@ -10661,7 +10661,7 @@ void CodeGenerator::emitStoreHoleCheck(R
                                        const LAllocation* index,
                                        LSnapshot* snapshot) {
   Label bail;
-  if (index->isConstant()) {
+  if (index->isConstant()) {MOZ_RELEASE_ASSERT(0);
     Address dest(elements, ToInt32(index) * sizeof(js::Value));
     masm.branchTestMagic(Assembler::Equal, dest, &bail);
   } else {
@@ -10869,7 +10869,7 @@ void CodeGenerator::visitOutOfLineStoreE
 
   pushArg(Imm32(ool->strict()));
   pushArg(value.ref());
-  if (index->isConstant()) {
+  if (index->isConstant()) {MOZ_RELEASE_ASSERT(0);
     pushArg(Imm32(ToInt32(index)));
   } else {
     pushArg(ToRegister(index));
@@ -11125,7 +11125,7 @@ void CodeGenerator::emitRest(LInstructio
   }
   masm.bind(&joinLength);
 
-  if (saveAndRestore) {
+  if (saveAndRestore) {MOZ_RELEASE_ASSERT(0);
     saveLive(lir);
   }
 
@@ -11221,7 +11221,7 @@ static bool CreateStackMapFromLSafepoint
     // associated with a trap.  For safepoints associated with a call, we
     // don't expect to have any live values in registers, hence no roots in
     // registers.
-    if (!vec.appendN(false, trapExitLayoutNumWords)) {
+    if (!vec.appendN(false, trapExitLayoutNumWords)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     for (; gcRegsIter.more(); ++gcRegsIter) {
@@ -11251,7 +11251,7 @@ static bool CreateStackMapFromLSafepoint
   // BODY (GENERAL SPILL) AREA and FRAME and INCOMING ARGS
   // Deal with roots on the stack.
   size_t wordsSoFar = vec.length();
-  if (!vec.appendN(false, nNonTrapBytes / sizeof(void*))) {
+  if (!vec.appendN(false, nNonTrapBytes / sizeof(void*))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   const LSafepoint::SlotList& gcSlots = safepoint.gcSlots();
@@ -11287,7 +11287,7 @@ static bool CreateStackMapFromLSafepoint
   MOZ_ASSERT(vec.length() * sizeof(void*) == nTotalBytes);
   wasm::StackMap* stackMap =
       wasm::ConvertStackMapBoolVectorToStackMap(vec, hasRefs);
-  if (!stackMap) {
+  if (!stackMap) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (safepoint.isWasmTrap()) {
@@ -11338,7 +11338,7 @@ bool CodeGenerator::generateWasm(wasm::T
     if (!CreateStackMapForFunctionEntryTrap(
             argTypes, trapExitLayout, trapExitLayoutNumWords,
             nBytesReservedBeforeTrap, nInboundStackArgBytes,
-            &functionEntryStackMap)) {
+            &functionEntryStackMap)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -11348,7 +11348,7 @@ bool CodeGenerator::generateWasm(wasm::T
 
     if (functionEntryStackMap &&
         !stackMaps->add((uint8_t*)(uintptr_t)trapInsnOffset.offset(),
-                        functionEntryStackMap)) {
+                        functionEntryStackMap)) {MOZ_RELEASE_ASSERT(0);
       functionEntryStackMap->destroy();
       return false;
     }
@@ -11356,7 +11356,7 @@ bool CodeGenerator::generateWasm(wasm::T
 
   MOZ_ASSERT(masm.framePushed() == frameSize());
 
-  if (!generateBody()) {
+  if (!generateBody()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11368,12 +11368,12 @@ bool CodeGenerator::generateWasm(wasm::T
   gen->perfSpewer().noteEndInlineCode(masm);
 #endif
 
-  if (!generateOutOfLineCode()) {
+  if (!generateOutOfLineCode()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   masm.flush();
-  if (masm.oom()) {
+  if (masm.oom()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11396,7 +11396,7 @@ bool CodeGenerator::generateWasm(wasm::T
     wasm::StackMap* stackMap = nullptr;
     if (!CreateStackMapFromLSafepoint(*index.safepoint(), trapExitLayout,
                                       trapExitLayoutNumWords,
-                                      nInboundStackArgBytes, &stackMap)) {
+                                      nInboundStackArgBytes, &stackMap)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -11426,42 +11426,42 @@ bool CodeGenerator::generate() {
   InlineScriptTree* tree = gen->outerInfo().inlineScriptTree();
   jsbytecode* startPC = tree->script()->code();
   BytecodeSite* startSite = new (gen->alloc()) BytecodeSite(tree, startPC);
-  if (!addNativeToBytecodeEntry(startSite)) {
+  if (!addNativeToBytecodeEntry(startSite)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!safepoints_.init(gen->alloc())) {
+  if (!safepoints_.init(gen->alloc())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!generatePrologue()) {
+  if (!generatePrologue()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (frameClass_ != FrameSizeClass::None()) {
+  if (frameClass_ != FrameSizeClass::None()) {MOZ_RELEASE_ASSERT(0);
     deoptTable_.emplace(gen->jitRuntime()->getBailoutTable(frameClass_));
   }
 
   // Reset native => bytecode map table with top-level script and startPc.
-  if (!addNativeToBytecodeEntry(startSite)) {
+  if (!addNativeToBytecodeEntry(startSite)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!generateBody()) {
+  if (!generateBody()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Reset native => bytecode map table with top-level script and startPc.
-  if (!addNativeToBytecodeEntry(startSite)) {
+  if (!addNativeToBytecodeEntry(startSite)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!generateEpilogue()) {
+  if (!generateEpilogue()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Reset native => bytecode map table with top-level script and startPc.
-  if (!addNativeToBytecodeEntry(startSite)) {
+  if (!addNativeToBytecodeEntry(startSite)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11473,7 +11473,7 @@ bool CodeGenerator::generate() {
 
   // native => bytecode entries for OOL code will be added
   // by CodeGeneratorShared::generateOutOfLineCode
-  if (!generateOutOfLineCode()) {
+  if (!generateOutOfLineCode()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11538,7 +11538,7 @@ bool CodeGenerator::link(JSContext* cx, 
   jr->performStubReadBarriers(realmStubsToReadBarrier_);
 
   if (scriptCounts_ && !script->hasScriptCounts() &&
-      !script->initScriptCounts(cx)) {
+      !script->initScriptCounts(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11560,7 +11560,7 @@ bool CodeGenerator::link(JSContext* cx, 
 
   // If an inlined script is invalidated (for example, by attaching
   // a debugger), we must also invalidate the parent IonScript.
-  if (!AddInlinedCompilations(cx, script, compilationId, snapshot, &isValid)) {
+  if (!AddInlinedCompilations(cx, script, compilationId, snapshot, &isValid)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!isValid) {
@@ -11571,9 +11571,9 @@ bool CodeGenerator::link(JSContext* cx, 
   // compilation. Since adding the new information to the actual type
   // information can reset the usecount, increase it back to what it was
   // before.
-  if (warmUpCount > script->getWarmUpCount()) {
+  if (warmUpCount > script->getWarmUpCount()) {MOZ_RELEASE_ASSERT(0);
     script->incWarmUpCounter(warmUpCount - script->getWarmUpCount());
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   uint32_t argumentSlots = (gen->outerInfo().nargs() + 1) * sizeof(Value);
   uint32_t scriptFrameSize =
@@ -11582,7 +11582,7 @@ bool CodeGenerator::link(JSContext* cx, 
           : FrameSizeClass::FromDepth(frameDepth_).frameSize();
 
   // We encode safepoints after the OSI-point offsets have been determined.
-  if (!encodeSafepoints()) {
+  if (!encodeSafepoints()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11594,7 +11594,7 @@ bool CodeGenerator::link(JSContext* cx, 
       bailouts_.length(), graph.numConstants(), numNurseryObjects,
       safepointIndices_.length(), osiIndices_.length(), icList_.length(),
       runtimeData_.length(), safepoints_.size());
-  if (!ionScript) {
+  if (!ionScript) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 #ifdef DEBUG
@@ -11609,14 +11609,14 @@ bool CodeGenerator::link(JSContext* cx, 
 
   Linker linker(masm);
   JitCode* code = linker.newCode(cx, CodeKind::Ion);
-  if (!code) {
+  if (!code) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Encode native to bytecode map if profiling is enabled.
   if (isProfilerInstrumentationEnabled()) {
     // Generate native-to-bytecode main table.
-    if (!generateCompactNativeToBytecodeMap(cx, code)) {
+    if (!generateCompactNativeToBytecodeMap(cx, code)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -11627,7 +11627,7 @@ bool CodeGenerator::link(JSContext* cx, 
     // Construct the IonEntry that will go into the global table.
     JitcodeGlobalEntry::IonEntry entry;
     if (!ionTable->makeIonEntry(cx, code, nativeToBytecodeScriptListLength_,
-                                nativeToBytecodeScriptList_, entry)) {
+                                nativeToBytecodeScriptList_, entry)) {MOZ_RELEASE_ASSERT(0);
       js_free(nativeToBytecodeScriptList_);
       js_free(nativeToBytecodeMap_);
       return false;
@@ -11639,7 +11639,7 @@ bool CodeGenerator::link(JSContext* cx, 
     // Add entry to the global table.
     JitcodeGlobalTable* globalTable =
         cx->runtime()->jitRuntime()->getJitcodeGlobalTable();
-    if (!globalTable->addEntry(entry)) {
+    if (!globalTable->addEntry(entry)) {MOZ_RELEASE_ASSERT(0);
       // Memory may have been allocated for the entry.
       entry.destroy();
       return false;
@@ -11655,7 +11655,7 @@ bool CodeGenerator::link(JSContext* cx, 
     // Add entry to the global table.
     JitcodeGlobalTable* globalTable =
         cx->runtime()->jitRuntime()->getJitcodeGlobalTable();
-    if (!globalTable->addEntry(entry)) {
+    if (!globalTable->addEntry(entry)) {MOZ_RELEASE_ASSERT(0);
       // Memory may have been allocated for the entry.
       entry.destroy();
       return false;
@@ -11677,7 +11677,7 @@ bool CodeGenerator::link(JSContext* cx, 
       CodeLocationLabel(code, invalidateEpilogueData_), ImmPtr(ionScript),
       ImmPtr((void*)-1));
 
-  for (CodeOffset offset : ionScriptLabels_) {
+  for (CodeOffset offset : ionScriptLabels_) {MOZ_RELEASE_ASSERT(0);
     Assembler::PatchDataWithValueCheck(CodeLocationLabel(code, offset),
                                        ImmPtr(ionScript), ImmPtr((void*)-1));
   }
@@ -11692,31 +11692,31 @@ bool CodeGenerator::link(JSContext* cx, 
   bool TLFailed = false;
 
   MOZ_ASSERT_IF(!JS::TraceLoggerSupported(), patchableTLEvents_.length() == 0);
-  for (uint32_t i = 0; i < patchableTLEvents_.length(); i++) {
+  for (uint32_t i = 0; i < patchableTLEvents_.length(); i++) {MOZ_RELEASE_ASSERT(0);
     TraceLoggerEvent event(patchableTLEvents_[i].event);
-    if (!event.hasTextId() || !ionScript->addTraceLoggerEvent(event)) {
+    if (!event.hasTextId() || !ionScript->addTraceLoggerEvent(event)) {MOZ_RELEASE_ASSERT(0);
       TLFailed = true;
       break;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     Assembler::PatchDataWithValueCheck(
         CodeLocationLabel(code, patchableTLEvents_[i].offset),
         ImmPtr((void*)uintptr_t(event.textId())), ImmPtr((void*)0));
   }
 
-  if (!TLFailed && patchableTLScripts_.length() > 0) {
+  if (!TLFailed && patchableTLScripts_.length() > 0) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(TraceLogTextIdEnabled(TraceLogger_Scripts));
     TraceLoggerEvent event(TraceLogger_Scripts, script);
-    if (!event.hasTextId() || !ionScript->addTraceLoggerEvent(event)) {
+    if (!event.hasTextId() || !ionScript->addTraceLoggerEvent(event)) {MOZ_RELEASE_ASSERT(0);
       TLFailed = true;
     }
-    if (!TLFailed) {
+    if (!TLFailed) {MOZ_RELEASE_ASSERT(0);
       uint32_t textId = event.textId();
-      for (uint32_t i = 0; i < patchableTLScripts_.length(); i++) {
+      for (uint32_t i = 0; i < patchableTLScripts_.length(); i++) {MOZ_RELEASE_ASSERT(0);
         Assembler::PatchDataWithValueCheck(
             CodeLocationLabel(code, patchableTLScripts_[i]),
             ImmPtr((void*)uintptr_t(textId)), ImmPtr((void*)0));
-      }
-    }
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
   }
 #endif
 
@@ -11768,7 +11768,7 @@ bool CodeGenerator::link(JSContext* cx, 
   }
 
   // for reconvering from an Ion Frame.
-  if (bailouts_.length()) {
+  if (bailouts_.length()) {MOZ_RELEASE_ASSERT(0);
     ionScript->copyBailoutTable(&bailouts_[0]);
   }
   if (osiIndices_.length()) {
@@ -11787,7 +11787,7 @@ bool CodeGenerator::link(JSContext* cx, 
     for (size_t i = 0; i < graph.numConstants(); i++) {
       const Value& v = vp[i];
       if (v.isGCThing()) {
-        if (gc::StoreBuffer* sb = v.toGCThing()->storeBuffer()) {
+        if (gc::StoreBuffer* sb = v.toGCThing()->storeBuffer()) {MOZ_RELEASE_ASSERT(0);
           sb->putWholeCell(script);
           break;
         }
@@ -11983,7 +11983,7 @@ void CodeGenerator::visitLoadElementAndU
   AnyRegister result = ToAnyRegister(ins->output());
 
   Label bail;
-  if (ins->index()->isConstant()) {
+  if (ins->index()->isConstant()) {MOZ_RELEASE_ASSERT(0);
     NativeObject::elementsSizeMustNotOverflow();
     int32_t offset = ToInt32(ins->index()) * sizeof(Value);
     Address address(elements, offset);
@@ -12421,7 +12421,7 @@ void CodeGenerator::visitLoadElementV(LL
   Register elements = ToRegister(load->elements());
   const ValueOperand out = ToOutValue(load);
 
-  if (load->index()->isConstant()) {
+  if (load->index()->isConstant()) {MOZ_RELEASE_ASSERT(0);
     NativeObject::elementsSizeMustNotOverflow();
     int32_t offset = ToInt32(load->index()) * sizeof(Value);
     masm.loadValue(Address(elements, offset), out);
@@ -12780,7 +12780,7 @@ class OutOfLineSwitch : public OutOfLine
   }
 
   // Register an entry in the switch table.
-  void addTableEntry(MacroAssembler& masm) {
+  void addTableEntry(MacroAssembler& masm) {MOZ_RELEASE_ASSERT(0);
     if ((!isOutOfLine_ && tableType == SwitchTableType::Inline) ||
         (isOutOfLine_ && tableType == SwitchTableType::OutOfLine)) {
       CodeLabel cl;
@@ -12800,11 +12800,11 @@ class OutOfLineSwitch : public OutOfLine
 
 template <SwitchTableType tableType>
 void CodeGenerator::visitOutOfLineSwitch(
-    OutOfLineSwitch<tableType>* jumpTable) {
+    OutOfLineSwitch<tableType>* jumpTable) {MOZ_RELEASE_ASSERT(0);
   jumpTable->setOutOfLine();
   auto& labels = jumpTable->labels();
 
-  if (tableType == SwitchTableType::OutOfLine) {
+  if (tableType == SwitchTableType::OutOfLine) {MOZ_RELEASE_ASSERT(0);
 #if defined(JS_CODEGEN_ARM)
     MOZ_CRASH("NYI: SwitchTableType::OutOfLine");
 #elif defined(JS_CODEGEN_NONE)
@@ -12823,11 +12823,11 @@ void CodeGenerator::visitOutOfLineSwitch
     // pointers to jump in the newly generated code.
     masm.bind(jumpTable->start());
     masm.addCodeLabel(*jumpTable->start());
-    for (size_t i = 0, e = labels.length(); i < e; i++) {
+    for (size_t i = 0, e = labels.length(); i < e; i++) {MOZ_RELEASE_ASSERT(0);
       jumpTable->addTableEntry(masm);
     }
 #endif
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Register all reserved pointers of the jump table to target labels. The
   // entries of the jump table need to be absolute addresses and thus must be
@@ -12962,7 +12962,7 @@ void CodeGenerator::visitStoreDataViewEl
   if (!noSwap) {
     // Swap the bytes in the loaded value.
     Label skip;
-    if (!littleEndian->isConstant()) {
+    if (!littleEndian->isConstant()) {MOZ_RELEASE_ASSERT(0);
       masm.branch32(
           MOZ_LITTLE_ENDIAN() ? Assembler::NotEqual : Assembler::Equal,
           ToRegister(littleEndian), Imm32(0), &skip);
@@ -12992,7 +12992,7 @@ void CodeGenerator::visitStoreDataViewEl
         MOZ_CRASH("Invalid typed array type");
     }
 
-    if (skip.used()) {
+    if (skip.used()) {MOZ_RELEASE_ASSERT(0);
       masm.bind(&skip);
     }
   }
@@ -13046,7 +13046,7 @@ void CodeGenerator::visitStoreTypedArray
 }
 
 void CodeGenerator::visitStoreTypedArrayElementHoleBigInt(
-    LStoreTypedArrayElementHoleBigInt* lir) {
+    LStoreTypedArrayElementHoleBigInt* lir) {MOZ_RELEASE_ASSERT(0);
   Register elements = ToRegister(lir->elements());
   Register value = ToRegister(lir->value());
   Register64 temp = ToRegister64(lir->temp());
@@ -13058,7 +13058,7 @@ void CodeGenerator::visitStoreTypedArray
   Register spectreTemp = temp.scratchReg();
 
   Label skip;
-  if (length->isRegister()) {
+  if (length->isRegister()) {MOZ_RELEASE_ASSERT(0);
     masm.spectreBoundsCheckPtr(index, ToRegister(length), spectreTemp, &skip);
   } else {
     masm.spectreBoundsCheckPtr(index, ToAddress(length), spectreTemp, &skip);
@@ -13133,7 +13133,7 @@ void CodeGenerator::visitInArray(LInArra
   if (lir->index()->isConstant()) {
     int32_t index = ToInt32(lir->index());
 
-    if (index < 0) {
+    if (index < 0) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(mir->needsNegativeIntCheck());
       bailout(lir->snapshot());
       return;
@@ -13183,7 +13183,7 @@ void CodeGenerator::visitGuardElementNot
   const LAllocation* index = lir->index();
 
   Label testMagic;
-  if (index->isConstant()) {
+  if (index->isConstant()) {MOZ_RELEASE_ASSERT(0);
     Address address(elements, ToInt32(index) * sizeof(js::Value));
     masm.branchTestMagic(Assembler::Equal, address, &testMagic);
   } else {
@@ -13339,7 +13339,7 @@ void CodeGenerator::visitGetDOMProperty(
     if (slot < NativeObject::MAX_FIXED_SLOTS) {
       masm.loadValue(Address(ObjectReg, NativeObject::getFixedSlotOffset(slot)),
                      JSReturnOperand);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       // It's a dynamic slot.
       slot -= NativeObject::MAX_FIXED_SLOTS;
       // Use PrivateReg as a scratch register for the slots pointer.
@@ -13371,7 +13371,7 @@ void CodeGenerator::visitGetDOMProperty(
   masm.moveStackPtrTo(ObjectReg);
 
   Realm* getterRealm = ins->mir()->getterRealm();
-  if (gen->realm->realmPtr() != getterRealm) {
+  if (gen->realm->realmPtr() != getterRealm) {MOZ_RELEASE_ASSERT(0);
     // We use JSContextReg as scratch register here.
     masm.switchToRealm(getterRealm, JSContextReg);
   }
@@ -13407,7 +13407,7 @@ void CodeGenerator::visitGetDOMProperty(
 
   // Switch back to the current realm if needed. Note: if the getter threw an
   // exception, the exception handler will do this.
-  if (gen->realm->realmPtr() != getterRealm) {
+  if (gen->realm->realmPtr() != getterRealm) {MOZ_RELEASE_ASSERT(0);
     static_assert(!JSReturnOperand.aliases(ReturnReg),
                   "Clobbering ReturnReg should not affect the return value");
     masm.switchToRealm(gen->realm->realmPtr(), ReturnReg);
@@ -13491,7 +13491,7 @@ void CodeGenerator::visitSetDOMProperty(
   masm.moveStackPtrTo(ObjectReg);
 
   Realm* setterRealm = ins->mir()->setterRealm();
-  if (gen->realm->realmPtr() != setterRealm) {
+  if (gen->realm->realmPtr() != setterRealm) {MOZ_RELEASE_ASSERT(0);
     // We use JSContextReg as scratch register here.
     masm.switchToRealm(setterRealm, JSContextReg);
   }
@@ -14098,29 +14098,29 @@ void CodeGenerator::visitAssertRangeF(LA
   emitAssertRangeD(r, temp, temp2);
 }
 
-void CodeGenerator::visitAssertRangeV(LAssertRangeV* ins) {
+void CodeGenerator::visitAssertRangeV(LAssertRangeV* ins) {MOZ_RELEASE_ASSERT(0);
   const Range* r = ins->range();
   const ValueOperand value = ToValue(ins, LAssertRangeV::Input);
   Label done;
 
-  {
+  {MOZ_RELEASE_ASSERT(0);
     ScratchTagScope tag(masm, value);
     masm.splitTagForTest(value, tag);
 
-    {
+    {MOZ_RELEASE_ASSERT(0);
       Label isNotInt32;
       masm.branchTestInt32(Assembler::NotEqual, tag, &isNotInt32);
-      {
+      {MOZ_RELEASE_ASSERT(0);
         ScratchTagScopeRelease _(&tag);
         Register unboxInt32 = ToTempUnboxRegister(ins->temp());
         Register input = masm.extractInt32(value, unboxInt32);
         emitAssertRangeI(MIRType::Int32, r, input);
         masm.jump(&done);
-      }
+      }MOZ_RELEASE_ASSERT(0);
       masm.bind(&isNotInt32);
     }
 
-    {
+    {MOZ_RELEASE_ASSERT(0);
       Label isNotDouble;
       masm.branchTestDouble(Assembler::NotEqual, tag, &isNotDouble);
       {
@@ -14580,7 +14580,7 @@ void CodeGenerator::visitNaNToZero(LNaNT
   OutOfLineNaNToZero* ool = new (alloc()) OutOfLineNaNToZero(lir);
   addOutOfLineCode(ool, lir->mir());
 
-  if (lir->mir()->operandIsNeverNegativeZero()) {
+  if (lir->mir()->operandIsNeverNegativeZero()) {MOZ_RELEASE_ASSERT(0);
     masm.branchDouble(Assembler::DoubleUnordered, input, input, ool->entry());
   } else {
     FloatRegister scratch = ToFloatRegister(lir->tempDouble());
@@ -15203,7 +15203,7 @@ template <size_t NumDefs>
 void CodeGenerator::emitIonToWasmCallBase(LIonToWasmCallBase<NumDefs>* lir) {
   wasm::JitCallStackArgVector stackArgs;
   masm.propagateOOM(stackArgs.reserve(lir->numOperands()));
-  if (masm.oom()) {
+  if (masm.oom()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -15422,7 +15422,7 @@ void CodeGenerator::visitWasmBoxValue(LW
   masm.bind(oolBoxValue->rejoin());
 }
 
-void CodeGenerator::visitWasmAnyRefFromJSObject(LWasmAnyRefFromJSObject* lir) {
+void CodeGenerator::visitWasmAnyRefFromJSObject(LWasmAnyRefFromJSObject* lir) {MOZ_RELEASE_ASSERT(0);
   Register input = ToRegister(lir->getOperand(LWasmAnyRefFromJSObject::Input));
   Register output = ToRegister(lir->output());
   // See the definition of AnyRef for a discussion of pointer representation.
diff --git a/js/src/jit/EffectiveAddressAnalysis.cpp b/js/src/jit/EffectiveAddressAnalysis.cpp
--- a/js/src/jit/EffectiveAddressAnalysis.cpp
+++ b/js/src/jit/EffectiveAddressAnalysis.cpp
@@ -63,14 +63,14 @@ static void AnalyzeLsh(TempAllocator& al
     if (MConstant* otherConst = other->maybeConstantValue()) {
       displacement += otherConst->toInt32();
     } else {
-      if (base) {
+      if (base) {MOZ_RELEASE_ASSERT(0);
         break;
       }
       base = other;
     }
 
     last = add;
-    if (last->isRecoveredOnBailout()) {
+    if (last->isRecoveredOnBailout()) {MOZ_RELEASE_ASSERT(0);
       return;
     }
   }
@@ -92,13 +92,13 @@ static void AnalyzeLsh(TempAllocator& al
     }
 
     MBitAnd* bitAnd = use->consumer()->toDefinition()->toBitAnd();
-    if (bitAnd->isRecoveredOnBailout()) {
+    if (bitAnd->isRecoveredOnBailout()) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
     MDefinition* other = bitAnd->getOperand(1 - bitAnd->indexOf(*use));
     MConstant* otherConst = other->maybeConstantValue();
-    if (!otherConst || otherConst->type() != MIRType::Int32) {
+    if (!otherConst || otherConst->type() != MIRType::Int32) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
@@ -136,32 +136,32 @@ static void AnalyzeLsh(TempAllocator& al
 //
 // This is possible when the AddI is only used by the LoadUnboxedScalar opcode.
 static void AnalyzeLoadUnboxedScalar(MLoadUnboxedScalar* load) {
-  if (load->isRecoveredOnBailout()) {
+  if (load->isRecoveredOnBailout()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
   if (!load->getOperand(1)->isAdd()) {
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   JitSpew(JitSpew_EAA, "analyze: %s%u", load->opName(), load->id());
 
   MAdd* add = load->getOperand(1)->toAdd();
 
   if (add->type() != MIRType::Int32 || !add->hasUses() ||
-      add->truncateKind() != TruncateKind::Truncate) {
+      add->truncateKind() != TruncateKind::Truncate) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MDefinition* lhs = add->lhs();
   MDefinition* rhs = add->rhs();
   MDefinition* constant = nullptr;
   MDefinition* node = nullptr;
 
-  if (lhs->isConstant()) {
+  if (lhs->isConstant()) {MOZ_RELEASE_ASSERT(0);
     constant = lhs;
     node = rhs;
-  } else if (rhs->isConstant()) {
+  } else if (rhs->isConstant()) {MOZ_RELEASE_ASSERT(0);
     constant = rhs;
     node = lhs;
   } else
@@ -172,14 +172,14 @@ static void AnalyzeLoadUnboxedScalar(MLo
   size_t storageSize = Scalar::byteSize(load->storageType());
   int32_t c1 = load->offsetAdjustment();
   int32_t c2 = 0;
-  if (!SafeMul(constant->maybeConstantValue()->toInt32(), storageSize, &c2)) {
+  if (!SafeMul(constant->maybeConstantValue()->toInt32(), storageSize, &c2)) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   int32_t offset = 0;
-  if (!SafeAdd(c1, c2, &offset)) {
+  if (!SafeAdd(c1, c2, &offset)) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   JitSpew(JitSpew_EAA, "set offset: %d + %d = %d on: %s%u", c1, c2, offset,
           load->opName(), load->id());
@@ -232,7 +232,7 @@ bool EffectiveAddressAnalysis::analyze()
   for (ReversePostorderIterator block(graph_.rpoBegin());
        block != graph_.rpoEnd(); block++) {
     for (MInstructionIterator i = block->begin(); i != block->end(); i++) {
-      if (!graph_.alloc().ensureBallast()) {
+      if (!graph_.alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
diff --git a/js/src/jit/ExecutableAllocator.cpp b/js/src/jit/ExecutableAllocator.cpp
--- a/js/src/jit/ExecutableAllocator.cpp
+++ b/js/src/jit/ExecutableAllocator.cpp
@@ -120,7 +120,7 @@ ExecutablePool* ExecutableAllocator::poo
 
   // Create a new allocator
   ExecutablePool* pool = createPool(ExecutableCodePageSize);
-  if (!pool) {
+  if (!pool) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   // At this point, local |pool| is the owner.
@@ -170,17 +170,17 @@ size_t ExecutableAllocator::roundUpAlloc
 
 ExecutablePool* ExecutableAllocator::createPool(size_t n) {
   size_t allocSize = roundUpAllocationSize(n, ExecutableCodePageSize);
-  if (allocSize == OVERSIZE_ALLOCATION) {
+  if (allocSize == OVERSIZE_ALLOCATION) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   ExecutablePool::Allocation a = systemAlloc(allocSize);
-  if (!a.pages) {
+  if (!a.pages) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   ExecutablePool* pool = js_new<ExecutablePool>(this, a);
-  if (!pool) {
+  if (!pool) {MOZ_RELEASE_ASSERT(0);
     systemRelease(a);
     return nullptr;
   }
@@ -201,7 +201,7 @@ void* ExecutableAllocator::alloc(JSConte
   // aligned.
   MOZ_ASSERT(roundUpAllocationSize(n, sizeof(void*)) == n);
 
-  if (n == OVERSIZE_ALLOCATION) {
+  if (n == OVERSIZE_ALLOCATION) {MOZ_RELEASE_ASSERT(0);
     *poolp = nullptr;
     return nullptr;
   }
diff --git a/js/src/jit/FoldLinearArithConstants.cpp b/js/src/jit/FoldLinearArithConstants.cpp
--- a/js/src/jit/FoldLinearArithConstants.cpp
+++ b/js/src/jit/FoldLinearArithConstants.cpp
@@ -87,12 +87,12 @@ bool FoldLinearArithConstants(MIRGenerat
   JitSpew(JitSpew_FLAC, "Begin");
   for (PostorderIterator block(graph.poBegin()); block != graph.poEnd();
        block++) {
-    if (mir->shouldCancel("Fold Linear Arithmetic Constants (main loop)")) {
+    if (mir->shouldCancel("Fold Linear Arithmetic Constants (main loop)")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     for (MInstructionIterator i = block->begin(); i != block->end(); i++) {
-      if (!graph.alloc().ensureBallast()) {
+      if (!graph.alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
diff --git a/js/src/jit/InstructionReordering.cpp b/js/src/jit/InstructionReordering.cpp
--- a/js/src/jit/InstructionReordering.cpp
+++ b/js/src/jit/InstructionReordering.cpp
@@ -72,7 +72,7 @@ bool jit::ReorderInstructions(MIRGraph& 
     }
 
     if (block->isLoopHeader()) {
-      if (!loopHeaders.append(*block)) {
+      if (!loopHeaders.append(*block)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -102,7 +102,7 @@ bool jit::ReorderInstructions(MIRGraph& 
         iter++;
         MInstructionIterator targetIter = block->begin();
         while (targetIter->isConstant() || targetIter->isInterruptCheck()) {
-          if (*targetIter == ins) {
+          if (*targetIter == ins) {MOZ_RELEASE_ASSERT(0);
             break;
           }
           targetIter++;
@@ -120,7 +120,7 @@ bool jit::ReorderInstructions(MIRGraph& 
       for (size_t i = 0; i < ins->numOperands(); i++) {
         MDefinition* input = ins->getOperand(i);
         if (!input->isConstant() && IsLastUse(ins, input, innerLoop)) {
-          if (!lastUsedInputs.append(input)) {
+          if (!lastUsedInputs.append(input)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -138,7 +138,7 @@ bool jit::ReorderInstructions(MIRGraph& 
       for (MInstructionReverseIterator riter = ++block->rbegin(ins);
            riter != rtop; riter++) {
         MInstruction* prev = *riter;
-        if (prev->isInterruptCheck()) {
+        if (prev->isInterruptCheck()) {MOZ_RELEASE_ASSERT(0);
           break;
         }
 
diff --git a/js/src/jit/Ion.cpp b/js/src/jit/Ion.cpp
--- a/js/src/jit/Ion.cpp
+++ b/js/src/jit/Ion.cpp
@@ -118,16 +118,16 @@ bool JitRuntime::initialize(JSContext* c
 
   JitContext jctx(cx, nullptr);
 
-  if (!generateTrampolines(cx)) {
+  if (!generateTrampolines(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!generateBaselineICFallbackCode(cx)) {
+  if (!generateBaselineICFallbackCode(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   jitcodeGlobalTable_ = cx->new_<JitcodeGlobalTable>();
-  if (!jitcodeGlobalTable_) {
+  if (!jitcodeGlobalTable_) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -155,7 +155,7 @@ bool JitRuntime::generateTrampolines(JSC
 
     // Initialize some Ion-only stubs that require floating-point support.
     BailoutTableVector& bailoutTables = bailoutTables_.writeRef();
-    if (!bailoutTables.reserve(FrameSizeClass::ClassLimit().classId())) {
+    if (!bailoutTables.reserve(FrameSizeClass::ClassLimit().classId())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -163,7 +163,7 @@ bool JitRuntime::generateTrampolines(JSC
       FrameSizeClass class_ = FrameSizeClass::FromClass(id);
       if (class_ == FrameSizeClass::ClassLimit()) {
         break;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       JitSpew(JitSpew_Codegen, "# Bailout table");
       bailoutTables.infallibleAppend(
           generateBailoutTable(masm, &bailoutTail, id));
@@ -219,7 +219,7 @@ bool JitRuntime::generateTrampolines(JSC
   generateDoubleToInt32ValueStub(masm);
 
   JitSpew(JitSpew_Codegen, "# Emitting VM function wrappers");
-  if (!generateVMWrappers(cx, masm)) {
+  if (!generateVMWrappers(cx, masm)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -373,7 +373,7 @@ void jit::LinkIonScript(JSContext* cx, H
 
   {
     gc::AutoSuppressGC suppressGC(cx);
-    if (!LinkBackgroundCodeGen(cx, task)) {
+    if (!LinkBackgroundCodeGen(cx, task)) {MOZ_RELEASE_ASSERT(0);
       // Silently ignore OOM during code generation. The assembly code
       // doesn't have code to handle it after linking happened. So it's
       // not OK to throw a catchable exception from there.
@@ -407,7 +407,7 @@ void JitRuntime::TraceAtomZoneRoots(JSTr
 
   // Shared stubs are allocated in the atoms zone, so do not iterate
   // them after the atoms heap after it has been "finished."
-  if (trc->runtime()->atomsAreFinished()) {
+  if (trc->runtime()->atomsAreFinished()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -480,7 +480,7 @@ void jit::AddPendingInvalidation(Recompi
   script->resetWarmUpCounterToDelayIonCompilation();
 
   JitScript* jitScript = script->maybeJitScript();
-  if (!jitScript) {
+  if (!jitScript) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -700,7 +700,7 @@ IonScript* IonScript::New(JSContext* cx,
                           size_t osiIndices, size_t icEntries,
                           size_t runtimeSize, size_t safepointsSize) {
   if (snapshotsListSize >= MAX_BUFFER_SIZE ||
-      (bailoutEntries >= MAX_BUFFER_SIZE / sizeof(uint32_t))) {
+      (bailoutEntries >= MAX_BUFFER_SIZE / sizeof(uint32_t))) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -726,7 +726,7 @@ IonScript* IonScript::New(JSContext* cx,
   allocSize += CheckedInt<Offset>(snapshotsRVATableSize);
   allocSize += CheckedInt<Offset>(recoversSize);
 
-  if (!allocSize.isValid()) {
+  if (!allocSize.isValid()) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return nullptr;
   }
@@ -1019,7 +1019,7 @@ bool OptimizeMIR(MIRGenerator* mir) {
 
   {
     AutoTraceLog log(logger, TraceLogger_FoldEmptyBlocks);
-    if (!FoldEmptyBlocks(graph)) {
+    if (!FoldEmptyBlocks(graph)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     gs.spewPass("Fold Empty Blocks");
@@ -1032,7 +1032,7 @@ bool OptimizeMIR(MIRGenerator* mir) {
 
   {
     AutoTraceLog log(logger, TraceLogger_FoldTests);
-    if (!FoldTests(graph)) {
+    if (!FoldTests(graph)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     gs.spewPass("Fold Tests");
@@ -1045,7 +1045,7 @@ bool OptimizeMIR(MIRGenerator* mir) {
 
   {
     AutoTraceLog log(logger, TraceLogger_SplitCriticalEdges);
-    if (!SplitCriticalEdges(graph)) {
+    if (!SplitCriticalEdges(graph)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     gs.spewPass("Split Critical Edges");
@@ -1069,7 +1069,7 @@ bool OptimizeMIR(MIRGenerator* mir) {
 
   {
     AutoTraceLog log(logger, TraceLogger_DominatorTree);
-    if (!BuildDominatorTree(graph)) {
+    if (!BuildDominatorTree(graph)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     // No spew: graph not changed.
@@ -1098,7 +1098,7 @@ bool OptimizeMIR(MIRGenerator* mir) {
       return false;
     }
 
-    if (!BuildPhiReverseMapping(graph)) {
+    if (!BuildPhiReverseMapping(graph)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     AssertExtendedGraphCoherency(graph);
@@ -1140,13 +1140,13 @@ bool OptimizeMIR(MIRGenerator* mir) {
   if (mir->optimizationInfo().amaEnabled()) {
     AutoTraceLog log(logger, TraceLogger_AlignmentMaskAnalysis);
     AlignmentMaskAnalysis ama(graph);
-    if (!ama.analyze()) {
+    if (!ama.analyze()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     gs.spewPass("Alignment Mask Analysis");
     AssertExtendedGraphCoherency(graph);
 
-    if (mir->shouldCancel("Alignment Mask Analysis")) {
+    if (mir->shouldCancel("Alignment Mask Analysis")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1224,7 +1224,7 @@ bool OptimizeMIR(MIRGenerator* mir) {
   if (mir->optimizationInfo().rangeAnalysisEnabled()) {
     AutoTraceLog log(logger, TraceLogger_RangeAnalysis);
     JitSpewCont(JitSpew_Range, "\n");
-    if (!r.addBetaNodes()) {
+    if (!r.addBetaNodes()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     gs.spewPass("Beta");
@@ -1234,7 +1234,7 @@ bool OptimizeMIR(MIRGenerator* mir) {
       return false;
     }
 
-    if (!r.analyze() || !r.addRangeAssertions()) {
+    if (!r.analyze() || !r.addRangeAssertions()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     gs.spewPass("Range Analysis");
@@ -1244,7 +1244,7 @@ bool OptimizeMIR(MIRGenerator* mir) {
       return false;
     }
 
-    if (!r.removeBetaNodes()) {
+    if (!r.removeBetaNodes()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     gs.spewPass("De-Beta");
@@ -1256,7 +1256,7 @@ bool OptimizeMIR(MIRGenerator* mir) {
 
     if (mir->optimizationInfo().gvnEnabled()) {
       bool shouldRunUCE = false;
-      if (!r.prepareForUCE(&shouldRunUCE)) {
+      if (!r.prepareForUCE(&shouldRunUCE)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       gs.spewPass("RA check UCE");
@@ -1267,20 +1267,20 @@ bool OptimizeMIR(MIRGenerator* mir) {
       }
 
       if (shouldRunUCE) {
-        if (!gvn.run(ValueNumberer::DontUpdateAliasAnalysis)) {
+        if (!gvn.run(ValueNumberer::DontUpdateAliasAnalysis)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         gs.spewPass("UCE After RA");
         AssertExtendedGraphCoherency(graph);
 
-        if (mir->shouldCancel("UCE After RA")) {
+        if (mir->shouldCancel("UCE After RA")) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
     }
 
     if (mir->optimizationInfo().autoTruncateEnabled()) {
-      if (!r.truncate()) {
+      if (!r.truncate()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       gs.spewPass("Truncate Doubles");
@@ -1310,7 +1310,7 @@ bool OptimizeMIR(MIRGenerator* mir) {
       mir->optimizationInfo().rangeAnalysisEnabled()) {
     AutoTraceLog log(logger, TraceLogger_RemoveUnnecessaryBitops);
     JitSpewCont(JitSpew_Range, "\n");
-    if (!r.removeUnnecessaryBitops()) {
+    if (!r.removeUnnecessaryBitops()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     gs.spewPass("Remove Unnecessary Bitops");
@@ -1339,7 +1339,7 @@ bool OptimizeMIR(MIRGenerator* mir) {
     AutoTraceLog log(logger, TraceLogger_EffectiveAddressAnalysis);
     EffectiveAddressAnalysis eaa(mir, graph);
     JitSpewCont(JitSpew_EAA, "\n");
-    if (!eaa.analyze()) {
+    if (!eaa.analyze()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     gs.spewPass("Effective Address Analysis");
@@ -1353,13 +1353,13 @@ bool OptimizeMIR(MIRGenerator* mir) {
   // BCE marks bounds checks as dead, so do BCE before DCE.
   if (mir->compilingWasm()) {
     JitSpewCont(JitSpew_WasmBCE, "\n");
-    if (!EliminateBoundsChecks(mir, graph)) {
+    if (!EliminateBoundsChecks(mir, graph)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     gs.spewPass("Redundant Bounds Check Elimination");
     AssertGraphCoherency(graph);
 
-    if (mir->shouldCancel("BCE")) {
+    if (mir->shouldCancel("BCE")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1380,7 +1380,7 @@ bool OptimizeMIR(MIRGenerator* mir) {
   if (mir->optimizationInfo().instructionReorderingEnabled() &&
       !mir->outerInfo().hadReorderingBailout()) {
     AutoTraceLog log(logger, TraceLogger_ReorderInstructions);
-    if (!ReorderInstructions(graph)) {
+    if (!ReorderInstructions(graph)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     gs.spewPass("Reordering");
@@ -1396,7 +1396,7 @@ bool OptimizeMIR(MIRGenerator* mir) {
   // which can remove CFG edges, exposing more blocks that can be moved.
   {
     AutoTraceLog log(logger, TraceLogger_MakeLoopsContiguous);
-    if (!MakeLoopsContiguous(graph)) {
+    if (!MakeLoopsContiguous(graph)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     gs.spewPass("Make loops contiguous");
@@ -1418,7 +1418,7 @@ bool OptimizeMIR(MIRGenerator* mir) {
     gs.spewPass("Remove fake loop predecessors");
     AssertGraphCoherency(graph);
 
-    if (mir->shouldCancel("Remove fake loop predecessors")) {
+    if (mir->shouldCancel("Remove fake loop predecessors")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1435,7 +1435,7 @@ bool OptimizeMIR(MIRGenerator* mir) {
     gs.spewPass("Edge Case Analysis (Late)");
     AssertGraphCoherency(graph);
 
-    if (mir->shouldCancel("Edge Case Analysis (Late)")) {
+    if (mir->shouldCancel("Edge Case Analysis (Late)")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1446,7 +1446,7 @@ bool OptimizeMIR(MIRGenerator* mir) {
     // instructions. Since check uses are replaced with the actual index,
     // code motion after this pass could incorrectly move a load or store
     // before its bounds check.
-    if (!EliminateRedundantChecks(graph)) {
+    if (!EliminateRedundantChecks(graph)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     gs.spewPass("Bounds Check Elimination");
@@ -1487,7 +1487,7 @@ LIRGraph* GenerateLIR(MIRGenerator* mir)
   TraceLoggerThread* logger = TraceLoggerForCurrentThread();
 
   LIRGraph* lir = mir->alloc().lifoAlloc()->new_<LIRGraph>(&graph);
-  if (!lir || !lir->init()) {
+  if (!lir || !lir->init()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1560,7 +1560,7 @@ CodeGenerator* GenerateCode(MIRGenerator
   AutoTraceLog log(logger, TraceLogger_GenerateCode);
 
   auto codegen = MakeUnique<CodeGenerator>(mir, lir);
-  if (!codegen) {
+  if (!codegen) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1627,40 +1627,40 @@ static AbortReason IonCompile(JSContext*
 
   auto alloc =
       cx->make_unique<LifoAlloc>(TempAllocator::PreferredLifoChunkSize);
-  if (!alloc) {
+  if (!alloc) {MOZ_RELEASE_ASSERT(0);
     return AbortReason::Alloc;
   }
 
   TempAllocator* temp = alloc->new_<TempAllocator>(alloc.get());
-  if (!temp) {
+  if (!temp) {MOZ_RELEASE_ASSERT(0);
     return AbortReason::Alloc;
   }
 
   JitContext jctx(cx, temp);
 
-  if (!cx->realm()->ensureJitRealmExists(cx)) {
+  if (!cx->realm()->ensureJitRealmExists(cx)) {MOZ_RELEASE_ASSERT(0);
     return AbortReason::Alloc;
   }
 
-  if (!cx->realm()->jitRealm()->ensureIonStubsExist(cx)) {
+  if (!cx->realm()->jitRealm()->ensureIonStubsExist(cx)) {MOZ_RELEASE_ASSERT(0);
     return AbortReason::Alloc;
   }
 
   MIRGraph* graph = alloc->new_<MIRGraph>(temp);
-  if (!graph) {
+  if (!graph) {MOZ_RELEASE_ASSERT(0);
     return AbortReason::Alloc;
   }
 
   InlineScriptTree* inlineScriptTree =
       InlineScriptTree::New(temp, nullptr, nullptr, script);
-  if (!inlineScriptTree) {
+  if (!inlineScriptTree) {MOZ_RELEASE_ASSERT(0);
     return AbortReason::Alloc;
   }
 
   CompileInfo* info = alloc->new_<CompileInfo>(
       CompileRuntime::get(cx->runtime()), script, script->function(), osrPc,
       Analysis_None, script->needsArgsObj(), inlineScriptTree);
-  if (!info) {
+  if (!info) {MOZ_RELEASE_ASSERT(0);
     return AbortReason::Alloc;
   }
 
@@ -1671,7 +1671,7 @@ static AbortReason IonCompile(JSContext*
   MIRGenerator* mirGen =
       alloc->new_<MIRGenerator>(CompileRealm::get(cx->realm()), options, temp,
                                 graph, info, optimizationInfo);
-  if (!mirGen) {
+  if (!mirGen) {MOZ_RELEASE_ASSERT(0);
     return AbortReason::Alloc;
   }
 
@@ -1697,12 +1697,12 @@ static AbortReason IonCompile(JSContext*
             script->filename(), script->lineno(), script->column());
 
     IonCompileTask* task = alloc->new_<IonCompileTask>(*mirGen, snapshot);
-    if (!task) {
+    if (!task) {MOZ_RELEASE_ASSERT(0);
       return AbortReason::Alloc;
     }
 
     AutoLockHelperThreadState lock;
-    if (!StartOffThreadIonCompile(task, lock)) {
+    if (!StartOffThreadIonCompile(task, lock)) {MOZ_RELEASE_ASSERT(0);
       JitSpew(JitSpew_IonAbort, "Unable to start off-thread ion compilation.");
       mirGen->graphSpewer().endFunction();
       return AbortReason::Alloc;
@@ -1721,11 +1721,11 @@ static AbortReason IonCompile(JSContext*
   {
     gc::AutoSuppressGC suppressGC(cx);
     UniquePtr<CodeGenerator> codegen(CompileBackEnd(mirGen, snapshot));
-    if (!codegen) {
+    if (!codegen) {MOZ_RELEASE_ASSERT(0);
       JitSpew(JitSpew_IonAbort, "Failed during back-end compilation.");
-      if (cx->isExceptionPending()) {
+      if (cx->isExceptionPending()) {MOZ_RELEASE_ASSERT(0);
         return AbortReason::Error;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       return AbortReason::Disable;
     }
 
@@ -1771,13 +1771,13 @@ static bool CanIonCompileOrInlineScript(
     return false;
   }
 
-  if (script->isGenerator() && !JitOptions.warpGenerator) {
+  if (script->isGenerator() && !JitOptions.warpGenerator) {MOZ_RELEASE_ASSERT(0);
     *reason = "generator script";
     return false;
   }
 
   if (script->isAsync()) {
-    if (!JitOptions.warpAsync) {
+    if (!JitOptions.warpAsync) {MOZ_RELEASE_ASSERT(0);
       *reason = "async script";
       return false;
     }
@@ -1852,10 +1852,10 @@ bool CanIonCompileScript(JSContext* cx, 
   return true;
 }
 
-bool CanIonInlineScript(JSScript* script) {
-  if (!script->canIonCompile()) {
+bool CanIonInlineScript(JSScript* script) {MOZ_RELEASE_ASSERT(0);
+  if (!script->canIonCompile()) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   const char* reason = nullptr;
   if (!CanIonCompileOrInlineScript(script, &reason)) {
@@ -1898,7 +1898,7 @@ static MethodStatus Compile(JSContext* c
 
   MOZ_ASSERT(optimizationLevel == OptimizationLevel::Normal);
 
-  if (!CanLikelyAllocateMoreExecutableMemory()) {
+  if (!CanLikelyAllocateMoreExecutableMemory()) {MOZ_RELEASE_ASSERT(0);
     script->resetWarmUpCounterToDelayIonCompilation();
     return Method_Skipped;
   }
@@ -1906,7 +1906,7 @@ static MethodStatus Compile(JSContext* c
   MOZ_ASSERT(!script->hasIonScript());
 
   AbortReason reason = IonCompile(cx, script, osrPc);
-  if (reason == AbortReason::Error) {
+  if (reason == AbortReason::Error) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(cx->isExceptionPending());
     return Method_Error;
   }
@@ -1915,7 +1915,7 @@ static MethodStatus Compile(JSContext* c
     return Method_CantCompile;
   }
 
-  if (reason == AbortReason::Alloc) {
+  if (reason == AbortReason::Alloc) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return Method_Error;
   }
@@ -1953,7 +1953,7 @@ MethodStatus jit::CanEnterIon(JSContext*
   }
 
   // Skip if the script is being compiled off thread.
-  if (script->isIonCompilingOffThread()) {
+  if (script->isIonCompilingOffThread()) {MOZ_RELEASE_ASSERT(0);
     return Method_Skipped;
   }
 
@@ -2005,7 +2005,7 @@ MethodStatus jit::CanEnterIon(JSContext*
     return status;
   }
 
-  if (state.script()->baselineScript()->hasPendingIonCompileTask()) {
+  if (state.script()->baselineScript()->hasPendingIonCompileTask()) {MOZ_RELEASE_ASSERT(0);
     LinkIonScript(cx, state.script());
     if (!state.script()->hasIonScript()) {
       return jit::Method_Skipped;
@@ -2024,7 +2024,7 @@ static MethodStatus BaselineCanEnterAtEn
   MOZ_ASSERT(frame->isFunctionFrame());
 
   // Mark as forbidden if frame can't be handled.
-  if (!CheckFrame(cx, frame)) {
+  if (!CheckFrame(cx, frame)) {MOZ_RELEASE_ASSERT(0);
     ForbidCompilation(cx, script);
     return Method_CantCompile;
   }
@@ -2057,12 +2057,12 @@ static MethodStatus BaselineCanEnterAtBr
   MOZ_ASSERT((JSOp)*pc == JSOp::LoopHead);
 
   // Skip if the script has been disabled.
-  if (!script->canIonCompile()) {
+  if (!script->canIonCompile()) {MOZ_RELEASE_ASSERT(0);
     return Method_Skipped;
   }
 
   // Skip if the script is being compiled off thread.
-  if (script->isIonCompilingOffThread()) {
+  if (script->isIonCompilingOffThread()) {MOZ_RELEASE_ASSERT(0);
     return Method_Skipped;
   }
 
@@ -2166,7 +2166,7 @@ static bool IonCompileScriptForBaseline(
     return true;
   }
 
-  if (stat == Method_Error) {
+  if (stat == Method_Error) {MOZ_RELEASE_ASSERT(0);
     JitSpew(JitSpew_BaselineOSR, "  Compile with Ion errored!");
     return false;
   }
@@ -2269,7 +2269,7 @@ bool jit::IonCompileScriptForBaselineOSR
   MOZ_ASSERT(frame->debugFrameSize() == frameSize);
   MOZ_ASSERT(JSOp(*pc) == JSOp::LoopHead);
 
-  if (!IonCompileScriptForBaseline(cx, frame, pc)) {
+  if (!IonCompileScriptForBaseline(cx, frame, pc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2383,7 +2383,7 @@ static void InvalidateActivation(JSFreeO
     }
 
     JSScript* script = frame.maybeForwardedScript();
-    if (!script->hasIonScript()) {
+    if (!script->hasIonScript()) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
@@ -2601,7 +2601,7 @@ void jit::Invalidate(JSContext* cx, JSSc
 
     // Get the script filename, if any, and its length.
     const char* filename = script->filename();
-    if (filename == nullptr) {
+    if (filename == nullptr) {MOZ_RELEASE_ASSERT(0);
       filename = "<unknown>";
     }
 
diff --git a/js/src/jit/IonAnalysis.cpp b/js/src/jit/IonAnalysis.cpp
--- a/js/src/jit/IonAnalysis.cpp
+++ b/js/src/jit/IonAnalysis.cpp
@@ -59,7 +59,7 @@ static bool DepthFirstSearchUse(MIRGener
   size_t useCount = 0;
 #endif
   MOZ_ASSERT(worklist.empty());
-  if (!push(phi, phi->usesBegin())) {
+  if (!push(phi, phi->usesBegin())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -81,7 +81,7 @@ static bool DepthFirstSearchUse(MIRGener
 #ifdef DEBUG
       useCount++;
 #endif
-      if (mir->shouldCancel("FlagPhiInputsAsImplicitlyUsed inner loop")) {
+      if (mir->shouldCancel("FlagPhiInputsAsImplicitlyUsed inner loop")) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -219,7 +219,7 @@ static bool FlagPhiInputsAsImplicitlyUse
   for (; it != end; it++) {
     MPhi* phi = *it;
 
-    if (mir->shouldCancel("FlagPhiInputsAsImplicitlyUsed outer loop")) {
+    if (mir->shouldCancel("FlagPhiInputsAsImplicitlyUsed outer loop")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -243,7 +243,7 @@ static bool FlagPhiInputsAsImplicitlyUse
     // with a depth-search of uses. Returns the matching stack in the
     // worklist as soon as one use is found.
     MOZ_ASSERT(worklist.empty());
-    if (!DepthFirstSearchUse(mir, worklist, phi)) {
+    if (!DepthFirstSearchUse(mir, worklist, phi)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -314,7 +314,7 @@ static bool FlagOperandsAsImplicitlyUsed
   // Flag Phi inputs of the successors as having implicit uses.
   MPhiUseIteratorStack worklist;
   for (size_t i = 0, e = block->numSuccessors(); i < e; i++) {
-    if (mir->shouldCancel("FlagOperandsAsImplicitlyUsedAfter (loop 2)")) {
+    if (mir->shouldCancel("FlagOperandsAsImplicitlyUsedAfter (loop 2)")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -332,7 +332,7 @@ static bool FlagEntryResumePointOperands
   // Flag observable operands of the entry resume point as having implicit uses.
   MResumePoint* rp = block->entryResumePoint();
   while (rp) {
-    if (mir->shouldCancel("FlagEntryResumePointOperands")) {
+    if (mir->shouldCancel("FlagEntryResumePointOperands")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -379,12 +379,12 @@ bool jit::PruneUnusedBranches(MIRGenerat
   };
 
   // The entry block is always reachable.
-  if (!markReachable(graph.entryBlock())) {
+  if (!markReachable(graph.entryBlock())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // The OSR entry block is always reachable if it exists.
-  if (graph.osrBlock() && !markReachable(graph.osrBlock())) {
+  if (graph.osrBlock() && !markReachable(graph.osrBlock())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -409,7 +409,7 @@ bool jit::PruneUnusedBranches(MIRGenerat
         continue;
       }
       JitSpew(JitSpew_Prune, "Reaches block %u", succ->id());
-      if (!markReachable(succ)) {
+      if (!markReachable(succ)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -470,12 +470,12 @@ bool jit::PruneUnusedBranches(MIRGenerat
       // the loop header via OSR, we create a fake unreachable predecessor.
       if (succ->isLoopHeader() && block != succ->backedge()) {
         MOZ_ASSERT(graph.osrBlock());
-        if (!graph.alloc().ensureBallast()) {
+        if (!graph.alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         MBasicBlock* fake = MBasicBlock::NewFakeLoopPredecessor(graph, succ);
-        if (!fake) {
+        if (!fake) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         // Mark the block to avoid removing it as unreachable.
@@ -575,11 +575,11 @@ static bool BlockComputesConstant(MBasic
   if (!value->isConstant() || value->block() != block) {
     return false;
   }
-  if (!block->phisEmpty()) {
+  if (!block->phisEmpty()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (MInstructionIterator iter = block->begin(); iter != block->end();
-       ++iter) {
+       ++iter) {MOZ_RELEASE_ASSERT(0);
     if (*iter != value || !iter->isGoto()) {
       return false;
     }
@@ -676,20 +676,20 @@ static bool BlockIsSingleTest(MBasicBloc
     MTest* test = ins->toTest();
     MOZ_ASSERT(test->input() == value);
 
-    if (ifTrue != test->ifTrue()) {
+    if (ifTrue != test->ifTrue()) {MOZ_RELEASE_ASSERT(0);
       test->ifTrue()->removePredecessor(block);
-      if (!ifTrue->addPredecessorSameInputsAs(block, existingPred)) {
+      if (!ifTrue->addPredecessorSameInputsAs(block, existingPred)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(test->ifTrue() == test->getSuccessor(0));
       test->replaceSuccessor(0, ifTrue);
     }
 
-    if (ifFalse != test->ifFalse()) {
+    if (ifFalse != test->ifFalse()) {MOZ_RELEASE_ASSERT(0);
       test->ifFalse()->removePredecessor(block);
-      if (!ifFalse->addPredecessorSameInputsAs(block, existingPred)) {
+      if (!ifFalse->addPredecessorSameInputsAs(block, existingPred)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(test->ifFalse() == test->getSuccessor(1));
       test->replaceSuccessor(1, ifFalse);
     }
@@ -704,7 +704,7 @@ static bool BlockIsSingleTest(MBasicBloc
   MTest* test = MTest::New(alloc, value, ifTrue, ifFalse);
   block->end(test);
 
-  if (!ifTrue->addPredecessorSameInputsAs(block, existingPred)) {
+  if (!ifTrue->addPredecessorSameInputsAs(block, existingPred)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!ifFalse->addPredecessorSameInputsAs(block, existingPred)) {
@@ -763,7 +763,7 @@ static bool MaybeFoldConditionBlock(MIRG
   }
 
   if (initialBlock->isLoopBackedge() || trueBranch->isLoopBackedge() ||
-      falseBranch->isLoopBackedge()) {
+      falseBranch->isLoopBackedge()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -779,7 +779,7 @@ static bool MaybeFoldConditionBlock(MIRG
   }
 
   // Make sure the test block does not have any outgoing loop backedges.
-  if (!SplitCriticalEdgesForBlock(graph, testBlock)) {
+  if (!SplitCriticalEdgesForBlock(graph, testBlock)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -812,31 +812,31 @@ static bool MaybeFoldConditionBlock(MIRG
     graph.removeBlock(trueBranch);
   } else if (initialTest->input() == trueResult) {
     if (!UpdateGotoSuccessor(graph.alloc(), trueBranch, finalTest->ifTrue(),
-                             testBlock)) {
+                             testBlock)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
     if (!UpdateTestSuccessors(graph.alloc(), trueBranch, trueResult,
                               finalTest->ifTrue(), finalTest->ifFalse(),
-                              testBlock)) {
+                              testBlock)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   MBasicBlock* falseTarget = falseBranch;
-  if (BlockComputesConstant(falseBranch, falseResult, &constBool)) {
+  if (BlockComputesConstant(falseBranch, falseResult, &constBool)) {MOZ_RELEASE_ASSERT(0);
     falseTarget = constBool ? finalTest->ifTrue() : finalTest->ifFalse();
     phiBlock->removePredecessor(falseBranch);
     graph.removeBlock(falseBranch);
   } else if (initialTest->input() == falseResult) {
     if (!UpdateGotoSuccessor(graph.alloc(), falseBranch, finalTest->ifFalse(),
-                             testBlock)) {
+                             testBlock)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
     if (!UpdateTestSuccessors(graph.alloc(), falseBranch, falseResult,
                               finalTest->ifTrue(), finalTest->ifFalse(),
-                              testBlock)) {
+                              testBlock)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -958,7 +958,7 @@ bool jit::EliminateDeadResumePointOperan
     }
 
     if (MResumePoint* rp = block->entryResumePoint()) {
-      if (!graph.alloc().ensureBallast()) {
+      if (!graph.alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       EliminateTriviallyDeadResumePointOperands(graph, rp);
@@ -972,7 +972,7 @@ bool jit::EliminateDeadResumePointOperan
     for (MInstructionIterator ins = block->begin(); ins != block->end();
          ins++) {
       if (MResumePoint* rp = ins->resumePoint()) {
-        if (!graph.alloc().ensureBallast()) {
+        if (!graph.alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         EliminateTriviallyDeadResumePointOperands(graph, rp);
@@ -1245,7 +1245,7 @@ bool jit::EliminatePhis(MIRGenerator* mi
       // Enqueue observable Phis.
       if (IsPhiObservable(phi, observe)) {
         phi->setInWorklist();
-        if (!worklist.append(phi)) {
+        if (!worklist.append(phi)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -1271,7 +1271,7 @@ bool jit::EliminatePhis(MIRGenerator* mi
           if (!use->isUnused()) {
             use->setUnusedUnchecked();
             use->setInWorklist();
-            if (!worklist.append(use)) {
+            if (!worklist.append(use)) {MOZ_RELEASE_ASSERT(0);
               return false;
             }
           }
@@ -1290,7 +1290,7 @@ bool jit::EliminatePhis(MIRGenerator* mi
         continue;
       }
       in->setInWorklist();
-      if (!worklist.append(in->toPhi())) {
+      if (!worklist.append(in->toPhi())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1540,19 +1540,19 @@ bool TypeAnalyzer::propagateSpecializati
       // We tried to specialize this phi, but were unable to guess its
       // type. Now that we know the type of one of its operands, we can
       // specialize it.
-      if (!respecialize(use, phi->type())) {
+      if (!respecialize(use, phi->type())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       continue;
     }
-    if (use->type() != phi->type()) {
+    if (use->type() != phi->type()) {MOZ_RELEASE_ASSERT(0);
       // Specialize phis with int32 that can be converted to float and float
       // operands as floats.
       if ((use->type() == MIRType::Int32 && use->canProduceFloat32() &&
            phi->type() == MIRType::Float32) ||
           (phi->type() == MIRType::Int32 && phi->canProduceFloat32() &&
            use->type() == MIRType::Float32)) {
-        if (!respecialize(use, MIRType::Float32)) {
+        if (!respecialize(use, MIRType::Float32)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         continue;
@@ -1561,7 +1561,7 @@ bool TypeAnalyzer::propagateSpecializati
       // Specialize phis with int32 and double operands as double.
       if (IsTypeRepresentableAsDouble(use->type()) &&
           IsTypeRepresentableAsDouble(phi->type())) {
-        if (!respecialize(use, MIRType::Double)) {
+        if (!respecialize(use, MIRType::Double)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         continue;
@@ -1579,7 +1579,7 @@ bool TypeAnalyzer::propagateSpecializati
 
 bool TypeAnalyzer::propagateAllPhiSpecializations() {
   while (!phiWorklist_.empty()) {
-    if (mir->shouldCancel("Specialize Phis (worklist)")) {
+    if (mir->shouldCancel("Specialize Phis (worklist)")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1603,12 +1603,12 @@ bool TypeAnalyzer::specializeOsrOnlyPhis
 
   for (PostorderIterator block(graph.poBegin()); block != graph.poEnd();
        block++) {
-    if (mir->shouldCancel("Specialize osr-only phis (main loop)")) {
+    if (mir->shouldCancel("Specialize osr-only phis (main loop)")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     for (MPhiIterator phi(block->phisBegin()); phi != block->phisEnd(); phi++) {
-      if (mir->shouldCancel("Specialize osr-only phis (inner loop)")) {
+      if (mir->shouldCancel("Specialize osr-only phis (inner loop)")) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -1641,13 +1641,13 @@ bool TypeAnalyzer::specializePhis() {
         // will do that once we know the type of one of the operands.
         continue;
       }
-      if (!propagateSpecialization(*phi)) {
+      if (!propagateSpecialization(*phi)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
   }
 
-  if (!propagateAllPhiSpecializations()) {
+  if (!propagateAllPhiSpecializations()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1661,7 +1661,7 @@ bool TypeAnalyzer::specializePhis() {
       MOZ_ASSERT(preHeader->getPredecessor(0) == graph.osrBlock());
       // Branch pruning has removed the path from the entry block
       // to the preheader. Specialize any phis with no non-osr inputs.
-      if (!specializeOsrOnlyPhis()) {
+      if (!specializeOsrOnlyPhis()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (header->isLoopHeader()) {
@@ -1676,11 +1676,11 @@ bool TypeAnalyzer::specializePhis() {
         }
 
         MIRType loopType = phi->type();
-        if (!respecialize(preHeaderPhi, loopType)) {
+        if (!respecialize(preHeaderPhi, loopType)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
-      if (!propagateAllPhiSpecializations()) {
+      if (!propagateAllPhiSpecializations()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -1714,11 +1714,11 @@ bool TypeAnalyzer::adjustPhiInputs(MPhi*
         continue;
       }
 
-      if (!alloc().ensureBallast()) {
+      if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
-      if (in->isBox() && in->toBox()->input()->type() == phiType) {
+      if (in->isBox() && in->toBox()->input()->type() == phiType) {MOZ_RELEASE_ASSERT(0);
         phi->replaceOperand(i, in->toBox()->input());
       } else {
         MInstruction* replacement;
@@ -1731,7 +1731,7 @@ bool TypeAnalyzer::adjustPhiInputs(MPhi*
             replacement = MToFloat32::New(alloc(), in);
           } else {
             // See comment below
-            if (in->type() != MIRType::Value) {
+            if (in->type() != MIRType::Value) {MOZ_RELEASE_ASSERT(0);
               MBox* box = MBox::New(alloc(), in);
               in->block()->insertBefore(in->block()->lastIns(), box);
               in = box;
@@ -1747,7 +1747,7 @@ bool TypeAnalyzer::adjustPhiInputs(MPhi*
           // If we know this branch will fail to convert to phiType,
           // insert a box that'll immediately fail in the fallible unbox
           // below.
-          if (in->type() != MIRType::Value) {
+          if (in->type() != MIRType::Value) {MOZ_RELEASE_ASSERT(0);
             MBox* box = MBox::New(alloc(), in);
             in->block()->insertBefore(in->block()->lastIns(), box);
             in = box;
@@ -1800,7 +1800,7 @@ bool TypeAnalyzer::adjustPhiInputs(MPhi*
 
 bool TypeAnalyzer::adjustInputs(MDefinition* def) {
   // Definitions such as MPhi have no type policy.
-  if (!def->isInstruction()) {
+  if (!def->isInstruction()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -1875,13 +1875,13 @@ bool TypeAnalyzer::insertConversions() {
       MPhi* phi = *iter++;
       if (IsNullOrUndefined(phi->type()) || IsMagicType(phi->type())) {
         // We can replace this phi with a constant.
-        if (!alloc().ensureBallast()) {
+        if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         replaceRedundantPhi(phi);
         block->discardPhi(phi);
       } else {
-        if (!adjustPhiInputs(phi)) {
+        if (!adjustPhiInputs(phi)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -1891,7 +1891,7 @@ bool TypeAnalyzer::insertConversions() {
     // current instruction. Only increment the iterator after it is finished.
     for (MInstructionIterator iter(block->begin()); iter != block->end();
          iter++) {
-      if (!alloc().ensureBallast()) {
+      if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -1949,7 +1949,7 @@ bool TypeAnalyzer::markPhiConsumers() {
   for (PostorderIterator block(graph.poBegin()); block != graph.poEnd();
        ++block) {
     if (mir->shouldCancel(
-            "Ensure Float32 commutativity - Consumer Phis - Initial state")) {
+            "Ensure Float32 commutativity - Consumer Phis - Initial state")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1962,7 +1962,7 @@ bool TypeAnalyzer::markPhiConsumers() {
             usedef->isPhi() || usedef->canConsumeFloat32(use.use());
       }
       phi->setCanConsumeFloat32(canConsumeFloat32);
-      if (canConsumeFloat32 && !addPhiToWorklist(*phi)) {
+      if (canConsumeFloat32 && !addPhiToWorklist(*phi)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1970,7 +1970,7 @@ bool TypeAnalyzer::markPhiConsumers() {
 
   while (!phiWorklist_.empty()) {
     if (mir->shouldCancel(
-            "Ensure Float32 commutativity - Consumer Phis - Fixed point")) {
+            "Ensure Float32 commutativity - Consumer Phis - Fixed point")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2025,7 +2025,7 @@ bool TypeAnalyzer::markPhiProducers() {
         canProduceFloat32 &= input->isPhi() || input->canProduceFloat32();
       }
       phi->setCanProduceFloat32(canProduceFloat32);
-      if (canProduceFloat32 && !addPhiToWorklist(*phi)) {
+      if (canProduceFloat32 && !addPhiToWorklist(*phi)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2033,7 +2033,7 @@ bool TypeAnalyzer::markPhiProducers() {
 
   while (!phiWorklist_.empty()) {
     if (mir->shouldCancel(
-            "Ensure Float32 commutativity - Producer Phis - Fixed point")) {
+            "Ensure Float32 commutativity - Producer Phis - Fixed point")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2079,7 +2079,7 @@ bool TypeAnalyzer::specializeValidFloatO
         continue;
       }
 
-      if (ins->type() == MIRType::Float32) {
+      if (ins->type() == MIRType::Float32) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
 
@@ -2115,7 +2115,7 @@ bool TypeAnalyzer::graphContainsFloat32(
 bool TypeAnalyzer::tryEmitFloatOperations() {
   // Asm.js uses the ahead of time type checks to specialize operations, no need
   // to check them again at this point.
-  if (mir->compilingWasm()) {
+  if (mir->compilingWasm()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -2125,7 +2125,7 @@ bool TypeAnalyzer::tryEmitFloatOperation
     return true;
   }
 
-  if (!markPhiConsumers()) {
+  if (!markPhiConsumers()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!markPhiProducers()) {
@@ -2210,7 +2210,7 @@ bool jit::AccountForCFGChanges(MIRGenera
   }
 
   // Recompute dominator info.
-  if (!BuildDominatorTree(graph)) {
+  if (!BuildDominatorTree(graph)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2232,7 +2232,7 @@ bool jit::AccountForCFGChanges(MIRGenera
 // Alias analysis dependencies may be invalid after calling this function.
 bool jit::RemoveUnmarkedBlocks(MIRGenerator* mir, MIRGraph& graph,
                                uint32_t numMarkedBlocks) {
-  if (numMarkedBlocks == graph.numBlocks()) {
+  if (numMarkedBlocks == graph.numBlocks()) {MOZ_RELEASE_ASSERT(0);
     // If all blocks are marked, no blocks need removal. Just clear the
     // marks. We'll still need to update the dominator tree below though,
     // since we may have removed edges even if we didn't remove any blocks.
@@ -2413,13 +2413,13 @@ bool jit::BuildDominatorTree(MIRGraph& g
     // Add it to the worklist as a root for pre-order traversal.
     // This includes all roots. Order does not matter.
     if (child == parent) {
-      if (!worklist.append(child)) {
+      if (!worklist.append(child)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       continue;
     }
 
-    if (!parent->addImmediatelyDominatedBlock(child)) {
+    if (!parent->addImmediatelyDominatedBlock(child)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3094,7 +3094,7 @@ static bool MonotoneSub(int32_t lhs, int
 SimpleLinearSum jit::ExtractLinearSum(MDefinition* ins, MathSpace space,
                                       int32_t recursionDepth) {
   const int32_t SAFE_RECURSION_LIMIT = 100;
-  if (recursionDepth > SAFE_RECURSION_LIMIT) {
+  if (recursionDepth > SAFE_RECURSION_LIMIT) {MOZ_RELEASE_ASSERT(0);
     return SimpleLinearSum(ins, 0);
   }
 
@@ -3206,7 +3206,7 @@ bool jit::ExtractLinearInequality(MTest*
   SimpleLinearSum lsum = ExtractLinearSum(lhs);
   SimpleLinearSum rsum = ExtractLinearSum(rhs);
 
-  if (!SafeSub(lsum.constant, rsum.constant, &lsum.constant)) {
+  if (!SafeSub(lsum.constant, rsum.constant, &lsum.constant)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3263,7 +3263,7 @@ static bool TryEliminateBoundsCheck(Boun
 
   MBoundsCheck* dominating =
       FindDominatingBoundsCheck(checks, dominated, blockIndex);
-  if (!dominating) {
+  if (!dominating) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3282,7 +3282,7 @@ static bool TryEliminateBoundsCheck(Boun
   SimpleLinearSum sumB = ExtractLinearSum(dominated->index());
 
   // Both terms should be nullptr or the same definition.
-  if (sumA.term != sumB.term) {
+  if (sumA.term != sumB.term) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -3294,7 +3294,7 @@ static bool TryEliminateBoundsCheck(Boun
   if (!SafeAdd(sumA.constant, dominating->minimum(), &minimumA) ||
       !SafeAdd(sumA.constant, dominating->maximum(), &maximumA) ||
       !SafeAdd(sumB.constant, dominated->minimum(), &minimumB) ||
-      !SafeAdd(sumB.constant, dominated->maximum(), &maximumB)) {
+      !SafeAdd(sumB.constant, dominated->maximum(), &maximumB)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3337,7 +3337,7 @@ bool jit::EliminateRedundantChecks(MIRGr
   for (MBasicBlockIterator i(graph.begin()); i != graph.end(); i++) {
     MBasicBlock* block = *i;
     if (block->immediateDominator() == block) {
-      if (!worklist.append(block)) {
+      if (!worklist.append(block)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -3351,7 +3351,7 @@ bool jit::EliminateRedundantChecks(MIRGr
 
     // Add all immediate dominators to the front of the worklist.
     if (!worklist.append(block->immediatelyDominatedBlocksBegin(),
-                         block->immediatelyDominatedBlocksEnd())) {
+                         block->immediatelyDominatedBlocksEnd())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3364,7 +3364,7 @@ bool jit::EliminateRedundantChecks(MIRGr
 
       bool eliminated = false;
       if (!TryEliminateBoundsCheck(checks, index, def->toBoundsCheck(),
-                                   &eliminated)) {
+                                   &eliminated)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -3511,15 +3511,15 @@ bool LinearSum::multiply(int32_t scale) 
   return SafeMul(scale, constant_, &constant_);
 }
 
-bool LinearSum::divide(uint32_t scale) {
+bool LinearSum::divide(uint32_t scale) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(scale > 0);
 
-  for (size_t i = 0; i < terms_.length(); i++) {
-    if (terms_[i].scale % scale != 0) {
+  for (size_t i = 0; i < terms_.length(); i++) {MOZ_RELEASE_ASSERT(0);
+    if (terms_[i].scale % scale != 0) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
-  if (constant_ % scale != 0) {
+  if (constant_ % scale != 0) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3534,10 +3534,10 @@ bool LinearSum::divide(uint32_t scale) {
 bool LinearSum::add(const LinearSum& other, int32_t scale /* = 1 */) {
   for (size_t i = 0; i < other.terms_.length(); i++) {
     int32_t newScale = scale;
-    if (!SafeMul(scale, other.terms_[i].scale, &newScale)) {
+    if (!SafeMul(scale, other.terms_[i].scale, &newScale)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!add(other.terms_[i].term, newScale)) {
+    if (!add(other.terms_[i].term, newScale)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -3548,10 +3548,10 @@ bool LinearSum::add(const LinearSum& oth
   return add(newConstant);
 }
 
-bool LinearSum::add(SimpleLinearSum other, int32_t scale) {
-  if (other.term && !add(other.term, scale)) {
+bool LinearSum::add(SimpleLinearSum other, int32_t scale) {MOZ_RELEASE_ASSERT(0);
+  if (other.term && !add(other.term, scale)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   int32_t constant;
   if (!SafeMul(other.constant, scale, &constant)) {
@@ -3564,13 +3564,13 @@ bool LinearSum::add(SimpleLinearSum othe
 bool LinearSum::add(MDefinition* term, int32_t scale) {
   MOZ_ASSERT(term);
 
-  if (scale == 0) {
+  if (scale == 0) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   if (MConstant* termConst = term->maybeConstantValue()) {
     int32_t constant = termConst->toInt32();
-    if (!SafeMul(constant, scale, &constant)) {
+    if (!SafeMul(constant, scale, &constant)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     return add(constant);
@@ -3578,7 +3578,7 @@ bool LinearSum::add(MDefinition* term, i
 
   for (size_t i = 0; i < terms_.length(); i++) {
     if (term == terms_[i].term) {
-      if (!SafeAdd(scale, terms_[i].scale, &terms_[i].scale)) {
+      if (!SafeAdd(scale, terms_[i].scale, &terms_[i].scale)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (terms_[i].scale == 0) {
@@ -3601,27 +3601,27 @@ bool LinearSum::add(int32_t constant) {
   return SafeAdd(constant, constant_, &constant_);
 }
 
-void LinearSum::dump(GenericPrinter& out) const {
-  for (size_t i = 0; i < terms_.length(); i++) {
+void LinearSum::dump(GenericPrinter& out) const {MOZ_RELEASE_ASSERT(0);
+  for (size_t i = 0; i < terms_.length(); i++) {MOZ_RELEASE_ASSERT(0);
     int32_t scale = terms_[i].scale;
     int32_t id = terms_[i].term->id();
     MOZ_ASSERT(scale);
-    if (scale > 0) {
-      if (i) {
+    if (scale > 0) {MOZ_RELEASE_ASSERT(0);
+      if (i) {MOZ_RELEASE_ASSERT(0);
         out.printf("+");
       }
-      if (scale == 1) {
+      if (scale == 1) {MOZ_RELEASE_ASSERT(0);
         out.printf("#%d", id);
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         out.printf("%d*#%d", scale, id);
       }
-    } else if (scale == -1) {
+    } else if (scale == -1) {MOZ_RELEASE_ASSERT(0);
       out.printf("-#%d", id);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       out.printf("%d*#%d", scale, id);
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
-  if (constant_ > 0) {
+  if (constant_ > 0) {MOZ_RELEASE_ASSERT(0);
     out.printf("+%d", constant_);
   } else if (constant_ < 0) {
     out.printf("%d", constant_);
@@ -3652,7 +3652,7 @@ MDefinition* jit::ConvertLinearSum(TempA
         def = term.term;
       }
     } else if (term.scale == -1) {
-      if (!def) {
+      if (!def) {MOZ_RELEASE_ASSERT(0);
         def = MConstant::New(alloc, Int32Value(0));
         block->insertAtEnd(def->toInstruction());
         def->computeRange(alloc);
@@ -3693,18 +3693,18 @@ static bool ArgumentsUseCanBeLazy(JSCont
                                   MInstruction* ins, size_t index,
                                   bool* argumentsContentsObserved) {
   // We can read the frame's arguments directly for f.apply(x, arguments).
-  if (ins->isCall()) {
+  if (ins->isCall()) {MOZ_RELEASE_ASSERT(0);
     if (JSOp(*ins->toCall()->resumePoint()->pc()) == JSOp::FunApply &&
         ins->toCall()->numActualArgs() == 2 &&
-        index == MCall::IndexOfArgument(1)) {
+        index == MCall::IndexOfArgument(1)) {MOZ_RELEASE_ASSERT(0);
       *argumentsContentsObserved = true;
       return true;
-    }
-  }
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
 
   // arguments[i] can read fp->unaliasedActual(i) directly.
   if (ins->isGetPropertyCache() && index == 0 &&
-      IsGetElemPC(ins->resumePoint()->pc())) {
+      IsGetElemPC(ins->resumePoint()->pc())) {MOZ_RELEASE_ASSERT(0);
     script->setUninlineable();
     *argumentsContentsObserved = true;
     return true;
@@ -3712,7 +3712,7 @@ static bool ArgumentsUseCanBeLazy(JSCont
 
   // MGetArgumentsObjectArg needs to be considered as a use that allows
   // laziness.
-  if (ins->isGetArgumentsObjectArg() && index == 0) {
+  if (ins->isGetArgumentsObjectArg() && index == 0) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -3729,7 +3729,7 @@ static bool ArgumentsUseCanBeLazy(JSCont
     return false;
   };
 
-  if (ins->isGetPropertyCache() && index == 0) {
+  if (ins->isGetPropertyCache() && index == 0) {MOZ_RELEASE_ASSERT(0);
     MDefinition* id = ins->toGetPropertyCache()->idval();
     if (id->isConstant() && id->type() == MIRType::String &&
         getPropCanBeLazy(id->toConstant()->toString())) {
@@ -3755,7 +3755,7 @@ bool jit::AnalyzeArgumentsUsage(JSContex
 
   if (JitOptions.scalarReplaceArguments) {
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Always construct arguments objects when in debug mode, for generator
   // scripts (generators can be suspended when speculation fails) or when
@@ -3763,33 +3763,33 @@ bool jit::AnalyzeArgumentsUsage(JSContex
   //
   // FIXME: Don't build arguments for ES6 generator expressions.
   if (scriptArg->isDebuggee() || script->isGenerator() || script->isAsync() ||
-      script->bindingsAccessedDynamically()) {
+      script->bindingsAccessedDynamically()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
-  if (!jit::IsIonEnabled(cx)) {
+  if (!jit::IsIonEnabled(cx)) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   static const uint32_t MAX_SCRIPT_SIZE = 10000;
-  if (script->length() > MAX_SCRIPT_SIZE) {
+  if (script->length() > MAX_SCRIPT_SIZE) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   // Check this before calling ensureJitRealmExists, so we're less
   // likely to report OOM in JSRuntime::createJitRuntime.
-  if (!jit::CanLikelyAllocateMoreExecutableMemory()) {
+  if (!jit::CanLikelyAllocateMoreExecutableMemory()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
-  if (!cx->realm()->ensureJitRealmExists(cx)) {
+  if (!cx->realm()->ensureJitRealmExists(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   AutoKeepJitScripts keepJitScript(cx);
-  if (!script->ensureHasJitScript(cx, keepJitScript)) {
+  if (!script->ensureHasJitScript(cx, keepJitScript)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   TraceLoggerThread* logger = TraceLoggerForCurrentThread(cx);
   TraceLoggerEvent event(TraceLogger_AnnotateScripts, script);
@@ -3803,10 +3803,10 @@ bool jit::AnalyzeArgumentsUsage(JSContex
   MIRGraph graph(&temp);
   InlineScriptTree* inlineScriptTree =
       InlineScriptTree::New(&temp, nullptr, nullptr, script);
-  if (!inlineScriptTree) {
+  if (!inlineScriptTree) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   CompileInfo info(CompileRuntime::get(cx->runtime()), script,
                    script->function(),
@@ -3821,82 +3821,82 @@ bool jit::AnalyzeArgumentsUsage(JSContex
   MIRGenerator mirGen(CompileRealm::get(cx->realm()), options, &temp, &graph,
                       &info, optimizationInfo);
 
-  {
+  {MOZ_RELEASE_ASSERT(0);
     WarpOracle oracle(cx, mirGen, script);
 
     AbortReasonOr<WarpSnapshot*> result = oracle.createSnapshot();
-    if (result.isErr()) {
+    if (result.isErr()) {MOZ_RELEASE_ASSERT(0);
       AbortReason reason = result.unwrapErr();
-      if (cx->isThrowingOverRecursed() || cx->isThrowingOutOfMemory()) {
+      if (cx->isThrowingOverRecursed() || cx->isThrowingOutOfMemory()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
-      if (reason == AbortReason::Alloc) {
+      if (reason == AbortReason::Alloc) {MOZ_RELEASE_ASSERT(0);
         ReportOutOfMemory(cx);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(!cx->isExceptionPending());
       return true;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     WarpCompilation comp(temp);
     WarpBuilder builder(*result.unwrap(), mirGen, &comp);
-    if (!builder.build()) {
+    if (!builder.build()) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
-  if (!SplitCriticalEdges(graph)) {
+  if (!SplitCriticalEdges(graph)) {MOZ_RELEASE_ASSERT(0);
+    ReportOutOfMemory(cx);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
+
+  RenumberBlocks(graph);
+
+  if (!BuildDominatorTree(graph)) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
 
-  RenumberBlocks(graph);
-
-  if (!BuildDominatorTree(graph)) {
+  if (!EliminatePhis(&mirGen, graph, AggressiveObservability)) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
-  }
-
-  if (!EliminatePhis(&mirGen, graph, AggressiveObservability)) {
-    ReportOutOfMemory(cx);
-    return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MDefinition* argumentsValue = graph.entryBlock()->getSlot(info.argsObjSlot());
 
   bool argumentsContentsObserved = false;
 
-  if (argumentsValue->isImplicitlyUsed()) {
+  if (argumentsValue->isImplicitlyUsed()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
-  for (MUseDefIterator uses(argumentsValue); uses; uses++) {
+  for (MUseDefIterator uses(argumentsValue); uses; uses++) {MOZ_RELEASE_ASSERT(0);
     MDefinition* use = uses.def();
 
     // Don't track |arguments| through assignments to phis.
-    if (!use->isInstruction()) {
+    if (!use->isInstruction()) {MOZ_RELEASE_ASSERT(0);
       return true;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     if (!ArgumentsUseCanBeLazy(cx, script, use->toInstruction(),
                                use->indexOf(uses.use()),
-                               &argumentsContentsObserved)) {
+                               &argumentsContentsObserved)) {MOZ_RELEASE_ASSERT(0);
       return true;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   // If a script explicitly accesses the contents of 'arguments', and has
   // formals which may be stored as part of a call object, don't use lazy
   // arguments. The compiler can then assume that accesses through
   // arguments[i] will be on unaliased variables.
-  if (argumentsContentsObserved) {
-    for (PositionalFormalParameterIter fi(script); fi; fi++) {
-      if (fi.closedOver()) {
+  if (argumentsContentsObserved) {MOZ_RELEASE_ASSERT(0);
+    for (PositionalFormalParameterIter fi(script); fi; fi++) {MOZ_RELEASE_ASSERT(0);
+      if (fi.closedOver()) {MOZ_RELEASE_ASSERT(0);
         return true;
-      }
-    }
-  }
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
 
   // If we assign to a positional formal parameter and the arguments object is
   // unmapped (strict mode or function with default/rest/destructing args),
@@ -4077,12 +4077,12 @@ bool jit::FoldLoadsWithUnbox(MIRGenerato
       // folding it with a fallible unbox so that we can eliminate the hole
       // check.
       if (load->isLoadElement() && load->toLoadElement()->needsHoleCheck() &&
-          !unbox->fallible()) {
+          !unbox->fallible()) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
 
       // Combine the load and unbox into a single MIR instruction.
-      if (!graph.alloc().ensureBallast()) {
+      if (!graph.alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
diff --git a/js/src/jit/IonCacheIRCompiler.cpp b/js/src/jit/IonCacheIRCompiler.cpp
--- a/js/src/jit/IonCacheIRCompiler.cpp
+++ b/js/src/jit/IonCacheIRCompiler.cpp
@@ -183,7 +183,7 @@ void CacheRegisterAllocator::saveIonLive
       stackPushed_ += operandSize;
       loc.setPayloadStack(stackPushed_, loc.payloadType());
       continue;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(loc.kind() == OperandLocation::ValueStack);
     masm.pushValue(
         Address(masm.getStackPointer(), stackPushed_ - operandStackPushed));
@@ -269,7 +269,7 @@ void IonCacheIRCompiler::prepareVMCall(M
 }
 
 bool IonCacheIRCompiler::init() {
-  if (!allocator.init()) {
+  if (!allocator.init()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -559,20 +559,20 @@ JitCode* IonCacheIRCompiler::compile(Ion
 
   // Done emitting the main IC code. Now emit the failure paths.
   for (size_t i = 0; i < failurePaths.length(); i++) {
-    if (!emitFailurePath(i)) {
+    if (!emitFailurePath(i)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     Register scratch = ic_->scratchRegisterForEntryJump();
     CodeOffset offset = masm.movWithPatch(ImmWord(-1), scratch);
     masm.jump(Address(scratch, 0));
-    if (!nextCodeOffsets_.append(offset)) {
+    if (!nextCodeOffsets_.append(offset)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
 
   Linker linker(masm);
   Rooted<JitCode*> newStubCode(cx_, linker.newCode(cx_, CodeKind::Ion));
-  if (!newStubCode) {
+  if (!newStubCode) {MOZ_RELEASE_ASSERT(0);
     cx_->recoverFromOutOfMemory();
     return nullptr;
   }
@@ -644,7 +644,7 @@ bool IonCacheIRCompiler::emitGuardShape(
   }
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -713,11 +713,11 @@ bool IonCacheIRCompiler::emitGuardAnyCla
   const JSClass* clasp = classStubField(claspOffset);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (objectGuardNeedsSpectreMitigations(objId)) {
+  if (objectGuardNeedsSpectreMitigations(objId)) {MOZ_RELEASE_ASSERT(0);
     masm.branchTestObjClass(Assembler::NotEqual, obj, clasp, scratch, obj,
                             failure->label());
   } else {
@@ -952,7 +952,7 @@ bool IonCacheIRCompiler::emitCallNativeG
   masm.Push(argUintN);
   pushStubCodePointer();
 
-  if (!masm.icBuildOOLFakeExitFrame(GetReturnAddressToIonCode(cx_), save)) {
+  if (!masm.icBuildOOLFakeExitFrame(GetReturnAddressToIonCode(cx_), save)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   masm.enterFakeExitFrame(argJSContext, scratch, ExitFrameType::IonOOLNative);
@@ -1071,7 +1071,7 @@ bool IonCacheIRCompiler::emitProxyGetRes
 
   masm.loadJSContext(argJSContext);
 
-  if (!masm.icBuildOOLFakeExitFrame(GetReturnAddressToIonCode(cx_), save)) {
+  if (!masm.icBuildOOLFakeExitFrame(GetReturnAddressToIonCode(cx_), save)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   masm.enterFakeExitFrame(argJSContext, scratch, ExitFrameType::IonOOLProxy);
@@ -1279,7 +1279,7 @@ bool IonCacheIRCompiler::emitAddAndStore
     // fallible but does not GC.
 
     FailurePath* failure;
-    if (!addFailurePath(&failure)) {
+    if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1372,7 +1372,7 @@ bool IonCacheIRCompiler::emitLoadStringC
   AutoScratchRegister scratch2(allocator, masm);
 
   FailurePath* failure;
-  if (!addFailurePath(&failure)) {
+  if (!addFailurePath(&failure)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1463,7 +1463,7 @@ bool IonCacheIRCompiler::emitCallNativeS
   masm.Push(argUintN);
   pushStubCodePointer();
 
-  if (!masm.icBuildOOLFakeExitFrame(GetReturnAddressToIonCode(cx_), save)) {
+  if (!masm.icBuildOOLFakeExitFrame(GetReturnAddressToIonCode(cx_), save)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   masm.enterFakeExitFrame(argJSContext, scratch, ExitFrameType::IonOOLNative);
@@ -1831,12 +1831,12 @@ void IonIC::attachCacheIRStub(JSContext*
     bool makesGCCalls = true;
     stubInfo = CacheIRStubInfo::New(kind, ICStubEngine::IonIC, makesGCCalls,
                                     stubDataOffset, writer);
-    if (!stubInfo) {
+    if (!stubInfo) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
     CacheIRStubKey key(stubInfo);
-    if (!jitZone->putIonCacheIRStubInfo(lookup, key)) {
+    if (!jitZone->putIonCacheIRStubInfo(lookup, key)) {MOZ_RELEASE_ASSERT(0);
       return;
     }
   }
@@ -1865,7 +1865,7 @@ void IonIC::attachCacheIRStub(JSContext*
   // IonICStub::poison method poisons the stub to catch bugs in this area.
   ICStubSpace* stubSpace = cx->zone()->jitZone()->optimizedStubSpace();
   void* newStubMem = stubSpace->alloc(bytesNeeded);
-  if (!newStubMem) {
+  if (!newStubMem) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -1875,7 +1875,7 @@ void IonIC::attachCacheIRStub(JSContext*
 
   JitContext jctx(cx, nullptr);
   IonCacheIRCompiler compiler(cx, writer, this, ionScript, stubDataOffset);
-  if (!compiler.init()) {
+  if (!compiler.init()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
diff --git a/js/src/jit/IonCompileTask.cpp b/js/src/jit/IonCompileTask.cpp
--- a/js/src/jit/IonCompileTask.cpp
+++ b/js/src/jit/IonCompileTask.cpp
@@ -67,7 +67,7 @@ void IonCompileTask::trace(JSTracer* trc
 IonCompileTask::IonCompileTask(MIRGenerator& mirGen, WarpSnapshot* snapshot)
     : mirGen_(mirGen), snapshot_(snapshot) {}
 
-size_t IonCompileTask::sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) {
+size_t IonCompileTask::sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) {MOZ_RELEASE_ASSERT(0);
   // See js::jit::FreeIonCompileTask.
   // The IonCompileTask and most of its contents live in the LifoAlloc we point
   // to.
@@ -192,7 +192,7 @@ void jit::FinishOffThreadTask(JSRuntime*
     script->jitScript()->clearIsIonCompilingOffThread(script);
 
     const AbortReasonOr<Ok>& status = task->mirGen().getOffThreadStatus();
-    if (status.isErr() && status.inspectErr() == AbortReason::Disable) {
+    if (status.isErr() && status.inspectErr() == AbortReason::Disable) {MOZ_RELEASE_ASSERT(0);
       script->disableIon();
     }
   }
diff --git a/js/src/jit/IonIC.cpp b/js/src/jit/IonIC.cpp
--- a/js/src/jit/IonIC.cpp
+++ b/js/src/jit/IonIC.cpp
@@ -197,7 +197,7 @@ bool IonGetPropSuperIC::update(JSContext
 
   if (ic->kind() == CacheKind::GetPropSuper) {
     RootedPropertyName name(cx, idVal.toString()->asAtom().asPropertyName());
-    if (!GetProperty(cx, obj, receiver, name, res)) {
+    if (!GetProperty(cx, obj, receiver, name, res)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -257,9 +257,9 @@ bool IonSetPropertyIC::update(JSContext*
 
   jsbytecode* pc = ic->pc();
   if (ic->kind() == CacheKind::SetElem) {
-    if (JSOp(*pc) == JSOp::InitElemInc) {
+    if (JSOp(*pc) == JSOp::InitElemInc) {MOZ_RELEASE_ASSERT(0);
       if (!InitElemIncOperation(cx, obj.as<ArrayObject>(), idVal.toInt32(),
-                                rhs)) {
+                                rhs)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (IsPropertyInitOp(JSOp(*pc))) {
@@ -275,7 +275,7 @@ bool IonSetPropertyIC::update(JSContext*
   } else {
     MOZ_ASSERT(ic->kind() == CacheKind::SetProp);
 
-    if (JSOp(*pc) == JSOp::InitGLexical) {
+    if (JSOp(*pc) == JSOp::InitGLexical) {MOZ_RELEASE_ASSERT(0);
       RootedScript script(cx, ic->script());
       MOZ_ASSERT(!script->hasNonSyntacticScope());
       InitGlobalLexicalOperation(cx, &cx->global()->lexicalEnvironment(),
@@ -285,7 +285,7 @@ bool IonSetPropertyIC::update(JSContext*
       // can't call InitPropertyOperation here as that function is
       // specialized for JSOp::Init*Prop (it does not support arbitrary
       // objects that might show up here).
-      if (!InitElemOperation(cx, pc, obj, idVal, rhs)) {
+      if (!InitElemOperation(cx, pc, obj, idVal, rhs)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -303,7 +303,7 @@ bool IonSetPropertyIC::update(JSContext*
 
   // The SetProperty call might have entered this IC recursively, so try
   // to transition.
-  if (ic->state().maybeTransition()) {
+  if (ic->state().maybeTransition()) {MOZ_RELEASE_ASSERT(0);
     ic->discardStubs(cx->zone(), ionScript);
   }
 
@@ -351,7 +351,7 @@ bool IonGetNameIC::update(JSContext* cx,
   RootedObject obj(cx);
   RootedObject holder(cx);
   Rooted<PropertyResult> prop(cx);
-  if (!LookupName(cx, name, envChain, &obj, &holder, &prop)) {
+  if (!LookupName(cx, name, envChain, &obj, &holder, &prop)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/jit/IonOptimizationLevels.cpp b/js/src/jit/IonOptimizationLevels.cpp
--- a/js/src/jit/IonOptimizationLevels.cpp
+++ b/js/src/jit/IonOptimizationLevels.cpp
@@ -99,7 +99,7 @@ uint32_t OptimizationInfo::compilerWarmU
 }
 
 uint32_t OptimizationInfo::recompileWarmUpThreshold(JSScript* script,
-                                                    jsbytecode* pc) const {
+                                                    jsbytecode* pc) const {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(pc == script->code() || JSOp(*pc) == JSOp::LoopHead);
 
   uint32_t threshold = compilerWarmUpThreshold(script, pc);
diff --git a/js/src/jit/JSJitFrameIter.cpp b/js/src/jit/JSJitFrameIter.cpp
--- a/js/src/jit/JSJitFrameIter.cpp
+++ b/js/src/jit/JSJitFrameIter.cpp
@@ -54,7 +54,7 @@ bool JSJitFrameIter::checkInvalidation()
 
 bool JSJitFrameIter::checkInvalidation(IonScript** ionScriptOut) const {
   JSScript* script = this->script();
-  if (isBailoutJS()) {
+  if (isBailoutJS()) {MOZ_RELEASE_ASSERT(0);
     *ionScriptOut = activation_->bailoutData()->ionScript();
     return !script->hasIonScript() || script->ionScript() != *ionScriptOut;
   }
@@ -301,20 +301,20 @@ unsigned JSJitFrameIter::numActualArgs()
   return exitFrame()->as<NativeExitFrameLayout>()->argc();
 }
 
-void JSJitFrameIter::dumpBaseline() const {
+void JSJitFrameIter::dumpBaseline() const {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(isBaselineJS());
 
   fprintf(stderr, " JS Baseline frame\n");
-  if (isFunctionFrame()) {
+  if (isFunctionFrame()) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "  callee fun: ");
 #if defined(DEBUG) || defined(JS_JITSPEW)
     DumpObject(callee());
 #else
     fprintf(stderr, "?\n");
 #endif
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "  global frame, no callee\n");
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   fprintf(stderr, "  file %s line %u\n", script()->filename(),
           script()->lineno());
@@ -341,7 +341,7 @@ void JSJitFrameIter::dumpBaseline() cons
   }
 }
 
-void JSJitFrameIter::dump() const {
+void JSJitFrameIter::dump() const {MOZ_RELEASE_ASSERT(0);
   switch (type_) {
     case FrameType::CppToJSJit:
       fprintf(stderr, " Entry frame\n");
@@ -481,7 +481,7 @@ JSJitProfilingFrameIterator::JSJitProfil
                                                          void* pc) {
   // If no profilingActivation is live, initialize directly to
   // end-of-iteration state.
-  if (!cx->profilingActivation()) {
+  if (!cx->profilingActivation()) {MOZ_RELEASE_ASSERT(0);
     type_ = FrameType::CppToJSJit;
     fp_ = nullptr;
     resumePCinCurrentFrame_ = nullptr;
@@ -597,7 +597,7 @@ bool JSJitProfilingFrameIterator::tryIni
              entry->isBaselineInterpreter() || entry->isDummy());
 
   // Treat dummy lookups as an empty frame sequence.
-  if (entry->isDummy()) {
+  if (entry->isDummy()) {MOZ_RELEASE_ASSERT(0);
     type_ = FrameType::CppToJSJit;
     fp_ = nullptr;
     resumePCinCurrentFrame_ = nullptr;
@@ -753,7 +753,7 @@ void JSJitProfilingFrameIterator::moveTo
         GetPreviousRawFrame<RectifierFrameLayout*>(frame);
     FrameType rectPrevType = rectFrame->prevType();
 
-    if (rectPrevType == FrameType::IonJS) {
+    if (rectPrevType == FrameType::IonJS) {MOZ_RELEASE_ASSERT(0);
       resumePCinCurrentFrame_ = rectFrame->returnAddress();
       fp_ = GetPreviousRawFrame<uint8_t*>(rectFrame);
       type_ = FrameType::IonJS;
@@ -770,7 +770,7 @@ void JSJitProfilingFrameIterator::moveTo
       return;
     }
 
-    if (rectPrevType == FrameType::WasmToJSJit) {
+    if (rectPrevType == FrameType::WasmToJSJit) {MOZ_RELEASE_ASSERT(0);
       moveToWasmFrame(rectFrame);
       return;
     }
@@ -778,7 +778,7 @@ void JSJitProfilingFrameIterator::moveTo
     if (rectPrevType == FrameType::CppToJSJit) {
       moveToCppEntryFrame();
       return;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     MOZ_CRASH("Bad frame type prior to rectifier frame.");
   }
@@ -795,7 +795,7 @@ void JSJitProfilingFrameIterator::moveTo
     return;
   }
 
-  if (prevType == FrameType::WasmToJSJit) {
+  if (prevType == FrameType::WasmToJSJit) {MOZ_RELEASE_ASSERT(0);
     moveToWasmFrame(frame);
     return;
   }
diff --git a/js/src/jit/Jit.cpp b/js/src/jit/Jit.cpp
--- a/js/src/jit/Jit.cpp
+++ b/js/src/jit/Jit.cpp
@@ -187,7 +187,7 @@ EnterJitStatus js::jit::MaybeEnterJit(JS
     if (IsBaselineInterpreterEnabled()) {
       jit::MethodStatus status =
           jit::CanEnterBaselineMethod<BaselineTier::Interpreter>(cx, state);
-      if (status == jit::Method_Error) {
+      if (status == jit::Method_Error) {MOZ_RELEASE_ASSERT(0);
         return EnterJitStatus::Error;
       }
       if (status == jit::Method_Compiled) {
diff --git a/js/src/jit/JitContext.cpp b/js/src/jit/JitContext.cpp
--- a/js/src/jit/JitContext.cpp
+++ b/js/src/jit/JitContext.cpp
@@ -84,7 +84,7 @@ JitContext::JitContext() : JitContext(nu
 JitContext::~JitContext() { SetJitContext(prev_); }
 
 bool jit::InitializeJit() {
-  if (!TlsJitContext.init()) {
+  if (!TlsJitContext.init()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/jit/JitFrames.cpp b/js/src/jit/JitFrames.cpp
--- a/js/src/jit/JitFrames.cpp
+++ b/js/src/jit/JitFrames.cpp
@@ -162,14 +162,14 @@ class TryNoteIterIon : public TryNoteIte
 static bool ShouldBailoutForDebugger(JSContext* cx,
                                      const InlineFrameIterator& frame,
                                      bool hitBailoutException) {
-  if (hitBailoutException) {
+  if (hitBailoutException) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(!cx->isPropagatingForcedReturn());
     return false;
   }
 
   // Bail out if we're propagating a forced return, even if the realm is no
   // longer a debuggee.
-  if (cx->isPropagatingForcedReturn()) {
+  if (cx->isPropagatingForcedReturn()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -609,10 +609,10 @@ void HandleException(ResumeFromException
       HandleExceptionWasm(cx, &iter.asWasm(), rfe);
       // If a wasm try-catch handler is found, we can immediately jump to it
       // and quit iterating through the stack.
-      if (rfe->kind == ResumeFromException::RESUME_WASM_CATCH) {
+      if (rfe->kind == ResumeFromException::RESUME_WASM_CATCH) {MOZ_RELEASE_ASSERT(0);
         return;
       }
-      if (!iter.done()) {
+      if (!iter.done()) {MOZ_RELEASE_ASSERT(0);
         ++iter;
       }
       continue;
@@ -637,7 +637,7 @@ void HandleException(ResumeFromException
       bool invalidated = frame.checkInvalidation(&ionScript);
 
 #ifdef JS_TRACE_LOGGING
-      if (logger && cx->realm()->isDebuggee() && logger->enabled()) {
+      if (logger && cx->realm()->isDebuggee() && logger->enabled()) {MOZ_RELEASE_ASSERT(0);
         logger->disable(/* force = */ true,
                         "Forcefully disabled tracelogger, due to "
                         "throwing an exception with an active Debugger "
@@ -919,7 +919,7 @@ static void TraceIonJSFrame(JSTracer* tr
 #endif
 }
 
-static void TraceBailoutFrame(JSTracer* trc, const JSJitFrameIter& frame) {
+static void TraceBailoutFrame(JSTracer* trc, const JSJitFrameIter& frame) {MOZ_RELEASE_ASSERT(0);
   JitFrameLayout* layout = (JitFrameLayout*)frame.fp();
 
   layout->replaceCalleeToken(TraceCalleeToken(trc, layout->calleeToken()));
@@ -943,8 +943,8 @@ static void TraceBailoutFrame(JSTracer* 
   // For each instruction, we read the allocations without evaluating the
   // recover instruction, nor reconstructing the frame. We are only looking at
   // tracing readable allocations.
-  while (true) {
-    while (snapIter.moreAllocations()) {
+  while (true) {MOZ_RELEASE_ASSERT(0);
+    while (snapIter.moreAllocations()) {MOZ_RELEASE_ASSERT(0);
       snapIter.traceAllocation(trc);
     }
 
@@ -1329,7 +1329,7 @@ void UpdateJitActivationsForMinorGC(JSRu
   }
 }
 
-JSScript* GetTopJitJSScript(JSContext* cx) {
+JSScript* GetTopJitJSScript(JSContext* cx) {MOZ_RELEASE_ASSERT(0);
   JSJitFrameIter frame(cx->activation()->asJit());
   MOZ_ASSERT(frame.type() == FrameType::Exit);
   ++frame;
@@ -1355,7 +1355,7 @@ void GetPcScript(JSContext* cx, JSScript
     ++it;
 
     // Skip rectifier frames.
-    if (it.frame().isRectifier()) {
+    if (it.frame().isRectifier()) {MOZ_RELEASE_ASSERT(0);
       ++it;
       MOZ_ASSERT(it.frame().isBaselineStub() || it.frame().isBaselineJS() ||
                  it.frame().isIonJS());
@@ -1365,7 +1365,7 @@ void GetPcScript(JSContext* cx, JSScript
     if (it.frame().isBaselineStub()) {
       ++it;
       MOZ_ASSERT(it.frame().isBaselineJS());
-    } else if (it.frame().isIonICCall()) {
+    } else if (it.frame().isIonICCall()) {MOZ_RELEASE_ASSERT(0);
       ++it;
       MOZ_ASSERT(it.frame().isIonJS());
     }
@@ -1383,7 +1383,7 @@ void GetPcScript(JSContext* cx, JSScript
     }
 
     retAddr = it.frame().resumePCinCurrentFrame();
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(it.frame().isBailoutJS());
     retAddr = it.frame().returnAddress();
   }
@@ -1445,7 +1445,7 @@ RInstructionResults::~RInstructionResult
 bool RInstructionResults::init(JSContext* cx, uint32_t numResults) {
   if (numResults) {
     results_ = cx->make_unique<Values>();
-    if (!results_ || !results_->growBy(numResults)) {
+    if (!results_ || !results_->growBy(numResults)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1708,7 +1708,7 @@ Value SnapshotIterator::maybeRead(const 
     // Code paths which are calling maybeRead are not always capable of
     // returning an error code, as these code paths used to be infallible.
     AutoEnterOOMUnsafeRegion oomUnsafe;
-    if (!initInstructionResults(fallback)) {
+    if (!initInstructionResults(fallback)) {MOZ_RELEASE_ASSERT(0);
       oomUnsafe.crash("js::jit::SnapshotIterator::maybeRead");
     }
 
@@ -1723,7 +1723,7 @@ Value SnapshotIterator::maybeRead(const 
 }
 
 void SnapshotIterator::writeAllocationValuePayload(
-    const RValueAllocation& alloc, const Value& v) {
+    const RValueAllocation& alloc, const Value& v) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(v.isGCThing());
 
   switch (alloc.mode()) {
@@ -1792,16 +1792,16 @@ void SnapshotIterator::writeAllocationVa
   }
 }
 
-void SnapshotIterator::traceAllocation(JSTracer* trc) {
+void SnapshotIterator::traceAllocation(JSTracer* trc) {MOZ_RELEASE_ASSERT(0);
   RValueAllocation alloc = readAllocation();
-  if (!allocationReadable(alloc, RM_AlwaysDefault)) {
+  if (!allocationReadable(alloc, RM_AlwaysDefault)) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   Value v = allocationValue(alloc, RM_AlwaysDefault);
-  if (!v.isGCThing()) {
+  if (!v.isGCThing()) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   Value copy = v;
   TraceRoot(trc, &v, "ion-typed-reg");
@@ -1863,7 +1863,7 @@ bool SnapshotIterator::initInstructionRe
     // cause a GC, we can ensure that the results are properly traced by the
     // activation.
     RInstructionResults tmp(fallback.frame->jsFrame());
-    if (!fallback.activation->registerIonFrameRecovery(std::move(tmp))) {
+    if (!fallback.activation->registerIonFrameRecovery(std::move(tmp))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1896,12 +1896,12 @@ bool SnapshotIterator::computeInstructio
   // The last instruction will always be a resume point.
   size_t numResults = recover_.numInstructions() - 1;
   if (!results->isInitialized()) {
-    if (!results->init(cx, numResults)) {
+    if (!results->init(cx, numResults)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // No need to iterate over the only resume point.
-    if (!numResults) {
+    if (!numResults) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(results->isInitialized());
       return true;
     }
@@ -1956,14 +1956,14 @@ void SnapshotIterator::nextFrame() {
   settleOnFrame();
 }
 
-Value SnapshotIterator::maybeReadAllocByIndex(size_t index) {
-  while (index--) {
+Value SnapshotIterator::maybeReadAllocByIndex(size_t index) {MOZ_RELEASE_ASSERT(0);
+  while (index--) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(moreAllocations());
     skip();
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   Value s;
-  {
+  {MOZ_RELEASE_ASSERT(0);
     // This MaybeReadFallback method cannot GC.
     JS::AutoSuppressGCAnalysis nogc;
     MaybeReadFallback fallback(UndefinedValue());
@@ -2059,13 +2059,13 @@ void InlineFrameIterator::findNextFrame(
       if (numActualArgs_ > 0) {
         numActualArgs_--;
       }
-    } else if (IsGetPropPC(pc_) || IsGetElemPC(pc_)) {
+    } else if (IsGetPropPC(pc_) || IsGetElemPC(pc_)) {MOZ_RELEASE_ASSERT(0);
       numActualArgs_ = 0;
     } else if (IsSetPropPC(pc_)) {
       numActualArgs_ = 1;
     }
 
-    if (numActualArgs_ == 0xbadbad) {
+    if (numActualArgs_ == 0xbadbad) {MOZ_RELEASE_ASSERT(0);
       MOZ_CRASH(
           "Couldn't deduce the number of arguments of an ionmonkey frame");
     }
@@ -2133,7 +2133,7 @@ JSObject* InlineFrameIterator::computeEn
         *hasInitialEnv = isFunctionFrame() &&
                          callee(fallback)->needsFunctionEnvironmentObjects();
         return obj;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       JS::AutoSuppressGCAnalysis
           nogc;  // If we cannot recover then we cannot GC.
       *hasInitialEnv = isFunctionFrame() &&
@@ -2275,17 +2275,17 @@ struct DumpOp {
   }
 };
 
-void InlineFrameIterator::dump() const {
+void InlineFrameIterator::dump() const {MOZ_RELEASE_ASSERT(0);
   MaybeReadFallback fallback(UndefinedValue());
 
-  if (more()) {
+  if (more()) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, " JS frame (inlined)\n");
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, " JS frame\n");
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   bool isFunction = false;
-  if (isFunctionFrame()) {
+  if (isFunctionFrame()) {MOZ_RELEASE_ASSERT(0);
     isFunction = true;
     fprintf(stderr, "  callee fun: ");
 #if defined(DEBUG) || defined(JS_JITSPEW)
@@ -2293,9 +2293,9 @@ void InlineFrameIterator::dump() const {
 #else
     fprintf(stderr, "?\n");
 #endif
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "  global frame, no callee\n");
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   fprintf(stderr, "  file %s line %u\n", script()->filename(),
           script()->lineno());
@@ -2303,21 +2303,21 @@ void InlineFrameIterator::dump() const {
   fprintf(stderr, "  script = %p, pc = %p\n", (void*)script(), pc());
   fprintf(stderr, "  current op: %s\n", CodeName(JSOp(*pc())));
 
-  if (!more()) {
+  if (!more()) {MOZ_RELEASE_ASSERT(0);
     numActualArgs();
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   SnapshotIterator si = snapshotIterator();
   fprintf(stderr, "  slots: %u\n", si.numAllocations() - 1);
-  for (unsigned i = 0; i < si.numAllocations() - 1; i++) {
-    if (isFunction) {
-      if (i == 0) {
+  for (unsigned i = 0; i < si.numAllocations() - 1; i++) {MOZ_RELEASE_ASSERT(0);
+    if (isFunction) {MOZ_RELEASE_ASSERT(0);
+      if (i == 0) {MOZ_RELEASE_ASSERT(0);
         fprintf(stderr, "  env chain: ");
-      } else if (i == 1) {
+      } else if (i == 1) {MOZ_RELEASE_ASSERT(0);
         fprintf(stderr, "  this: ");
-      } else if (i - 2 < calleeTemplate()->nargs()) {
+      } else if (i - 2 < calleeTemplate()->nargs()) {MOZ_RELEASE_ASSERT(0);
         fprintf(stderr, "  formal (arg %u): ", i - 2);
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         if (i - 2 == calleeTemplate()->nargs() &&
             numActualArgs() > calleeTemplate()->nargs()) {
           DumpOp d(calleeTemplate()->nargs());
diff --git a/js/src/jit/JitOptions.cpp b/js/src/jit/JitOptions.cpp
--- a/js/src/jit/JitOptions.cpp
+++ b/js/src/jit/JitOptions.cpp
@@ -25,7 +25,7 @@ static void Warn(const char* env, const 
   fprintf(stderr, "Warning: I didn't understand %s=\"%s\"\n", env, value);
 }
 
-static Maybe<int> ParseInt(const char* str) {
+static Maybe<int> ParseInt(const char* str) {MOZ_RELEASE_ASSERT(0);
   char* endp;
   int retval = strtol(str, &endp, 0);
   if (*endp == '\0') {
@@ -41,14 +41,14 @@ T overrideDefault(const char* param, T d
     return dflt;
   }
   if constexpr (std::is_same_v<T, bool>) {
-    if (strcmp(str, "true") == 0 || strcmp(str, "yes") == 0) {
+    if (strcmp(str, "true") == 0 || strcmp(str, "yes") == 0) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
-    if (strcmp(str, "false") == 0 || strcmp(str, "no") == 0) {
+    if (strcmp(str, "false") == 0 || strcmp(str, "no") == 0) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     Warn(param, str);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     Maybe<int> value = ParseInt(str);
     if (value.isSome()) {
       return value.ref();
@@ -242,7 +242,7 @@ DefaultJitOptions::DefaultJitOptions() {
   // Force the used register allocator instead of letting the optimization
   // pass decide.
   const char* forcedRegisterAllocatorEnv = "JIT_OPTION_forcedRegisterAllocator";
-  if (const char* env = getenv(forcedRegisterAllocatorEnv)) {
+  if (const char* env = getenv(forcedRegisterAllocatorEnv)) {MOZ_RELEASE_ASSERT(0);
     forcedRegisterAllocator = LookupRegisterAllocator(env);
     if (!forcedRegisterAllocator.isSome()) {
       Warn(forcedRegisterAllocatorEnv, env);
diff --git a/js/src/jit/JitScript.cpp b/js/src/jit/JitScript.cpp
--- a/js/src/jit/JitScript.cpp
+++ b/js/src/jit/JitScript.cpp
@@ -46,7 +46,7 @@ JitScript::JitScript(JSScript* script, O
                 /*depth=*/0) {
   // Ensure the baselineScript_ and ionScript_ fields match the BaselineDisabled
   // and IonDisabled script flags.
-  if (!script->canBaselineCompile()) {
+  if (!script->canBaselineCompile()) {MOZ_RELEASE_ASSERT(0);
     setBaselineScriptImpl(script, BaselineDisabledScriptPtr);
   }
   if (!script->canIonCompile()) {
@@ -67,12 +67,12 @@ bool JSScript::createJitScript(JSContext
 
   // Run the arguments-analysis if needed. Both the Baseline Interpreter and
   // Compiler rely on this.
-  if (!ensureHasAnalyzedArgsUsage(cx)) {
+  if (!ensureHasAnalyzedArgsUsage(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // If ensureHasAnalyzedArgsUsage allocated the JitScript we're done.
-  if (hasJitScript()) {
+  if (hasJitScript()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -80,7 +80,7 @@ bool JSScript::createJitScript(JSContext
   const char* profileString = nullptr;
   if (cx->runtime()->geckoProfiler().enabled()) {
     profileString = cx->runtime()->geckoProfiler().profileString(cx, this);
-    if (!profileString) {
+    if (!profileString) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -97,14 +97,14 @@ bool JSScript::createJitScript(JSContext
   // Calculate allocation size.
   CheckedInt<uint32_t> allocSize = sizeof(JitScript);
   allocSize += CheckedInt<uint32_t>(numICEntries()) * sizeof(ICEntry);
-  if (!allocSize.isValid()) {
+  if (!allocSize.isValid()) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return false;
   }
 
   void* raw = cx->pod_malloc<uint8_t>(allocSize.value());
   MOZ_ASSERT(uintptr_t(raw) % alignof(JitScript) == 0);
-  if (!raw) {
+  if (!raw) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -210,7 +210,7 @@ bool ICScript::addInlinedChild(JSContext
 
   if (!inlinedChildren_) {
     inlinedChildren_ = cx->make_unique<Vector<CallSite>>(cx);
-    if (!inlinedChildren_) {
+    if (!inlinedChildren_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -218,7 +218,7 @@ bool ICScript::addInlinedChild(JSContext
   // First reserve space in inlinedChildren_ to ensure that if the ICScript is
   // added to the inlining root, it can also be added to inlinedChildren_.
   CallSite callsite(child.get(), pcOffset);
-  if (!inlinedChildren_->reserve(inlinedChildren_->length() + 1)) {
+  if (!inlinedChildren_->reserve(inlinedChildren_->length() + 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!inliningRoot()->addInlinedScript(std::move(child))) {
@@ -244,11 +244,11 @@ void ICScript::removeInlinedChild(uint32
   });
 }
 
-bool ICScript::hasInlinedChild(uint32_t pcOffset) {
-  if (!inlinedChildren_) {
+bool ICScript::hasInlinedChild(uint32_t pcOffset) {MOZ_RELEASE_ASSERT(0);
+  if (!inlinedChildren_) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  for (auto& callsite : *inlinedChildren_) {
+  for (auto& callsite : *inlinedChildren_) {MOZ_RELEASE_ASSERT(0);
     if (callsite.pcOffset_ == pcOffset) {
       return true;
     }
@@ -333,15 +333,15 @@ ICEntry& ICScript::icEntryFromPCOffset(u
 }
 
 ICEntry* ICScript::maybeICEntryFromPCOffset(uint32_t pcOffset,
-                                            ICEntry* prevLookedUpEntry) {
+                                            ICEntry* prevLookedUpEntry) {MOZ_RELEASE_ASSERT(0);
   // Do a linear forward search from the last queried PC offset, or fallback to
   // a binary search if the last offset is too far away.
   if (prevLookedUpEntry && pcOffset >= prevLookedUpEntry->pcOffset() &&
-      (pcOffset - prevLookedUpEntry->pcOffset()) <= 10) {
+      (pcOffset - prevLookedUpEntry->pcOffset()) <= 10) {MOZ_RELEASE_ASSERT(0);
     ICEntry* firstEntry = &icEntry(0);
     ICEntry* lastEntry = &icEntry(numICEntries() - 1);
     ICEntry* curEntry = prevLookedUpEntry;
-    while (curEntry >= firstEntry && curEntry <= lastEntry) {
+    while (curEntry >= firstEntry && curEntry <= lastEntry) {MOZ_RELEASE_ASSERT(0);
       if (curEntry->pcOffset() == pcOffset) {
         return curEntry;
       }
@@ -381,7 +381,7 @@ void JitScript::purgeOptimizedStubs(JSSc
   MOZ_ASSERT(script->jitScript() == this);
 
   Zone* zone = script->zone();
-  if (IsAboutToBeFinalizedUnbarriered(&script)) {
+  if (IsAboutToBeFinalizedUnbarriered(&script)) {MOZ_RELEASE_ASSERT(0);
     // We're sweeping and the script is dead. Don't purge optimized stubs
     // because (1) accessing CacheIRStubInfo pointers in ICStubs is invalid
     // because we may have swept them already when we started (incremental)
@@ -458,7 +458,7 @@ bool JitScript::ensureHasCachedIonData(J
     if (fun->needsNamedLambdaEnvironment()) {
       templateEnv =
           NamedLambdaObject::createTemplateObject(cx, fun, gc::TenuredHeap);
-      if (!templateEnv) {
+      if (!templateEnv) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -466,7 +466,7 @@ bool JitScript::ensureHasCachedIonData(J
     if (fun->needsCallObject()) {
       templateEnv = CallObject::createTemplateObject(cx, script, templateEnv,
                                                      gc::TenuredHeap);
-      if (!templateEnv) {
+      if (!templateEnv) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -538,7 +538,7 @@ void JitScript::setIonScriptImpl(JSFreeO
 }
 
 #ifdef JS_STRUCTURED_SPEW
-static bool HasEnteredCounters(ICEntry& entry) {
+static bool HasEnteredCounters(ICEntry& entry) {MOZ_RELEASE_ASSERT(0);
   ICStub* stub = entry.firstStub();
   if (stub && !stub->isFallback()) {
     return true;
@@ -546,22 +546,22 @@ static bool HasEnteredCounters(ICEntry& 
   return false;
 }
 
-void jit::JitSpewBaselineICStats(JSScript* script, const char* dumpReason) {
+void jit::JitSpewBaselineICStats(JSScript* script, const char* dumpReason) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(script->hasJitScript());
   JSContext* cx = TlsContext.get();
   AutoStructuredSpewer spew(cx, SpewChannel::BaselineICStats, script);
-  if (!spew) {
+  if (!spew) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   JitScript* jitScript = script->jitScript();
   spew->property("reason", dumpReason);
   spew->beginListProperty("entries");
-  for (size_t i = 0; i < jitScript->numICEntries(); i++) {
+  for (size_t i = 0; i < jitScript->numICEntries(); i++) {MOZ_RELEASE_ASSERT(0);
     ICEntry& entry = jitScript->icEntry(i);
-    if (!HasEnteredCounters(entry)) {
+    if (!HasEnteredCounters(entry)) {MOZ_RELEASE_ASSERT(0);
       continue;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     uint32_t pcOffset = entry.pcOffset();
     jsbytecode* pc = entry.pc(script);
diff --git a/js/src/jit/JitcodeMap.cpp b/js/src/jit/JitcodeMap.cpp
--- a/js/src/jit/JitcodeMap.cpp
+++ b/js/src/jit/JitcodeMap.cpp
@@ -50,7 +50,7 @@ void* JitcodeGlobalEntry::IonEntry::cano
 }
 
 bool JitcodeGlobalEntry::IonEntry::callStackAtAddr(
-    void* ptr, BytecodeLocationVector& results, uint32_t* depth) const {
+    void* ptr, BytecodeLocationVector& results, uint32_t* depth) const {MOZ_RELEASE_ASSERT(0);
   uint32_t ptrOffset;
   JitcodeRegionEntry region = RegionAtAddr(*this, ptr, &ptrOffset);
   *depth = region.scriptDepth();
@@ -58,15 +58,15 @@ bool JitcodeGlobalEntry::IonEntry::callS
   JitcodeRegionEntry::ScriptPcIterator locationIter = region.scriptPcIterator();
   MOZ_ASSERT(locationIter.hasMore());
   bool first = true;
-  while (locationIter.hasMore()) {
+  while (locationIter.hasMore()) {MOZ_RELEASE_ASSERT(0);
     uint32_t scriptIdx, pcOffset;
     locationIter.readNext(&scriptIdx, &pcOffset);
     // For the first entry pushed (innermost frame), the pcOffset is obtained
     // from the delta-run encodings.
-    if (first) {
+    if (first) {MOZ_RELEASE_ASSERT(0);
       pcOffset = region.findPcOffset(ptrOffset, pcOffset);
       first = false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     JSScript* script = getScript(scriptIdx);
     jsbytecode* pc = script->offsetToPC(pcOffset);
     if (!results.append(BytecodeLocation(script, pc))) {
@@ -144,7 +144,7 @@ void* JitcodeGlobalEntry::BaselineEntry:
 }
 
 bool JitcodeGlobalEntry::BaselineEntry::callStackAtAddr(
-    void* ptr, BytecodeLocationVector& results, uint32_t* depth) const {
+    void* ptr, BytecodeLocationVector& results, uint32_t* depth) const {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(containsPointer(ptr));
   MOZ_ASSERT(script_->hasBaselineScript());
 
@@ -304,7 +304,7 @@ JitcodeGlobalEntry* JitcodeGlobalTable::
 
   if (searchTower[0] == nullptr) {
     // Check startTower
-    if (startTower_[0] == nullptr) {
+    if (startTower_[0] == nullptr) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -336,12 +336,12 @@ bool JitcodeGlobalTable::addEntry(const 
 
   // Allocate a new entry and tower.
   JitcodeSkiplistTower* newTower = allocateTower(generateTowerHeight());
-  if (!newTower) {
+  if (!newTower) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JitcodeGlobalEntry* newEntry = allocateEntry();
-  if (!newEntry) {
+  if (!newEntry) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -777,7 +777,7 @@ void JitcodeRegionEntry::WriteDelta(Comp
 
 /* static */
 void JitcodeRegionEntry::ReadDelta(CompactBufferReader& reader,
-                                   uint32_t* nativeDelta, int32_t* pcDelta) {
+                                   uint32_t* nativeDelta, int32_t* pcDelta) {MOZ_RELEASE_ASSERT(0);
   // NB:
   // It's possible to get nativeDeltas with value 0 in two cases:
   //
@@ -791,41 +791,41 @@ void JitcodeRegionEntry::ReadDelta(Compa
 
   //  NNNN-BBB0
   const uint32_t firstByte = reader.readByte();
-  if ((firstByte & ENC1_MASK) == ENC1_MASK_VAL) {
+  if ((firstByte & ENC1_MASK) == ENC1_MASK_VAL) {MOZ_RELEASE_ASSERT(0);
     uint32_t encVal = firstByte;
     *nativeDelta = encVal >> ENC1_NATIVE_DELTA_SHIFT;
     *pcDelta = (encVal & ENC1_PC_DELTA_MASK) >> ENC1_PC_DELTA_SHIFT;
     MOZ_ASSERT_IF(*nativeDelta == 0, *pcDelta <= 0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   //  NNNN-NNNN BBBB-BB01
   const uint32_t secondByte = reader.readByte();
-  if ((firstByte & ENC2_MASK) == ENC2_MASK_VAL) {
+  if ((firstByte & ENC2_MASK) == ENC2_MASK_VAL) {MOZ_RELEASE_ASSERT(0);
     uint32_t encVal = firstByte | secondByte << 8;
     *nativeDelta = encVal >> ENC2_NATIVE_DELTA_SHIFT;
     *pcDelta = (encVal & ENC2_PC_DELTA_MASK) >> ENC2_PC_DELTA_SHIFT;
     MOZ_ASSERT(*pcDelta != 0);
     MOZ_ASSERT_IF(*nativeDelta == 0, *pcDelta <= 0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   //  NNNN-NNNN NNNB-BBBB BBBB-B011
   const uint32_t thirdByte = reader.readByte();
-  if ((firstByte & ENC3_MASK) == ENC3_MASK_VAL) {
+  if ((firstByte & ENC3_MASK) == ENC3_MASK_VAL) {MOZ_RELEASE_ASSERT(0);
     uint32_t encVal = firstByte | secondByte << 8 | thirdByte << 16;
     *nativeDelta = encVal >> ENC3_NATIVE_DELTA_SHIFT;
 
     uint32_t pcDeltaU = (encVal & ENC3_PC_DELTA_MASK) >> ENC3_PC_DELTA_SHIFT;
     // Fix sign if necessary.
-    if (pcDeltaU > static_cast<uint32_t>(ENC3_PC_DELTA_MAX)) {
+    if (pcDeltaU > static_cast<uint32_t>(ENC3_PC_DELTA_MAX)) {MOZ_RELEASE_ASSERT(0);
       pcDeltaU |= ~ENC3_PC_DELTA_MAX;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     *pcDelta = pcDeltaU;
     MOZ_ASSERT(*pcDelta != 0);
     MOZ_ASSERT_IF(*nativeDelta == 0, *pcDelta <= 0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   //  NNNN-NNNN NNNN-NNNN BBBB-BBBB BBBB-B111
   MOZ_ASSERT((firstByte & ENC4_MASK) == ENC4_MASK_VAL);
@@ -872,7 +872,7 @@ uint32_t JitcodeRegionEntry::ExpectedRun
         int32_t(nextBytecodeOffset) - int32_t(curBytecodeOffset);
 
     // If deltas are too large (very unlikely), stop the run.
-    if (!IsDeltaEncodeable(nativeDelta, bytecodeDelta)) {
+    if (!IsDeltaEncodeable(nativeDelta, bytecodeDelta)) {MOZ_RELEASE_ASSERT(0);
       break;
     }
 
@@ -1059,11 +1059,11 @@ void JitcodeRegionEntry::unpack() {
 }
 
 uint32_t JitcodeRegionEntry::findPcOffset(uint32_t queryNativeOffset,
-                                          uint32_t startPcOffset) const {
+                                          uint32_t startPcOffset) const {MOZ_RELEASE_ASSERT(0);
   DeltaIterator iter = deltaIterator();
   uint32_t curNativeOffset = nativeOffset();
   uint32_t curPcOffset = startPcOffset;
-  while (iter.hasMore()) {
+  while (iter.hasMore()) {MOZ_RELEASE_ASSERT(0);
     uint32_t nativeDelta;
     int32_t pcDelta;
     iter.readNext(&nativeDelta, &pcDelta);
@@ -1091,7 +1091,7 @@ bool JitcodeIonTable::makeIonEntry(JSCon
   typedef js::Vector<char*, 32, SystemAllocPolicy> ProfilingStringVector;
 
   ProfilingStringVector profilingStrings;
-  if (!profilingStrings.reserve(numScripts)) {
+  if (!profilingStrings.reserve(numScripts)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1104,10 +1104,10 @@ bool JitcodeIonTable::makeIonEntry(JSCon
 
   for (uint32_t i = 0; i < numScripts; i++) {
     UniqueChars str = GeckoProfilerRuntime::allocProfileString(cx, scripts[i]);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!profilingStrings.append(str.release())) {
+    if (!profilingStrings.append(str.release())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1217,13 +1217,13 @@ bool JitcodeIonTable::WriteIonTable(
             int(curEntry - start), int(runLength), int(writer.length()));
 
     // Store the offset of the run.
-    if (!runOffsets.append(writer.length())) {
+    if (!runOffsets.append(writer.length())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // Encode the run.
     if (!JitcodeRegionEntry::WriteRun(writer, scriptList, scriptListSize,
-                                      runLength, curEntry)) {
+                                      runLength, curEntry)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1292,7 +1292,7 @@ JS::ProfiledFrameHandle::ProfiledFrameHa
 
 JS_PUBLIC_API JS::ProfilingFrameIterator::FrameKind
 JS::ProfiledFrameHandle::frameKind() const {
-  if (entry_.isBaselineInterpreter()) {
+  if (entry_.isBaselineInterpreter()) {MOZ_RELEASE_ASSERT(0);
     return JS::ProfilingFrameIterator::Frame_BaselineInterpreter;
   }
   if (entry_.isBaseline()) {
diff --git a/js/src/jit/LIR.cpp b/js/src/jit/LIR.cpp
--- a/js/src/jit/LIR.cpp
+++ b/js/src/jit/LIR.cpp
@@ -89,7 +89,7 @@ bool LBlock::init(TempAllocator& alloc) 
   }
 
   // Allocate space for the LPhis.
-  if (!phis_.init(alloc, numLPhis)) {
+  if (!phis_.init(alloc, numLPhis)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -130,7 +130,7 @@ bool LBlock::init(TempAllocator& alloc) 
 
 const LInstruction* LBlock::firstInstructionWithId() const {
   for (LInstructionIterator i(instructions_.begin()); i != instructions_.end();
-       ++i) {
+       ++i) {MOZ_RELEASE_ASSERT(0);
     if (i->id()) {
       return *i;
     }
@@ -230,7 +230,7 @@ bool LRecoverInfo::appendDefinition(MDef
   auto clearWorklistFlagOnFailure =
       mozilla::MakeScopeExit([&] { def->setNotInWorklist(); });
 
-  if (!appendOperands(def)) {
+  if (!appendOperands(def)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -246,12 +246,12 @@ bool LRecoverInfo::appendResumePoint(MRe
   // Stores should be recovered first.
   for (auto iter(rp->storesBegin()), end(rp->storesEnd()); iter != end;
        ++iter) {
-    if (!appendDefinition(iter->operand)) {
+    if (!appendDefinition(iter->operand)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (rp->caller() && !appendResumePoint(rp->caller())) {
+  if (rp->caller() && !appendResumePoint(rp->caller())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/jit/Linker.cpp b/js/src/jit/Linker.cpp
--- a/js/src/jit/Linker.cpp
+++ b/js/src/jit/Linker.cpp
@@ -17,7 +17,7 @@ namespace jit {
 
 JitCode* Linker::newCode(JSContext* cx, CodeKind kind) {
   JS::AutoAssertNoGC nogc(cx);
-  if (masm.oom()) {
+  if (masm.oom()) {MOZ_RELEASE_ASSERT(0);
     return fail(cx);
   }
 
@@ -29,7 +29,7 @@ JitCode* Linker::newCode(JSContext* cx, 
   // padding.
   size_t bytesNeeded = masm.bytesNeeded() + sizeof(JitCodeHeader) +
                        (CodeAlignment - ExecutableAllocatorAlignment);
-  if (bytesNeeded >= MAX_BUFFER_SIZE) {
+  if (bytesNeeded >= MAX_BUFFER_SIZE) {MOZ_RELEASE_ASSERT(0);
     return fail(cx);
   }
 
@@ -37,7 +37,7 @@ JitCode* Linker::newCode(JSContext* cx, 
   bytesNeeded = AlignBytes(bytesNeeded, ExecutableAllocatorAlignment);
 
   JitZone* jitZone = cx->zone()->getJitZone(cx);
-  if (!jitZone) {
+  if (!jitZone) {MOZ_RELEASE_ASSERT(0);
     // Note: don't call fail(cx) here, getJitZone reports OOM.
     return nullptr;
   }
@@ -45,7 +45,7 @@ JitCode* Linker::newCode(JSContext* cx, 
   ExecutablePool* pool;
   uint8_t* result =
       (uint8_t*)jitZone->execAlloc().alloc(cx, bytesNeeded, &pool, kind);
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return fail(cx);
   }
 
@@ -61,11 +61,11 @@ JitCode* Linker::newCode(JSContext* cx, 
   if (!code) {
     return fail(cx);
   }
-  if (masm.oom()) {
+  if (masm.oom()) {MOZ_RELEASE_ASSERT(0);
     return fail(cx);
   }
   awjcf.emplace(result, bytesNeeded);
-  if (!awjcf->makeWritable()) {
+  if (!awjcf->makeWritable()) {MOZ_RELEASE_ASSERT(0);
     return fail(cx);
   }
   code->copyFrom(masm);
diff --git a/js/src/jit/Lowering.cpp b/js/src/jit/Lowering.cpp
--- a/js/src/jit/Lowering.cpp
+++ b/js/src/jit/Lowering.cpp
@@ -91,7 +91,7 @@ void LIRGenerator::visitTableSwitch(MTab
   MOZ_ASSERT(tableswitch->numSuccessors() > 0);
 
   // If there are no cases, the default case is always taken.
-  if (tableswitch->numSuccessors() == 1) {
+  if (tableswitch->numSuccessors() == 1) {MOZ_RELEASE_ASSERT(0);
     add(new (alloc()) LGoto(tableswitch->getDefault()));
     return;
   }
@@ -105,7 +105,7 @@ void LIRGenerator::visitTableSwitch(MTab
 
   // Case indices are numeric, so other types will always go to the default
   // case.
-  if (opd->type() != MIRType::Int32 && opd->type() != MIRType::Double) {
+  if (opd->type() != MIRType::Int32 && opd->type() != MIRType::Double) {MOZ_RELEASE_ASSERT(0);
     add(new (alloc()) LGoto(tableswitch->getDefault()));
     return;
   }
@@ -276,7 +276,7 @@ void LIRGenerator::visitCreateInlinedArg
 
   auto* lir = allocateVariadic<LCreateInlinedArgumentsObject>(
       numOperands, tempFixed(CallTempReg0));
-  if (!lir) {
+  if (!lir) {MOZ_RELEASE_ASSERT(0);
     abort(AbortReason::Alloc,
           "OOM: LIRGenerator::visitCreateInlinedArgumentsObject");
     return;
@@ -314,7 +314,7 @@ void LIRGenerator::visitGetInlinedArgume
       numActuals * BOX_PIECES + LGetInlinedArgument::NumNonArgumentOperands;
 
   auto* lir = allocateVariadic<LGetInlinedArgument>(numOperands);
-  if (!lir) {
+  if (!lir) {MOZ_RELEASE_ASSERT(0);
     abort(AbortReason::Alloc, "OOM: LIRGenerator::visitGetInlinedArgument");
     return;
   }
@@ -455,7 +455,7 @@ void LIRGenerator::visitCall(MCall* call
   MOZ_ASSERT(call->getCallee()->type() == MIRType::Object);
 
   // In case of oom, skip the rest of the allocations.
-  if (!lowerCallArguments(call)) {
+  if (!lowerCallArguments(call)) {MOZ_RELEASE_ASSERT(0);
     abort(AbortReason::Alloc, "OOM: LIRGenerator::visitCall");
     return;
   }
@@ -620,7 +620,7 @@ void LIRGenerator::visitUnreachableResul
   }
 }
 
-void LIRGenerator::visitAssertFloat32(MAssertFloat32* assertion) {
+void LIRGenerator::visitAssertFloat32(MAssertFloat32* assertion) {MOZ_RELEASE_ASSERT(0);
   MIRType type = assertion->input()->type();
   DebugOnly<bool> checkIsFloat32 = assertion->mustBeFloat32();
 
@@ -682,13 +682,13 @@ void LIRGenerator::visitTest(MTest* test
 
   // These must be explicitly sniffed out since they are constants and have
   // no payload.
-  if (opd->type() == MIRType::Undefined || opd->type() == MIRType::Null) {
+  if (opd->type() == MIRType::Undefined || opd->type() == MIRType::Null) {MOZ_RELEASE_ASSERT(0);
     add(new (alloc()) LGoto(ifFalse));
     return;
   }
 
   // All symbols are truthy.
-  if (opd->type() == MIRType::Symbol) {
+  if (opd->type() == MIRType::Symbol) {MOZ_RELEASE_ASSERT(0);
     add(new (alloc()) LGoto(ifTrue));
     return;
   }
@@ -716,7 +716,7 @@ void LIRGenerator::visitTest(MTest* test
           cond = Assembler::Zero;
         } else if (cond == Assembler::NotEqual) {
           cond = Assembler::NonZero;
-        } else {
+        } else {MOZ_RELEASE_ASSERT(0);
           MOZ_ASSERT_UNREACHABLE("inequality operators cannot be folded");
         }
         lowerForBitAndAndBranch(new (alloc())
@@ -737,7 +737,7 @@ void LIRGenerator::visitTest(MTest* test
 
     // Try to fold the comparison so that we don't have to handle all cases.
     bool result;
-    if (comp->tryFold(&result)) {
+    if (comp->tryFold(&result)) {MOZ_RELEASE_ASSERT(0);
       add(new (alloc()) LGoto(result ? ifTrue : ifFalse));
       return;
     }
@@ -1148,7 +1148,7 @@ static bool CanEmitBitAndAtUses(MInstruc
   }
 
   MUseIterator iter(ins->usesBegin());
-  if (iter == ins->usesEnd()) {
+  if (iter == ins->usesEnd()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1590,7 +1590,7 @@ static void MaybeSetRecoversInput(S* mir
     return;
   }
 
-  if (lir->output()->policy() != LDefinition::MUST_REUSE_INPUT) {
+  if (lir->output()->policy() != LDefinition::MUST_REUSE_INPUT) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -1750,7 +1750,7 @@ void LIRGenerator::visitMul(MMul* ins) {
 
     // We apply the same optimizations as for doubles
     if (!ins->mustPreserveNaN() && rhs->isConstant() &&
-        rhs->toConstant()->toFloat32() == -1.0f) {
+        rhs->toConstant()->toFloat32() == -1.0f) {MOZ_RELEASE_ASSERT(0);
       defineReuseInput(new (alloc()) LNegF(useRegisterAtStart(lhs)), ins, 0);
     } else {
       lowerForFPU(new (alloc()) LMathF(JSOp::Mul), ins, lhs, rhs);
@@ -2406,7 +2406,7 @@ void LIRGenerator::visitAdjustDataViewLe
   defineReuseInput(lir, ins, 0);
 }
 
-void LIRGenerator::visitToBigInt(MToBigInt* ins) {
+void LIRGenerator::visitToBigInt(MToBigInt* ins) {MOZ_RELEASE_ASSERT(0);
   MDefinition* opd = ins->input();
 
   switch (opd->type()) {
@@ -2946,7 +2946,7 @@ void LIRGenerator::visitPostWriteBarrier
   }
 }
 
-void LIRGenerator::visitPostWriteElementBarrier(MPostWriteElementBarrier* ins) {
+void LIRGenerator::visitPostWriteElementBarrier(MPostWriteElementBarrier* ins) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(ins->object()->type() == MIRType::Object);
   MOZ_ASSERT(ins->index()->type() == MIRType::Int32);
 
@@ -3712,7 +3712,7 @@ void LIRGenerator::visitStoreTypedArrayE
                   ins->value()->type() == MIRType::Float32);
     MOZ_ASSERT_IF(ins->arrayType() == Scalar::Float64,
                   ins->value()->type() == MIRType::Double);
-  } else if (ins->isBigIntWrite()) {
+  } else if (ins->isBigIntWrite()) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(ins->value()->type() == MIRType::BigInt);
   } else {
     MOZ_ASSERT(ins->value()->type() == MIRType::Int32);
@@ -3726,7 +3726,7 @@ void LIRGenerator::visitStoreTypedArrayE
   LAllocation value;
   if (ins->isByteWrite()) {
     value = useByteOpRegisterOrNonDoubleConstant(ins->value());
-  } else if (ins->isBigIntWrite()) {
+  } else if (ins->isBigIntWrite()) {MOZ_RELEASE_ASSERT(0);
     value = useRegister(ins->value());
   } else {
     value = useRegisterOrNonDoubleConstant(ins->value());
@@ -4555,12 +4555,12 @@ void LIRGenerator::visitIsCrossRealmArra
 }
 
 static bool CanEmitIsObjectOrIsNullOrUndefinedAtUses(MInstruction* ins) {
-  if (!ins->canEmitAtUses()) {
+  if (!ins->canEmitAtUses()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MUseIterator iter(ins->usesBegin());
-  if (iter == ins->usesEnd()) {
+  if (iter == ins->usesEnd()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4651,7 +4651,7 @@ void LIRGenerator::visitWasmBoundsCheck(
       auto* lir = new (alloc()) LWasmBoundsCheck64(
           useInt64RegisterAtStart(index), useInt64Register(boundsCheckLimit));
       defineInt64ReuseInput(lir, ins, 0);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       auto* lir = new (alloc())
           LWasmBoundsCheck64(useInt64RegisterAtStart(index),
                              useInt64RegisterAtStart(boundsCheckLimit));
@@ -4978,7 +4978,7 @@ void LIRGenerator::visitWasmCall(MWasmCa
   }
 
   auto* lir = allocateVariadic<LWasmCall>(ins->numOperands(), needsBoundsCheck);
-  if (!lir) {
+  if (!lir) {MOZ_RELEASE_ASSERT(0);
     abort(AbortReason::Alloc, "OOM: LIRGenerator::lowerWasmCall");
     return;
   }
@@ -5688,7 +5688,7 @@ bool LIRGenerator::visitInstruction(MIns
     return true;
   }
 
-  if (!gen->ensureBallast()) {
+  if (!gen->ensureBallast()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   visitInstructionDispatch(ins);
@@ -5758,7 +5758,7 @@ bool LIRGenerator::visitBlock(MBasicBloc
   MOZ_ASSERT_IF(block->unreachable(), !mir()->optimizationInfo().gvnEnabled());
   for (MInstructionIterator iter = block->begin(); *iter != block->lastIns();
        iter++) {
-    if (!visitInstruction(*iter)) {
+    if (!visitInstruction(*iter)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -5771,7 +5771,7 @@ bool LIRGenerator::visitBlock(MBasicBloc
     size_t lirIndex = 0;
     for (MPhiIterator phi(successor->phisBegin()); phi != successor->phisEnd();
          phi++) {
-      if (!gen->ensureBallast()) {
+      if (!gen->ensureBallast()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -5821,7 +5821,7 @@ bool LIRGenerator::generate() {
       return false;
     }
 
-    if (!lirGraph_.initBlock(*block)) {
+    if (!lirGraph_.initBlock(*block)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -5887,7 +5887,7 @@ void LIRGenerator::visitIonToWasmCall(MI
   } else {
     lir = allocateVariadic<LIonToWasmCall>(ins->numOperands(), scratch, fp);
   }
-  if (!lir) {
+  if (!lir) {MOZ_RELEASE_ASSERT(0);
     abort(AbortReason::Alloc, "OOM: LIRGenerator::visitIonToWasmCall");
     return;
   }
diff --git a/js/src/jit/MIR.cpp b/js/src/jit/MIR.cpp
--- a/js/src/jit/MIR.cpp
+++ b/js/src/jit/MIR.cpp
@@ -223,7 +223,7 @@ static MMul* EvaluateExactReciprocal(Tem
   ret.setDouble(1.0 / double(num));
 
   MConstant* foldedRhs;
-  if (ins->type() == MIRType::Float32) {
+  if (ins->type() == MIRType::Float32) {MOZ_RELEASE_ASSERT(0);
     foldedRhs = MConstant::NewFloat32(alloc, ret.toDouble());
   } else {
     foldedRhs = MConstant::New(alloc, ret);
@@ -313,7 +313,7 @@ HashNumber MQuaternaryInstruction::value
 }
 
 bool MDefinition::congruentIfOperandsEqual(const MDefinition* ins) const {
-  if (op() != ins->op()) {
+  if (op() != ins->op()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -321,11 +321,11 @@ bool MDefinition::congruentIfOperandsEqu
     return false;
   }
 
-  if (isEffectful() || ins->isEffectful()) {
+  if (isEffectful() || ins->isEffectful()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (numOperands() != ins->numOperands()) {
+  if (numOperands() != ins->numOperands()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -344,7 +344,7 @@ MDefinition* MDefinition::foldsTo(TempAl
 }
 
 bool MDefinition::mightBeMagicType() const {
-  if (IsMagicType(type())) {
+  if (IsMagicType(type())) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -520,7 +520,7 @@ MDefinition* MTest::foldsNeedlessControl
     }
   }
 
-  if (ifTrue()->numSuccessors() != 1 || ifFalse()->numSuccessors() != 1) {
+  if (ifTrue()->numSuccessors() != 1 || ifFalse()->numSuccessors() != 1) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (ifTrue()->getSuccessor(0) != ifFalse()->getSuccessor(0)) {
@@ -543,7 +543,7 @@ MDefinition* MTest::foldsTo(TempAllocato
     return def;
   }
 
-  if (MDefinition* def = foldsTypes(alloc)) {
+  if (MDefinition* def = foldsTypes(alloc)) {MOZ_RELEASE_ASSERT(0);
     return def;
   }
 
@@ -669,8 +669,8 @@ bool MDefinition::hasOneDefUse() const {
   return hasOneDefUse;
 }
 
-bool MDefinition::hasDefUses() const {
-  for (MUseIterator i(uses_.begin()); i != uses_.end(); i++) {
+bool MDefinition::hasDefUses() const {MOZ_RELEASE_ASSERT(0);
+  for (MUseIterator i(uses_.begin()); i != uses_.end(); i++) {MOZ_RELEASE_ASSERT(0);
     if ((*i)->consumer()->isDefinition()) {
       return true;
     }
diff --git a/js/src/jit/MIRGraph.cpp b/js/src/jit/MIRGraph.cpp
--- a/js/src/jit/MIRGraph.cpp
+++ b/js/src/jit/MIRGraph.cpp
@@ -43,8 +43,8 @@ MIRGenerator::MIRGenerator(CompileRealm*
       options(options),
       gs_(alloc) {}
 
-mozilla::GenericErrorResult<AbortReason> MIRGenerator::abort(AbortReason r) {
-  if (JitSpewEnabled(JitSpew_IonAbort)) {
+mozilla::GenericErrorResult<AbortReason> MIRGenerator::abort(AbortReason r) {MOZ_RELEASE_ASSERT(0);
+  if (JitSpewEnabled(JitSpew_IonAbort)) {MOZ_RELEASE_ASSERT(0);
     switch (r) {
       case AbortReason::Alloc:
         JitSpew(JitSpew_IonAbort, "AbortReason::Alloc");
@@ -100,19 +100,19 @@ void MIRGraph::insertBlockBefore(MBasicB
 void MIRGraph::removeBlock(MBasicBlock* block) {
   // Remove a block from the graph. It will also cleanup the block.
 
-  if (block == osrBlock_) {
+  if (block == osrBlock_) {MOZ_RELEASE_ASSERT(0);
     osrBlock_ = nullptr;
   }
 
-  if (returnAccumulator_) {
+  if (returnAccumulator_) {MOZ_RELEASE_ASSERT(0);
     size_t i = 0;
-    while (i < returnAccumulator_->length()) {
-      if ((*returnAccumulator_)[i] == block) {
+    while (i < returnAccumulator_->length()) {MOZ_RELEASE_ASSERT(0);
+      if ((*returnAccumulator_)[i] == block) {MOZ_RELEASE_ASSERT(0);
         returnAccumulator_->erase(returnAccumulator_->begin() + i);
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         i++;
       }
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   block->clear();
@@ -136,7 +136,7 @@ MBasicBlock* MBasicBlock::New(MIRGraph& 
   MOZ_ASSERT(site->pc() != nullptr);
 
   MBasicBlock* block = new (graph.alloc()) MBasicBlock(graph, info, site, kind);
-  if (!block->init()) {
+  if (!block->init()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -153,7 +153,7 @@ MBasicBlock* MBasicBlock::NewPopN(MIRGra
   MOZ_ASSERT(site->pc() != nullptr);
 
   MBasicBlock* block = new (graph.alloc()) MBasicBlock(graph, info, site, kind);
-  if (!block->init()) {
+  if (!block->init()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -172,7 +172,7 @@ MBasicBlock* MBasicBlock::NewPendingLoop
 
   MBasicBlock* block =
       new (graph.alloc()) MBasicBlock(graph, info, site, PENDING_LOOP_HEADER);
-  if (!block->init()) {
+  if (!block->init()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -189,7 +189,7 @@ MBasicBlock* MBasicBlock::NewSplitEdge(M
   if (!succ->pc()) {
     // The predecessor does not have a PC, this is a Wasm compilation.
     split = MBasicBlock::New(graph, succ->info(), pred, SPLIT_EDGE);
-    if (!split) {
+    if (!split) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
@@ -201,7 +201,7 @@ MBasicBlock* MBasicBlock::NewSplitEdge(M
     split =
         new (graph.alloc()) MBasicBlock(graph, succ->info(), site, SPLIT_EDGE);
 
-    if (!split->init()) {
+    if (!split->init()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -222,7 +222,7 @@ MBasicBlock* MBasicBlock::NewSplitEdge(M
     // Create a resume point using our initial stack position.
     MResumePoint* splitEntry = new (graph.alloc())
         MResumePoint(split, succEntry->pc(), MResumePoint::ResumeAt);
-    if (!splitEntry->init(graph.alloc())) {
+    if (!splitEntry->init(graph.alloc())) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     split->entryResumePoint_ = splitEntry;
@@ -266,7 +266,7 @@ MBasicBlock* MBasicBlock::New(MIRGraph& 
                               MBasicBlock* pred, Kind kind) {
   BytecodeSite* site = new (graph.alloc()) BytecodeSite();
   MBasicBlock* block = new (graph.alloc()) MBasicBlock(graph, info, site, kind);
-  if (!block->init()) {
+  if (!block->init()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -282,7 +282,7 @@ MBasicBlock* MBasicBlock::New(MIRGraph& 
       MPhi* phis = nullptr;
       if (nphis > nfree) {
         phis = alloc.allocateArray<MPhi>(nphis - nfree);
-        if (!phis) {
+        if (!phis) {MOZ_RELEASE_ASSERT(0);
           return nullptr;
         }
       }
@@ -308,7 +308,7 @@ MBasicBlock* MBasicBlock::New(MIRGraph& 
         block->setSlot(i, phi);
       }
     } else {
-      if (!block->ensureHasSlots(0)) {
+      if (!block->ensureHasSlots(0)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       block->copySlots(pred);
@@ -336,7 +336,7 @@ MBasicBlock* MBasicBlock::NewFakeLoopPre
   MBasicBlock* backedge = header->backedge();
   MBasicBlock* fake = MBasicBlock::New(graph, header->info(), nullptr,
                                        MBasicBlock::FAKE_LOOP_PRED);
-  if (!fake) {
+  if (!fake) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -349,7 +349,7 @@ MBasicBlock* MBasicBlock::NewFakeLoopPre
     MPhi* phi = *iter;
     auto* fakeDef = MUnreachableResult::New(graph.alloc(), phi->type());
     fake->add(fakeDef);
-    if (!phi->addInputSlow(fakeDef)) {
+    if (!phi->addInputSlow(fakeDef)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -465,19 +465,19 @@ bool MBasicBlock::inherit(TempAllocator&
   // Create a resume point using our initial stack state.
   entryResumePoint_ =
       new (alloc) MResumePoint(this, pc(), MResumePoint::ResumeAt);
-  if (!entryResumePoint_->init(alloc)) {
+  if (!entryResumePoint_->init(alloc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (maybePred) {
-    if (!predecessors_.append(maybePred)) {
+    if (!predecessors_.append(maybePred)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (kind_ == PENDING_LOOP_HEADER) {
       for (size_t i = 0; i < stackDepth; i++) {
         MPhi* phi = MPhi::New(alloc.fallible());
-        if (!phi) {
+        if (!phi) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         phi->addInlineInput(maybePred->getSlot(i));
@@ -673,7 +673,7 @@ void MBasicBlock::discardIgnoreOperands(
 }
 
 void MBasicBlock::discardDef(MDefinition* at) {
-  if (at->isPhi()) {
+  if (at->isPhi()) {MOZ_RELEASE_ASSERT(0);
     at->block()->discardPhi(at->toPhi());
   } else {
     at->block()->discard(at->toInstruction());
@@ -841,20 +841,20 @@ bool MBasicBlock::addPredecessorPopN(Tem
         MOZ_ASSERT(!mine->hasDefUses(),
                    "should only change type of newly created phis");
         mine->setResultType(phiType);
-        if (!mine->toPhi()->addInputSlow(other)) {
+        if (!mine->toPhi()->addInputSlow(other)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
         // Otherwise, create a new phi node.
         MPhi* phi = MPhi::New(alloc.fallible(), phiType);
-        if (!phi) {
+        if (!phi) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         addPhi(phi);
 
         // Prime the phi for each predecessor, so input(x) comes from
         // predecessor(x).
-        if (!phi->reserveLength(predecessors_.length() + 1)) {
+        if (!phi->reserveLength(predecessors_.length() + 1)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -888,7 +888,7 @@ bool MBasicBlock::addPredecessorSameInpu
   if (!phisEmpty()) {
     size_t existingPosition = indexForPredecessor(existingPred);
     for (MPhiIterator iter = phisBegin(); iter != phisEnd(); iter++) {
-      if (!iter->addInputSlow(iter->getOperand(existingPosition))) {
+      if (!iter->addInputSlow(iter->getOperand(existingPosition))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1136,7 +1136,7 @@ bool MBasicBlock::inheritPhisFromBackedg
 
     // Get the value of the loop header.
     MDefinition* loopDef = entryResumePoint()->getOperand(slot);
-    if (loopDef->block() != this) {
+    if (loopDef->block() != this) {MOZ_RELEASE_ASSERT(0);
       // If we are finishing a pending loop header, then we need to ensure
       // that all operands are phis. This is usualy the case, except for
       // object/arrays build with generators, in which case we share the
@@ -1177,7 +1177,7 @@ MTest* MBasicBlock::immediateDominatorBr
   }
 
   MBasicBlock* dom = immediateDominator();
-  if (dom != getPredecessor(0)) {
+  if (dom != getPredecessor(0)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1198,7 +1198,7 @@ MTest* MBasicBlock::immediateDominatorBr
   return nullptr;
 }
 
-void MBasicBlock::dumpStack(GenericPrinter& out) {
+void MBasicBlock::dumpStack(GenericPrinter& out) {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
   out.printf(" %-3s %-16s %-6s %-10s\n", "#", "name", "copyOf", "first/next");
   out.printf("-------------------------------------------\n");
@@ -1215,7 +1215,7 @@ void MBasicBlock::dumpStack() {
   out.finish();
 }
 
-void MIRGraph::dump(GenericPrinter& out) {
+void MIRGraph::dump(GenericPrinter& out) {MOZ_RELEASE_ASSERT(0);
 #ifdef JS_JITSPEW
   for (MBasicBlockIterator iter(begin()); iter != end(); iter++) {
     iter->dump(out);
@@ -1230,7 +1230,7 @@ void MIRGraph::dump() {
   out.finish();
 }
 
-void MBasicBlock::dump(GenericPrinter& out) {
+void MBasicBlock::dump(GenericPrinter& out) {MOZ_RELEASE_ASSERT(0);
 #ifdef JS_JITSPEW
   out.printf("block%u:%s%s%s\n", id(), isLoopHeader() ? " (loop header)" : "",
              unreachable() ? " (unreachable)" : "",
diff --git a/js/src/jit/MacroAssembler.cpp b/js/src/jit/MacroAssembler.cpp
--- a/js/src/jit/MacroAssembler.cpp
+++ b/js/src/jit/MacroAssembler.cpp
@@ -311,7 +311,7 @@ void MacroAssembler::nurseryAllocateObje
   // shouldNurseryAllocate; however, we need to insert into the
   // mallocedBuffers set, so bail to do the nursery allocation in the
   // interpreter.
-  if (nDynamicSlots >= Nursery::MaxNurseryBufferSize / sizeof(Value)) {
+  if (nDynamicSlots >= Nursery::MaxNurseryBufferSize / sizeof(Value)) {MOZ_RELEASE_ASSERT(0);
     jump(fail);
     return;
   }
@@ -443,7 +443,7 @@ void MacroAssembler::createGCObject(Regi
 void MacroAssembler::createPlainGCObject(
     Register result, Register shape, Register temp, Register temp2,
     uint32_t numFixedSlots, uint32_t numDynamicSlots, gc::AllocKind allocKind,
-    gc::InitialHeap initialHeap, Label* fail) {
+    gc::InitialHeap initialHeap, Label* fail) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(gc::IsObjectAllocKind(allocKind));
   MOZ_ASSERT(shape != temp, "shape can overlap with temp2, but not temp");
 
@@ -455,10 +455,10 @@ void MacroAssembler::createPlainGCObject
 
   // If the object has dynamic slots, allocateObject will initialize
   // the slots field. If not, we must initialize it now.
-  if (numDynamicSlots == 0) {
+  if (numDynamicSlots == 0) {MOZ_RELEASE_ASSERT(0);
     storePtr(ImmPtr(emptyObjectSlots),
              Address(result, NativeObject::offsetOfSlots()));
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Initialize elements field.
   storePtr(ImmPtr(emptyObjectElements),
@@ -548,7 +548,7 @@ void MacroAssembler::bumpPointerAllocate
         (CheckedInt<uintptr_t>(uintptr_t(countAddress)) -
          CheckedInt<uintptr_t>(uintptr_t(posAddr)))
             .toChecked<int32_t>();
-    if (counterOffset.isValid()) {
+    if (counterOffset.isValid()) {MOZ_RELEASE_ASSERT(0);
       add32(Imm32(1), Address(temp, counterOffset.value()));
     } else {
       movePtr(ImmPtr(countAddress), temp);
@@ -900,7 +900,7 @@ void MacroAssembler::initGCThing(Registe
 
       initGCSlots(obj, temp, ntemplate, initContents);
 
-      if (ntemplate.hasPrivate() && !ntemplate.isTypedArrayObject()) {
+      if (ntemplate.hasPrivate() && !ntemplate.isTypedArrayObject()) {MOZ_RELEASE_ASSERT(0);
         uint32_t nfixed = ntemplate.numFixedSlots();
         Address privateSlot(obj, NativeObject::getPrivateDataOffset(nfixed));
         storeObjPrivate(ImmPtr(ntemplate.getPrivate()), privateSlot);
@@ -2289,7 +2289,7 @@ void MacroAssembler::convertValueToFloat
   // On some non-multiAlias platforms, unboxDouble may use the scratch register,
   // so do not merge code paths here.
   bind(&isDouble);
-  if (outputType == MIRType::Float32 && hasMultiAlias()) {
+  if (outputType == MIRType::Float32 && hasMultiAlias()) {MOZ_RELEASE_ASSERT(0);
     ScratchDoubleScope tmp(*this);
     unboxDouble(value, tmp);
     convertDoubleToFloat32(tmp, output);
@@ -2811,7 +2811,7 @@ void MacroAssembler::Push(TypedOrValueRe
     Push(v.valueReg());
   } else if (IsFloatingPointType(v.type())) {
     FloatRegister reg = v.typedReg().fpu();
-    if (v.type() == MIRType::Float32) {
+    if (v.type() == MIRType::Float32) {MOZ_RELEASE_ASSERT(0);
       ScratchDoubleScope fpscratch(*this);
       convertFloat32ToDouble(reg, fpscratch);
       PushBoxed(fpscratch);
@@ -3692,13 +3692,13 @@ CodeOffset MacroAssembler::wasmCallBuilt
   if (instanceArg.kind() == ABIArg::GPR) {
     loadPtr(Address(WasmTlsReg, offsetof(wasm::TlsData, instance)),
             instanceArg.gpr());
-  } else if (instanceArg.kind() == ABIArg::Stack) {
+  } else if (instanceArg.kind() == ABIArg::Stack) {MOZ_RELEASE_ASSERT(0);
     // Safe to use ABINonArgReg0 since it's the last thing before the call.
     Register scratch = ABINonArgReg0;
     loadPtr(Address(WasmTlsReg, offsetof(wasm::TlsData, instance)), scratch);
     storePtr(scratch,
              Address(getStackPointer(), instanceArg.offsetFromArgBase()));
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     MOZ_CRASH("Unknown abi passing style for pointer");
   }
 
diff --git a/js/src/jit/MoveResolver.cpp b/js/src/jit/MoveResolver.cpp
--- a/js/src/jit/MoveResolver.cpp
+++ b/js/src/jit/MoveResolver.cpp
@@ -301,7 +301,7 @@ bool MoveResolver::resolve() {
         // complete and not participating in a cycle. The resulting
         // move can safely be added to the ordered move list.
         PendingMove* done = stack.popBack();
-        if (!addOrderedMove(*done)) {
+        if (!addOrderedMove(*done)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         movePool_.free(done);
@@ -356,12 +356,12 @@ bool MoveResolver::addOrderedMove(const 
   return orderedMoves_.append(move);
 }
 
-void MoveResolver::reorderMove(size_t from, size_t to) {
+void MoveResolver::reorderMove(size_t from, size_t to) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(from != to);
 
   MoveOp op = orderedMoves_[from];
-  if (from < to) {
-    for (size_t i = from; i < to; i++) {
+  if (from < to) {MOZ_RELEASE_ASSERT(0);
+    for (size_t i = from; i < to; i++) {MOZ_RELEASE_ASSERT(0);
       orderedMoves_[i] = orderedMoves_[i + 1];
     }
   } else {
@@ -372,50 +372,50 @@ void MoveResolver::reorderMove(size_t fr
   orderedMoves_[to] = op;
 }
 
-void MoveResolver::sortMemoryToMemoryMoves() {
+void MoveResolver::sortMemoryToMemoryMoves() {MOZ_RELEASE_ASSERT(0);
   // Try to reorder memory->memory moves so that they are executed right
   // before a move that clobbers some register. This will allow the move
   // emitter to use that clobbered register as a scratch register for the
   // memory->memory move, if necessary.
-  for (size_t i = 0; i < orderedMoves_.length(); i++) {
+  for (size_t i = 0; i < orderedMoves_.length(); i++) {MOZ_RELEASE_ASSERT(0);
     const MoveOp& base = orderedMoves_[i];
-    if (!base.from().isMemory() || !base.to().isMemory()) {
+    if (!base.from().isMemory() || !base.to().isMemory()) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
-    if (base.type() != MoveOp::GENERAL && base.type() != MoveOp::INT32) {
+    if (base.type() != MoveOp::GENERAL && base.type() != MoveOp::INT32) {MOZ_RELEASE_ASSERT(0);
       continue;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Look for an earlier move clobbering a register.
     bool found = false;
-    for (int j = i - 1; j >= 0; j--) {
+    for (int j = i - 1; j >= 0; j--) {MOZ_RELEASE_ASSERT(0);
       const MoveOp& previous = orderedMoves_[j];
       if (previous.aliases(base) || previous.isCycleBegin() ||
-          previous.isCycleEnd()) {
+          previous.isCycleEnd()) {MOZ_RELEASE_ASSERT(0);
         break;
       }
 
-      if (previous.to().isGeneralReg()) {
+      if (previous.to().isGeneralReg()) {MOZ_RELEASE_ASSERT(0);
         reorderMove(i, j);
         found = true;
         break;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
-    if (found) {
+    if (found) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
     // Look for a later move clobbering a register.
-    if (i + 1 < orderedMoves_.length()) {
+    if (i + 1 < orderedMoves_.length()) {MOZ_RELEASE_ASSERT(0);
       bool found = false, skippedRegisterUse = false;
-      for (size_t j = i + 1; j < orderedMoves_.length(); j++) {
+      for (size_t j = i + 1; j < orderedMoves_.length(); j++) {MOZ_RELEASE_ASSERT(0);
         const MoveOp& later = orderedMoves_[j];
-        if (later.aliases(base) || later.isCycleBegin() || later.isCycleEnd()) {
+        if (later.aliases(base) || later.isCycleBegin() || later.isCycleEnd()) {MOZ_RELEASE_ASSERT(0);
           break;
         }
 
-        if (later.to().isGeneralReg()) {
-          if (skippedRegisterUse) {
+        if (later.to().isGeneralReg()) {MOZ_RELEASE_ASSERT(0);
+          if (skippedRegisterUse) {MOZ_RELEASE_ASSERT(0);
             reorderMove(i, j);
             found = true;
           } else {
@@ -424,13 +424,13 @@ void MoveResolver::sortMemoryToMemoryMov
             // clobbers a register. The move should already be able
             // to use a scratch register, so don't shift anything
             // around.
-          }
+          }MOZ_RELEASE_ASSERT(0);
           break;
         }
 
-        if (later.from().isGeneralReg()) {
+        if (later.from().isGeneralReg()) {MOZ_RELEASE_ASSERT(0);
           skippedRegisterUse = true;
-        }
+        }MOZ_RELEASE_ASSERT(0);
       }
 
       if (found) {
diff --git a/js/src/jit/ProcessExecutableMemory.cpp b/js/src/jit/ProcessExecutableMemory.cpp
--- a/js/src/jit/ProcessExecutableMemory.cpp
+++ b/js/src/jit/ProcessExecutableMemory.cpp
@@ -145,7 +145,7 @@ PRUNTIME_FUNCTION RuntimeFunctionCallbac
 // For an explanation of the problem being solved here, see
 // SetJitExceptionFilter in jsfriendapi.h.
 static bool RegisterExecutableMemory(void* p, size_t bytes, size_t pageSize) {
-  if (!VirtualAlloc(p, pageSize, MEM_COMMIT, PAGE_READWRITE)) {
+  if (!VirtualAlloc(p, pageSize, MEM_COMMIT, PAGE_READWRITE)) {MOZ_RELEASE_ASSERT(0);
     MOZ_CRASH();
   }
 
@@ -257,12 +257,12 @@ static void* ReserveProcessExecutableMem
     }
   }
 
-  if (!p) {
+  if (!p) {MOZ_RELEASE_ASSERT(0);
     // Try again without randomization.
     p = VirtualAlloc(nullptr, bytes, MEM_RESERVE, PAGE_NOACCESS);
-    if (!p) {
+    if (!p) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
 #  ifdef NEED_JIT_UNWIND_HANDLING
@@ -597,7 +597,7 @@ void* ProcessExecutableMemory::allocate(
     MOZ_ASSERT(pagesAllocated_ <= MaxCodePages);
 
     // Check if we have enough pages available.
-    if (pagesAllocated_ + numPages >= MaxCodePages) {
+    if (pagesAllocated_ + numPages >= MaxCodePages) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -608,7 +608,7 @@ void* ProcessExecutableMemory::allocate(
 
     for (size_t i = 0; i < MaxCodePages; i++) {
       // Make sure page + numPages - 1 is a valid index.
-      if (page + numPages > MaxCodePages) {
+      if (page + numPages > MaxCodePages) {MOZ_RELEASE_ASSERT(0);
         page = 0;
       }
 
@@ -642,7 +642,7 @@ void* ProcessExecutableMemory::allocate(
       p = base_ + page * ExecutableCodePageSize;
       break;
     }
-    if (!p) {
+    if (!p) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -777,7 +777,7 @@ bool js::jit::ReprotectRegion(void* star
 #ifdef XP_WIN
   DWORD oldProtect;
   DWORD flags = ProtectionSettingToFlags(protection);
-  if (!VirtualProtect(pageStart, size, flags, &oldProtect)) {
+  if (!VirtualProtect(pageStart, size, flags, &oldProtect)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 #else
@@ -793,7 +793,7 @@ bool js::jit::ReprotectRegion(void* star
 
 #if defined(XP_WIN) && defined(NEED_JIT_UNWIND_HANDLING)
 static PRUNTIME_FUNCTION RuntimeFunctionCallback(DWORD64 ControlPc,
-                                                 PVOID Context) {
+                                                 PVOID Context) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(sJitExceptionHandler);
 
   // RegisterExecutableMemory already set up the runtime function in the
diff --git a/js/src/jit/RangeAnalysis.cpp b/js/src/jit/RangeAnalysis.cpp
--- a/js/src/jit/RangeAnalysis.cpp
+++ b/js/src/jit/RangeAnalysis.cpp
@@ -200,7 +200,7 @@ bool RangeAnalysis::addBetaNodes() {
     }
 
     // TODO: support unsigned comparisons
-    if (compare->compareType() == MCompare::Compare_UInt32) {
+    if (compare->compareType() == MCompare::Compare_UInt32) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
@@ -243,7 +243,7 @@ bool RangeAnalysis::addBetaNodes() {
         greater = left;
       }
       if (smaller && greater) {
-        if (!alloc().ensureBallast()) {
+        if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -342,7 +342,7 @@ bool RangeAnalysis::addBetaNodes() {
         continue;
     }
 
-    if (JitSpewEnabled(JitSpew_Range)) {
+    if (JitSpewEnabled(JitSpew_Range)) {MOZ_RELEASE_ASSERT(0);
       JitSpewHeader(JitSpew_Range);
       Fprinter& out = JitSpewPrinter();
       out.printf("  Adding beta node for %u with range ", val->id());
@@ -386,7 +386,7 @@ bool RangeAnalysis::removeBetaNodes() {
   return true;
 }
 
-void SymbolicBound::dump(GenericPrinter& out) const {
+void SymbolicBound::dump(GenericPrinter& out) const {MOZ_RELEASE_ASSERT(0);
   if (loop) {
     out.printf("[loop] ");
   }
@@ -402,9 +402,9 @@ void SymbolicBound::dump() const {
 
 // Test whether the given range's exponent tells us anything that its lower
 // and upper bound values don't.
-static bool IsExponentInteresting(const Range* r) {
+static bool IsExponentInteresting(const Range* r) {MOZ_RELEASE_ASSERT(0);
   // If it lacks either a lower or upper bound, the exponent is interesting.
-  if (!r->hasInt32Bounds()) {
+  if (!r->hasInt32Bounds()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -419,41 +419,41 @@ static bool IsExponentInteresting(const 
   return FloorLog2(std::max(Abs(r->lower()), Abs(r->upper()))) > r->exponent();
 }
 
-void Range::dump(GenericPrinter& out) const {
+void Range::dump(GenericPrinter& out) const {MOZ_RELEASE_ASSERT(0);
   assertInvariants();
 
   // Floating-point or Integer subset.
-  if (canHaveFractionalPart_) {
+  if (canHaveFractionalPart_) {MOZ_RELEASE_ASSERT(0);
     out.printf("F");
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     out.printf("I");
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   out.printf("[");
 
-  if (!hasInt32LowerBound_) {
+  if (!hasInt32LowerBound_) {MOZ_RELEASE_ASSERT(0);
     out.printf("?");
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     out.printf("%d", lower_);
   }
-  if (symbolicLower_) {
+  if (symbolicLower_) {MOZ_RELEASE_ASSERT(0);
     out.printf(" {");
     symbolicLower_->dump(out);
     out.printf("}");
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   out.printf(", ");
 
-  if (!hasInt32UpperBound_) {
+  if (!hasInt32UpperBound_) {MOZ_RELEASE_ASSERT(0);
     out.printf("?");
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     out.printf("%d", upper_);
   }
-  if (symbolicUpper_) {
+  if (symbolicUpper_) {MOZ_RELEASE_ASSERT(0);
     out.printf(" {");
     symbolicUpper_->dump(out);
     out.printf("}");
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   out.printf("]");
 
@@ -465,41 +465,41 @@ void Range::dump(GenericPrinter& out) co
   bool includesNegativeZero = canBeNegativeZero_;
 
   if (includesNaN || includesNegativeInfinity || includesPositiveInfinity ||
-      includesNegativeZero) {
+      includesNegativeZero) {MOZ_RELEASE_ASSERT(0);
     out.printf(" (");
     bool first = true;
-    if (includesNaN) {
-      if (first) {
+    if (includesNaN) {MOZ_RELEASE_ASSERT(0);
+      if (first) {MOZ_RELEASE_ASSERT(0);
         first = false;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         out.printf(" ");
-      }
+      }MOZ_RELEASE_ASSERT(0);
       out.printf("U NaN");
     }
-    if (includesNegativeInfinity) {
-      if (first) {
+    if (includesNegativeInfinity) {MOZ_RELEASE_ASSERT(0);
+      if (first) {MOZ_RELEASE_ASSERT(0);
         first = false;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         out.printf(" ");
-      }
+      }MOZ_RELEASE_ASSERT(0);
       out.printf("U -Infinity");
     }
-    if (includesPositiveInfinity) {
-      if (first) {
+    if (includesPositiveInfinity) {MOZ_RELEASE_ASSERT(0);
+      if (first) {MOZ_RELEASE_ASSERT(0);
         first = false;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         out.printf(" ");
-      }
+      }MOZ_RELEASE_ASSERT(0);
       out.printf("U Infinity");
     }
-    if (includesNegativeZero) {
-      if (first) {
+    if (includesNegativeZero) {MOZ_RELEASE_ASSERT(0);
+      if (first) {MOZ_RELEASE_ASSERT(0);
         first = false;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         out.printf(" ");
-      }
+      }MOZ_RELEASE_ASSERT(0);
       out.printf("U -0");
-    }
+    }MOZ_RELEASE_ASSERT(0);
     out.printf(")");
   }
   if (max_exponent_ < IncludesInfinity && IsExponentInteresting(this)) {
@@ -518,14 +518,14 @@ Range* Range::intersect(TempAllocator& a
                         const Range* rhs, bool* emptyRange) {
   *emptyRange = false;
 
-  if (!lhs && !rhs) {
+  if (!lhs && !rhs) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!lhs) {
+  if (!lhs) {MOZ_RELEASE_ASSERT(0);
     return new (alloc) Range(*rhs);
   }
-  if (!rhs) {
+  if (!rhs) {MOZ_RELEASE_ASSERT(0);
     return new (alloc) Range(*lhs);
   }
 
@@ -874,7 +874,7 @@ Range* Range::or_(TempAllocator& alloc, 
     if (lhs->lower() == 0) {
       return new (alloc) Range(*rhs);
     }
-    if (lhs->lower() == -1) {
+    if (lhs->lower() == -1) {MOZ_RELEASE_ASSERT(0);
       return new (alloc) Range(*lhs);
     }
   }
@@ -882,7 +882,7 @@ Range* Range::or_(TempAllocator& alloc, 
     if (rhs->lower() == 0) {
       return new (alloc) Range(*lhs);
     }
-    if (rhs->lower() == -1) {
+    if (rhs->lower() == -1) {MOZ_RELEASE_ASSERT(0);
       return new (alloc) Range(*rhs);
     }
   }
@@ -907,7 +907,7 @@ Range* Range::or_(TempAllocator& alloc, 
                                            CountLeadingZeroes32(rhs->upper())));
   } else {
     // The result will have leading ones where either operand has leading ones.
-    if (lhs->upper() < 0) {
+    if (lhs->upper() < 0) {MOZ_RELEASE_ASSERT(0);
       unsigned leadingOnes = CountLeadingZeroes32(~lhs->lower());
       lower = std::max(lower, ~int32_t(UINT32_MAX >> leadingOnes));
       upper = -1;
@@ -1001,7 +1001,7 @@ Range* Range::mul(TempAllocator& alloc, 
   if (!lhs->canBeInfiniteOrNaN() && !rhs->canBeInfiniteOrNaN()) {
     // Two finite values.
     exponent = lhs->numBits() + rhs->numBits() - 1;
-    if (exponent > Range::MaxFiniteExponent) {
+    if (exponent > Range::MaxFiniteExponent) {MOZ_RELEASE_ASSERT(0);
       exponent = Range::IncludesInfinity;
     }
   } else if (!lhs->canBeNaN() && !rhs->canBeNaN() &&
@@ -1582,7 +1582,7 @@ void MMod::computeRange(TempAllocator& a
 
   // If both operands are non-negative integers, we can optimize this to an
   // unsigned mod.
-  if (type() == MIRType::Int32 && rhs.lower() > 0) {
+  if (type() == MIRType::Int32 && rhs.lower() > 0) {MOZ_RELEASE_ASSERT(0);
     bool hasDoubles = lhs.lower() < 0 || lhs.canHaveFractionalPart() ||
                       rhs.canHaveFractionalPart();
     // It is not possible to check that lhs.lower() >= 0, since the range
@@ -1613,7 +1613,7 @@ void MMod::computeRange(TempAllocator& a
     if (lhs.lower() <= -1 && lhs.upper() >= -1) {
       lhsBound = UINT32_MAX;
     }
-    if (rhs.lower() <= -1 && rhs.upper() >= -1) {
+    if (rhs.lower() <= -1 && rhs.upper() >= -1) {MOZ_RELEASE_ASSERT(0);
       rhsBound = UINT32_MAX;
     }
 
@@ -1632,7 +1632,7 @@ void MMod::computeRange(TempAllocator& a
   // absolute value of rhs. (And if rhs is zero, the result is NaN).
   int64_t a = Abs<int64_t>(rhs.lower());
   int64_t b = Abs<int64_t>(rhs.upper());
-  if (a == 0 && b == 0) {
+  if (a == 0 && b == 0) {MOZ_RELEASE_ASSERT(0);
     return;
   }
   int64_t rhsAbsBound = std::max(a, b);
@@ -1944,7 +1944,7 @@ bool RangeAnalysis::analyzeLoop(MBasicBl
       direction = NegateBranchDirection(direction);
       MBasicBlock* otherBlock = branch->branchSuccessor(direction);
       if (!otherBlock->isMarked()) {
-        if (!alloc().ensureBallast()) {
+        if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         iterationBound = analyzeLoopIterationCount(header, branch, direction);
@@ -1960,7 +1960,7 @@ bool RangeAnalysis::analyzeLoop(MBasicBl
     return true;
   }
 
-  if (!loopIterationBounds.append(iterationBound)) {
+  if (!loopIterationBounds.append(iterationBound)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1999,11 +1999,11 @@ bool RangeAnalysis::analyzeLoop(MBasicBl
       for (MDefinitionIterator iter(block); iter; iter++) {
         MDefinition* def = *iter;
         if (def->isBoundsCheck() && def->isMovable()) {
-          if (!alloc().ensureBallast()) {
+          if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
           if (tryHoistBoundsCheck(header, def->toBoundsCheck())) {
-            if (!hoistedChecks.append(def->toBoundsCheck())) {
+            if (!hoistedChecks.append(def->toBoundsCheck())) {MOZ_RELEASE_ASSERT(0);
               return false;
             }
           }
@@ -2053,7 +2053,7 @@ LoopIterationBound* RangeAnalysis::analy
     MDefinition* temp = lhs.term;
     lhs.term = rhs;
     rhs = temp;
-    if (!SafeSub(0, lhs.constant, &lhs.constant)) {
+    if (!SafeSub(0, lhs.constant, &lhs.constant)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     lessEqual = !lessEqual;
@@ -2071,7 +2071,7 @@ LoopIterationBound* RangeAnalysis::analy
   // iteration with a value that is a constant difference from its value at
   // the start of the iteration.
 
-  if (lhs.term->toPhi()->numOperands() != 2) {
+  if (lhs.term->toPhi()->numOperands() != 2) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2079,7 +2079,7 @@ LoopIterationBound* RangeAnalysis::analy
   // the first executed iteration, and not a value written which could
   // replace the second operand below during the middle of execution.
   MDefinition* lhsInitial = lhs.term->toPhi()->getLoopPredecessorOperand();
-  if (lhsInitial->block()->isMarked()) {
+  if (lhsInitial->block()->isMarked()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2090,14 +2090,14 @@ LoopIterationBound* RangeAnalysis::analy
   if (!lhsWrite->isAdd() && !lhsWrite->isSub()) {
     return nullptr;
   }
-  if (!lhsWrite->block()->isMarked()) {
+  if (!lhsWrite->block()->isMarked()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   MBasicBlock* bb = header->backedge();
   for (; bb != lhsWrite->block() && bb != header;
        bb = bb->immediateDominator()) {
   }
-  if (bb != lhsWrite->block()) {
+  if (bb != lhsWrite->block()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2126,26 +2126,26 @@ LoopIterationBound* RangeAnalysis::analy
     // iterCount == rhsN - initial(lhs) - lhsN
 
     if (rhs) {
-      if (!iterationBound.add(rhs, 1)) {
+      if (!iterationBound.add(rhs, 1)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
-    if (!iterationBound.add(lhsInitial, -1)) {
+    if (!iterationBound.add(lhsInitial, -1)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     int32_t lhsConstant;
-    if (!SafeSub(0, lhs.constant, &lhsConstant)) {
+    if (!SafeSub(0, lhs.constant, &lhsConstant)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (!iterationBound.add(lhsConstant)) {
+    if (!iterationBound.add(lhsConstant)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (!currentIteration.add(lhs.term, 1)) {
+    if (!currentIteration.add(lhs.term, 1)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (!currentIteration.add(lhsInitial, -1)) {
+    if (!currentIteration.add(lhsInitial, -1)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else if (lhsModified.constant == -1 && lessEqual) {
@@ -2155,22 +2155,22 @@ LoopIterationBound* RangeAnalysis::analy
     // initial(lhs) - iterCount + lhsN == rhs
     // iterCount == initial(lhs) - rhs + lhsN
 
-    if (!iterationBound.add(lhsInitial, 1)) {
+    if (!iterationBound.add(lhsInitial, 1)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (rhs) {
-      if (!iterationBound.add(rhs, -1)) {
+      if (!iterationBound.add(rhs, -1)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
-    if (!iterationBound.add(lhs.constant)) {
+    if (!iterationBound.add(lhs.constant)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (!currentIteration.add(lhsInitial, 1)) {
+    if (!currentIteration.add(lhsInitial, 1)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (!currentIteration.add(lhs.term, -1)) {
+    if (!currentIteration.add(lhs.term, -1)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
@@ -2192,7 +2192,7 @@ void RangeAnalysis::analyzeLoopPhi(LoopI
   MOZ_ASSERT(phi->numOperands() == 2);
 
   MDefinition* initial = phi->getLoopPredecessorOperand();
-  if (initial->block()->isMarked()) {
+  if (initial->block()->isMarked()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -2208,7 +2208,7 @@ void RangeAnalysis::analyzeLoopPhi(LoopI
   }
 
   LinearSum initialSum(alloc());
-  if (!initialSum.add(initial, 1)) {
+  if (!initialSum.add(initial, 1)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -2229,13 +2229,13 @@ void RangeAnalysis::analyzeLoopPhi(LoopI
   // ensure that loopBound >= 0.
 
   LinearSum limitSum(loopBound->boundSum);
-  if (!limitSum.multiply(modified.constant) || !limitSum.add(initialSum)) {
+  if (!limitSum.multiply(modified.constant) || !limitSum.add(initialSum)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
   int32_t negativeConstant;
   if (!SafeSub(0, modified.constant, &negativeConstant) ||
-      !limitSum.add(negativeConstant)) {
+      !limitSum.add(negativeConstant)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -2290,7 +2290,7 @@ bool RangeAnalysis::tryHoistBoundsCheck(
   // The bounds check's index should not be loop invariant (else we would
   // already have hoisted it during LICM).
   SimpleLinearSum index = ExtractLinearSum(ins->index());
-  if (!index.term || !index.term->block()->isMarked()) {
+  if (!index.term || !index.term->block()->isMarked()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2301,7 +2301,7 @@ bool RangeAnalysis::tryHoistBoundsCheck(
     return false;
   }
   const SymbolicBound* lower = index.term->range()->symbolicLower();
-  if (!lower || !SymbolicBoundIsValid(header, ins, lower)) {
+  if (!lower || !SymbolicBoundIsValid(header, ins, lower)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   const SymbolicBound* upper = index.term->range()->symbolicUpper();
@@ -2314,13 +2314,13 @@ bool RangeAnalysis::tryHoistBoundsCheck(
 
   MDefinition* lowerTerm = ConvertLinearSum(alloc(), preLoop, lower->sum,
                                             BailoutKind::HoistBoundsCheck);
-  if (!lowerTerm) {
+  if (!lowerTerm) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MDefinition* upperTerm = ConvertLinearSum(alloc(), preLoop, upper->sum,
                                             BailoutKind::HoistBoundsCheck);
-  if (!upperTerm) {
+  if (!upperTerm) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2331,10 +2331,10 @@ bool RangeAnalysis::tryHoistBoundsCheck(
   // lowerTerm >= -lowerConstant - indexConstant
 
   int32_t lowerConstant = 0;
-  if (!SafeSub(lowerConstant, index.constant, &lowerConstant)) {
+  if (!SafeSub(lowerConstant, index.constant, &lowerConstant)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!SafeSub(lowerConstant, lower->sum.constant(), &lowerConstant)) {
+  if (!SafeSub(lowerConstant, lower->sum.constant(), &lowerConstant)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2344,7 +2344,7 @@ bool RangeAnalysis::tryHoistBoundsCheck(
   // upperTerm + upperConstant < boundsLength
 
   int32_t upperConstant = index.constant;
-  if (!SafeAdd(upper->sum.constant(), upperConstant, &upperConstant)) {
+  if (!SafeAdd(upper->sum.constant(), upperConstant, &upperConstant)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2422,7 +2422,7 @@ bool RangeAnalysis::analyze() {
 
     for (MDefinitionIterator iter(block); iter; iter++) {
       MDefinition* def = *iter;
-      if (!alloc().ensureBallast()) {
+      if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -2438,7 +2438,7 @@ bool RangeAnalysis::analyze() {
     }
 
     if (block->isLoopHeader()) {
-      if (!analyzeLoop(block)) {
+      if (!analyzeLoop(block)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2499,11 +2499,11 @@ bool RangeAnalysis::addRangeAssertions()
       }
 
       // Don't add a use to an instruction that is recovered on bailout.
-      if (ins->isRecoveredOnBailout()) {
+      if (ins->isRecoveredOnBailout()) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
 
-      if (!alloc().ensureBallast()) {
+      if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       MAssertRange* guard =
@@ -2738,7 +2738,7 @@ bool MCompare::needTruncation(TruncateKi
   // the code presumably is already using the type it wants. Also, wasm
   // doesn't support bailouts, so we woudn't be able to rely on
   // TruncateAfterBailouts to convert our inputs.
-  if (block()->info().compilingWasm()) {
+  if (block()->info().compilingWasm()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2903,18 +2903,18 @@ static bool CloneForDeadBranches(TempAll
                                  MInstruction* candidate) {
   // Compare returns a boolean so it doesn't have to be recovered on bailout
   // because the output would remain correct.
-  if (candidate->isCompare()) {
+  if (candidate->isCompare()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   MOZ_ASSERT(candidate->canClone());
-  if (!alloc.ensureBallast()) {
+  if (!alloc.ensureBallast()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MDefinitionVector operands(alloc);
   size_t end = candidate->numOperands();
-  if (!operands.reserve(end)) {
+  if (!operands.reserve(end)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (size_t i = 0; i < end; ++i) {
@@ -2922,7 +2922,7 @@ static bool CloneForDeadBranches(TempAll
   }
 
   MInstruction* clone = candidate->clone(alloc, operands);
-  if (!clone) {
+  if (!clone) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   clone->setRange(nullptr);
@@ -3093,7 +3093,7 @@ void RangeAnalysis::adjustTruncatedInput
   MBasicBlock* block = truncated->block();
   for (size_t i = 0, e = truncated->numOperands(); i < e; i++) {
     TruncateKind kind = truncated->operandTruncateKind(i);
-    if (kind == TruncateKind::NoTruncate) {
+    if (kind == TruncateKind::NoTruncate) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
@@ -3190,7 +3190,7 @@ bool RangeAnalysis::truncate() {
 
       if (iter->type() == MIRType::None) {
         if (iter->isTest()) {
-          if (!TruncateTest(alloc(), iter->toTest())) {
+          if (!TruncateTest(alloc(), iter->toTest())) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -3225,7 +3225,7 @@ bool RangeAnalysis::truncate() {
       // If needed, clone the current instruction for keeping it for the
       // bailout path.  This give us the ability to truncate instructions
       // even after the removal of branches.
-      if (shouldClone && !CloneForDeadBranches(alloc(), *iter)) {
+      if (shouldClone && !CloneForDeadBranches(alloc(), *iter)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -3243,7 +3243,7 @@ bool RangeAnalysis::truncate() {
       // Delay updates of inputs/outputs to avoid creating node which
       // would be removed by the truncation of the next operations.
       iter->setInWorklist();
-      if (!worklist.append(*iter)) {
+      if (!worklist.append(*iter)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -3265,7 +3265,7 @@ bool RangeAnalysis::truncate() {
       // Delay updates of inputs/outputs to avoid creating node which
       // would be removed by the truncation of the next operations.
       iter->setInWorklist();
-      if (!worklist.append(*iter)) {
+      if (!worklist.append(*iter)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -3619,7 +3619,7 @@ bool RangeAnalysis::tryRemovingGuards() 
       }
 
       iter->setInWorklist();
-      if (!guards.append(*iter)) {
+      if (!guards.append(*iter)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -3675,7 +3675,7 @@ bool RangeAnalysis::tryRemovingGuards() 
 
       operand->setInWorklist();
       operand->setGuardRangeBailouts();
-      if (!guards.append(operand)) {
+      if (!guards.append(operand)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
diff --git a/js/src/jit/Recover.cpp b/js/src/jit/Recover.cpp
--- a/js/src/jit/Recover.cpp
+++ b/js/src/jit/Recover.cpp
@@ -310,7 +310,7 @@ bool RSignExtendInt32::recover(JSContext
   RootedValue operand(cx, iter.read());
 
   int32_t i;
-  if (!ToInt32(cx, operand, &i)) {
+  if (!ToInt32(cx, operand, &i)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -346,7 +346,7 @@ bool RAdd::recover(JSContext* cx, Snapsh
   RootedValue result(cx);
 
   MOZ_ASSERT(!lhs.isObject() && !rhs.isObject());
-  if (!js::AddValues(cx, &lhs, &rhs, &result)) {
+  if (!js::AddValues(cx, &lhs, &rhs, &result)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -377,7 +377,7 @@ bool RSub::recover(JSContext* cx, Snapsh
   RootedValue result(cx);
 
   MOZ_ASSERT(!lhs.isObject() && !rhs.isObject());
-  if (!js::SubValues(cx, &lhs, &rhs, &result)) {
+  if (!js::SubValues(cx, &lhs, &rhs, &result)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -411,13 +411,13 @@ bool RMul::recover(JSContext* cx, Snapsh
   RootedValue result(cx);
 
   if (MMul::Mode(mode_) == MMul::Normal) {
-    if (!js::MulValues(cx, &lhs, &rhs, &result)) {
+    if (!js::MulValues(cx, &lhs, &rhs, &result)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // MIRType::Float32 is a specialization embedding the fact that the
     // result is rounded to a Float32.
-    if (isFloatOperation_ && !RoundFloat32(cx, result, &result)) {
+    if (isFloatOperation_ && !RoundFloat32(cx, result, &result)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -447,7 +447,7 @@ bool RDiv::recover(JSContext* cx, Snapsh
   RootedValue rhs(cx, iter.read());
   RootedValue result(cx);
 
-  if (!js::DivValues(cx, &lhs, &rhs, &result)) {
+  if (!js::DivValues(cx, &lhs, &rhs, &result)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1043,7 +1043,7 @@ bool MPowHalf::writeRecoverData(CompactB
 
 RPowHalf::RPowHalf(CompactBufferReader& reader) {}
 
-bool RPowHalf::recover(JSContext* cx, SnapshotIterator& iter) const {
+bool RPowHalf::recover(JSContext* cx, SnapshotIterator& iter) const {MOZ_RELEASE_ASSERT(0);
   RootedValue base(cx, iter.read());
   RootedValue power(cx);
   RootedValue result(cx);
@@ -1088,7 +1088,7 @@ bool MAbs::writeRecoverData(CompactBuffe
 
 RAbs::RAbs(CompactBufferReader& reader) {}
 
-bool RAbs::recover(JSContext* cx, SnapshotIterator& iter) const {
+bool RAbs::recover(JSContext* cx, SnapshotIterator& iter) const {MOZ_RELEASE_ASSERT(0);
   RootedValue v(cx, iter.read());
   RootedValue result(cx);
 
@@ -1116,7 +1116,7 @@ bool RSqrt::recover(JSContext* cx, Snaps
   RootedValue result(cx);
 
   MOZ_ASSERT(num.isNumber());
-  if (!math_sqrt_handle(cx, num, &result)) {
+  if (!math_sqrt_handle(cx, num, &result)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1159,10 +1159,10 @@ bool MHypot::writeRecoverData(CompactBuf
 RHypot::RHypot(CompactBufferReader& reader)
     : numOperands_(reader.readUnsigned()) {}
 
-bool RHypot::recover(JSContext* cx, SnapshotIterator& iter) const {
+bool RHypot::recover(JSContext* cx, SnapshotIterator& iter) const {MOZ_RELEASE_ASSERT(0);
   JS::RootedValueVector vec(cx);
 
-  if (!vec.reserve(numOperands_)) {
+  if (!vec.reserve(numOperands_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1252,7 +1252,7 @@ RMathFunction::RMathFunction(CompactBuff
   function_ = UnaryMathFunction(reader.readByte());
 }
 
-bool RMathFunction::recover(JSContext* cx, SnapshotIterator& iter) const {
+bool RMathFunction::recover(JSContext* cx, SnapshotIterator& iter) const {MOZ_RELEASE_ASSERT(0);
   switch (function_) {
     case UnaryMathFunction::Sin: {
       RootedValue arg(cx, iter.read());
@@ -1302,7 +1302,7 @@ bool MStringSplit::writeRecoverData(Comp
 
 RStringSplit::RStringSplit(CompactBufferReader& reader) {}
 
-bool RStringSplit::recover(JSContext* cx, SnapshotIterator& iter) const {
+bool RStringSplit::recover(JSContext* cx, SnapshotIterator& iter) const {MOZ_RELEASE_ASSERT(0);
   RootedString str(cx, iter.read().toString());
   RootedString sep(cx, iter.read().toString());
 
@@ -1323,13 +1323,13 @@ bool MNaNToZero::writeRecoverData(Compac
 
 RNaNToZero::RNaNToZero(CompactBufferReader& reader) {}
 
-bool RNaNToZero::recover(JSContext* cx, SnapshotIterator& iter) const {
+bool RNaNToZero::recover(JSContext* cx, SnapshotIterator& iter) const {MOZ_RELEASE_ASSERT(0);
   RootedValue v(cx, iter.read());
   RootedValue result(cx);
   MOZ_ASSERT(v.isDouble() || v.isInt32());
 
   // x ? x : 0.0
-  if (ToBoolean(v)) {
+  if (ToBoolean(v)) {MOZ_RELEASE_ASSERT(0);
     result = v;
   } else {
     result.setDouble(0.0);
@@ -1347,7 +1347,7 @@ bool MRegExpMatcher::writeRecoverData(Co
 
 RRegExpMatcher::RRegExpMatcher(CompactBufferReader& reader) {}
 
-bool RRegExpMatcher::recover(JSContext* cx, SnapshotIterator& iter) const {
+bool RRegExpMatcher::recover(JSContext* cx, SnapshotIterator& iter) const {MOZ_RELEASE_ASSERT(0);
   RootedObject regexp(cx, &iter.read().toObject());
   RootedString input(cx, iter.read().toString());
   int32_t lastIndex = iter.read().toInt32();
@@ -1369,7 +1369,7 @@ bool MRegExpSearcher::writeRecoverData(C
 
 RRegExpSearcher::RRegExpSearcher(CompactBufferReader& reader) {}
 
-bool RRegExpSearcher::recover(JSContext* cx, SnapshotIterator& iter) const {
+bool RRegExpSearcher::recover(JSContext* cx, SnapshotIterator& iter) const {MOZ_RELEASE_ASSERT(0);
   RootedObject regexp(cx, &iter.read().toObject());
   RootedString input(cx, iter.read().toString());
   int32_t lastIndex = iter.read().toInt32();
@@ -1393,7 +1393,7 @@ bool MRegExpTester::writeRecoverData(Com
 
 RRegExpTester::RRegExpTester(CompactBufferReader& reader) {}
 
-bool RRegExpTester::recover(JSContext* cx, SnapshotIterator& iter) const {
+bool RRegExpTester::recover(JSContext* cx, SnapshotIterator& iter) const {MOZ_RELEASE_ASSERT(0);
   RootedString string(cx, iter.read().toString());
   RootedObject regexp(cx, &iter.read().toObject());
   int32_t lastIndex = iter.read().toInt32();
@@ -1594,7 +1594,7 @@ RNewIterator::RNewIterator(CompactBuffer
   type_ = reader.readByte();
 }
 
-bool RNewIterator::recover(JSContext* cx, SnapshotIterator& iter) const {
+bool RNewIterator::recover(JSContext* cx, SnapshotIterator& iter) const {MOZ_RELEASE_ASSERT(0);
   RootedObject templateObject(cx, &iter.read().toObject());
   RootedValue result(cx);
 
@@ -1630,7 +1630,7 @@ bool MCreateThisWithTemplate::writeRecov
 RCreateThisWithTemplate::RCreateThisWithTemplate(CompactBufferReader& reader) {}
 
 bool RCreateThisWithTemplate::recover(JSContext* cx,
-                                      SnapshotIterator& iter) const {
+                                      SnapshotIterator& iter) const {MOZ_RELEASE_ASSERT(0);
   RootedObject templateObject(cx, &iter.read().toObject());
 
   // See CodeGenerator::visitCreateThisWithTemplate
@@ -1700,7 +1700,7 @@ bool MFunctionWithProto::writeRecoverDat
 
 RFunctionWithProto::RFunctionWithProto(CompactBufferReader& reader) {}
 
-bool RFunctionWithProto::recover(JSContext* cx, SnapshotIterator& iter) const {
+bool RFunctionWithProto::recover(JSContext* cx, SnapshotIterator& iter) const {MOZ_RELEASE_ASSERT(0);
   RootedObject scopeChain(cx, &iter.read().toObject());
   RootedObject prototype(cx, &iter.read().toObject());
   RootedFunction fun(cx, &iter.read().toObject().as<JSFunction>());
@@ -1815,7 +1815,7 @@ bool MSetArrayLength::writeRecoverData(C
 
 RSetArrayLength::RSetArrayLength(CompactBufferReader& reader) {}
 
-bool RSetArrayLength::recover(JSContext* cx, SnapshotIterator& iter) const {
+bool RSetArrayLength::recover(JSContext* cx, SnapshotIterator& iter) const {MOZ_RELEASE_ASSERT(0);
   RootedValue result(cx);
   RootedArrayObject obj(cx, &iter.read().toObject().as<ArrayObject>());
   RootedValue len(cx, iter.read());
@@ -1864,7 +1864,7 @@ RStringReplace::RStringReplace(CompactBu
   isFlatReplacement_ = reader.readByte();
 }
 
-bool RStringReplace::recover(JSContext* cx, SnapshotIterator& iter) const {
+bool RStringReplace::recover(JSContext* cx, SnapshotIterator& iter) const {MOZ_RELEASE_ASSERT(0);
   RootedString string(cx, iter.read().toString());
   RootedString pattern(cx, iter.read().toString());
   RootedString replace(cx, iter.read().toString());
@@ -1890,7 +1890,7 @@ bool MAtomicIsLockFree::writeRecoverData
 
 RAtomicIsLockFree::RAtomicIsLockFree(CompactBufferReader& reader) {}
 
-bool RAtomicIsLockFree::recover(JSContext* cx, SnapshotIterator& iter) const {
+bool RAtomicIsLockFree::recover(JSContext* cx, SnapshotIterator& iter) const {MOZ_RELEASE_ASSERT(0);
   RootedValue operand(cx, iter.read());
   MOZ_ASSERT(operand.isInt32());
 
@@ -1912,7 +1912,7 @@ bool MBigIntAsIntN::writeRecoverData(Com
 
 RBigIntAsIntN::RBigIntAsIntN(CompactBufferReader& reader) {}
 
-bool RBigIntAsIntN::recover(JSContext* cx, SnapshotIterator& iter) const {
+bool RBigIntAsIntN::recover(JSContext* cx, SnapshotIterator& iter) const {MOZ_RELEASE_ASSERT(0);
   int32_t bits = iter.read().toInt32();
   RootedBigInt input(cx, iter.read().toBigInt());
 
diff --git a/js/src/jit/RegisterAllocator.cpp b/js/src/jit/RegisterAllocator.cpp
--- a/js/src/jit/RegisterAllocator.cpp
+++ b/js/src/jit/RegisterAllocator.cpp
@@ -504,12 +504,12 @@ const CodePosition CodePosition::MAX(UIN
 const CodePosition CodePosition::MIN(0);
 
 bool RegisterAllocator::init() {
-  if (!insData.init(mir, graph.numInstructions())) {
+  if (!insData.init(mir, graph.numInstructions())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (!entryPositions.reserve(graph.numBlocks()) ||
-      !exitPositions.reserve(graph.numBlocks())) {
+      !exitPositions.reserve(graph.numBlocks())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -550,7 +550,7 @@ LMoveGroup* RegisterAllocator::getInputM
   return moves;
 }
 
-LMoveGroup* RegisterAllocator::getFixReuseMoveGroup(LInstruction* ins) {
+LMoveGroup* RegisterAllocator::getFixReuseMoveGroup(LInstruction* ins) {MOZ_RELEASE_ASSERT(0);
   if (ins->fixReuseMoves()) {
     return ins->fixReuseMoves();
   }
@@ -561,7 +561,7 @@ LMoveGroup* RegisterAllocator::getFixReu
   return moves;
 }
 
-LMoveGroup* RegisterAllocator::getMoveGroupAfter(LInstruction* ins) {
+LMoveGroup* RegisterAllocator::getMoveGroupAfter(LInstruction* ins) {MOZ_RELEASE_ASSERT(0);
   if (ins->movesAfter()) {
     return ins->movesAfter();
   }
@@ -573,7 +573,7 @@ LMoveGroup* RegisterAllocator::getMoveGr
   return moves;
 }
 
-void RegisterAllocator::dumpInstructions() {
+void RegisterAllocator::dumpInstructions() {MOZ_RELEASE_ASSERT(0);
 #ifdef JS_JITSPEW
   JitSpewCont(JitSpew_RegAlloc, "\n");
   JitSpew(JitSpew_RegAlloc, "Instructions:");
diff --git a/js/src/jit/RematerializedFrame.cpp b/js/src/jit/RematerializedFrame.cpp
--- a/js/src/jit/RematerializedFrame.cpp
+++ b/js/src/jit/RematerializedFrame.cpp
@@ -89,7 +89,7 @@ bool RematerializedFrame::RematerializeI
     MaybeReadFallback& fallback, RematerializedFrameVector& frames) {
   Rooted<RematerializedFrameVector> tempFrames(cx,
                                                RematerializedFrameVector(cx));
-  if (!tempFrames.resize(iter.frameCount())) {
+  if (!tempFrames.resize(iter.frameCount())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -97,11 +97,11 @@ bool RematerializedFrame::RematerializeI
     size_t frameNo = iter.frameNo();
     tempFrames[frameNo].reset(
         RematerializedFrame::New(cx, top, iter, fallback));
-    if (!tempFrames[frameNo]) {
+    if (!tempFrames[frameNo]) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (tempFrames[frameNo]->environmentChain()) {
-      if (!EnsureHasEnvironmentObjects(cx, tempFrames[frameNo].get().get())) {
+      if (!EnsureHasEnvironmentObjects(cx, tempFrames[frameNo].get().get())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -116,7 +116,7 @@ bool RematerializedFrame::RematerializeI
   return true;
 }
 
-CallObject& RematerializedFrame::callObj() const {
+CallObject& RematerializedFrame::callObj() const {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(hasInitialEnvironment());
   MOZ_ASSERT(callee()->needsCallObject());
 
@@ -151,26 +151,26 @@ void RematerializedFrame::trace(JSTracer
                  "remat ion frame stack");
 }
 
-void RematerializedFrame::dump() {
+void RematerializedFrame::dump() {MOZ_RELEASE_ASSERT(0);
   fprintf(stderr, " Rematerialized Ion Frame%s\n",
           inlined() ? " (inlined)" : "");
-  if (isFunctionFrame()) {
+  if (isFunctionFrame()) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "  callee fun: ");
 #ifdef DEBUG
     DumpValue(ObjectValue(*callee()));
 #else
     fprintf(stderr, "?\n");
 #endif
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "  global frame, no callee\n");
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   fprintf(stderr, "  file %s line %u offset %zu\n", script()->filename(),
           script()->lineno(), script()->pcToOffset(pc()));
 
   fprintf(stderr, "  script = %p\n", (void*)script());
 
-  if (isFunctionFrame()) {
+  if (isFunctionFrame()) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "  env chain: ");
 #ifdef DEBUG
     DumpValue(ObjectValue(*environmentChain()));
@@ -178,14 +178,14 @@ void RematerializedFrame::dump() {
     fprintf(stderr, "?\n");
 #endif
 
-    if (hasArgsObj()) {
+    if (hasArgsObj()) {MOZ_RELEASE_ASSERT(0);
       fprintf(stderr, "  args obj: ");
 #ifdef DEBUG
       DumpValue(ObjectValue(argsObj()));
 #else
       fprintf(stderr, "?\n");
 #endif
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     fprintf(stderr, "  this: ");
 #ifdef DEBUG
@@ -194,12 +194,12 @@ void RematerializedFrame::dump() {
     fprintf(stderr, "?\n");
 #endif
 
-    for (unsigned i = 0; i < numActualArgs(); i++) {
-      if (i < numFormalArgs()) {
+    for (unsigned i = 0; i < numActualArgs(); i++) {MOZ_RELEASE_ASSERT(0);
+      if (i < numFormalArgs()) {MOZ_RELEASE_ASSERT(0);
         fprintf(stderr, "  formal (arg %u): ", i);
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         fprintf(stderr, "  overflown (arg %u): ", i);
-      }
+      }MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
       DumpValue(argv()[i]);
 #else
diff --git a/js/src/jit/Safepoints.cpp b/js/src/jit/Safepoints.cpp
--- a/js/src/jit/Safepoints.cpp
+++ b/js/src/jit/Safepoints.cpp
@@ -485,11 +485,11 @@ bool SafepointReader::getValueSlot(Safep
 
 static inline LAllocation PartFromStream(CompactBufferReader& stream,
                                          NunboxPartKind kind, uint32_t info) {
-  if (kind == Part_Reg) {
+  if (kind == Part_Reg) {MOZ_RELEASE_ASSERT(0);
     return LGeneralReg(Register::FromCode(info));
   }
 
-  if (info == MAX_INFO_VALUE) {
+  if (info == MAX_INFO_VALUE) {MOZ_RELEASE_ASSERT(0);
     info = stream.readUnsigned();
   }
 
@@ -501,7 +501,7 @@ static inline LAllocation PartFromStream
   return LArgument(info);
 }
 
-bool SafepointReader::getNunboxSlot(LAllocation* type, LAllocation* payload) {
+bool SafepointReader::getNunboxSlot(LAllocation* type, LAllocation* payload) {MOZ_RELEASE_ASSERT(0);
   if (!nunboxSlotsRemaining_--) {
     advanceFromNunboxOrValueSlots();
     return false;
diff --git a/js/src/jit/ScalarReplacement.cpp b/js/src/jit/ScalarReplacement.cpp
--- a/js/src/jit/ScalarReplacement.cpp
+++ b/js/src/jit/ScalarReplacement.cpp
@@ -42,13 +42,13 @@ class EmulateStateOf {
 template <typename MemoryView>
 bool EmulateStateOf<MemoryView>::run(MemoryView& view) {
   // Initialize the current block state of each block to an unknown state.
-  if (!states_.appendN(nullptr, graph_.numBlocks())) {
+  if (!states_.appendN(nullptr, graph_.numBlocks())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Initialize the first block which needs to be traversed in RPO.
   MBasicBlock* startBlock = view.startingBlock();
-  if (!view.initStartingState(&states_[startBlock->id()])) {
+  if (!view.initStartingState(&states_[startBlock->id()])) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -87,7 +87,7 @@ bool EmulateStateOf<MemoryView>::run(Mem
       } else {
         view.visitResumePoint(ins->toResumePoint());
       }
-      if (view.oom()) {
+      if (view.oom()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -122,7 +122,7 @@ static bool IsLambdaEscaped(MInstruction
     MNode* consumer = (*i)->consumer();
     if (!consumer->isDefinition()) {
       // Cannot optimize if it is observable from fun.arguments or others.
-      if (!consumer->toResumePoint()->isRecoverableOperand(*i)) {
+      if (!consumer->toResumePoint()->isRecoverableOperand(*i)) {MOZ_RELEASE_ASSERT(0);
         JitSpew(JitSpew_Escape, "Observable lambda cannot be recovered");
         return true;
       }
@@ -359,7 +359,7 @@ bool ObjectMemoryView::initStartingState
   // Create a new block state and insert at it at the location of the new
   // object.
   BlockState* state = BlockState::New(alloc_, obj_);
-  if (!state) {
+  if (!state) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -411,14 +411,14 @@ bool ObjectMemoryView::mergeIntoSuccesso
     // nodes.  These would later be removed by the removal of redundant phi
     // nodes.
     succState = BlockState::Copy(alloc_, state_);
-    if (!succState) {
+    if (!succState) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     size_t numPreds = succ->numPredecessors();
     for (size_t slot = 0; slot < state_->numSlots(); slot++) {
       MPhi* phi = MPhi::New(alloc_.fallible());
-      if (!phi || !phi->reserveLength(numPreds)) {
+      if (!phi || !phi->reserveLength(numPreds)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -514,7 +514,7 @@ void ObjectMemoryView::visitStoreFixedSl
   // Clone the state and update the slot value.
   if (state_->hasFixedSlot(ins->slot())) {
     state_ = BlockState::Copy(alloc_, state_);
-    if (!state_) {
+    if (!state_) {MOZ_RELEASE_ASSERT(0);
       oom_ = true;
       return;
     }
@@ -576,7 +576,7 @@ void ObjectMemoryView::visitStoreDynamic
   // Clone the state and update the slot value.
   if (state_->hasDynamicSlot(ins->slot())) {
     state_ = BlockState::Copy(alloc_, state_);
-    if (!state_) {
+    if (!state_) {MOZ_RELEASE_ASSERT(0);
       oom_ = true;
       return;
     }
@@ -672,15 +672,15 @@ void ObjectMemoryView::visitFunctionEnvi
   // Skip function environment which are not aliases of the NewCallObject.
   MDefinition* input = ins->input();
   if (input->isLambda()) {
-    if (input->toLambda()->environmentChain() != obj_) {
+    if (input->toLambda()->environmentChain() != obj_) {MOZ_RELEASE_ASSERT(0);
       return;
     }
   } else if (input->isLambdaArrow()) {
-    if (input->toLambdaArrow()->environmentChain() != obj_) {
+    if (input->toLambdaArrow()->environmentChain() != obj_) {MOZ_RELEASE_ASSERT(0);
       return;
     }
   } else if (input->isFunctionWithProto()) {
-    if (input->toFunctionWithProto()->environmentChain() != obj_) {
+    if (input->toFunctionWithProto()->environmentChain() != obj_) {MOZ_RELEASE_ASSERT(0);
       return;
     }
   } else {
@@ -712,7 +712,7 @@ void ObjectMemoryView::visitLambdaArrow(
   ins->setIncompleteObject();
 }
 
-void ObjectMemoryView::visitFunctionWithProto(MFunctionWithProto* ins) {
+void ObjectMemoryView::visitFunctionWithProto(MFunctionWithProto* ins) {MOZ_RELEASE_ASSERT(0);
   if (ins->environmentChain() != obj_) {
     return;
   }
@@ -865,7 +865,7 @@ static bool IsArrayEscaped(MInstruction*
     MNode* consumer = (*i)->consumer();
     if (!consumer->isDefinition()) {
       // Cannot optimize if it is observable from fun.arguments or others.
-      if (!consumer->toResumePoint()->isRecoverableOperand(*i)) {
+      if (!consumer->toResumePoint()->isRecoverableOperand(*i)) {MOZ_RELEASE_ASSERT(0);
         JitSpew(JitSpew_Escape, "Observable array cannot be recovered");
         return true;
       }
@@ -1035,7 +1035,7 @@ bool ArrayMemoryView::initStartingState(
 
   // Create a new block state and insert at it at the location of the new array.
   BlockState* state = BlockState::New(alloc_, arr_, initLength);
-  if (!state) {
+  if (!state) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1087,14 +1087,14 @@ bool ArrayMemoryView::mergeIntoSuccessor
     // nodes.  These would later be removed by the removal of redundant phi
     // nodes.
     succState = BlockState::Copy(alloc_, state_);
-    if (!succState) {
+    if (!succState) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     size_t numPreds = succ->numPredecessors();
     for (size_t index = 0; index < state_->numElements(); index++) {
       MPhi* phi = MPhi::New(alloc_.fallible());
-      if (!phi || !phi->reserveLength(numPreds)) {
+      if (!phi || !phi->reserveLength(numPreds)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -1394,7 +1394,7 @@ bool ArgumentsReplacer::escapes(MInstruc
     // If a resume point can observe this instruction, we can only optimize
     // if it is recoverable.
     if (consumer->isResumePoint()) {
-      if (!consumer->toResumePoint()->isRecoverableOperand(*i)) {
+      if (!consumer->toResumePoint()->isRecoverableOperand(*i)) {MOZ_RELEASE_ASSERT(0);
         JitSpew(JitSpew_Escape, "Observable args object cannot be recovered");
         return true;
       }
@@ -1638,7 +1638,7 @@ void ArgumentsReplacer::visitLoadArgumen
     check->setBailoutKind(ins->bailoutKind());
     ins->block()->insertBefore(ins, check);
 
-    if (mir_->outerInfo().hadBoundsCheckBailout()) {
+    if (mir_->outerInfo().hadBoundsCheckBailout()) {MOZ_RELEASE_ASSERT(0);
       check->setNotMovable();
     }
 
@@ -1719,7 +1719,7 @@ void ArgumentsReplacer::visitApplyArgsOb
     bool isDOMCall = false;
     auto* call = MakeCall(alloc(), addUndefined, callInfo, needsThisCheck,
                           ins->getSingleTarget(), isDOMCall);
-    if (!ins->maybeCrossRealm()) {
+    if (!ins->maybeCrossRealm()) {MOZ_RELEASE_ASSERT(0);
       call->setNotCrossRealm();
     }
     newIns = call;
@@ -1730,7 +1730,7 @@ void ArgumentsReplacer::visitApplyArgsOb
     // TODO: Should we rename MApplyArgs?
     auto* apply = MApplyArgs::New(alloc(), ins->getSingleTarget(),
                                   ins->getFunction(), numArgs, ins->getThis());
-    if (!ins->maybeCrossRealm()) {
+    if (!ins->maybeCrossRealm()) {MOZ_RELEASE_ASSERT(0);
       apply->setNotCrossRealm();
     }
     if (ins->ignoresReturnValue()) {
@@ -1755,7 +1755,7 @@ void ArgumentsReplacer::visitLoadFixedSl
   MOZ_ASSERT(ins->slot() == ArgumentsObject::CALLEE_SLOT);
 
   MDefinition* replacement;
-  if (isInlinedArguments()) {
+  if (isInlinedArguments()) {MOZ_RELEASE_ASSERT(0);
     replacement = args_->toCreateInlinedArgumentsObject()->getCallee();
   } else {
     auto* callee = MCallee::New(alloc());
diff --git a/js/src/jit/Sink.cpp b/js/src/jit/Sink.cpp
--- a/js/src/jit/Sink.cpp
+++ b/js/src/jit/Sink.cpp
@@ -134,7 +134,7 @@ bool Sink(MIRGenerator* mir, MIRGraph& g
       // against LICM by moving everything back into the loop, but if the
       // loop is it-self inside an if, then we still want to move the
       // computation under this if statement.
-      while (block->loopDepth() < usesDominator->loopDepth()) {
+      while (block->loopDepth() < usesDominator->loopDepth()) {MOZ_RELEASE_ASSERT(0);
         MOZ_ASSERT(usesDominator != usesDominator->immediateDominator());
         usesDominator = usesDominator->immediateDominator();
       }
@@ -149,7 +149,7 @@ bool Sink(MIRGenerator* mir, MIRGraph& g
         MBasicBlock* next = lastJoin->immediateDominator();
         if (next->numSuccessors() > 1) {
           break;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         lastJoin = next;
       }
       if (*block == lastJoin) {
@@ -159,7 +159,7 @@ bool Sink(MIRGenerator* mir, MIRGraph& g
       // Skip to the next instruction if we cannot find a common dominator
       // for all the uses of this instruction, or if the common dominator
       // correspond to the block of the current instruction.
-      if (!usesDominator || usesDominator == *block) {
+      if (!usesDominator || usesDominator == *block) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
 
@@ -170,7 +170,7 @@ bool Sink(MIRGenerator* mir, MIRGraph& g
       // If the instruction has live uses and if it is clonable, then we
       // can clone the instruction for all non-dominated uses and move the
       // instruction into the block which is dominating all live uses.
-      if (!ins->canClone()) {
+      if (!ins->canClone()) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
 
@@ -179,7 +179,7 @@ bool Sink(MIRGenerator* mir, MIRGraph& g
       // multiple predecessors.  In such case, we cannot safely move
       // bailing instruction to these blocks as we have no way to bailout.
       if (!usesDominator->entryResumePoint() &&
-          usesDominator->numPredecessors() != 1) {
+          usesDominator->numPredecessors() != 1) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
 
@@ -190,13 +190,13 @@ bool Sink(MIRGenerator* mir, MIRGraph& g
       // Copy the arguments and clone the instruction.
       MDefinitionVector operands(alloc);
       for (size_t i = 0, end = ins->numOperands(); i < end; i++) {
-        if (!operands.append(ins->getOperand(i))) {
+        if (!operands.append(ins->getOperand(i))) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
 
       MInstruction* clone = ins->clone(alloc, operands);
-      if (!clone) {
+      if (!clone) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       ins->block()->insertBefore(ins, clone);
@@ -218,7 +218,7 @@ bool Sink(MIRGenerator* mir, MIRGraph& g
         // use to find the corresponding predecessor block, which is
         // then used as the consumer block.
         MBasicBlock* consumerBlock = consumer->block();
-        if (consumer->isDefinition() && consumer->toDefinition()->isPhi()) {
+        if (consumer->isDefinition() && consumer->toDefinition()->isPhi()) {MOZ_RELEASE_ASSERT(0);
           consumerBlock = consumerBlock->getPredecessor(
               consumer->toDefinition()->toPhi()->indexOf(use));
         }
diff --git a/js/src/jit/Snapshots.cpp b/js/src/jit/Snapshots.cpp
--- a/js/src/jit/Snapshots.cpp
+++ b/js/src/jit/Snapshots.cpp
@@ -332,7 +332,7 @@ HashNumber RValueAllocation::hash() cons
   return res;
 }
 
-static const char* ValTypeToString(JSValueType type) {
+static const char* ValTypeToString(JSValueType type) {MOZ_RELEASE_ASSERT(0);
   switch (type) {
     case JSVAL_TYPE_INT32:
       return "int32_t";
@@ -378,17 +378,17 @@ void RValueAllocation::dumpPayload(Gener
   }
 }
 
-void RValueAllocation::dump(GenericPrinter& out) const {
+void RValueAllocation::dump(GenericPrinter& out) const {MOZ_RELEASE_ASSERT(0);
   const Layout& layout = layoutFromMode(mode());
   out.printf("%s", layout.name);
 
-  if (layout.type1 != PAYLOAD_NONE) {
+  if (layout.type1 != PAYLOAD_NONE) {MOZ_RELEASE_ASSERT(0);
     out.printf(" (");
-  }
+  }MOZ_RELEASE_ASSERT(0);
   dumpPayload(out, layout.type1, arg1_);
-  if (layout.type2 != PAYLOAD_NONE) {
+  if (layout.type2 != PAYLOAD_NONE) {MOZ_RELEASE_ASSERT(0);
     out.printf(", ");
-  }
+  }MOZ_RELEASE_ASSERT(0);
   dumpPayload(out, layout.type2, arg2_);
   if (layout.type1 != PAYLOAD_NONE) {
     out.printf(")");
@@ -588,7 +588,7 @@ bool SnapshotWriter::add(const RValueAll
   if (!p) {
     offset = allocWriter_.length();
     alloc.write(allocWriter_);
-    if (!allocMap_.add(p, alloc, offset)) {
+    if (!allocMap_.add(p, alloc, offset)) {MOZ_RELEASE_ASSERT(0);
       allocWriter_.setOOM();
       return false;
     }
diff --git a/js/src/jit/TrialInlining.cpp b/js/src/jit/TrialInlining.cpp
--- a/js/src/jit/TrialInlining.cpp
+++ b/js/src/jit/TrialInlining.cpp
@@ -27,30 +27,30 @@ bool DoTrialInlining(JSContext* cx, Base
 
 #ifdef JS_CACHEIR_SPEW
   if (cx->spewer().enabled(cx, script, SpewChannel::RateMyCacheIR)) {
-    for (uint32_t i = 0; i < icScript->numICEntries(); i++) {
+    for (uint32_t i = 0; i < icScript->numICEntries(); i++) {MOZ_RELEASE_ASSERT(0);
       ICEntry& entry = icScript->icEntry(i);
 
       // If the IC is megamorphic or generic, then we have already
       // spewed the IC report on transition.
-      if (!(uint8_t(entry.fallbackStub()->state().mode()) > 0)) {
+      if (!(uint8_t(entry.fallbackStub()->state().mode()) > 0)) {MOZ_RELEASE_ASSERT(0);
         jit::ICStub* stub = entry.firstStub();
         bool sawNonZeroCount = false;
-        while (!stub->isFallback()) {
+        while (!stub->isFallback()) {MOZ_RELEASE_ASSERT(0);
           uint32_t count = stub->enteredCount();
-          if (count > 0 && sawNonZeroCount) {
+          if (count > 0 && sawNonZeroCount) {MOZ_RELEASE_ASSERT(0);
             CacheIRHealth cih;
             cih.rateIC(cx, &entry, script, SpewContext::TrialInlining);
             break;
           }
 
-          if (count > 0 && !sawNonZeroCount) {
+          if (count > 0 && !sawNonZeroCount) {MOZ_RELEASE_ASSERT(0);
             sawNonZeroCount = true;
-          }
+          }MOZ_RELEASE_ASSERT(0);
 
           stub = stub->toCacheIRStub()->next();
-        }
-      }
-    }
+        }MOZ_RELEASE_ASSERT(0);
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
   }
 #endif
 
@@ -449,7 +449,7 @@ bool TrialInliner::canInline(JSFunction*
     JitSpew(JitSpew_WarpTrialInlining, "SKIP: can't ion-compile");
     return false;
   }
-  if (script->isDebuggee()) {
+  if (script->isDebuggee()) {MOZ_RELEASE_ASSERT(0);
     JitSpew(JitSpew_WarpTrialInlining, "SKIP: is debuggee");
     return false;
   }
@@ -468,7 +468,7 @@ bool TrialInliner::canInline(JSFunction*
     return false;
   }
 
-  if (TooManyFormalArguments(target->nargs())) {
+  if (TooManyFormalArguments(target->nargs())) {MOZ_RELEASE_ASSERT(0);
     JitSpew(JitSpew_WarpTrialInlining, "SKIP: Too many formal arguments: %u",
             unsigned(target->nargs()));
     return false;
@@ -517,7 +517,7 @@ bool TrialInliner::shouldInline(JSFuncti
 
   // Ensure the total bytecode size does not exceed ionMaxScriptSize.
   size_t newTotalSize = root_->totalBytecodeSize() + targetScript->length();
-  if (newTotalSize > JitOptions.ionMaxScriptSize) {
+  if (newTotalSize > JitOptions.ionMaxScriptSize) {MOZ_RELEASE_ASSERT(0);
     JitSpew(JitSpew_WarpTrialInlining, "SKIP: total size too big");
     return false;
   }
@@ -561,7 +561,7 @@ ICScript* TrialInliner::createInlinedICS
 
   void* raw = cx()->pod_malloc<uint8_t>(allocSize);
   MOZ_ASSERT(uintptr_t(raw) % alignof(ICScript) == 0);
-  if (!raw) {
+  if (!raw) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -577,7 +577,7 @@ ICScript* TrialInliner::createInlinedICS
     // template object for JSOp::Rest and the object group for
     // JSOp::NewArray.
     gc::AutoSuppressGC suppress(cx());
-    if (!inlinedICScript->initICEntries(cx(), targetScript)) {
+    if (!inlinedICScript->initICEntries(cx(), targetScript)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -624,7 +624,7 @@ bool TrialInliner::maybeInlineCall(const
                 data->callFlags.getArgFormat() == CallFlags::FunCall);
 
   ICScript* newICScript = createInlinedICScript(data->target, loc);
-  if (!newICScript) {
+  if (!newICScript) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -654,7 +654,7 @@ bool TrialInliner::maybeInlineGetter(con
   MOZ_ASSERT(!icScript_->hasInlinedChild(entry.pcOffset()));
 
   Maybe<InlinableGetterData> data = FindInlinableGetterData(stub);
-  if (data.isNothing()) {
+  if (data.isNothing()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -666,7 +666,7 @@ bool TrialInliner::maybeInlineGetter(con
   }
 
   ICScript* newICScript = createInlinedICScript(data->target, loc);
-  if (!newICScript) {
+  if (!newICScript) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -696,7 +696,7 @@ bool TrialInliner::maybeInlineSetter(con
   MOZ_ASSERT(!icScript_->hasInlinedChild(entry.pcOffset()));
 
   Maybe<InlinableSetterData> data = FindInlinableSetterData(stub);
-  if (data.isNothing()) {
+  if (data.isNothing()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -708,7 +708,7 @@ bool TrialInliner::maybeInlineSetter(con
   }
 
   ICScript* newICScript = createInlinedICScript(data->target, loc);
-  if (!newICScript) {
+  if (!newICScript) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/jit/TypePolicy.cpp b/js/src/jit/TypePolicy.cpp
--- a/js/src/jit/TypePolicy.cpp
+++ b/js/src/jit/TypePolicy.cpp
@@ -110,7 +110,7 @@ bool ArithPolicy::adjustInputs(TempAlloc
 
     if (ins->type() == MIRType::Double) {
       replace = MToDouble::New(alloc, in);
-    } else if (ins->type() == MIRType::Float32) {
+    } else if (ins->type() == MIRType::Float32) {MOZ_RELEASE_ASSERT(0);
       replace = MToFloat32::New(alloc, in);
     } else {
       replace = MToNumberInt32::New(alloc, in);
@@ -149,9 +149,9 @@ bool AllDoublePolicy::staticAdjustInputs
       continue;
     }
 
-    if (!alloc.ensureBallast()) {
+    if (!alloc.ensureBallast()) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     MInstruction* replace = MToDouble::New(alloc, in);
 
     ins->block()->insertBefore(ins, replace);
@@ -173,7 +173,7 @@ bool ComparePolicy::adjustInputs(TempAll
   // Convert Float32 operands to doubles
   for (size_t i = 0; i < 2; i++) {
     MDefinition* in = def->getOperand(i);
-    if (in->type() == MIRType::Float32) {
+    if (in->type() == MIRType::Float32) {MOZ_RELEASE_ASSERT(0);
       MInstruction* replace = MToDouble::New(alloc, in);
       def->block()->insertBefore(def, replace);
       def->replaceOperand(i, replace);
@@ -204,37 +204,37 @@ bool ComparePolicy::adjustInputs(TempAll
   if (compare->compareType() == MCompare::Compare_BigInt_Int32 ||
       compare->compareType() == MCompare::Compare_BigInt_Double ||
       compare->compareType() == MCompare::Compare_BigInt_String) {
-    if (MDefinition* in = def->getOperand(0); in->type() != MIRType::BigInt) {
+    if (MDefinition* in = def->getOperand(0); in->type() != MIRType::BigInt) {MOZ_RELEASE_ASSERT(0);
       auto* replace =
           MUnbox::New(alloc, in, MIRType::BigInt, MUnbox::Infallible);
-      if (!replaceOperand(0, replace)) {
+      if (!replaceOperand(0, replace)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
     MDefinition* in = def->getOperand(1);
 
     MInstruction* replace = nullptr;
     if (compare->compareType() == MCompare::Compare_BigInt_Int32) {
-      if (in->type() != MIRType::Int32) {
+      if (in->type() != MIRType::Int32) {MOZ_RELEASE_ASSERT(0);
         replace = MToNumberInt32::New(
             alloc, in, IntConversionInputKind::NumbersOrBoolsOnly);
       }
     } else if (compare->compareType() == MCompare::Compare_BigInt_Double) {
-      if (in->type() != MIRType::Double) {
+      if (in->type() != MIRType::Double) {MOZ_RELEASE_ASSERT(0);
         replace = MToDouble::New(alloc, in, MToFPInstruction::NumbersOnly);
       }
     } else {
       MOZ_ASSERT(compare->compareType() == MCompare::Compare_BigInt_String);
-      if (in->type() != MIRType::String) {
+      if (in->type() != MIRType::String) {MOZ_RELEASE_ASSERT(0);
         replace = MUnbox::New(alloc, in, MIRType::String, MUnbox::Infallible);
       }
     }
 
     if (replace) {
-      if (!replaceOperand(1, replace)) {
+      if (!replaceOperand(1, replace)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
     return true;
@@ -344,7 +344,7 @@ bool PowPolicy::adjustInputs(TempAllocat
   }
 
   // Otherwise, input must be a double.
-  if (!DoublePolicy<0>::staticAdjustInputs(alloc, ins)) {
+  if (!DoublePolicy<0>::staticAdjustInputs(alloc, ins)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -719,7 +719,7 @@ bool ToInt32Policy::staticAdjustInputs(T
 }
 
 bool ToBigIntPolicy::staticAdjustInputs(TempAllocator& alloc,
-                                        MInstruction* ins) {
+                                        MInstruction* ins) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(ins->isToBigInt());
 
   MDefinition* in = ins->getOperand(0);
@@ -813,7 +813,7 @@ bool CallPolicy::adjustInputs(TempAlloca
     call->block()->insertBefore(call, unbox);
     call->replaceCallee(unbox);
 
-    if (!unbox->typePolicy()->adjustInputs(alloc, unbox)) {
+    if (!unbox->typePolicy()->adjustInputs(alloc, unbox)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -831,7 +831,7 @@ bool CallPolicy::adjustInputs(TempAlloca
 bool CallSetElementPolicy::adjustInputs(TempAllocator& alloc,
                                         MInstruction* ins) const {
   // The first operand should be an object.
-  if (!SingleObjectPolicy::staticAdjustInputs(alloc, ins)) {
+  if (!SingleObjectPolicy::staticAdjustInputs(alloc, ins)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -854,7 +854,7 @@ bool StoreUnboxedScalarPolicy::adjustVal
   if (Scalar::isBigIntType(writeType)) {
     if (value->type() == MIRType::BigInt) {
       return true;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     auto* replace = MToBigInt::New(alloc, value);
     ins->block()->insertBefore(ins, replace);
@@ -893,7 +893,7 @@ bool StoreUnboxedScalarPolicy::adjustVal
       MOZ_CRASH("Unexpected type");
   }
 
-  if (value != curValue) {
+  if (value != curValue) {MOZ_RELEASE_ASSERT(0);
     ins->replaceOperand(valueOperand, value);
     curValue = value;
   }
diff --git a/js/src/jit/VMFunctions.cpp b/js/src/jit/VMFunctions.cpp
--- a/js/src/jit/VMFunctions.cpp
+++ b/js/src/jit/VMFunctions.cpp
@@ -623,7 +623,7 @@ bool JitRuntime::generateVMWrappers(JSCo
 
   static constexpr size_t NumVMFunctions = size_t(IdT::Count);
 
-  if (!offsets.reserve(NumVMFunctions)) {
+  if (!offsets.reserve(NumVMFunctions)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -659,7 +659,7 @@ bool JitRuntime::generateVMWrappers(JSCo
 };
 
 bool JitRuntime::generateVMWrappers(JSContext* cx, MacroAssembler& masm) {
-  if (!generateVMWrappers<VMFunctionId>(cx, masm, functionWrapperOffsets_)) {
+  if (!generateVMWrappers<VMFunctionId>(cx, masm, functionWrapperOffsets_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -692,7 +692,7 @@ bool InvokeFunction(JSContext* cx, Handl
     }
 
     ConstructArgs cargs(cx);
-    if (!cargs.init(cx, argc)) {
+    if (!cargs.init(cx, argc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -732,7 +732,7 @@ bool InvokeFunction(JSContext* cx, Handl
   }
 
   InvokeArgsMaybeIgnoresReturnValue args(cx);
-  if (!args.init(cx, argc, ignoresReturnValue)) {
+  if (!args.init(cx, argc, ignoresReturnValue)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -819,7 +819,7 @@ bool MutatePrototype(JSContext* cx, Hand
 template <EqualityKind Kind>
 bool StringsEqual(JSContext* cx, HandleString lhs, HandleString rhs,
                   bool* res) {
-  if (!js::EqualStrings(cx, lhs, rhs, res)) {
+  if (!js::EqualStrings(cx, lhs, rhs, res)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (Kind != EqualityKind::Equal) {
@@ -838,7 +838,7 @@ template <ComparisonKind Kind>
 bool StringsCompare(JSContext* cx, HandleString lhs, HandleString rhs,
                     bool* res) {
   int32_t result;
-  if (!js::CompareStrings(cx, lhs, rhs, &result)) {
+  if (!js::CompareStrings(cx, lhs, rhs, &result)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (Kind == ComparisonKind::LessThan) {
@@ -864,7 +864,7 @@ bool ArrayPushDense(JSContext* cx, Handl
   if (result != DenseElementResult::Incomplete) {
     (*length)++;
     return result == DenseElementResult::Success;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   JS::RootedValueArray<3> argv(cx);
   argv[0].setUndefined();
@@ -909,7 +909,7 @@ bool SetArrayLength(JSContext* cx, Handl
   //
   // So, perform ArraySetLength if and only if "length" is writable.
   if (array->lengthIsWritable()) {
-    if (!ArraySetLength(cx, array, id, JSPROP_PERMANENT, value, result)) {
+    if (!ArraySetLength(cx, array, id, JSPROP_PERMANENT, value, result)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -976,7 +976,7 @@ bool SetProperty(JSContext* cx, HandleOb
       }
     } else {
       if (!NativeSetProperty<Qualified>(cx, obj.as<NativeObject>(), id, value,
-                                        receiver, result)) {
+                                        receiver, result)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -996,7 +996,7 @@ bool InterruptCheck(JSContext* cx) {
 
 JSObject* NewCallObject(JSContext* cx, HandleShape shape) {
   JSObject* obj = CallObject::create(cx, shape);
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1136,7 +1136,7 @@ template void PostWriteElementBarrier<In
                                                             JSObject* obj,
                                                             int32_t index);
 
-void PostGlobalWriteBarrier(JSRuntime* rt, GlobalObject* obj) {
+void PostGlobalWriteBarrier(JSRuntime* rt, GlobalObject* obj) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(obj->JSObject::is<GlobalObject>());
 
   if (!obj->realm()->globalWriteBarriered) {
@@ -1550,7 +1550,7 @@ void AssertValidBigIntPtr(JSContext* cx,
   MOZ_ASSERT(bi->getAllocKind() == gc::AllocKind::BIGINT);
 }
 
-void AssertValidObjectPtr(JSContext* cx, JSObject* obj) {
+void AssertValidObjectPtr(JSContext* cx, JSObject* obj) {MOZ_RELEASE_ASSERT(0);
   AutoUnsafeCallWithABI unsafe;
 #ifdef DEBUG
   // Check what we can, so that we'll hopefully assert/crash if we get a
@@ -1567,7 +1567,7 @@ void AssertValidObjectPtr(JSContext* cx,
 #endif
 }
 
-void AssertValidStringPtr(JSContext* cx, JSString* str) {
+void AssertValidStringPtr(JSContext* cx, JSString* str) {MOZ_RELEASE_ASSERT(0);
   AutoUnsafeCallWithABI unsafe;
 #ifdef DEBUG
   // We can't closely inspect strings from another runtime.
@@ -1602,14 +1602,14 @@ void AssertValidStringPtr(JSContext* cx,
 #endif
 }
 
-void AssertValidSymbolPtr(JSContext* cx, JS::Symbol* sym) {
+void AssertValidSymbolPtr(JSContext* cx, JS::Symbol* sym) {MOZ_RELEASE_ASSERT(0);
   AutoUnsafeCallWithABI unsafe;
 
   // We can't closely inspect symbols from another runtime.
-  if (sym->runtimeFromAnyThread() != cx->runtime()) {
+  if (sym->runtimeFromAnyThread() != cx->runtime()) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(sym->isWellKnownSymbol());
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MOZ_ASSERT(sym->zone()->isAtomsZone());
   MOZ_ASSERT(sym->isAligned());
@@ -1620,13 +1620,13 @@ void AssertValidSymbolPtr(JSContext* cx,
   MOZ_ASSERT(sym->getAllocKind() == gc::AllocKind::SYMBOL);
 }
 
-void AssertValidValue(JSContext* cx, Value* v) {
+void AssertValidValue(JSContext* cx, Value* v) {MOZ_RELEASE_ASSERT(0);
   AutoUnsafeCallWithABI unsafe;
-  if (v->isObject()) {
+  if (v->isObject()) {MOZ_RELEASE_ASSERT(0);
     AssertValidObjectPtr(cx, &v->toObject());
-  } else if (v->isString()) {
+  } else if (v->isString()) {MOZ_RELEASE_ASSERT(0);
     AssertValidStringPtr(cx, v->toString());
-  } else if (v->isSymbol()) {
+  } else if (v->isSymbol()) {MOZ_RELEASE_ASSERT(0);
     AssertValidSymbolPtr(cx, v->toSymbol());
   } else if (v->isBigInt()) {
     AssertValidBigIntPtr(cx, v->toBigInt());
@@ -1866,7 +1866,7 @@ static MOZ_ALWAYS_INLINE bool ValueToAto
       atom = &s->asAtom();
     } else {
       atom = AtomizeString(cx, s);
-      if (!atom) {
+      if (!atom) {MOZ_RELEASE_ASSERT(0);
         cx->recoverFromOutOfMemory();
         return false;
       }
@@ -2003,9 +2003,9 @@ bool HasNativeDataPropertyPure(JSContext
           }
         }
       }
-    } else if (obj->is<TypedObject>()) {
+    } else if (obj->is<TypedObject>()) {MOZ_RELEASE_ASSERT(0);
       RootedTypedObject typedObj(cx, &obj->as<TypedObject>());
-      if (typedObj->rttValue().hasProperty(cx, typedObj, id)) {
+      if (typedObj->rttValue().hasProperty(cx, typedObj, id)) {MOZ_RELEASE_ASSERT(0);
         vp[1].setBoolean(true);
         return true;
       }
@@ -2060,7 +2060,7 @@ bool HasNativeElementPure(JSContext* cx,
 
   // Fail if there's a resolve hook, unless the mayResolve hook tells
   // us the resolve hook won't define a property with this id.
-  if (MOZ_UNLIKELY(ClassMayResolveId(cx->names(), obj->getClass(), id, obj))) {
+  if (MOZ_UNLIKELY(ClassMayResolveId(cx->names(), obj->getClass(), id, obj))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   // TypedArrayObject are also native and contain indexed properties.
@@ -2083,7 +2083,7 @@ void HandleCodeCoverageAtPC(BaselineFram
   MOZ_ASSERT(pc == script->main() || BytecodeIsJumpTarget(JSOp(*pc)));
 
   if (!script->hasScriptCounts()) {
-    if (!script->realm()->collectCoverageForDebug()) {
+    if (!script->realm()->collectCoverageForDebug()) {MOZ_RELEASE_ASSERT(0);
       return;
     }
     JSContext* cx = script->runtimeFromMainThread()->mainContextFromOwnThread();
@@ -2378,7 +2378,7 @@ template <ComparisonKind Kind>
 bool BigIntStringCompare(JSContext* cx, HandleBigInt x, HandleString y,
                          bool* res) {
   mozilla::Maybe<bool> result;
-  if (!BigInt::lessThan(cx, x, y, result)) {
+  if (!BigInt::lessThan(cx, x, y, result)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (Kind == ComparisonKind::LessThan) {
@@ -2400,7 +2400,7 @@ template <ComparisonKind Kind>
 bool StringBigIntCompare(JSContext* cx, HandleString x, HandleBigInt y,
                          bool* res) {
   mozilla::Maybe<bool> result;
-  if (!BigInt::lessThan(cx, x, y, result)) {
+  if (!BigInt::lessThan(cx, x, y, result)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (Kind == ComparisonKind::LessThan) {
@@ -2784,7 +2784,7 @@ void Printf0(const char* output) {
   fprintf(stderr, "%s", output);
 }
 
-void Printf1(const char* output, uintptr_t value) {
+void Printf1(const char* output, uintptr_t value) {MOZ_RELEASE_ASSERT(0);
   AutoUnsafeCallWithABI unsafe;
   AutoEnterOOMUnsafeRegion oomUnsafe;
   js::UniqueChars line = JS_sprintf_append(nullptr, output, value);
diff --git a/js/src/jit/ValueNumbering.cpp b/js/src/jit/ValueNumbering.cpp
--- a/js/src/jit/ValueNumbering.cpp
+++ b/js/src/jit/ValueNumbering.cpp
@@ -232,7 +232,7 @@ bool ValueNumberer::handleUseReleased(MD
                                       ImplicitUseOption implicitUseOption) {
   if (IsDiscardable(def)) {
     values_.forget(def);
-    if (!deadDefs_.append(def)) {
+    if (!deadDefs_.append(def)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -319,18 +319,18 @@ bool ValueNumberer::discardDef(MDefiniti
   MBasicBlock* block = def->block();
   if (def->isPhi()) {
     MPhi* phi = def->toPhi();
-    if (!releaseAndRemovePhiOperands(phi)) {
+    if (!releaseAndRemovePhiOperands(phi)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     block->discardPhi(phi);
   } else {
     MInstruction* ins = def->toInstruction();
     if (MResumePoint* resume = ins->resumePoint()) {
-      if (!releaseResumePointOperands(resume)) {
+      if (!releaseResumePointOperands(resume)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
-    if (!releaseOperands(ins)) {
+    if (!releaseOperands(ins)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     block->discardIgnoreOperands(ins);
@@ -507,7 +507,7 @@ bool ValueNumberer::removePredecessorAnd
 
   // Actually remove the CFG edge.
   if (!removePredecessorAndDoDCE(block, pred,
-                                 block->getPredecessorIndex(pred))) {
+                                 block->getPredecessorIndex(pred))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -532,7 +532,7 @@ bool ValueNumberer::removePredecessorAnd
       block->clearLoopHeader();
     }
     for (size_t i = 0, e = block->numPredecessors(); i < e; ++i) {
-      if (!removePredecessorAndDoDCE(block, block->getPredecessor(i), i)) {
+      if (!removePredecessorAndDoDCE(block, block->getPredecessor(i), i)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -540,11 +540,11 @@ bool ValueNumberer::removePredecessorAnd
     // Clear out the resume point operands, as they can hold things that
     // don't appear to dominate them live.
     if (MResumePoint* resume = block->entryResumePoint()) {
-      if (!releaseResumePointOperands(resume) || !processDeadDefs()) {
+      if (!releaseResumePointOperands(resume) || !processDeadDefs()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (MResumePoint* outer = block->outerResumePoint()) {
-        if (!releaseResumePointOperands(outer) || !processDeadDefs()) {
+        if (!releaseResumePointOperands(outer) || !processDeadDefs()) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -554,7 +554,7 @@ bool ValueNumberer::removePredecessorAnd
         MInstruction* ins = *iter++;
         nextDef_ = iter != end ? *iter : nullptr;
         if (MResumePoint* resume = ins->resumePoint()) {
-          if (!releaseResumePointOperands(resume) || !processDeadDefs()) {
+          if (!releaseResumePointOperands(resume) || !processDeadDefs()) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -608,7 +608,7 @@ MDefinition* ValueNumberer::leader(MDefi
       values_.overwrite(p, def);
     } else {
       // No match. Add a new entry.
-      if (!values_.add(p, def)) {
+      if (!values_.add(p, def)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -637,7 +637,7 @@ bool ValueNumberer::hasLeader(const MPhi
 // discarding the phi triggering the iteration.
 bool ValueNumberer::loopHasOptimizablePhi(MBasicBlock* header) const {
   // If the header is unreachable, don't bother re-optimizing it.
-  if (header->isMarked()) {
+  if (header->isMarked()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -671,7 +671,7 @@ bool ValueNumberer::visitDefinition(MDef
 
     // This nop is at the beginning of the basic block, just replace the
     // resume point of the basic block by the one from the resume point.
-    if (iter == block->rend()) {
+    if (iter == block->rend()) {MOZ_RELEASE_ASSERT(0);
       JitSpew(JitSpew_GVN, "      Removing Nop%u", nop->id());
       nop->moveResumePointAsEntry();
       block->discard(nop);
@@ -680,7 +680,7 @@ bool ValueNumberer::visitDefinition(MDef
 
     // The previous instruction is also a Nop, no need to keep it anymore.
     MInstruction* prev = *iter;
-    if (prev->isNop()) {
+    if (prev->isNop()) {MOZ_RELEASE_ASSERT(0);
       JitSpew(JitSpew_GVN, "      Removing Nop%u", prev->id());
       block->discard(prev);
       return true;
@@ -694,21 +694,21 @@ bool ValueNumberer::visitDefinition(MDef
     if (rp && rp->numOperands() > 0 &&
         rp->getOperand(rp->numOperands() - 1) == prev &&
         !nop->block()->lastIns()->isThrow() &&
-        !prev->isAssertRecoveredOnBailout()) {
+        !prev->isAssertRecoveredOnBailout()) {MOZ_RELEASE_ASSERT(0);
       size_t numOperandsLive = 0;
-      for (size_t j = 0; j < prev->numOperands(); j++) {
-        for (size_t i = 0; i < rp->numOperands(); i++) {
-          if (prev->getOperand(j) == rp->getOperand(i)) {
+      for (size_t j = 0; j < prev->numOperands(); j++) {MOZ_RELEASE_ASSERT(0);
+        for (size_t i = 0; i < rp->numOperands(); i++) {MOZ_RELEASE_ASSERT(0);
+          if (prev->getOperand(j) == rp->getOperand(i)) {MOZ_RELEASE_ASSERT(0);
             numOperandsLive++;
             break;
-          }
-        }
+          }MOZ_RELEASE_ASSERT(0);
+        }MOZ_RELEASE_ASSERT(0);
       }
 
-      if (numOperandsLive == prev->numOperands()) {
+      if (numOperandsLive == prev->numOperands()) {MOZ_RELEASE_ASSERT(0);
         JitSpew(JitSpew_GVN, "      Removing Nop%u", nop->id());
         block->discard(nop);
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
     return true;
@@ -742,7 +742,7 @@ bool ValueNumberer::visitDefinition(MDef
   // Look for a simplified form of |def|.
   MDefinition* sim = simplified(def);
   if (sim != def) {
-    if (sim == nullptr) {
+    if (sim == nullptr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -774,7 +774,7 @@ bool ValueNumberer::visitDefinition(MDef
     }
 
     if (DeadIfUnused(def)) {
-      if (!discardDefsRecursively(def)) {
+      if (!discardDefsRecursively(def)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -812,7 +812,7 @@ bool ValueNumberer::visitDefinition(MDef
   // Look for a dominating def which makes |def| redundant.
   MDefinition* rep = leader(def);
   if (rep != def) {
-    if (rep == nullptr) {
+    if (rep == nullptr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (rep->updateForReplacement(def)) {
@@ -854,7 +854,7 @@ bool ValueNumberer::visitControlInstruct
     return true;
   }
 
-  if (rep == nullptr) {
+  if (rep == nullptr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -879,24 +879,24 @@ bool ValueNumberer::visitControlInstruct
       if (HasSuccessor(newControl, succ)) {
         continue;
       }
-      if (succ->isMarked()) {
+      if (succ->isMarked()) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
-      if (!removePredecessorAndCleanUp(succ, block)) {
+      if (!removePredecessorAndCleanUp(succ, block)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (succ->isMarked()) {
         continue;
       }
-      if (!rerun_) {
-        if (!remainingBlocks_.append(succ)) {
+      if (!rerun_) {MOZ_RELEASE_ASSERT(0);
+        if (!remainingBlocks_.append(succ)) {MOZ_RELEASE_ASSERT(0);
           return false;
-        }
+        }MOZ_RELEASE_ASSERT(0);
       }
     }
   }
 
-  if (!releaseOperands(control)) {
+  if (!releaseOperands(control)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   block->discardIgnoreOperands(control);
@@ -929,7 +929,7 @@ bool ValueNumberer::visitUnreachableBloc
     if (succ->isDead() || succ->isMarked()) {
       continue;
     }
-    if (!removePredecessorAndCleanUp(succ, block)) {
+    if (!removePredecessorAndCleanUp(succ, block)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (succ->isMarked()) {
@@ -938,7 +938,7 @@ bool ValueNumberer::visitUnreachableBloc
     // |succ| is still reachable. Make a note of it so that we can scan
     // it for interesting dominator tree changes later.
     if (!rerun_) {
-      if (!remainingBlocks_.append(succ)) {
+      if (!remainingBlocks_.append(succ)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -953,7 +953,7 @@ bool ValueNumberer::visitUnreachableBloc
       continue;
     }
     nextDef_ = iter ? *iter : nullptr;
-    if (!discardDefsRecursively(def)) {
+    if (!discardDefsRecursively(def)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -973,7 +973,7 @@ bool ValueNumberer::visitBlock(MBasicBlo
   // Visit the definitions in the block top-down.
   MOZ_ASSERT(nextDef_ == nullptr);
   for (MDefinitionIterator iter(block); iter;) {
-    if (!graph_.alloc().ensureBallast()) {
+    if (!graph_.alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     MDefinition* def = *iter++;
@@ -983,19 +983,19 @@ bool ValueNumberer::visitBlock(MBasicBlo
 
     // If the definition is dead, discard it.
     if (IsDiscardable(def)) {
-      if (!discardDefsRecursively(def)) {
+      if (!discardDefsRecursively(def)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       continue;
     }
 
-    if (!visitDefinition(def)) {
+    if (!visitDefinition(def)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
   nextDef_ = nullptr;
 
-  if (!graph_.alloc().ensureBallast()) {
+  if (!graph_.alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1037,13 +1037,13 @@ bool ValueNumberer::visitDominatorTree(M
 
     if (block->isMarked()) {
       // This block has become unreachable; handle it specially.
-      if (!visitUnreachableBlock(block)) {
+      if (!visitUnreachableBlock(block)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       ++numDiscarded;
     } else {
       // Visit the block!
-      if (!visitBlock(block)) {
+      if (!visitBlock(block)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       ++numVisited;
@@ -1082,7 +1082,7 @@ bool ValueNumberer::visitGraph() {
     MOZ_ASSERT(iter != graph_.rpoEnd(), "Inconsistent dominator information");
     MBasicBlock* block = *iter;
     if (block->immediateDominator() == block) {
-      if (!visitDominatorTree(block)) {
+      if (!visitDominatorTree(block)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -1092,7 +1092,7 @@ bool ValueNumberer::visitGraph() {
       // we've finished the tree, increment the iterator, and then if it's
       // marked for removal, remove it.
       ++iter;
-      if (block->isMarked()) {
+      if (block->isMarked()) {MOZ_RELEASE_ASSERT(0);
         JitSpew(JitSpew_GVN, "      Discarding dominator root block%u",
                 block->id());
         MOZ_ASSERT(
@@ -1135,7 +1135,7 @@ bool ValueNumberer::insertOSRFixups() {
       continue;
     }
 
-    if (!fixupOSROnlyLoop(block)) {
+    if (!fixupOSROnlyLoop(block)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1154,7 +1154,7 @@ bool ValueNumberer::cleanupOSRFixups() {
   graph_.entryBlock()->mark();
   graph_.osrBlock()->mark();
   if (!worklist.append(graph_.entryBlock()) ||
-      !worklist.append(graph_.osrBlock())) {
+      !worklist.append(graph_.osrBlock())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   while (!worklist.empty()) {
@@ -1164,7 +1164,7 @@ bool ValueNumberer::cleanupOSRFixups() {
       if (!succ->isMarked()) {
         ++numMarked;
         succ->mark();
-        if (!worklist.append(succ)) {
+        if (!worklist.append(succ)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else if (succ->isLoopHeader() && succ->loopPredecessor() == block &&
@@ -1239,7 +1239,7 @@ bool ValueNumberer::run(UpdateAliasAnaly
   // Adding fixup blocks only make sense iff we have a second entry point into
   // the graph which cannot be reached any more from the entry point.
   if (graph_.osrBlock()) {
-    if (!insertOSRFixups()) {
+    if (!insertOSRFixups()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1250,7 +1250,7 @@ bool ValueNumberer::run(UpdateAliasAnaly
   // iteration.
   int runs = 0;
   for (;;) {
-    if (!visitGraph()) {
+    if (!visitGraph()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1270,7 +1270,7 @@ bool ValueNumberer::run(UpdateAliasAnaly
 
     if (blocksRemoved_) {
       if (!AccountForCFGChanges(mir_, graph_, dependenciesBroken_,
-                                /* underValueNumberer = */ true)) {
+                                /* underValueNumberer = */ true)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
diff --git a/js/src/jit/WarpBuilder.cpp b/js/src/jit/WarpBuilder.cpp
--- a/js/src/jit/WarpBuilder.cpp
+++ b/js/src/jit/WarpBuilder.cpp
@@ -139,7 +139,7 @@ bool WarpBuilder::startNewOsrPreHeaderBl
   MBasicBlock* pred = current;
 
   // Create the OSR entry block.
-  if (!startNewEntryBlock(pred->stackDepth(), loopHead)) {
+  if (!startNewEntryBlock(pred->stackDepth(), loopHead)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -183,7 +183,7 @@ bool WarpBuilder::startNewOsrPreHeaderBl
   if (info().hasArguments()) {
     if (needsArgsObj) {
       argsObj = MOsrArgumentsObject::New(alloc(), entry);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       argsObj = MConstant::New(alloc(), UndefinedValue());
     }
     osrBlock->add(argsObj);
@@ -215,7 +215,7 @@ bool WarpBuilder::startNewOsrPreHeaderBl
       } else {
         osrv = MGetArgumentsObjectArg::New(alloc().fallible(), argsObj, i);
       }
-      if (!osrv) {
+      if (!osrv) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       current->add(osrv);
@@ -229,7 +229,7 @@ bool WarpBuilder::startNewOsrPreHeaderBl
     uint32_t slot = info().localSlot(i);
     ptrdiff_t offset = BaselineFrame::reverseOffsetOfLocal(i);
     MOsrValue* osrv = MOsrValue::New(alloc().fallible(), entry, offset);
-    if (!osrv) {
+    if (!osrv) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     current->add(osrv);
@@ -242,7 +242,7 @@ bool WarpBuilder::startNewOsrPreHeaderBl
     uint32_t slot = info().stackSlot(i);
     ptrdiff_t offset = BaselineFrame::reverseOffsetOfLocal(nlocals + i);
     MOsrValue* osrv = MOsrValue::New(alloc().fallible(), entry, offset);
-    if (!osrv) {
+    if (!osrv) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     current->add(osrv);
@@ -257,7 +257,7 @@ bool WarpBuilder::startNewOsrPreHeaderBl
 
   // Create the preheader block, with the predecessor block and OSR block as
   // predecessors.
-  if (!startNewBlock(pred, loopHead)) {
+  if (!startNewBlock(pred, loopHead)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -288,7 +288,7 @@ bool WarpBuilder::addPendingEdge(const P
 }
 
 bool WarpBuilder::build() {
-  if (!buildPrologue()) {
+  if (!buildPrologue()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -308,7 +308,7 @@ bool WarpBuilder::build() {
 }
 
 bool WarpBuilder::buildInline() {
-  if (!buildInlinePrologue()) {
+  if (!buildInlinePrologue()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -366,7 +366,7 @@ MInstruction* WarpBuilder::buildCallObje
       continue;
     }
 
-    if (!alloc().ensureBallast()) {
+    if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -439,7 +439,7 @@ bool WarpBuilder::buildEnvironmentChain(
 
 bool WarpBuilder::buildPrologue() {
   BytecodeLocation startLoc(script_, script_->code());
-  if (!startNewEntryBlock(info().firstStackSlot(), startLoc)) {
+  if (!startNewEntryBlock(info().firstStackSlot(), startLoc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -452,7 +452,7 @@ bool WarpBuilder::buildPrologue() {
     // Initialize arguments.
     for (uint32_t i = 0; i < info().nargs(); i++) {
       MParameter* param = MParameter::New(alloc().fallible(), i);
-      if (!param) {
+      if (!param) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       current->add(param);
@@ -480,7 +480,7 @@ bool WarpBuilder::buildPrologue() {
   MCheckOverRecursed* check = MCheckOverRecursed::New(alloc());
   current->add(check);
 
-  if (!buildEnvironmentChain()) {
+  if (!buildEnvironmentChain()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -498,7 +498,7 @@ bool WarpBuilder::buildPrologue() {
 bool WarpBuilder::buildInlinePrologue() {
   // Generate entry block.
   BytecodeLocation startLoc(script_, script_->code());
-  if (!startNewEntryBlock(info().firstStackSlot(), startLoc)) {
+  if (!startNewEntryBlock(info().firstStackSlot(), startLoc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   current->setCallerResumePoint(callerResumePoint());
@@ -508,7 +508,7 @@ bool WarpBuilder::buildInlinePrologue() 
   MOZ_ASSERT(pred == callerResumePoint()->block());
 
   pred->end(MGoto::New(alloc(), current));
-  if (!current->addPredecessorWithoutPhis(pred)) {
+  if (!current->addPredecessorWithoutPhis(pred)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -663,7 +663,7 @@ bool WarpBuilder::buildBody() {
       }
     }
 
-    if (!alloc().ensureBallast()) {
+    if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1118,7 +1118,7 @@ bool WarpBuilder::build_JumpTarget(Bytec
   // Create join block if there's fall-through from the previous bytecode op.
   if (!hasTerminatedBlock()) {
     MBasicBlock* pred = current;
-    if (!startNewBlock(pred, loc)) {
+    if (!startNewBlock(pred, loc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     pred->end(MGoto::New(alloc(), current));
@@ -1321,7 +1321,7 @@ bool WarpBuilder::build_LoopHead(Bytecod
 
   // Handle OSR from Baseline JIT code.
   if (loc.toRawBytecode() == info().osrPc()) {
-    if (!startNewOsrPreHeaderBlock(loc)) {
+    if (!startNewOsrPreHeaderBlock(loc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1329,13 +1329,13 @@ bool WarpBuilder::build_LoopHead(Bytecod
   incLoopDepth();
 
   MBasicBlock* pred = current;
-  if (!startNewLoopHeaderBlock(loc)) {
+  if (!startNewLoopHeaderBlock(loc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   pred->end(MGoto::New(alloc(), current));
 
-  if (!addIteratorLoopPhis(loc)) {
+  if (!addIteratorLoopPhis(loc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1384,7 +1384,7 @@ bool WarpBuilder::buildTestOp(BytecodeLo
                            /* ifFalse = */ nullptr);
   current->end(test);
 
-  if (!addPendingEdge(PendingEdge::NewTestTrue(current, op), target1)) {
+  if (!addPendingEdge(PendingEdge::NewTestTrue(current, op), target1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!addPendingEdge(PendingEdge::NewTestFalse(current, op), target2)) {
@@ -1411,7 +1411,7 @@ bool WarpBuilder::buildTestBackedge(Byte
   // because the stack depth at the start of that op matches the current stack
   // depth (after popping our operand).
   MBasicBlock* pred = current;
-  if (!startNewBlock(current, loopHead)) {
+  if (!startNewBlock(current, loopHead)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1458,7 +1458,7 @@ bool WarpBuilder::build_Coalesce(Bytecod
                           /* ifFalse = */ nullptr));
 
   if (!addPendingEdge(PendingEdge::NewTestTrue(current, JSOp::Coalesce),
-                      target1)) {
+                      target1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!addPendingEdge(PendingEdge::NewTestFalse(current, JSOp::Coalesce),
@@ -1503,7 +1503,7 @@ bool WarpBuilder::build_Goto(BytecodeLoc
   return buildForwardGoto(loc.getJumpTarget());
 }
 
-bool WarpBuilder::build_DebugCheckSelfHosted(BytecodeLocation loc) {
+bool WarpBuilder::build_DebugCheckSelfHosted(BytecodeLocation loc) {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
   MDefinition* val = current->pop();
   MDebugCheckSelfHosted* check = MDebugCheckSelfHosted::New(alloc(), val);
@@ -1623,7 +1623,7 @@ bool WarpBuilder::build_Arguments(Byteco
   auto* snapshot = getOpSnapshot<WarpArguments>(loc);
   MOZ_ASSERT(info().needsArgsObj() == !!snapshot);
 
-  if (!snapshot) {
+  if (!snapshot) {MOZ_RELEASE_ASSERT(0);
     pushConstant(MagicValue(JS_OPTIMIZED_ARGUMENTS));
     return true;
   }
@@ -1767,7 +1767,7 @@ bool WarpBuilder::buildCallOp(BytecodeLo
   bool ignoresReturnValue = (op == JSOp::CallIgnoresRv || loc.resultIsPopped());
 
   CallInfo callInfo(alloc(), constructing, ignoresReturnValue);
-  if (!callInfo.init(current, argc)) {
+  if (!callInfo.init(current, argc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1776,7 +1776,7 @@ bool WarpBuilder::buildCallOp(BytecodeLo
     // inlining.  In this case, CacheOp::CallInlinedFunction updates
     // the CallInfo, but does not generate a call.
     callInfo.markAsInlined();
-    if (!transpileCall(loc, inliningSnapshot->cacheIRSnapshot(), &callInfo)) {
+    if (!transpileCall(loc, inliningSnapshot->cacheIRSnapshot(), &callInfo)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2911,17 +2911,17 @@ bool WarpBuilder::build_TableSwitch(Byte
   // Create |default| block.
   {
     BytecodeLocation defaultLoc = loc.getTableSwitchDefaultTarget();
-    if (!startNewBlock(switchBlock, defaultLoc)) {
+    if (!startNewBlock(switchBlock, defaultLoc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     size_t index;
-    if (!tableswitch->addDefault(current, &index)) {
+    if (!tableswitch->addDefault(current, &index)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     MOZ_ASSERT(index == 0);
 
-    if (!buildForwardGoto(defaultLoc)) {
+    if (!buildForwardGoto(defaultLoc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2929,15 +2929,15 @@ bool WarpBuilder::build_TableSwitch(Byte
   // Create blocks for all cases.
   for (size_t i = 0; i < numCases; i++) {
     BytecodeLocation caseLoc = loc.getTableSwitchCaseTarget(script_, i);
-    if (!startNewBlock(switchBlock, caseLoc)) {
+    if (!startNewBlock(switchBlock, caseLoc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     size_t index;
-    if (!tableswitch->addSuccessor(current, &index)) {
+    if (!tableswitch->addSuccessor(current, &index)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!tableswitch->addCase(index)) {
+    if (!tableswitch->addCase(index)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2969,7 +2969,7 @@ bool WarpBuilder::build_Rest(BytecodeLoc
     // Allocate an array of the correct size.
     MConstant* templateConst = constant(ObjectValue(*templateObject));
     MNewArray* newArray;
-    if (numRest > snapshot->maxInlineElements()) {
+    if (numRest > snapshot->maxInlineElements()) {MOZ_RELEASE_ASSERT(0);
       newArray = MNewArray::NewVM(alloc(), numRest, templateConst, heap);
     } else {
       newArray = MNewArray::New(alloc(), numRest, templateConst, heap);
@@ -3116,7 +3116,7 @@ bool WarpBuilder::buildIC(BytecodeLocati
     callInfo.markAsInlined();
 
     if (!TranspileCacheIRToMIR(this, loc, inliningSnapshot->cacheIRSnapshot(),
-                               inputs, &callInfo)) {
+                               inputs, &callInfo)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     return buildInlinedCall(loc, inliningSnapshot, callInfo);
@@ -3400,12 +3400,12 @@ bool WarpBuilder::buildInlinedCall(Bytec
   callInfo.setImplicitlyUsedUnchecked();
 
   // Capture formals in the outer resume point.
-  if (!callInfo.pushCallStack(current)) {
+  if (!callInfo.pushCallStack(current)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MResumePoint* outerResumePoint =
       MResumePoint::New(alloc(), current, pc, MResumePoint::Outer);
-  if (!outerResumePoint) {
+  if (!outerResumePoint) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   current->setOuterResumePoint(outerResumePoint);
@@ -3433,7 +3433,7 @@ bool WarpBuilder::buildInlinedCall(Bytec
   // Create return block
   BytecodeLocation postCall = loc.next();
   MBasicBlock* prev = current;
-  if (!startNewEntryBlock(prev->stackDepth(), postCall)) {
+  if (!startNewEntryBlock(prev->stackDepth(), postCall)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   // Restore previous value of callerResumePoint.
@@ -3446,7 +3446,7 @@ bool WarpBuilder::buildInlinedCall(Bytec
   // Accumulate return values.
   MDefinition* returnValue =
       patchInlinedReturns(calleeCompileInfo, callInfo, returns, current);
-  if (!returnValue) {
+  if (!returnValue) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   current->push(returnValue);
@@ -3470,7 +3470,7 @@ MDefinition* WarpBuilder::patchInlinedRe
 
   // Accumulate multiple returns with a phi.
   MPhi* phi = MPhi::New(alloc());
-  if (!phi->reserveLength(exits.length())) {
+  if (!phi->reserveLength(exits.length())) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/jit/WarpCacheIRTranspiler.cpp b/js/src/jit/WarpCacheIRTranspiler.cpp
--- a/js/src/jit/WarpCacheIRTranspiler.cpp
+++ b/js/src/jit/WarpCacheIRTranspiler.cpp
@@ -288,7 +288,7 @@ class MOZ_RAII WarpCacheIRTranspiler : p
 
 bool WarpCacheIRTranspiler::transpile(
     std::initializer_list<MDefinition*> inputs) {
-  if (!operands_.append(inputs.begin(), inputs.end())) {
+  if (!operands_.append(inputs.begin(), inputs.end())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -552,7 +552,7 @@ bool WarpCacheIRTranspiler::emitCallDOMG
                                nullptr, nullptr);
   }
 
-  if (!ins) {
+  if (!ins) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1000,7 +1000,7 @@ bool WarpCacheIRTranspiler::emitGuardArg
   return true;
 }
 
-bool WarpCacheIRTranspiler::emitLoadFrameCalleeResult() {
+bool WarpCacheIRTranspiler::emitLoadFrameCalleeResult() {MOZ_RELEASE_ASSERT(0);
   if (const CallInfo* callInfo = builder_->inlineCallInfo()) {
     pushResult(callInfo->callee());
     return true;
@@ -1012,7 +1012,7 @@ bool WarpCacheIRTranspiler::emitLoadFram
   return true;
 }
 
-bool WarpCacheIRTranspiler::emitLoadFrameNumActualArgsResult() {
+bool WarpCacheIRTranspiler::emitLoadFrameNumActualArgsResult() {MOZ_RELEASE_ASSERT(0);
   if (const CallInfo* callInfo = builder_->inlineCallInfo()) {
     auto* ins = constant(Int32Value(callInfo->argc()));
     pushResult(ins);
@@ -2737,7 +2737,7 @@ bool WarpCacheIRTranspiler::emitIndirect
 bool WarpCacheIRTranspiler::emitMathHypot2NumberResult(
     NumberOperandId firstId, NumberOperandId secondId) {
   MDefinitionVector vector(alloc());
-  if (!vector.reserve(2)) {
+  if (!vector.reserve(2)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2758,7 +2758,7 @@ bool WarpCacheIRTranspiler::emitMathHypo
     NumberOperandId firstId, NumberOperandId secondId,
     NumberOperandId thirdId) {
   MDefinitionVector vector(alloc());
-  if (!vector.reserve(3)) {
+  if (!vector.reserve(3)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2780,7 +2780,7 @@ bool WarpCacheIRTranspiler::emitMathHypo
     NumberOperandId firstId, NumberOperandId secondId, NumberOperandId thirdId,
     NumberOperandId fourthId) {
   MDefinitionVector vector(alloc());
-  if (!vector.reserve(4)) {
+  if (!vector.reserve(4)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4226,7 +4226,7 @@ bool WarpCacheIRTranspiler::emitCallFunc
              static_cast<int32_t>(callInfo_->argc()));
 #endif
 
-  if (!updateCallInfo(callee, flags)) {
+  if (!updateCallInfo(callee, flags)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4293,7 +4293,7 @@ bool WarpCacheIRTranspiler::emitCallFunc
 }
 
 bool WarpCacheIRTranspiler::emitFunApplyMagicArgs(
-    WrappedFunction* wrappedTarget, CallFlags flags) {
+    WrappedFunction* wrappedTarget, CallFlags flags) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(!callInfo_->constructing());
   MOZ_ASSERT(!builder_->inlineCallInfo());
 
@@ -4306,7 +4306,7 @@ bool WarpCacheIRTranspiler::emitFunApply
   MApplyArgs* apply =
       MApplyArgs::New(alloc(), wrappedTarget, argFunc, numArgs, argThis);
 
-  if (flags.isSameRealm()) {
+  if (flags.isSameRealm()) {MOZ_RELEASE_ASSERT(0);
     apply->setNotCrossRealm();
   }
   if (callInfo_->ignoresReturnValue()) {
@@ -4330,7 +4330,7 @@ bool WarpCacheIRTranspiler::emitFunApply
   MApplyArgsObj* apply =
       MApplyArgsObj::New(alloc(), wrappedTarget, callee, argsObj, thisArg);
 
-  if (flags.isSameRealm()) {
+  if (flags.isSameRealm()) {MOZ_RELEASE_ASSERT(0);
     apply->setNotCrossRealm();
   }
   if (callInfo_->ignoresReturnValue()) {
@@ -4396,7 +4396,7 @@ bool WarpCacheIRTranspiler::emitCallInli
     // inlined function itself will be generated in
     // WarpBuilder::buildInlinedCall.
     MDefinition* callee = getOperand(calleeId);
-    if (!updateCallInfo(callee, flags)) {
+    if (!updateCallInfo(callee, flags)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (callInfo_->constructing()) {
@@ -4439,7 +4439,7 @@ bool WarpCacheIRTranspiler::emitCallWasm
   const wasm::FuncExport* funcExport = wasmFuncExportField(funcExportOffset);
   const wasm::FuncType& sig = funcExport->funcType();
 
-  if (!updateCallInfo(callee, flags)) {
+  if (!updateCallInfo(callee, flags)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4451,13 +4451,13 @@ bool WarpCacheIRTranspiler::emitCallWasm
 
   auto* wasmInstanceObj = &instanceObject->as<WasmInstanceObject>();
   auto* call = MIonToWasmCall::New(alloc(), wasmInstanceObj, *funcExport);
-  if (!call) {
+  if (!call) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   mozilla::Maybe<MDefinition*> undefined;
   for (size_t i = 0; i < sig.args().length(); i++) {
-    if (!alloc().ensureBallast()) {
+    if (!alloc().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -4583,7 +4583,7 @@ bool WarpCacheIRTranspiler::emitCallGett
   callInfo.initForGetterCall(getter, receiver);
 
   MCall* call = makeCall(callInfo, /* needsThisCheck = */ false, wrappedTarget);
-  if (!call) {
+  if (!call) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4655,7 +4655,7 @@ bool WarpCacheIRTranspiler::emitCallSett
   callInfo.initForSetterCall(setter, receiver, rhs);
 
   MCall* call = makeCall(callInfo, /* needsThisCheck = */ false, wrappedTarget);
-  if (!call) {
+  if (!call) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4739,7 +4739,7 @@ bool WarpCacheIRTranspiler::emitAssertRe
   MDefinition* val = getOperand(valId);
 
   // Don't assert for recovered instructions when recovering is disabled.
-  if (JitOptions.disableRecoverIns) {
+  if (JitOptions.disableRecoverIns) {MOZ_RELEASE_ASSERT(0);
     pushResult(constant(UndefinedValue()));
     return true;
   }
@@ -4819,7 +4819,7 @@ bool jit::TranspileCacheIRToMIR(WarpBuil
 
   WarpCacheIRTranspiler transpiler(builder, loc, maybeCallInfo,
                                    cacheIRSnapshot);
-  if (!transpiler.transpile(inputs)) {
+  if (!transpiler.transpile(inputs)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/jit/WarpOracle.cpp b/js/src/jit/WarpOracle.cpp
--- a/js/src/jit/WarpOracle.cpp
+++ b/js/src/jit/WarpOracle.cpp
@@ -156,11 +156,11 @@ AbortReasonOr<WarpSnapshot*> WarpOracle:
   auto* snapshot = new (alloc_.fallible())
       WarpSnapshot(cx_, alloc_, std::move(scriptSnapshots_), bailoutInfo_,
                    recordFinalWarmUpCount);
-  if (!snapshot) {
+  if (!snapshot) {MOZ_RELEASE_ASSERT(0);
     return abort(outerScript_, AbortReason::Alloc);
   }
 
-  if (!snapshot->nurseryObjects().appendAll(nurseryObjects_)) {
+  if (!snapshot->nurseryObjects().appendAll(nurseryObjects_)) {MOZ_RELEASE_ASSERT(0);
     return abort(outerScript_, AbortReason::Alloc);
   }
 
@@ -271,7 +271,7 @@ AbortReasonOr<WarpEnvironment> WarpScrip
   }
 
   // Parameter expression-induced extra var environment not yet handled.
-  if (fun->needsExtraBodyVarEnvironment()) {
+  if (fun->needsExtraBodyVarEnvironment()) {MOZ_RELEASE_ASSERT(0);
     return abort(AbortReason::Disable, "Extra var environment unsupported");
   }
 
@@ -297,11 +297,11 @@ AbortReasonOr<WarpEnvironment> WarpScrip
 AbortReasonOr<WarpScriptSnapshot*> WarpScriptOracle::createScriptSnapshot() {
   MOZ_ASSERT(script_->hasJitScript());
 
-  if (!script_->jitScript()->ensureHasCachedIonData(cx_, script_)) {
+  if (!script_->jitScript()->ensureHasCachedIonData(cx_, script_)) {MOZ_RELEASE_ASSERT(0);
     return abort(AbortReason::Error);
   }
 
-  if (script_->jitScript()->hasTryFinally()) {
+  if (script_->jitScript()->hasTryFinally()) {MOZ_RELEASE_ASSERT(0);
     return abort(AbortReason::Disable, "Try-finally not supported");
   }
 
@@ -835,7 +835,7 @@ AbortReasonOr<Ok> WarpScriptOracle::mayb
     }
 
     // Cold IC. Bailout to collect information.
-    if (!AddOpSnapshot<WarpBailout>(alloc_, snapshots, offset)) {
+    if (!AddOpSnapshot<WarpBailout>(alloc_, snapshots, offset)) {MOZ_RELEASE_ASSERT(0);
       return abort(AbortReason::Alloc);
     }
     return Ok();
@@ -930,7 +930,7 @@ AbortReasonOr<Ok> WarpScriptOracle::mayb
   size_t bytesNeeded = stubInfo->stubDataSize();
   if (bytesNeeded > 0) {
     stubDataCopy = alloc_.allocateArray<uint8_t>(bytesNeeded);
-    if (!stubDataCopy) {
+    if (!stubDataCopy) {MOZ_RELEASE_ASSERT(0);
       return abort(AbortReason::Alloc);
     }
 
@@ -938,7 +938,7 @@ AbortReasonOr<Ok> WarpScriptOracle::mayb
     // GC barriers and can do a bitwise copy.
     std::copy_n(stubData, bytesNeeded, stubDataCopy);
 
-    if (!replaceNurseryPointers(stub, stubInfo, stubDataCopy)) {
+    if (!replaceNurseryPointers(stub, stubInfo, stubDataCopy)) {MOZ_RELEASE_ASSERT(0);
       return abort(AbortReason::Alloc);
     }
   }
@@ -968,7 +968,7 @@ AbortReasonOr<bool> WarpScriptOracle::ma
     WarpOpSnapshotList& snapshots, BytecodeLocation loc, ICCacheIRStub* stub,
     ICFallbackStub* fallbackStub, uint8_t* stubDataCopy) {
   Maybe<InlinableOpData> inlineData = FindInlinableOpData(stub, loc);
-  if (inlineData.isNothing() || !inlineData->icScript) {
+  if (inlineData.isNothing() || !inlineData->icScript) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -984,7 +984,7 @@ AbortReasonOr<bool> WarpScriptOracle::ma
   LifoAlloc* lifoAlloc = alloc_.lifoAlloc();
   InlineScriptTree* inlineScriptTree = info_->inlineScriptTree()->addCallee(
       &alloc_, loc.toRawBytecode(), targetScript);
-  if (!inlineScriptTree) {
+  if (!inlineScriptTree) {MOZ_RELEASE_ASSERT(0);
     return abort(AbortReason::Alloc);
   }
 
@@ -994,7 +994,7 @@ AbortReasonOr<bool> WarpScriptOracle::ma
   CompileInfo* info = lifoAlloc->new_<CompileInfo>(
       mirGen_.runtime, targetScript, targetFunction, osrPc,
       info_->analysisMode(), needsArgsObj, inlineScriptTree);
-  if (!info) {
+  if (!info) {MOZ_RELEASE_ASSERT(0);
     return abort(AbortReason::Alloc);
   }
 
@@ -1004,7 +1004,7 @@ AbortReasonOr<bool> WarpScriptOracle::ma
   const CacheIRStubInfo* stubInfo = stub->stubInfo();
   WarpCacheIR* cacheIRSnapshot = new (alloc_.fallible())
       WarpCacheIR(offset, jitCode, stubInfo, stubDataCopy);
-  if (!cacheIRSnapshot) {
+  if (!cacheIRSnapshot) {MOZ_RELEASE_ASSERT(0);
     return abort(AbortReason::Alloc);
   }
 
@@ -1015,7 +1015,7 @@ AbortReasonOr<bool> WarpScriptOracle::ma
   AbortReasonOr<WarpScriptSnapshot*> maybeScriptSnapshot =
       scriptOracle.createScriptSnapshot();
 
-  if (maybeScriptSnapshot.isErr()) {
+  if (maybeScriptSnapshot.isErr()) {MOZ_RELEASE_ASSERT(0);
     JitSpew(JitSpew_WarpTranspiler, "Can't create snapshot for JSOp::%s",
             CodeName(loc.getOp()));
 
diff --git a/js/src/jit/WarpSnapshot.cpp b/js/src/jit/WarpSnapshot.cpp
--- a/js/src/jit/WarpSnapshot.cpp
+++ b/js/src/jit/WarpSnapshot.cpp
@@ -233,14 +233,14 @@ void WarpScriptSnapshot::trace(JSTracer*
 
   environment_.match(
       [](const NoEnvironment&) {},
-      [trc](WarpGCPtr<JSObject*>& obj) {
+      [trc](WarpGCPtr<JSObject*>& obj) {MOZ_RELEASE_ASSERT(0);
         TraceWarpGCPtr(trc, obj, "warp-env-object");
       },
       [trc](FunctionEnvironment& env) {
         if (env.callObjectTemplate) {
           TraceWarpGCPtr(trc, env.callObjectTemplate, "warp-env-callobject");
         }
-        if (env.namedLambdaTemplate) {
+        if (env.namedLambdaTemplate) {MOZ_RELEASE_ASSERT(0);
           TraceWarpGCPtr(trc, env.namedLambdaTemplate, "warp-env-namedlambda");
         }
       });
@@ -249,7 +249,7 @@ void WarpScriptSnapshot::trace(JSTracer*
     snapshot->trace(trc);
   }
 
-  if (moduleObject_) {
+  if (moduleObject_) {MOZ_RELEASE_ASSERT(0);
     TraceWarpGCPtr(trc, moduleObject_, "warp-module-obj");
   }
   if (instrumentationCallback_) {
diff --git a/js/src/jit/shared/AtomicOperations-shared-jit.cpp b/js/src/jit/shared/AtomicOperations-shared-jit.cpp
--- a/js/src/jit/shared/AtomicOperations-shared-jit.cpp
+++ b/js/src/jit/shared/AtomicOperations-shared-jit.cpp
@@ -670,7 +670,7 @@ void AtomicMemcpyDownUnsynchronized(uint
     } else if (UnalignedAccessesAreOK()) {
       copyBlock = AtomicCopyBlockDownUnsynchronized;
       copyWord = AtomicCopyWordUnsynchronized;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       copyBlock = AtomicCopyUnalignedBlockDownUnsynchronized;
       copyWord = AtomicCopyUnalignedWordDownUnsynchronized;
     }
@@ -713,7 +713,7 @@ void AtomicMemcpyUpUnsynchronized(uint8_
     if (((uintptr_t(dest) ^ uintptr_t(src)) & WORDMASK) == 0) {
       const uint8_t* cutoff = (const uint8_t*)(uintptr_t(src) & ~WORDMASK);
       MOZ_ASSERT(cutoff >= lim);  // Because nbytes >= WORDSIZE
-      while (src > cutoff) {
+      while (src > cutoff) {MOZ_RELEASE_ASSERT(0);
         AtomicCopyByteUnsynchronized(--dest, --src);
       }
       copyBlock = AtomicCopyBlockUpUnsynchronized;
@@ -721,7 +721,7 @@ void AtomicMemcpyUpUnsynchronized(uint8_
     } else if (UnalignedAccessesAreOK()) {
       copyBlock = AtomicCopyBlockUpUnsynchronized;
       copyWord = AtomicCopyWordUnsynchronized;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       copyBlock = AtomicCopyUnalignedBlockUpUnsynchronized;
       copyWord = AtomicCopyUnalignedWordUpUnsynchronized;
     }
@@ -855,7 +855,7 @@ bool InitializeJittedAtomics() {
 #endif
 
   masm.finish();
-  if (masm.oom()) {
+  if (masm.oom()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -865,7 +865,7 @@ bool InitializeJittedAtomics() {
   uint8_t* code = (uint8_t*)AllocateExecutableMemory(
       roundedCodeLength, ProtectionSetting::Writable,
       MemCheckKind::MakeUndefined);
-  if (!code) {
+  if (!code) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/jit/shared/CodeGenerator-shared.cpp b/js/src/jit/shared/CodeGenerator-shared.cpp
--- a/js/src/jit/shared/CodeGenerator-shared.cpp
+++ b/js/src/jit/shared/CodeGenerator-shared.cpp
@@ -142,7 +142,7 @@ bool CodeGeneratorShared::generateEpilog
   MOZ_ASSERT(!gen->compilingWasm());
   masm.bind(&returnLabel_);
 
-  if (JS::TraceLoggerSupported()) {
+  if (JS::TraceLoggerSupported()) {MOZ_RELEASE_ASSERT(0);
     emitTracelogIonStop();
   }
 
@@ -171,7 +171,7 @@ bool CodeGeneratorShared::generateOutOfL
     // Add native => bytecode mapping entries for OOL sites.
     // Not enabled on wasm yet since it doesn't contain bytecode mappings.
     if (!gen->compilingWasm()) {
-      if (!addNativeToBytecodeEntry(outOfLineCode_[i]->bytecodeSite())) {
+      if (!addNativeToBytecodeEntry(outOfLineCode_[i]->bytecodeSite())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -217,7 +217,7 @@ bool CodeGeneratorShared::addNativeToByt
 
   // Fails early if the last added instruction caused the macro assembler to
   // run out of memory as continuity assumption below do not hold.
-  if (masm.oom()) {
+  if (masm.oom()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -245,21 +245,21 @@ bool CodeGeneratorShared::addNativeToByt
     // If the new entry is for the same native offset, then update the
     // previous entry with the new bytecode site, since the previous
     // bytecode site did not generate any native code.
-    if (lastEntry.nativeOffset.offset() == nativeOffset) {
+    if (lastEntry.nativeOffset.offset() == nativeOffset) {MOZ_RELEASE_ASSERT(0);
       lastEntry.tree = tree;
       lastEntry.pc = pc;
       JitSpew(JitSpew_Profiling, " => Overwriting zero-length native region.");
 
       // This overwrite might have made the entry merge-able with a
       // previous one.  If so, merge it.
-      if (lastIdx > 0) {
+      if (lastIdx > 0) {MOZ_RELEASE_ASSERT(0);
         NativeToBytecode& nextToLastEntry = nativeToBytecodeList_[lastIdx - 1];
         if (nextToLastEntry.tree == lastEntry.tree &&
-            nextToLastEntry.pc == lastEntry.pc) {
+            nextToLastEntry.pc == lastEntry.pc) {MOZ_RELEASE_ASSERT(0);
           JitSpew(JitSpew_Profiling, " => Merging with previous region");
           nativeToBytecodeList_.erase(&lastEntry);
-        }
-      }
+        }MOZ_RELEASE_ASSERT(0);
+      }MOZ_RELEASE_ASSERT(0);
 
       dumpNativeToBytecodeEntry(nativeToBytecodeList_.length() - 1);
       return true;
@@ -590,17 +590,17 @@ void CodeGeneratorShared::encode(LSnapsh
   masm.propagateOOM(!snapshots_.oom());
 }
 
-bool CodeGeneratorShared::assignBailoutId(LSnapshot* snapshot) {
+bool CodeGeneratorShared::assignBailoutId(LSnapshot* snapshot) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(snapshot->snapshotOffset() != INVALID_SNAPSHOT_OFFSET);
 
   // Can we not use bailout tables at all?
-  if (!deoptTable_) {
+  if (!deoptTable_) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MOZ_ASSERT(frameClass_ != FrameSizeClass::None());
 
-  if (snapshot->bailoutId() != INVALID_BAILOUT_ID) {
+  if (snapshot->bailoutId() != INVALID_BAILOUT_ID) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -641,7 +641,7 @@ bool CodeGeneratorShared::createNativeTo
       }
     }
     if (!found) {
-      if (!scriptList.append(tree->script())) {
+      if (!scriptList.append(tree->script())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -673,7 +673,7 @@ bool CodeGeneratorShared::createNativeTo
 
   // Allocate array for list.
   JSScript** data = cx->pod_malloc<JSScript*>(scriptList.length());
-  if (!data) {
+  if (!data) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -696,7 +696,7 @@ bool CodeGeneratorShared::generateCompac
   MOZ_ASSERT(nativeToBytecodeTableOffset_ == 0);
   MOZ_ASSERT(nativeToBytecodeNumRegions_ == 0);
 
-  if (!createNativeToBytecodeScriptList(cx)) {
+  if (!createNativeToBytecodeScriptList(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -711,7 +711,7 @@ bool CodeGeneratorShared::generateCompac
           writer, nativeToBytecodeScriptList_,
           nativeToBytecodeScriptListLength_, &nativeToBytecodeList_[0],
           &nativeToBytecodeList_[0] + nativeToBytecodeList_.length(),
-          &tableOffset, &numRegions)) {
+          &tableOffset, &numRegions)) {MOZ_RELEASE_ASSERT(0);
     js_free(nativeToBytecodeScriptList_);
     return false;
   }
@@ -971,7 +971,7 @@ bool CodeGeneratorShared::omitOverRecurs
 
 void CodeGeneratorShared::emitPreBarrier(Register elements,
                                          const LAllocation* index) {
-  if (index->isConstant()) {
+  if (index->isConstant()) {MOZ_RELEASE_ASSERT(0);
     Address address(elements, ToInt32(index) * sizeof(Value));
     masm.guardedCallPreBarrier(address, MIRType::Value);
   } else {
@@ -1095,10 +1095,10 @@ ReciprocalMulConstants CodeGeneratorShar
 
 #ifdef JS_TRACE_LOGGING
 
-void CodeGeneratorShared::emitTracelogScript(bool isStart) {
-  if (!TraceLogTextIdEnabled(TraceLogger_Scripts)) {
+void CodeGeneratorShared::emitTracelogScript(bool isStart) {MOZ_RELEASE_ASSERT(0);
+  if (!TraceLogTextIdEnabled(TraceLogger_Scripts)) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   Label done;
 
@@ -1119,7 +1119,7 @@ void CodeGeneratorShared::emitTracelogSc
   CodeOffset patchScript = masm.movWithPatch(ImmWord(0), script);
   masm.propagateOOM(patchableTLScripts_.append(patchScript));
 
-  if (isStart) {
+  if (isStart) {MOZ_RELEASE_ASSERT(0);
     masm.tracelogStartId(logger, script);
   } else {
     masm.tracelogStopId(logger, script);
@@ -1132,10 +1132,10 @@ void CodeGeneratorShared::emitTracelogSc
   masm.Pop(logger);
 }
 
-void CodeGeneratorShared::emitTracelogTree(bool isStart, uint32_t textId) {
-  if (!TraceLogTextIdEnabled(textId)) {
+void CodeGeneratorShared::emitTracelogTree(bool isStart, uint32_t textId) {MOZ_RELEASE_ASSERT(0);
+  if (!TraceLogTextIdEnabled(textId)) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   Label done;
   AllocatableRegisterSet regs(RegisterSet::Volatile());
@@ -1149,7 +1149,7 @@ void CodeGeneratorShared::emitTracelogTr
   Address enabledAddress(logger, TraceLoggerThread::offsetOfEnabled());
   masm.branch32(Assembler::Equal, enabledAddress, Imm32(0), &done);
 
-  if (isStart) {
+  if (isStart) {MOZ_RELEASE_ASSERT(0);
     masm.tracelogStartId(logger, textId);
   } else {
     masm.tracelogStopId(logger, textId);
@@ -1162,9 +1162,9 @@ void CodeGeneratorShared::emitTracelogTr
 
 void CodeGeneratorShared::emitTracelogTree(bool isStart, const char* text,
                                            TraceLoggerTextId enabledTextId) {
-  if (!TraceLogTextIdEnabled(enabledTextId)) {
+  if (!TraceLogTextIdEnabled(enabledTextId)) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   Label done;
 
@@ -1185,7 +1185,7 @@ void CodeGeneratorShared::emitTracelogTr
   PatchableTLEvent patchEvent(masm.movWithPatch(ImmWord(0), eventReg), text);
   masm.propagateOOM(patchableTLEvents_.append(std::move(patchEvent)));
 
-  if (isStart) {
+  if (isStart) {MOZ_RELEASE_ASSERT(0);
     masm.tracelogStartId(loggerReg, eventReg);
   } else {
     masm.tracelogStopId(loggerReg, eventReg);
diff --git a/js/src/jit/shared/Disassembler-shared.cpp b/js/src/jit/shared/Disassembler-shared.cpp
--- a/js/src/jit/shared/Disassembler-shared.cpp
+++ b/js/src/jit/shared/Disassembler-shared.cpp
@@ -47,7 +47,7 @@ DisassemblerSpew::DisassemblerSpew()
 #endif
 }
 
-DisassemblerSpew::~DisassemblerSpew() {
+DisassemblerSpew::~DisassemblerSpew() {MOZ_RELEASE_ASSERT(0);
 #ifdef JS_DISASM_SUPPORTED
   Node* p = nodes_;
   while (p) {
@@ -64,7 +64,7 @@ bool DisassemblerSpew::isDisabled() {
   return !(JitSpewEnabled(JitSpew_Codegen) || printer_);
 }
 
-void DisassemblerSpew::spew(const char* fmt, ...) {
+void DisassemblerSpew::spew(const char* fmt, ...) {MOZ_RELEASE_ASSERT(0);
 #ifdef JS_DISASM_SUPPORTED
   static const char prefix_chars[] =
       "0123456789"
@@ -87,7 +87,7 @@ void DisassemblerSpew::spew(const char* 
   va_end(args);
 }
 
-void DisassemblerSpew::spewVA(const char* fmt, va_list va) {
+void DisassemblerSpew::spewVA(const char* fmt, va_list va) {MOZ_RELEASE_ASSERT(0);
   if (printer_) {
     printer_->vprintf(fmt, va);
     printer_->put("\n");
diff --git a/js/src/jit/shared/Lowering-shared.cpp b/js/src/jit/shared/Lowering-shared.cpp
--- a/js/src/jit/shared/Lowering-shared.cpp
+++ b/js/src/jit/shared/Lowering-shared.cpp
@@ -222,12 +222,12 @@ LSnapshot* LIRGeneratorShared::buildSnap
 LSnapshot* LIRGeneratorShared::buildSnapshot(MResumePoint* rp,
                                              BailoutKind kind) {
   LRecoverInfo* recoverInfo = getRecoverInfo(rp);
-  if (!recoverInfo) {
+  if (!recoverInfo) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   LSnapshot* snapshot = LSnapshot::New(gen, recoverInfo, kind);
-  if (!snapshot) {
+  if (!snapshot) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -293,7 +293,7 @@ void LIRGeneratorShared::assignSafepoint
   MResumePoint* mrp =
       mir->resumePoint() ? mir->resumePoint() : lastResumePoint_;
   LSnapshot* postSnapshot = buildSnapshot(mrp, kind);
-  if (!postSnapshot) {
+  if (!postSnapshot) {MOZ_RELEASE_ASSERT(0);
     abort(AbortReason::Alloc, "buildSnapshot failed");
     return;
   }
@@ -478,11 +478,11 @@ static bool IsIdentity(const T* lanes) {
 // Recognize part of an identity permutation starting at start, with
 // the first value of the permutation expected to be bias.
 template <typename T>
-static bool IsIdentity(const T* lanes, int start, int len, int bias) {
-  if (lanes[start] != bias) {
+static bool IsIdentity(const T* lanes, int start, int len, int bias) {MOZ_RELEASE_ASSERT(0);
+  if (lanes[start] != bias) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  for (int i = start + 1; i < start + len; i++) {
+  for (int i = start + 1; i < start + len; i++) {MOZ_RELEASE_ASSERT(0);
     if (lanes[i] != lanes[i - 1] + 1) {
       return false;
     }
@@ -515,7 +515,7 @@ static bool TryRotateRight8x16(SimdConst
   }
 
   // If we reached the end of the vector, we're done.
-  if (i == 16) {
+  if (i == 16) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -535,28 +535,28 @@ static bool TryPermute16x8(SimdConstant*
   SimdConstant tmp = *control;
   if (!ByteMaskToWordMask(&tmp)) {
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   const SimdConstant::I16x8& lanes = tmp.asInt16x8();
   SimdConstant::I16x8 mapped;
-  MapLanes(mapped, lanes, [](int x) -> int { return x < 4 ? 0 : 1; });
+  MapLanes(mapped, lanes, [](int x) -> int {MOZ_RELEASE_ASSERT(0); return x < 4 ? 0 : 1; });
   int i = ScanConstant(mapped, mapped[0], 0);
-  if (i != 4) {
+  if (i != 4) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   i = ScanConstant(mapped, mapped[4], 4);
-  if (i != 8) {
+  if (i != 8) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   // Now compute the operation bits.  `mapped` holds the adjusted lane mask.
   memcpy(mapped, lanes, sizeof(mapped));
   int16_t op = 0;
-  if (mapped[0] > mapped[4]) {
+  if (mapped[0] > mapped[4]) {MOZ_RELEASE_ASSERT(0);
     op |= LWasmPermuteSimd128::SWAP_QWORDS;
   }
-  for (int i = 0; i < 8; i++) {
+  for (int i = 0; i < 8; i++) {MOZ_RELEASE_ASSERT(0);
     mapped[i] &= 3;
   }
-  if (!IsIdentity(mapped, 0, 4, 0)) {
+  if (!IsIdentity(mapped, 0, 4, 0)) {MOZ_RELEASE_ASSERT(0);
     op |= LWasmPermuteSimd128::PERM_LOW;
   }
   if (!IsIdentity(mapped, 4, 4, 0)) {
@@ -573,7 +573,7 @@ static bool TryBroadcast16x8(SimdConstan
   SimdConstant tmp = *control;
   if (!ByteMaskToWordMask(&tmp)) {
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   const SimdConstant::I16x8& lanes = tmp.asInt16x8();
   if (ScanConstant(lanes, lanes[0], 0) < 8) {
     return false;
@@ -621,16 +621,16 @@ static LWasmPermuteSimd128::Op AnalyzePe
   //
   // Dword and qword broadcasts are handled by dword permute.
 
-  if (TryPermute32x4(control)) {
+  if (TryPermute32x4(control)) {MOZ_RELEASE_ASSERT(0);
     return LWasmPermuteSimd128::PERMUTE_32x4;
   }
-  if (TryRotateRight8x16(control)) {
+  if (TryRotateRight8x16(control)) {MOZ_RELEASE_ASSERT(0);
     return LWasmPermuteSimd128::ROTATE_RIGHT_8x16;
   }
-  if (TryPermute16x8(control)) {
+  if (TryPermute16x8(control)) {MOZ_RELEASE_ASSERT(0);
     return LWasmPermuteSimd128::PERMUTE_16x8;
   }
-  if (TryBroadcast16x8(control)) {
+  if (TryBroadcast16x8(control)) {MOZ_RELEASE_ASSERT(0);
     return LWasmPermuteSimd128::BROADCAST_16x8;
   }
   if (TryBroadcast8x16(control)) {
@@ -669,11 +669,11 @@ static Maybe<LWasmPermuteSimd128::Op> Tr
   int shiftRight = 16 - i;
   if (shiftRight > 0 && lanes[i - 1] != 15) {
     return Nothing();
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   i = ScanConstant(zeroesMasked, 16, i);
   if (i < 16 || (shiftRight > 0 && shiftLeft > 0) ||
-      (shiftRight == 0 && shiftLeft == 0)) {
+      (shiftRight == 0 && shiftLeft == 0)) {MOZ_RELEASE_ASSERT(0);
     return Nothing();
   }
 
@@ -711,18 +711,18 @@ static Maybe<LWasmShuffleSimd128::Op> Tr
     return Nothing();
   }
   // Second run must start with 0 % 16
-  if ((lanes[i] & 15) != 0) {
+  if ((lanes[i] & 15) != 0) {MOZ_RELEASE_ASSERT(0);
     return Nothing();
   }
   // The two runs must come from different inputs
-  if ((lanes[i] & 16) == (lanes[i - 1] & 16)) {
+  if ((lanes[i] & 16) == (lanes[i - 1] & 16)) {MOZ_RELEASE_ASSERT(0);
     return Nothing();
-  }
+  }MOZ_RELEASE_ASSERT(0);
   int suffixLength = i;
 
   i = ScanIncreasingUnmasked(lanes, i);
   // Must end at the left end
-  if (i != 16) {
+  if (i != 16) {MOZ_RELEASE_ASSERT(0);
     return Nothing();
   }
 
@@ -744,7 +744,7 @@ static Maybe<LWasmShuffleSimd128::Op> Tr
   }
   SimdConstant::I16x8 masked;
   MaskLanes(masked, tmp.asInt16x8());
-  if (!IsIdentity(masked)) {
+  if (!IsIdentity(masked)) {MOZ_RELEASE_ASSERT(0);
     return Nothing();
   }
   SimdConstant::I16x8 mapped;
@@ -795,7 +795,7 @@ static Maybe<LWasmShuffleSimd128::Op> Tr
   if (MatchInterleave(lanes, lhs, rhs, len)) {
     return Some(lowOp);
   }
-  if (MatchInterleave(lanes, rhs, lhs, len)) {
+  if (MatchInterleave(lanes, rhs, lhs, len)) {MOZ_RELEASE_ASSERT(0);
     *swapOperands = !*swapOperands;
     return Some(lowOp);
   }
@@ -912,7 +912,7 @@ Shuffle LIRGeneratorShared::AnalyzeShuff
   // If only one of the inputs is used, determine which.
   bool useLeft = true;
   bool useRight = true;
-  if (lhs == rhs) {
+  if (lhs == rhs) {MOZ_RELEASE_ASSERT(0);
     useRight = false;
   } else {
     bool allAbove = true;
diff --git a/js/src/jit/x64/Assembler-x64.cpp b/js/src/jit/x64/Assembler-x64.cpp
--- a/js/src/jit/x64/Assembler-x64.cpp
+++ b/js/src/jit/x64/Assembler-x64.cpp
@@ -136,7 +136,7 @@ void Assembler::addPendingJump(JmpSrc sr
 }
 
 void Assembler::finish() {
-  if (oom()) {
+  if (oom()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -185,7 +185,7 @@ void Assembler::executableCopy(uint8_t* 
     uint8_t* src = buffer + rp.offset;
     MOZ_ASSERT(rp.target);
 
-    if (X86Encoding::CanRelinkJump(src, rp.target)) {
+    if (X86Encoding::CanRelinkJump(src, rp.target)) {MOZ_RELEASE_ASSERT(0);
       X86Encoding::SetRel32(src, rp.target);
     } else {
       // An extended jump table must exist, and its offset must be in
diff --git a/js/src/jit/x64/CodeGenerator-x64.cpp b/js/src/jit/x64/CodeGenerator-x64.cpp
--- a/js/src/jit/x64/CodeGenerator-x64.cpp
+++ b/js/src/jit/x64/CodeGenerator-x64.cpp
@@ -699,7 +699,7 @@ void CodeGenerator::visitWasmAtomicBinop
     masm.wasmAtomicEffectOp64(mir->access(), op, val, srcAddr);
   } else if (value->isConstant()) {
     Imm32 c(0);
-    if (value->toConstant()->type() == MIRType::Int64) {
+    if (value->toConstant()->type() == MIRType::Int64) {MOZ_RELEASE_ASSERT(0);
       c = Imm32(ToInt64(value));
     } else {
       c = Imm32(ToInt32(value));
diff --git a/js/src/jit/x64/MacroAssembler-x64.cpp b/js/src/jit/x64/MacroAssembler-x64.cpp
--- a/js/src/jit/x64/MacroAssembler-x64.cpp
+++ b/js/src/jit/x64/MacroAssembler-x64.cpp
@@ -865,16 +865,16 @@ void MacroAssembler::storeUnboxedValue(c
   // the slot has the same type.
   if ((valueType == MIRType::Int32 || valueType == MIRType::Boolean) &&
       slotType == valueType) {
-    if (value.constant()) {
+    if (value.constant()) {MOZ_RELEASE_ASSERT(0);
       Value val = value.value();
-      if (valueType == MIRType::Int32) {
+      if (valueType == MIRType::Int32) {MOZ_RELEASE_ASSERT(0);
         store32(Imm32(val.toInt32()), dest);
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         store32(Imm32(val.toBoolean() ? 1 : 0), dest);
       }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       store32(value.reg().typedReg().gpr(), dest);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -1259,7 +1259,7 @@ void MacroAssembler::wasmCompareExchange
                                            const Address& mem,
                                            Register64 expected,
                                            Register64 replacement,
-                                           Register64 output) {
+                                           Register64 output) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(output.reg == rax);
   if (expected != output) {
     movq(expected.reg, output.reg);
@@ -1487,7 +1487,7 @@ void MacroAssembler::wasmBoundsCheck64(C
 }
 
 void MacroAssembler::wasmBoundsCheck64(Condition cond, Register64 index,
-                                       Address boundsCheckLimit, Label* label) {
+                                       Address boundsCheckLimit, Label* label) {MOZ_RELEASE_ASSERT(0);
   cmpPtr(index.reg, Operand(boundsCheckLimit));
   j(cond, label);
   if (JitOptions.spectreIndexMasking) {
diff --git a/js/src/jit/x64/Trampoline-x64.cpp b/js/src/jit/x64/Trampoline-x64.cpp
--- a/js/src/jit/x64/Trampoline-x64.cpp
+++ b/js/src/jit/x64/Trampoline-x64.cpp
@@ -380,7 +380,7 @@ void JitRuntime::generateEnterJIT(JSCont
 
 // static
 mozilla::Maybe<::JS::ProfilingFrameIterator::RegisterState>
-JitRuntime::getCppEntryRegisters(JitFrameLayout* frameStackAddress) {
+JitRuntime::getCppEntryRegisters(JitFrameLayout* frameStackAddress) {MOZ_RELEASE_ASSERT(0);
   if (frameStackAddress->prevType() != FrameType::CppToJSJit) {
     // This is not a CppToJSJit frame, there are no C++ registers here.
     return mozilla::Nothing{};
@@ -809,7 +809,7 @@ bool JitRuntime::generateVMWrapper(JSCon
   masm.callWithABI(nativeFun, MoveOp::GENERAL,
                    CheckUnsafeCallWithABI::DontCheckHasExitFrame);
 
-  if (!generateTLExitVM(masm, f)) {
+  if (!generateTLExitVM(masm, f)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/jit/x86-shared/Assembler-x86-shared.cpp b/js/src/jit/x86-shared/Assembler-x86-shared.cpp
--- a/js/src/jit/x86-shared/Assembler-x86-shared.cpp
+++ b/js/src/jit/x86-shared/Assembler-x86-shared.cpp
@@ -313,17 +313,17 @@ void CPUInfo::SetSSEVersion() {
 
   if (flagsEcx & SSE42Bit) {
     maxSSEVersion = SSE4_2;
-  } else if (flagsEcx & SSE41Bit) {
+  } else if (flagsEcx & SSE41Bit) {MOZ_RELEASE_ASSERT(0);
     maxSSEVersion = SSE4_1;
-  } else if (flagsEcx & SSSE3Bit) {
+  } else if (flagsEcx & SSSE3Bit) {MOZ_RELEASE_ASSERT(0);
     maxSSEVersion = SSSE3;
-  } else if (flagsEcx & SSE3Bit) {
+  } else if (flagsEcx & SSE3Bit) {MOZ_RELEASE_ASSERT(0);
     maxSSEVersion = SSE3;
-  } else if (flagsEdx & SSE2Bit) {
+  } else if (flagsEdx & SSE2Bit) {MOZ_RELEASE_ASSERT(0);
     maxSSEVersion = SSE2;
-  } else if (flagsEdx & SSEBit) {
+  } else if (flagsEdx & SSEBit) {MOZ_RELEASE_ASSERT(0);
     maxSSEVersion = SSE;
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     maxSSEVersion = NoSSE;
   }
 
diff --git a/js/src/jit/x86-shared/CodeGenerator-x86-shared.cpp b/js/src/jit/x86-shared/CodeGenerator-x86-shared.cpp
--- a/js/src/jit/x86-shared/CodeGenerator-x86-shared.cpp
+++ b/js/src/jit/x86-shared/CodeGenerator-x86-shared.cpp
@@ -203,7 +203,7 @@ void CodeGenerator::visitNotI(LNotI* ins
   masm.emitSet(Assembler::Equal, ToRegister(ins->output()));
 }
 
-void CodeGenerator::visitNotD(LNotD* ins) {
+void CodeGenerator::visitNotD(LNotD* ins) {MOZ_RELEASE_ASSERT(0);
   FloatRegister opd = ToFloatRegister(ins->input());
 
   // Not returns true if the input is a NaN. We don't have to worry about
@@ -336,19 +336,19 @@ void CodeGenerator::visitWasmSelect(LWas
   if (mirType == MIRType::Float32) {
     if (falseExpr.kind() == Operand::FPREG) {
       masm.moveFloat32(ToFloatRegister(ins->falseExpr()), out);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       masm.loadFloat32(falseExpr, out);
     }
   } else if (mirType == MIRType::Double) {
     if (falseExpr.kind() == Operand::FPREG) {
       masm.moveDouble(ToFloatRegister(ins->falseExpr()), out);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       masm.loadDouble(falseExpr, out);
     }
   } else if (mirType == MIRType::Simd128) {
     if (falseExpr.kind() == Operand::FPREG) {
       masm.moveSimd128(ToFloatRegister(ins->falseExpr()), out);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       masm.loadUnalignedSimd128(falseExpr, out);
     }
   } else {
@@ -500,7 +500,7 @@ void CodeGenerator::visitWasmTruncateToI
     } else if (inputType == MIRType::Float32) {
       masm.wasmTruncateFloat32ToUInt32(input, output, mir->isSaturating(),
                                        oolEntry);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       MOZ_CRASH("unexpected type");
     }
     if (mir->isSaturating()) {
@@ -523,7 +523,7 @@ void CodeGenerator::visitWasmTruncateToI
 }
 
 bool CodeGeneratorX86Shared::generateOutOfLineCode() {
-  if (!CodeGeneratorShared::generateOutOfLineCode()) {
+  if (!CodeGeneratorShared::generateOutOfLineCode()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -706,7 +706,7 @@ void CodeGenerator::visitPowHalfD(LPowHa
     masm.loadConstantDouble(NegativeInfinity<double>(), scratch);
 
     Assembler::DoubleCondition cond = Assembler::DoubleNotEqualOrUnordered;
-    if (ins->mir()->operandIsNeverNaN()) {
+    if (ins->mir()->operandIsNeverNaN()) {MOZ_RELEASE_ASSERT(0);
       cond = Assembler::DoubleNotEqual;
     }
     masm.branchDouble(cond, input, scratch, &sqrt);
@@ -1009,7 +1009,7 @@ void CodeGenerator::visitUDivOrMod(LUDiv
         ool = new (alloc()) ReturnZero(output);
         masm.j(Assembler::Zero, ool->entry());
       }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       bailoutIf(Assembler::Zero, ins->snapshot());
     }
   }
@@ -1019,7 +1019,7 @@ void CodeGenerator::visitUDivOrMod(LUDiv
   masm.udiv(rhs);
 
   // If the remainder is > 0, bailout since this must be a double.
-  if (ins->mir()->isDiv() && !ins->mir()->toDiv()->canTruncateRemainder()) {
+  if (ins->mir()->isDiv() && !ins->mir()->toDiv()->canTruncateRemainder()) {MOZ_RELEASE_ASSERT(0);
     Register remainder = ToRegister(ins->remainder());
     masm.test32(remainder, remainder);
     bailoutIf(Assembler::NonZero, ins->snapshot());
@@ -1052,10 +1052,10 @@ void CodeGenerator::visitUDivOrModConsta
     if (ins->mir()->isTruncated()) {
       if (ins->trapOnError()) {
         masm.wasmTrap(wasm::Trap::IntegerDivideByZero, ins->bytecodeOffset());
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         masm.xorl(output, output);
       }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       bailout(ins->snapshot());
     }
     return;
@@ -1187,7 +1187,7 @@ void CodeGenerator::visitDivPowTwoI(LDiv
       }
       masm.sarl(Imm32(shift), lhs);
 
-      if (negativeDivisor) {
+      if (negativeDivisor) {MOZ_RELEASE_ASSERT(0);
         masm.negl(lhs);
       }
     }
@@ -1277,7 +1277,7 @@ void CodeGenerator::visitDivOrModConstan
 
       // If lhs is zero and the divisor is negative, the answer should have
       // been -0.
-      if (d < 0) {
+      if (d < 0) {MOZ_RELEASE_ASSERT(0);
         masm.test32(lhs, lhs);
         bailoutIf(Assembler::Zero, ins->snapshot());
       }
@@ -1751,7 +1751,7 @@ void CodeGenerator::visitUrshD(LUrshD* i
 
   if (rhs->isConstant()) {
     int32_t shift = ToInt32(rhs) & 0x1F;
-    if (shift) {
+    if (shift) {MOZ_RELEASE_ASSERT(0);
       masm.shrl(Imm32(shift), lhs);
     }
   } else {
@@ -2045,7 +2045,7 @@ void CodeGenerator::visitAtomicTypedArra
 
   Scalar::Type arrayType = lir->mir()->arrayType();
 
-  if (lir->index()->isConstant()) {
+  if (lir->index()->isConstant()) {MOZ_RELEASE_ASSERT(0);
     Address mem = ToAddress(elements, lir->index(), arrayType);
     AtomicBinopToTypedArray(masm, lir->mir()->operation(), arrayType, value,
                             mem, temp1, temp2, output);
@@ -2113,7 +2113,7 @@ void CodeGeneratorX86Shared::visitOutOfL
       masm.oolWasmTruncateCheckF32ToI32(input, output, flags, off, oolRejoin);
     } else if (toType == MIRType::Int64) {
       masm.oolWasmTruncateCheckF32ToI64(input, output64, flags, off, oolRejoin);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       MOZ_CRASH("unexpected type");
     }
   } else if (fromType == MIRType::Double) {
@@ -2121,7 +2121,7 @@ void CodeGeneratorX86Shared::visitOutOfL
       masm.oolWasmTruncateCheckF64ToI32(input, output, flags, off, oolRejoin);
     } else if (toType == MIRType::Int64) {
       masm.oolWasmTruncateCheckF64ToI64(input, output64, flags, off, oolRejoin);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       MOZ_CRASH("unexpected type");
     }
   } else {
@@ -2913,7 +2913,7 @@ void CodeGenerator::visitWasmConstantShi
   int32_t shift = ins->shift();
 
   if (shift == 0) {
-    if (src != dest) {
+    if (src != dest) {MOZ_RELEASE_ASSERT(0);
       masm.moveSimd128(src, dest);
     }
     return;
diff --git a/js/src/jit/x86-shared/Lowering-x86-shared.cpp b/js/src/jit/x86-shared/Lowering-x86-shared.cpp
--- a/js/src/jit/x86-shared/Lowering-x86-shared.cpp
+++ b/js/src/jit/x86-shared/Lowering-x86-shared.cpp
@@ -315,7 +315,7 @@ void LIRGenerator::visitAsmJSLoadHeap(MA
   define(lir, ins);
 }
 
-void LIRGenerator::visitAsmJSStoreHeap(MAsmJSStoreHeap* ins) {
+void LIRGenerator::visitAsmJSStoreHeap(MAsmJSStoreHeap* ins) {MOZ_RELEASE_ASSERT(0);
   MDefinition* base = ins->base();
   MOZ_ASSERT(base->type() == MIRType::Int32);
 
@@ -380,14 +380,14 @@ void LIRGeneratorX86Shared::lowerUDiv(MD
     LAllocation lhs = useRegisterAtStart(div->lhs());
     if (rhs != 0 && uint32_t(1) << shift == rhs) {
       LDivPowTwoI* lir = new (alloc()) LDivPowTwoI(lhs, lhs, shift, false);
-      if (div->fallible()) {
+      if (div->fallible()) {MOZ_RELEASE_ASSERT(0);
         assignSnapshot(lir, div->bailoutKind());
       }
       defineReuseInput(lir, div, 0);
     } else {
       LUDivOrModConstant* lir = new (alloc())
           LUDivOrModConstant(useRegister(div->lhs()), rhs, tempFixed(eax));
-      if (div->fallible()) {
+      if (div->fallible()) {MOZ_RELEASE_ASSERT(0);
         assignSnapshot(lir, div->bailoutKind());
       }
       defineFixed(lir, div, LAllocation(AnyRegister(edx)));
@@ -563,12 +563,12 @@ void LIRGeneratorX86Shared::lowerCompare
   bool fixedOutput = false;
   LDefinition tempDef = LDefinition::BogusTemp();
   LAllocation newval;
-  if (ins->arrayType() == Scalar::Uint32 && IsFloatingPointType(ins->type())) {
+  if (ins->arrayType() == Scalar::Uint32 && IsFloatingPointType(ins->type())) {MOZ_RELEASE_ASSERT(0);
     tempDef = tempFixed(eax);
     newval = useRegister(ins->newval());
   } else {
     fixedOutput = true;
-    if (useI386ByteRegisters && ins->isByteArray()) {
+    if (useI386ByteRegisters && ins->isByteArray()) {MOZ_RELEASE_ASSERT(0);
       newval = useFixed(ins->newval(), ebx);
     } else {
       newval = useRegister(ins->newval());
@@ -611,7 +611,7 @@ void LIRGeneratorX86Shared::lowerAtomicE
   // an appropriate register and use that as a temp in the back-end.
 
   LDefinition tempDef = LDefinition::BogusTemp();
-  if (ins->arrayType() == Scalar::Uint32) {
+  if (ins->arrayType() == Scalar::Uint32) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(ins->type() == MIRType::Double);
     tempDef = temp();
   }
@@ -619,7 +619,7 @@ void LIRGeneratorX86Shared::lowerAtomicE
   LAtomicExchangeTypedArrayElement* lir = new (alloc())
       LAtomicExchangeTypedArrayElement(elements, index, value, tempDef);
 
-  if (useI386ByteRegisters && ins->isByteArray()) {
+  if (useI386ByteRegisters && ins->isByteArray()) {MOZ_RELEASE_ASSERT(0);
     defineFixed(lir, ins, LAllocation(AnyRegister(eax)));
   } else {
     define(lir, ins);
@@ -647,7 +647,7 @@ void LIRGeneratorX86Shared::lowerAtomicT
   if (ins->isForEffect()) {
     LAllocation value;
     if (useI386ByteRegisters && ins->isByteArray() &&
-        !ins->value()->isConstant()) {
+        !ins->value()->isConstant()) {MOZ_RELEASE_ASSERT(0);
       value = useFixed(ins->value(), ebx);
     } else {
       value = useRegisterOrConstant(ins->value());
@@ -705,19 +705,19 @@ void LIRGeneratorX86Shared::lowerAtomicT
   if (ins->arrayType() == Scalar::Uint32 && IsFloatingPointType(ins->type())) {
     value = useRegisterOrConstant(ins->value());
     fixedOutput = false;
-    if (bitOp) {
+    if (bitOp) {MOZ_RELEASE_ASSERT(0);
       tempDef1 = tempFixed(eax);
       tempDef2 = temp();
     } else {
       tempDef1 = temp();
     }
   } else if (useI386ByteRegisters && ins->isByteArray()) {
-    if (ins->value()->isConstant()) {
+    if (ins->value()->isConstant()) {MOZ_RELEASE_ASSERT(0);
       value = useRegisterOrConstant(ins->value());
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       value = useFixed(ins->value(), ebx);
     }
-    if (bitOp) {
+    if (bitOp) {MOZ_RELEASE_ASSERT(0);
       tempDef1 = tempFixed(ecx);
     }
   } else if (bitOp) {
@@ -1387,7 +1387,7 @@ bool LIRGeneratorX86Shared::canFoldReduc
 
 bool LIRGeneratorX86Shared::canEmitWasmReduceSimd128AtUses(
     MWasmReduceSimd128* ins) {
-  if (!ins->canEmitAtUses()) {
+  if (!ins->canEmitAtUses()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   // Only specific ops generating int32.
@@ -1399,7 +1399,7 @@ bool LIRGeneratorX86Shared::canEmitWasmR
   }
   // If never used then defer (it will be removed).
   MUseIterator iter(ins->usesBegin());
-  if (iter == ins->usesEnd()) {
+  if (iter == ins->usesEnd()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
   // We require an MTest consumer.
diff --git a/js/src/jit/x86-shared/MacroAssembler-x86-shared-SIMD-unused.cpp b/js/src/jit/x86-shared/MacroAssembler-x86-shared-SIMD-unused.cpp
--- a/js/src/jit/x86-shared/MacroAssembler-x86-shared-SIMD-unused.cpp
+++ b/js/src/jit/x86-shared/MacroAssembler-x86-shared-SIMD-unused.cpp
@@ -164,10 +164,10 @@ void MacroAssemblerX86Shared::createFloa
 void MacroAssemblerX86Shared::reinterpretSimd(bool isIntegerLaneType,
                                               FloatRegister input,
                                               FloatRegister output) {
-  if (input.aliases(output)) {
+  if (input.aliases(output)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
-  if (isIntegerLaneType) {
+  if (isIntegerLaneType) {MOZ_RELEASE_ASSERT(0);
     vmovdqa(input, output);
   } else {
     vmovaps(input, output);
@@ -225,13 +225,13 @@ void MacroAssemblerX86Shared::oldSwizzle
                                                 FloatRegister output,
                                                 const Maybe<Register>& temp,
                                                 int8_t lanes[16]) {
-  if (AssemblerX86Shared::HasSSSE3()) {
+  if (AssemblerX86Shared::HasSSSE3()) {MOZ_RELEASE_ASSERT(0);
     ScratchSimd128Scope scratch(asMasm());
     asMasm().loadConstantSimd128Int(SimdConstant::CreateX16(lanes), scratch);
     FloatRegister inputCopy = reusedInputInt32x4(input, output);
     vpshufb(scratch, inputCopy, output);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Worst-case fallback for pre-SSSE3 machines. Bounce through memory.
   MOZ_ASSERT(!!temp, "needs a temp for the memory fallback");
@@ -253,36 +253,36 @@ static inline bool LanesMatch(unsigned l
 void MacroAssemblerX86Shared::swizzleFloat32x4(FloatRegister input,
                                                FloatRegister output,
                                                unsigned lanes[4]) {
-  if (AssemblerX86Shared::HasSSE3()) {
-    if (LanesMatch(lanes, 0, 0, 2, 2)) {
+  if (AssemblerX86Shared::HasSSE3()) {MOZ_RELEASE_ASSERT(0);
+    if (LanesMatch(lanes, 0, 0, 2, 2)) {MOZ_RELEASE_ASSERT(0);
       vmovsldup(input, output);
       return;
     }
-    if (LanesMatch(lanes, 1, 1, 3, 3)) {
+    if (LanesMatch(lanes, 1, 1, 3, 3)) {MOZ_RELEASE_ASSERT(0);
       vmovshdup(input, output);
       return;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   // TODO Here and below, arch specific lowering could identify this pattern
   // and use defineReuseInput to avoid this move (bug 1084404)
-  if (LanesMatch(lanes, 2, 3, 2, 3)) {
+  if (LanesMatch(lanes, 2, 3, 2, 3)) {MOZ_RELEASE_ASSERT(0);
     FloatRegister inputCopy = reusedInputSimd128Float(input, output);
     vmovhlps(input, inputCopy, output);
     return;
   }
 
-  if (LanesMatch(lanes, 0, 1, 0, 1)) {
-    if (AssemblerX86Shared::HasSSE3() && !AssemblerX86Shared::HasAVX()) {
+  if (LanesMatch(lanes, 0, 1, 0, 1)) {MOZ_RELEASE_ASSERT(0);
+    if (AssemblerX86Shared::HasSSE3() && !AssemblerX86Shared::HasAVX()) {MOZ_RELEASE_ASSERT(0);
       vmovddup(Operand(input), output);
       return;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     FloatRegister inputCopy = reusedInputSimd128Float(input, output);
     vmovlhps(input, inputCopy, output);
     return;
   }
 
-  if (LanesMatch(lanes, 0, 0, 1, 1)) {
+  if (LanesMatch(lanes, 0, 0, 1, 1)) {MOZ_RELEASE_ASSERT(0);
     FloatRegister inputCopy = reusedInputSimd128Float(input, output);
     vunpcklps(input, inputCopy, output);
     return;
@@ -306,7 +306,7 @@ void MacroAssemblerX86Shared::swizzleFlo
 void MacroAssemblerX86Shared::shuffleX4(FloatRegister lhs, Operand rhs,
                                         FloatRegister out,
                                         const Maybe<FloatRegister>& maybeTemp,
-                                        unsigned lanes[4]) {
+                                        unsigned lanes[4]) {MOZ_RELEASE_ASSERT(0);
   uint32_t x = lanes[0];
   uint32_t y = lanes[1];
   uint32_t z = lanes[2];
@@ -331,166 +331,166 @@ void MacroAssemblerX86Shared::shuffleX4(
   MOZ_ASSERT(numLanesFromLHS < 4);
 
   // If all values stay in their lane, this is a blend.
-  if (AssemblerX86Shared::HasSSE41()) {
-    if (x % 4 == 0 && y % 4 == 1 && z % 4 == 2 && w % 4 == 3) {
+  if (AssemblerX86Shared::HasSSE41()) {MOZ_RELEASE_ASSERT(0);
+    if (x % 4 == 0 && y % 4 == 1 && z % 4 == 2 && w % 4 == 3) {MOZ_RELEASE_ASSERT(0);
       vblendps(blendpsMask(x >= 4, y >= 4, z >= 4, w >= 4), rhs, lhs, out);
       return;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   // One element of the second, all other elements of the first
-  if (numLanesFromLHS == 3) {
+  if (numLanesFromLHS == 3) {MOZ_RELEASE_ASSERT(0);
     unsigned firstMask = -1, secondMask = -1;
 
     // register-register vmovss preserves the high lanes.
-    if (LanesMatch(lanes, 4, 1, 2, 3) && rhs.kind() == Operand::FPREG) {
+    if (LanesMatch(lanes, 4, 1, 2, 3) && rhs.kind() == Operand::FPREG) {MOZ_RELEASE_ASSERT(0);
       vmovss(FloatRegister::FromCode(rhs.fpu()), lhs, out);
       return;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // SSE4.1 vinsertps can handle any single element.
     unsigned numLanesUnchanged = (x == 0) + (y == 1) + (z == 2) + (w == 3);
-    if (AssemblerX86Shared::HasSSE41() && numLanesUnchanged == 3) {
+    if (AssemblerX86Shared::HasSSE41() && numLanesUnchanged == 3) {MOZ_RELEASE_ASSERT(0);
       unsigned srcLane;
       unsigned dstLane;
-      if (x >= 4) {
+      if (x >= 4) {MOZ_RELEASE_ASSERT(0);
         srcLane = x - 4;
         dstLane = 0;
-      } else if (y >= 4) {
+      } else if (y >= 4) {MOZ_RELEASE_ASSERT(0);
         srcLane = y - 4;
         dstLane = 1;
-      } else if (z >= 4) {
+      } else if (z >= 4) {MOZ_RELEASE_ASSERT(0);
         srcLane = z - 4;
         dstLane = 2;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         MOZ_ASSERT(w >= 4);
         srcLane = w - 4;
         dstLane = 3;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       vinsertps(vinsertpsMask(srcLane, dstLane), rhs, lhs, out);
       return;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     MOZ_ASSERT(!!maybeTemp);
     FloatRegister rhsCopy = *maybeTemp;
     loadAlignedSimd128Float(rhs, rhsCopy);
 
-    if (x < 4 && y < 4) {
-      if (w >= 4) {
+    if (x < 4 && y < 4) {MOZ_RELEASE_ASSERT(0);
+      if (w >= 4) {MOZ_RELEASE_ASSERT(0);
         w %= 4;
         // T = (Rw Rw Lz Lz) = vshufps(firstMask, lhs, rhs, rhsCopy)
         firstMask = MacroAssembler::ComputeShuffleMask(w, w, z, z);
         // (Lx Ly Lz Rw) = (Lx Ly Tz Tx) = vshufps(secondMask, T, lhs, out)
         secondMask = MacroAssembler::ComputeShuffleMask(x, y, 2, 0);
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         MOZ_ASSERT(z >= 4);
         z %= 4;
         // T = (Rz Rz Lw Lw) = vshufps(firstMask, lhs, rhs, rhsCopy)
         firstMask = MacroAssembler::ComputeShuffleMask(z, z, w, w);
         // (Lx Ly Rz Lw) = (Lx Ly Tx Tz) = vshufps(secondMask, T, lhs, out)
         secondMask = MacroAssembler::ComputeShuffleMask(x, y, 0, 2);
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       vshufps(firstMask, lhs, rhsCopy, rhsCopy);
       vshufps(secondMask, rhsCopy, lhs, out);
       return;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     MOZ_ASSERT(z < 4 && w < 4);
 
-    if (y >= 4) {
+    if (y >= 4) {MOZ_RELEASE_ASSERT(0);
       y %= 4;
       // T = (Ry Ry Lx Lx) = vshufps(firstMask, lhs, rhs, rhsCopy)
       firstMask = MacroAssembler::ComputeShuffleMask(y, y, x, x);
       // (Lx Ry Lz Lw) = (Tz Tx Lz Lw) = vshufps(secondMask, lhs, T, out)
       secondMask = MacroAssembler::ComputeShuffleMask(2, 0, z, w);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(x >= 4);
       x %= 4;
       // T = (Rx Rx Ly Ly) = vshufps(firstMask, lhs, rhs, rhsCopy)
       firstMask = MacroAssembler::ComputeShuffleMask(x, x, y, y);
       // (Rx Ly Lz Lw) = (Tx Tz Lz Lw) = vshufps(secondMask, lhs, T, out)
       secondMask = MacroAssembler::ComputeShuffleMask(0, 2, z, w);
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     vshufps(firstMask, lhs, rhsCopy, rhsCopy);
-    if (AssemblerX86Shared::HasAVX()) {
+    if (AssemblerX86Shared::HasAVX()) {MOZ_RELEASE_ASSERT(0);
       vshufps(secondMask, lhs, rhsCopy, out);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       vshufps(secondMask, lhs, rhsCopy, rhsCopy);
       moveSimd128Float(rhsCopy, out);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Two elements from one vector, two other elements from the other
   MOZ_ASSERT(numLanesFromLHS == 2);
 
   // TODO Here and below, symmetric case would be more handy to avoid a move,
   // but can't be reached because operands would get swapped (bug 1084404).
-  if (LanesMatch(lanes, 2, 3, 6, 7)) {
+  if (LanesMatch(lanes, 2, 3, 6, 7)) {MOZ_RELEASE_ASSERT(0);
     ScratchSimd128Scope scratch(asMasm());
-    if (AssemblerX86Shared::HasAVX()) {
+    if (AssemblerX86Shared::HasAVX()) {MOZ_RELEASE_ASSERT(0);
       FloatRegister rhsCopy = reusedInputAlignedSimd128Float(rhs, scratch);
       vmovhlps(lhs, rhsCopy, out);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       loadAlignedSimd128Float(rhs, scratch);
       vmovhlps(lhs, scratch, scratch);
       moveSimd128Float(scratch, out);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return;
   }
 
-  if (LanesMatch(lanes, 0, 1, 4, 5)) {
+  if (LanesMatch(lanes, 0, 1, 4, 5)) {MOZ_RELEASE_ASSERT(0);
     FloatRegister rhsCopy;
     ScratchSimd128Scope scratch(asMasm());
-    if (rhs.kind() == Operand::FPREG) {
+    if (rhs.kind() == Operand::FPREG) {MOZ_RELEASE_ASSERT(0);
       // No need to make an actual copy, since the operand is already
       // in a register, and it won't be clobbered by the vmovlhps.
       rhsCopy = FloatRegister::FromCode(rhs.fpu());
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       loadAlignedSimd128Float(rhs, scratch);
       rhsCopy = scratch;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     vmovlhps(rhsCopy, lhs, out);
     return;
   }
 
-  if (LanesMatch(lanes, 0, 4, 1, 5)) {
+  if (LanesMatch(lanes, 0, 4, 1, 5)) {MOZ_RELEASE_ASSERT(0);
     vunpcklps(rhs, lhs, out);
     return;
   }
 
   // TODO swapped case would be better (bug 1084404)
-  if (LanesMatch(lanes, 4, 0, 5, 1)) {
+  if (LanesMatch(lanes, 4, 0, 5, 1)) {MOZ_RELEASE_ASSERT(0);
     ScratchSimd128Scope scratch(asMasm());
-    if (AssemblerX86Shared::HasAVX()) {
+    if (AssemblerX86Shared::HasAVX()) {MOZ_RELEASE_ASSERT(0);
       FloatRegister rhsCopy = reusedInputAlignedSimd128Float(rhs, scratch);
       vunpcklps(lhs, rhsCopy, out);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       loadAlignedSimd128Float(rhs, scratch);
       vunpcklps(lhs, scratch, scratch);
       moveSimd128Float(scratch, out);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return;
   }
 
-  if (LanesMatch(lanes, 2, 6, 3, 7)) {
+  if (LanesMatch(lanes, 2, 6, 3, 7)) {MOZ_RELEASE_ASSERT(0);
     vunpckhps(rhs, lhs, out);
     return;
   }
 
   // TODO swapped case would be better (bug 1084404)
-  if (LanesMatch(lanes, 6, 2, 7, 3)) {
+  if (LanesMatch(lanes, 6, 2, 7, 3)) {MOZ_RELEASE_ASSERT(0);
     ScratchSimd128Scope scratch(asMasm());
-    if (AssemblerX86Shared::HasAVX()) {
+    if (AssemblerX86Shared::HasAVX()) {MOZ_RELEASE_ASSERT(0);
       FloatRegister rhsCopy = reusedInputAlignedSimd128Float(rhs, scratch);
       vunpckhps(lhs, rhsCopy, out);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       loadAlignedSimd128Float(rhs, scratch);
       vunpckhps(lhs, scratch, scratch);
       moveSimd128Float(scratch, out);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -536,7 +536,7 @@ void MacroAssemblerX86Shared::shuffleX4(
 
 void MacroAssemblerX86Shared::minNumFloat32x4(FloatRegister lhs, Operand rhs,
                                               FloatRegister temp,
-                                              FloatRegister output) {
+                                              FloatRegister output) {MOZ_RELEASE_ASSERT(0);
   ScratchSimd128Scope scratch(asMasm());
   asMasm().loadConstantSimd128Int(SimdConstant::SplatX4(int32_t(0x80000000)),
                                   temp);
@@ -550,14 +550,14 @@ void MacroAssemblerX86Shared::minNumFloa
   vminps(rhs, lhsCopy, temp);
   vorps(mask, temp, temp);
 
-  if (AssemblerX86Shared::HasAVX()) {
+  if (AssemblerX86Shared::HasAVX()) {MOZ_RELEASE_ASSERT(0);
     MOZ_CRASH("Can do better by avoiding the movaps");
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     vmovaps(rhs, mask);
     vcmpneqps(rhs, mask);
   }
 
-  if (AssemblerX86Shared::HasAVX()) {
+  if (AssemblerX86Shared::HasAVX()) {MOZ_RELEASE_ASSERT(0);
     vblendvps(mask, lhs, temp, output);
   } else {
     // Emulate vblendvps.
@@ -574,7 +574,7 @@ void MacroAssemblerX86Shared::minNumFloa
 
 void MacroAssemblerX86Shared::maxNumFloat32x4(FloatRegister lhs, Operand rhs,
                                               FloatRegister temp,
-                                              FloatRegister output) {
+                                              FloatRegister output) {MOZ_RELEASE_ASSERT(0);
   ScratchSimd128Scope scratch(asMasm());
   FloatRegister mask = scratch;
 
@@ -593,14 +593,14 @@ void MacroAssemblerX86Shared::maxNumFloa
   mask = temp;
   temp = scratch;
 
-  if (AssemblerX86Shared::HasAVX()) {
+  if (AssemblerX86Shared::HasAVX()) {MOZ_RELEASE_ASSERT(0);
     MOZ_CRASH("Can do better by avoiding the movaps");
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     vmovaps(rhs, mask);
     vcmpneqps(rhs, mask);
   }
 
-  if (AssemblerX86Shared::HasAVX()) {
+  if (AssemblerX86Shared::HasAVX()) {MOZ_RELEASE_ASSERT(0);
     vblendvps(mask, lhs, temp, output);
   } else {
     // Emulate vblendvps.
diff --git a/js/src/jit/x86-shared/MacroAssembler-x86-shared-SIMD.cpp b/js/src/jit/x86-shared/MacroAssembler-x86-shared-SIMD.cpp
--- a/js/src/jit/x86-shared/MacroAssembler-x86-shared-SIMD.cpp
+++ b/js/src/jit/x86-shared/MacroAssembler-x86-shared-SIMD.cpp
@@ -106,7 +106,7 @@ void MacroAssemblerX86Shared::extractLan
                                                  SimdSign sign) {
   vpextrb(lane, input, Operand(output));
   if (sign == SimdSign::Signed) {
-    if (!AllocatableGeneralRegisterSet(Registers::SingleByteRegs).has(output)) {
+    if (!AllocatableGeneralRegisterSet(Registers::SingleByteRegs).has(output)) {MOZ_RELEASE_ASSERT(0);
       xchgl(eax, output);
       movsbl(eax, eax);
       xchgl(eax, output);
@@ -766,7 +766,7 @@ void MacroAssemblerX86Shared::compareFor
 void MacroAssemblerX86Shared::compareFloat32x4(FloatRegister lhs, Operand rhs,
                                                Assembler::Condition cond,
                                                FloatRegister output) {
-  if (HasAVX()) {
+  if (HasAVX()) {MOZ_RELEASE_ASSERT(0);
     MOZ_CRASH("Can do better here with three-address compares");
   }
 
@@ -833,7 +833,7 @@ void MacroAssemblerX86Shared::compareFlo
 void MacroAssemblerX86Shared::compareFloat64x2(FloatRegister lhs, Operand rhs,
                                                Assembler::Condition cond,
                                                FloatRegister output) {
-  if (HasAVX()) {
+  if (HasAVX()) {MOZ_RELEASE_ASSERT(0);
     MOZ_CRASH("Can do better here with three-address compares");
   }
 
diff --git a/js/src/jit/x86-shared/MacroAssembler-x86-shared.cpp b/js/src/jit/x86-shared/MacroAssembler-x86-shared.cpp
--- a/js/src/jit/x86-shared/MacroAssembler-x86-shared.cpp
+++ b/js/src/jit/x86-shared/MacroAssembler-x86-shared.cpp
@@ -133,7 +133,7 @@ T* MacroAssemblerX86Shared::getConstant(
   } else {
     index = vec.length();
     enoughMemory_ &= vec.append(T(value));
-    if (!enoughMemory_) {
+    if (!enoughMemory_) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     enoughMemory_ &= map.add(p, value, index);
@@ -182,9 +182,9 @@ void MacroAssemblerX86Shared::binarySimd
 }
 
 void MacroAssemblerX86Shared::bitwiseTestSimd128(const SimdConstant& rhs,
-                                                 FloatRegister lhs) {
+                                                 FloatRegister lhs) {MOZ_RELEASE_ASSERT(0);
   ScratchSimd128Scope scratch(asMasm());
-  if (maybeInlineSimd128Int(rhs, scratch)) {
+  if (maybeInlineSimd128Int(rhs, scratch)) {MOZ_RELEASE_ASSERT(0);
     vptest(scratch, lhs);
   } else {
     asMasm().vptestSimd128(rhs, lhs);
@@ -354,12 +354,12 @@ void MacroAssembler::flexibleDivMod32(Re
 
   // Shuffle input into place.
   moveRegPair(lhsOutput, rhs, eax, regForRhs);
-  if (oom()) {
+  if (oom()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
   // Sign extend eax into edx to make (edx:eax): idiv/udiv are 64-bit.
-  if (isUnsigned) {
+  if (isUnsigned) {MOZ_RELEASE_ASSERT(0);
     mov(ImmWord(0), edx);
     udiv(regForRhs);
   } else {
@@ -473,7 +473,7 @@ void MacroAssembler::storeRegsInMask(Liv
       storeDouble(reg, dest);
     } else if (reg.isSingle()) {
       storeFloat32(reg, dest);
-    } else if (reg.isSimd128()) {
+    } else if (reg.isSimd128()) {MOZ_RELEASE_ASSERT(0);
       storeUnalignedSimd128(reg, dest);
     } else {
       MOZ_CRASH("Unknown register type.");
@@ -510,7 +510,7 @@ void MacroAssembler::PopRegsInMaskIgnore
       loadFloat32(spillAddress, reg);
     } else if (reg.isSimd128()) {
       loadUnalignedSimd128(spillAddress, reg);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       MOZ_CRASH("Unknown register type.");
     }
   }
@@ -1444,7 +1444,7 @@ static void CompareExchangeJS(MacroAssem
                               const Synchronization& sync, const T& mem,
                               Register oldval, Register newval, Register temp,
                               AnyRegister output) {
-  if (arrayType == Scalar::Uint32) {
+  if (arrayType == Scalar::Uint32) {MOZ_RELEASE_ASSERT(0);
     masm.compareExchange(arrayType, sync, mem, oldval, newval, temp);
     masm.convertUInt32ToDouble(temp, output.fpu());
   } else {
@@ -1473,7 +1473,7 @@ static void AtomicExchangeJS(MacroAssemb
                              const Synchronization& sync, const T& mem,
                              Register value, Register temp,
                              AnyRegister output) {
-  if (arrayType == Scalar::Uint32) {
+  if (arrayType == Scalar::Uint32) {MOZ_RELEASE_ASSERT(0);
     masm.atomicExchange(arrayType, sync, mem, value, temp);
     masm.convertUInt32ToDouble(temp, output.fpu());
   } else {
@@ -1500,7 +1500,7 @@ static void AtomicFetchOpJS(MacroAssembl
                             const Synchronization& sync, AtomicOp op,
                             Register value, const T& mem, Register temp1,
                             Register temp2, AnyRegister output) {
-  if (arrayType == Scalar::Uint32) {
+  if (arrayType == Scalar::Uint32) {MOZ_RELEASE_ASSERT(0);
     masm.atomicFetchOp(arrayType, sync, op, value, mem, temp2, temp1);
     masm.convertUInt32ToDouble(temp1, output.fpu());
   } else {
@@ -1597,25 +1597,25 @@ void MacroAssembler::speculationBarrier(
 
 void MacroAssembler::floorFloat32ToInt32(FloatRegister src, Register dest,
                                          Label* fail) {
-  if (HasSSE41()) {
+  if (HasSSE41()) {MOZ_RELEASE_ASSERT(0);
     // Fail on negative-zero.
     branchNegativeZeroFloat32(src, dest, fail);
 
     // Round toward -Infinity.
-    {
+    {MOZ_RELEASE_ASSERT(0);
       ScratchFloat32Scope scratch(*this);
       vroundss(X86Encoding::RoundDown, src, scratch);
       truncateFloat32ToInt32(scratch, dest, fail);
     }
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     Label negative, end;
 
     // Branch to a slow path for negative inputs. Doesn't catch NaN or -0.
-    {
+    {MOZ_RELEASE_ASSERT(0);
       ScratchFloat32Scope scratch(*this);
       zeroFloat32(scratch);
       branchFloat(Assembler::DoubleLessThan, src, scratch, &negative);
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Fail on negative-zero.
     branchNegativeZeroFloat32(src, dest, fail);
@@ -1628,7 +1628,7 @@ void MacroAssembler::floorFloat32ToInt32
     // Negative values go on a comparatively expensive path, since no
     // native rounding mode matches JS semantics. Still better than callVM.
     bind(&negative);
-    {
+    {MOZ_RELEASE_ASSERT(0);
       // Truncate and round toward zero.
       // This is off-by-one for everything but integer-valued inputs.
       truncateFloat32ToInt32(src, dest, fail);
@@ -1706,7 +1706,7 @@ void MacroAssembler::floorDoubleToInt32(
 }
 
 void MacroAssembler::ceilFloat32ToInt32(FloatRegister src, Register dest,
-                                        Label* fail) {
+                                        Label* fail) {MOZ_RELEASE_ASSERT(0);
   ScratchFloat32Scope scratch(*this);
 
   Label lessThanOrEqualMinusOne;
@@ -1817,7 +1817,7 @@ void MacroAssembler::truncDoubleToInt32(
 }
 
 void MacroAssembler::truncFloat32ToInt32(FloatRegister src, Register dest,
-                                         Label* fail) {
+                                         Label* fail) {MOZ_RELEASE_ASSERT(0);
   Label lessThanOrEqualMinusOne;
 
   // Bail on ]-1; -0] range
@@ -1838,7 +1838,7 @@ void MacroAssembler::truncFloat32ToInt32
 }
 
 void MacroAssembler::roundFloat32ToInt32(FloatRegister src, Register dest,
-                                         FloatRegister temp, Label* fail) {
+                                         FloatRegister temp, Label* fail) {MOZ_RELEASE_ASSERT(0);
   ScratchFloat32Scope scratch(*this);
 
   Label negativeOrZero, negative, end;
@@ -1847,7 +1847,7 @@ void MacroAssembler::roundFloat32ToInt32
   zeroFloat32(scratch);
   loadConstantFloat32(GetBiggestNumberLessThan(0.5f), temp);
   branchFloat(Assembler::DoubleLessThanOrEqual, src, scratch, &negativeOrZero);
-  {
+  {MOZ_RELEASE_ASSERT(0);
     // Input is non-negative. Add the biggest float less than 0.5 and truncate,
     // rounding down (because if the input is the biggest float less than 0.5,
     // adding 0.5 would undesirably round up to 1). Note that we have to add the
@@ -1856,11 +1856,11 @@ void MacroAssembler::roundFloat32ToInt32
     addFloat32(src, temp);
     truncateFloat32ToInt32(temp, dest, fail);
     jump(&end);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Input is negative, +0 or -0.
   bind(&negativeOrZero);
-  {
+  {MOZ_RELEASE_ASSERT(0);
     // Branch on negative input.
     j(Assembler::NotEqual, &negative);
 
@@ -1870,11 +1870,11 @@ void MacroAssembler::roundFloat32ToInt32
     // Input is +0.
     xor32(dest, dest);
     jump(&end);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Input is negative.
   bind(&negative);
-  {
+  {MOZ_RELEASE_ASSERT(0);
     // Inputs in ]-0.5; 0] need to be added 0.5, other negative inputs need to
     // be added the biggest double less than 0.5.
     Label loadJoin;
@@ -1883,7 +1883,7 @@ void MacroAssembler::roundFloat32ToInt32
     loadConstantFloat32(0.5f, temp);
     bind(&loadJoin);
 
-    if (HasSSE41()) {
+    if (HasSSE41()) {MOZ_RELEASE_ASSERT(0);
       // Add 0.5 and round toward -Infinity. The result is stored in the temp
       // register (currently contains 0.5).
       addFloat32(src, temp);
@@ -1896,7 +1896,7 @@ void MacroAssembler::roundFloat32ToInt32
       // Otherwise, the truncation will have produced the correct negative
       // integer.
       branchTest32(Assembler::Zero, dest, dest, fail);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       addFloat32(src, temp);
       // Round toward -Infinity without the benefit of ROUNDSS.
       {
diff --git a/js/src/jit/x86-shared/MoveEmitter-x86-shared.cpp b/js/src/jit/x86-shared/MoveEmitter-x86-shared.cpp
--- a/js/src/jit/x86-shared/MoveEmitter-x86-shared.cpp
+++ b/js/src/jit/x86-shared/MoveEmitter-x86-shared.cpp
@@ -215,7 +215,7 @@ Operand MoveEmitterX86::toOperand(const 
 // use in a pop.
 Operand MoveEmitterX86::toPopOperand(const MoveOperand& operand) const {
   if (operand.isMemory()) {
-    if (operand.base() != StackPointer) {
+    if (operand.base() != StackPointer) {MOZ_RELEASE_ASSERT(0);
       return Operand(operand.base(), operand.disp());
     }
 
@@ -394,7 +394,7 @@ void MoveEmitterX86::emitGeneralMove(con
     if (reg.isSome()) {
       masm.loadPtr(toAddress(from), reg.value());
       masm.mov(reg.value(), toOperand(to));
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       // No scratch register available; bounce it off the stack.
       masm.Push(toOperand(from));
       masm.Pop(toPopOperand(to));
diff --git a/js/src/jsapi-tests/testAtomizeUtf8NonAsciiLatin1CodePoint.cpp b/js/src/jsapi-tests/testAtomizeUtf8NonAsciiLatin1CodePoint.cpp
--- a/js/src/jsapi-tests/testAtomizeUtf8NonAsciiLatin1CodePoint.cpp
+++ b/js/src/jsapi-tests/testAtomizeUtf8NonAsciiLatin1CodePoint.cpp
@@ -36,12 +36,12 @@ BEGIN_TEST(testAtomizeTwoByteUTF8) {
         if (IsAscii(char16_t(j))) {
           // If both units are ASCII, the sequence encodes a two-code point
           // string.
-          if (!shouldBeTwoCodePoints(i, j, &atom16, &atom8)) {
+          if (!shouldBeTwoCodePoints(i, j, &atom16, &atom8)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         } else {
           // ASCII followed by non-ASCII should be invalid.
-          if (!shouldBeInvalid(i, j)) {
+          if (!shouldBeInvalid(i, j)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -55,7 +55,7 @@ BEGIN_TEST(testAtomizeTwoByteUTF8) {
       for (uint16_t j = 0; j <= UINT8_MAX; j++) {
         // If the first unit isn't a two-byte lead, the sequence is invalid no
         // matter what the second unit is.
-        if (!shouldBeInvalid(i, j)) {
+        if (!shouldBeInvalid(i, j)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -68,11 +68,11 @@ BEGIN_TEST(testAtomizeTwoByteUTF8) {
     if (i >= 0b1100'0100) {
       for (uint16_t j = 0; j <= UINT8_MAX; j++) {
         if (IsTrailingUnit(Utf8Unit(static_cast<uint8_t>(j)))) {
-          if (!shouldBeSingleNonLatin1(i, j, &atom16, &atom8)) {
+          if (!shouldBeSingleNonLatin1(i, j, &atom16, &atom8)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         } else {
-          if (!shouldBeInvalid(i, j)) {
+          if (!shouldBeInvalid(i, j)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -85,7 +85,7 @@ BEGIN_TEST(testAtomizeTwoByteUTF8) {
     // overlong ASCII code point.
     if (i < 0b1100'0010) {
       for (uint16_t j = 0; j <= UINT8_MAX; j++) {
-        if (!shouldBeInvalid(i, j)) {
+        if (!shouldBeInvalid(i, j)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -97,7 +97,7 @@ BEGIN_TEST(testAtomizeTwoByteUTF8) {
     // of a Latin-1 code point.
     for (uint16_t j = 0; j <= UINT8_MAX; j++) {
       if (IsTrailingUnit(Utf8Unit(static_cast<uint8_t>(j)))) {
-        if (!shouldBeSingleLatin1(i, j, &atom16, &atom8)) {
+        if (!shouldBeSingleLatin1(i, j, &atom16, &atom8)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
diff --git a/js/src/jsapi-tests/testCallArgs.cpp b/js/src/jsapi-tests/testCallArgs.cpp
--- a/js/src/jsapi-tests/testCallArgs.cpp
+++ b/js/src/jsapi-tests/testCallArgs.cpp
@@ -51,7 +51,7 @@ static bool CustomConstructor(JSContext*
 
   if (args.isConstructing()) {
     JSObject* obj = JS_NewPlainObject(cx);
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
diff --git a/js/src/jsapi-tests/testDefinePropertyIgnoredAttributes.cpp b/js/src/jsapi-tests/testDefinePropertyIgnoredAttributes.cpp
--- a/js/src/jsapi-tests/testDefinePropertyIgnoredAttributes.cpp
+++ b/js/src/jsapi-tests/testDefinePropertyIgnoredAttributes.cpp
@@ -18,17 +18,17 @@ enum PropertyDescriptorKind { DataDescri
 static bool CheckDescriptor(JS::Handle<JS::PropertyDescriptor> desc,
                             PropertyDescriptorKind kind, bool enumerable,
                             bool writable, bool configurable) {
-  if (!desc.object()) {
+  if (!desc.object()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!(kind == DataDescriptor ? desc.isDataDescriptor()
-                               : desc.isAccessorDescriptor())) {
+                               : desc.isAccessorDescriptor())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (desc.enumerable() != enumerable) {
+  if (desc.enumerable() != enumerable) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (kind == DataDescriptor && desc.writable() != writable) {
+  if (kind == DataDescriptor && desc.writable() != writable) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (desc.configurable() != configurable) {
diff --git a/js/src/jsapi-tests/testErrorInterceptor.cpp b/js/src/jsapi-tests/testErrorInterceptor.cpp
--- a/js/src/jsapi-tests/testErrorInterceptor.cpp
+++ b/js/src/jsapi-tests/testErrorInterceptor.cpp
@@ -66,7 +66,7 @@ BEGIN_TEST(testErrorInterceptor) {
   CHECK(gLatestMessage == nullptr);
 
   for (auto sample : SAMPLES) {
-    if (execDontReport(sample, __FILE__, __LINE__)) {
+    if (execDontReport(sample, __FILE__, __LINE__)) {MOZ_RELEASE_ASSERT(0);
       MOZ_CRASH("This sample should have failed");
     }
     CHECK(JS_IsExceptionPending(cx));
@@ -89,7 +89,7 @@ BEGIN_TEST(testErrorInterceptor) {
   // Test error throwing with a callback that succeeds.
   for (size_t i = 0; i < std::size(SAMPLES); ++i) {
     // This should cause the appropriate error.
-    if (execDontReport(SAMPLES[i], __FILE__, __LINE__)) {
+    if (execDontReport(SAMPLES[i], __FILE__, __LINE__)) {MOZ_RELEASE_ASSERT(0);
       MOZ_CRASH("This sample should have failed");
     }
     CHECK(JS_IsExceptionPending(cx));
diff --git a/js/src/jsapi-tests/testGCAllocator.cpp b/js/src/jsapi-tests/testGCAllocator.cpp
--- a/js/src/jsapi-tests/testGCAllocator.cpp
+++ b/js/src/jsapi-tests/testGCAllocator.cpp
@@ -28,7 +28,7 @@ BEGIN_TEST(testGCAllocator) {
   // If we're using the scattershot allocator, this test does not apply.
   if (js::gc::UsingScattershotAllocator()) {
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 #endif
 
   size_t PageSize = js::gc::SystemPageSize();
@@ -39,7 +39,7 @@ BEGIN_TEST(testGCAllocator) {
   bool growUp = false;
   CHECK(addressesGrowUp(&growUp));
 
-  if (growUp) {
+  if (growUp) {MOZ_RELEASE_ASSERT(0);
     return testGCAllocatorUp(PageSize);
   } else {
     return testGCAllocatorDown(PageSize);
@@ -51,7 +51,7 @@ static const size_t Alignment = 2 * Chun
 static const int MaxTempChunks = 4096;
 static const size_t StagingSize = 16 * Chunk;
 
-bool addressesGrowUp(bool* resultOut) {
+bool addressesGrowUp(bool* resultOut) {MOZ_RELEASE_ASSERT(0);
   /*
    * Try to detect whether the OS allocates memory in increasing or decreasing
    * address order by making several allocations and comparing the addresses.
@@ -61,20 +61,20 @@ bool addressesGrowUp(bool* resultOut) {
   static const int ThresholdCount = 15;
 
   void* chunks[ChunksToTest];
-  for (unsigned i = 0; i < ChunksToTest; i++) {
+  for (unsigned i = 0; i < ChunksToTest; i++) {MOZ_RELEASE_ASSERT(0);
     chunks[i] = mapMemory(2 * Chunk);
     CHECK(chunks[i]);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   int upCount = 0;
   int downCount = 0;
 
-  for (unsigned i = 0; i < ChunksToTest - 1; i++) {
-    if (chunks[i] < chunks[i + 1]) {
+  for (unsigned i = 0; i < ChunksToTest - 1; i++) {MOZ_RELEASE_ASSERT(0);
+    if (chunks[i] < chunks[i + 1]) {MOZ_RELEASE_ASSERT(0);
       upCount++;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       downCount++;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   for (unsigned i = 0; i < ChunksToTest; i++) {
@@ -93,27 +93,27 @@ size_t offsetFromAligned(void* p) { retu
 
 enum AllocType { UseNormalAllocator, UseLastDitchAllocator };
 
-bool testGCAllocatorUp(const size_t PageSize) {
+bool testGCAllocatorUp(const size_t PageSize) {MOZ_RELEASE_ASSERT(0);
   const size_t UnalignedSize = StagingSize + Alignment - PageSize;
   void* chunkPool[MaxTempChunks];
   // Allocate a contiguous chunk that we can partition for testing.
   void* stagingArea = mapMemory(UnalignedSize);
-  if (!stagingArea) {
+  if (!stagingArea) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   // Ensure that the staging area is aligned.
   unmapPages(stagingArea, UnalignedSize);
-  if (offsetFromAligned(stagingArea)) {
+  if (offsetFromAligned(stagingArea)) {MOZ_RELEASE_ASSERT(0);
     const size_t Offset = offsetFromAligned(stagingArea);
     // Place the area at the lowest aligned address.
     stagingArea = (void*)(uintptr_t(stagingArea) + (Alignment - Offset));
-  }
+  }MOZ_RELEASE_ASSERT(0);
   mapMemoryAt(stagingArea, StagingSize);
   // Make sure there are no available chunks below the staging area.
   int tempChunks;
-  if (!fillSpaceBeforeStagingArea(tempChunks, stagingArea, chunkPool, false)) {
+  if (!fillSpaceBeforeStagingArea(tempChunks, stagingArea, chunkPool, false)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   // Unmap the staging area so we can set it up for testing.
   unmapPages(stagingArea, StagingSize);
   // Check that the first chunk is used if it is aligned.
@@ -145,28 +145,28 @@ bool testGCAllocatorUp(const size_t Page
   return true;
 }
 
-bool testGCAllocatorDown(const size_t PageSize) {
+bool testGCAllocatorDown(const size_t PageSize) {MOZ_RELEASE_ASSERT(0);
   const size_t UnalignedSize = StagingSize + Alignment - PageSize;
   void* chunkPool[MaxTempChunks];
   // Allocate a contiguous chunk that we can partition for testing.
   void* stagingArea = mapMemory(UnalignedSize);
-  if (!stagingArea) {
+  if (!stagingArea) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   // Ensure that the staging area is aligned.
   unmapPages(stagingArea, UnalignedSize);
-  if (offsetFromAligned(stagingArea)) {
+  if (offsetFromAligned(stagingArea)) {MOZ_RELEASE_ASSERT(0);
     void* stagingEnd = (void*)(uintptr_t(stagingArea) + UnalignedSize);
     const size_t Offset = offsetFromAligned(stagingEnd);
     // Place the area at the highest aligned address.
     stagingArea = (void*)(uintptr_t(stagingEnd) - Offset - StagingSize);
-  }
+  }MOZ_RELEASE_ASSERT(0);
   mapMemoryAt(stagingArea, StagingSize);
   // Make sure there are no available chunks above the staging area.
   int tempChunks;
-  if (!fillSpaceBeforeStagingArea(tempChunks, stagingArea, chunkPool, true)) {
+  if (!fillSpaceBeforeStagingArea(tempChunks, stagingArea, chunkPool, true)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   // Unmap the staging area so we can set it up for testing.
   unmapPages(stagingArea, StagingSize);
   // Check that the first chunk is used if it is aligned.
@@ -199,31 +199,31 @@ bool testGCAllocatorDown(const size_t Pa
 }
 
 bool fillSpaceBeforeStagingArea(int& tempChunks, void* stagingArea,
-                                void** chunkPool, bool addressesGrowDown) {
+                                void** chunkPool, bool addressesGrowDown) {MOZ_RELEASE_ASSERT(0);
   // Make sure there are no available chunks before the staging area.
   tempChunks = 0;
   chunkPool[tempChunks++] = mapMemory(2 * Chunk);
   while (tempChunks < MaxTempChunks && chunkPool[tempChunks - 1] &&
-         (chunkPool[tempChunks - 1] < stagingArea) ^ addressesGrowDown) {
+         (chunkPool[tempChunks - 1] < stagingArea) ^ addressesGrowDown) {MOZ_RELEASE_ASSERT(0);
     chunkPool[tempChunks++] = mapMemory(2 * Chunk);
-    if (!chunkPool[tempChunks - 1]) {
+    if (!chunkPool[tempChunks - 1]) {MOZ_RELEASE_ASSERT(0);
       break;  // We already have our staging area, so OOM here is okay.
-    }
+    }MOZ_RELEASE_ASSERT(0);
     if ((chunkPool[tempChunks - 1] < chunkPool[tempChunks - 2]) ^
-        addressesGrowDown) {
+        addressesGrowDown) {MOZ_RELEASE_ASSERT(0);
       break;  // The address growth direction is inconsistent!
     }
   }
   // OOM also means success in this case.
-  if (!chunkPool[tempChunks - 1]) {
+  if (!chunkPool[tempChunks - 1]) {MOZ_RELEASE_ASSERT(0);
     --tempChunks;
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   // Bail if we can't guarantee the right address space layout.
   if ((chunkPool[tempChunks - 1] < stagingArea) ^ addressesGrowDown ||
       (tempChunks > 1 &&
        (chunkPool[tempChunks - 1] < chunkPool[tempChunks - 2]) ^
-           addressesGrowDown)) {
+           addressesGrowDown)) {MOZ_RELEASE_ASSERT(0);
     while (--tempChunks >= 0) {
       unmapPages(chunkPool[tempChunks], 2 * Chunk);
     }
@@ -235,7 +235,7 @@ bool fillSpaceBeforeStagingArea(int& tem
 
 bool positionIsCorrect(const char* str, void* base, void** chunkPool,
                        int tempChunks,
-                       AllocType allocator = UseNormalAllocator) {
+                       AllocType allocator = UseNormalAllocator) {MOZ_RELEASE_ASSERT(0);
   // str represents a region of memory, with each character representing a
   // region of Chunk bytes. str should contain only x, o and -, where
   // x = mapped by the test to set up the initial conditions,
@@ -250,29 +250,29 @@ bool positionIsCorrect(const char* str, 
     ;
   void* desired = (void*)(uintptr_t(base) + i * Chunk);
   // Map the regions indicated by str.
-  for (i = 0; i < len; ++i) {
-    if (str[i] == 'x') {
+  for (i = 0; i < len; ++i) {MOZ_RELEASE_ASSERT(0);
+    if (str[i] == 'x') {MOZ_RELEASE_ASSERT(0);
       mapMemoryAt((void*)(uintptr_t(base) + i * Chunk), Chunk);
-    }
-  }
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
   // Allocate using the GC's allocator.
   void* result;
-  if (allocator == UseNormalAllocator) {
+  if (allocator == UseNormalAllocator) {MOZ_RELEASE_ASSERT(0);
     result = js::gc::MapAlignedPages(2 * Chunk, Alignment);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     result = js::gc::TestMapAlignedPagesLastDitch(2 * Chunk, Alignment);
   }
   // Clean up the mapped regions.
-  if (result) {
+  if (result) {MOZ_RELEASE_ASSERT(0);
     js::gc::UnmapPages(result, 2 * Chunk);
   }
-  for (--i; i >= 0; --i) {
-    if (str[i] == 'x') {
+  for (--i; i >= 0; --i) {MOZ_RELEASE_ASSERT(0);
+    if (str[i] == 'x') {MOZ_RELEASE_ASSERT(0);
       js::gc::UnmapPages((void*)(uintptr_t(base) + i * Chunk), Chunk);
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
   // CHECK returns, so clean up on failure.
-  if (result != desired) {
+  if (result != desired) {MOZ_RELEASE_ASSERT(0);
     while (--tempChunks >= 0) {
       js::gc::UnmapPages(chunkPool[tempChunks], 2 * Chunk);
     }
@@ -298,13 +298,13 @@ void unmapPages(void* p, size_t size) {
 
 #else
 
-void* mapMemoryAt(void* desired, size_t length) {
+void* mapMemoryAt(void* desired, size_t length) {MOZ_RELEASE_ASSERT(0);
   void* region = mmap(desired, length, PROT_READ | PROT_WRITE,
                       MAP_PRIVATE | MAP_ANON, -1, 0);
-  if (region == MAP_FAILED) {
+  if (region == MAP_FAILED) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
-  if (region != desired) {
+  if (region != desired) {MOZ_RELEASE_ASSERT(0);
     if (munmap(region, length)) {
       MOZ_RELEASE_ASSERT(errno == ENOMEM);
     }
@@ -313,7 +313,7 @@ void* mapMemoryAt(void* desired, size_t 
   return region;
 }
 
-void* mapMemory(size_t length) {
+void* mapMemory(size_t length) {MOZ_RELEASE_ASSERT(0);
   int prot = PROT_READ | PROT_WRITE;
   int flags = MAP_PRIVATE | MAP_ANON;
   int fd = -1;
@@ -325,7 +325,7 @@ void* mapMemory(size_t length) {
   return region;
 }
 
-void unmapPages(void* p, size_t size) {
+void unmapPages(void* p, size_t size) {MOZ_RELEASE_ASSERT(0);
   if (munmap(p, size)) {
     MOZ_RELEASE_ASSERT(errno == ENOMEM);
   }
diff --git a/js/src/jsapi-tests/testGCExactRooting.cpp b/js/src/jsapi-tests/testGCExactRooting.cpp
--- a/js/src/jsapi-tests/testGCExactRooting.cpp
+++ b/js/src/jsapi-tests/testGCExactRooting.cpp
@@ -217,7 +217,7 @@ static bool FillMyHashMap(JSContext* cx,
     char buffer[2];
     buffer[0] = 'a' + i;
     buffer[1] = '\0';
-    if (!JS_SetProperty(cx, obj, buffer, val)) {
+    if (!JS_SetProperty(cx, obj, buffer, val)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!map.putNew(obj->as<NativeObject>().lastProperty(), obj)) {
@@ -368,10 +368,10 @@ static bool FillVector(JSContext* cx, Mu
     char buffer[2];
     buffer[0] = 'a' + i;
     buffer[1] = '\0';
-    if (!JS_SetProperty(cx, obj, buffer, val)) {
+    if (!JS_SetProperty(cx, obj, buffer, val)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!shapes.append(obj->as<NativeObject>().lastProperty())) {
+    if (!shapes.append(obj->as<NativeObject>().lastProperty())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -392,10 +392,10 @@ static bool CheckVector(JSContext* cx, H
     char letter = 'a' + i;
     bool match;
     if (!JS_StringEqualsAscii(cx, JSID_TO_STRING(shapes[i]->propid()), &letter,
-                              1, &match)) {
+                              1, &match)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!match) {
+    if (!match) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
diff --git a/js/src/jsapi-tests/testGCGrayMarking.cpp b/js/src/jsapi-tests/testGCGrayMarking.cpp
--- a/js/src/jsapi-tests/testGCGrayMarking.cpp
+++ b/js/src/jsapi-tests/testGCGrayMarking.cpp
@@ -677,7 +677,7 @@ JSObject* AllocPlainObject() {
 
 JSObject* AllocSameCompartmentSourceObject(JSObject* target) {
   JS::RootedObject source(cx, JS_NewPlainObject(cx));
-  if (!source) {
+  if (!source) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -726,7 +726,7 @@ JSObject* AllocObjectChain(size_t length
   // objects.
   RootedString nextPropName(cx, JS_NewStringCopyZ(cx, "unique14142135"));
   RootedId nextId(cx);
-  if (!JS_StringToId(cx, nextPropName, &nextId)) {
+  if (!JS_StringToId(cx, nextPropName, &nextId)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -734,7 +734,7 @@ JSObject* AllocObjectChain(size_t length
   for (size_t i = 0; i < length; i++) {
     RootedValue next(cx, ObjectOrNullValue(head));
     head = AllocPlainObject();
-    if (!head) {
+    if (!head) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (!JS_DefinePropertyById(cx, head, nextId, next, 0)) {
@@ -777,7 +777,7 @@ static bool IsMarkedGray(Cell* cell) {
 
 static bool CheckCellColor(Cell* cell, MarkColor color) {
   MOZ_ASSERT(color == MarkColor::Black || color == MarkColor::Gray);
-  if (color == MarkColor::Black && !IsMarkedBlack(cell)) {
+  if (color == MarkColor::Black && !IsMarkedBlack(cell)) {MOZ_RELEASE_ASSERT(0);
     printf("Found non-black cell: %p\n", cell);
     return false;
   } else if (color == MarkColor::Gray && !IsMarkedGray(cell)) {
diff --git a/js/src/jsapi-tests/testGCMarking.cpp b/js/src/jsapi-tests/testGCMarking.cpp
--- a/js/src/jsapi-tests/testGCMarking.cpp
+++ b/js/src/jsapi-tests/testGCMarking.cpp
@@ -19,7 +19,7 @@ static bool ConstructCCW(JSContext* cx, 
                          JS::MutableHandleObject wrapper,
                          JS::MutableHandleObject global2,
                          JS::MutableHandleObject wrappee) {
-  if (!global1) {
+  if (!global1) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "null initial global");
     return false;
   }
@@ -28,19 +28,19 @@ static bool ConstructCCW(JSContext* cx, 
   JS::RealmOptions options;
   global2.set(JS_NewGlobalObject(cx, globalClasp, nullptr,
                                  JS::FireOnNewGlobalHook, options));
-  if (!global2) {
+  if (!global2) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "failed to create second global");
     return false;
   }
 
   // This should always be false, regardless.
-  if (global1->compartment() == global2->compartment()) {
+  if (global1->compartment() == global2->compartment()) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "second global claims to be in global1's compartment");
     return false;
   }
 
   // This checks that the API obeys the implicit zone request.
-  if (global1->zone() == global2->zone()) {
+  if (global1->zone() == global2->zone()) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "global2 is in global1's zone");
     return false;
   }
@@ -50,18 +50,18 @@ static bool ConstructCCW(JSContext* cx, 
   {
     JSAutoRealm ar(cx, global2);
     wrappee.set(JS_NewPlainObject(cx));
-    if (wrappee->compartment() != global2->compartment()) {
+    if (wrappee->compartment() != global2->compartment()) {MOZ_RELEASE_ASSERT(0);
       fprintf(stderr, "wrappee in wrong compartment");
       return false;
     }
   }
 
   wrapper.set(wrappee);
-  if (!JS_WrapObject(cx, wrapper)) {
+  if (!JS_WrapObject(cx, wrapper)) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "failed to wrap");
     return false;
   }
-  if (wrappee == wrapper) {
+  if (wrappee == wrapper) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "expected wrapping");
     return false;
   }
@@ -302,7 +302,7 @@ BEGIN_TEST(testIncrementalRoots) {
   // with leafOwner the object that has the 'obj' and 'leaf2' properties.
 
   JS::RootedObject obj(cx, JS_NewObject(cx, nullptr));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -313,10 +313,10 @@ BEGIN_TEST(testIncrementalRoots) {
 
   for (size_t i = 0; i < 3000; i++) {
     JS::RootedObject subobj(cx, JS_NewObject(cx, nullptr));
-    if (!subobj) {
+    if (!subobj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!JS_DefineProperty(cx, obj, "obj", subobj, 0)) {
+    if (!JS_DefineProperty(cx, obj, "obj", subobj, 0)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     leafOwner = obj;
@@ -327,17 +327,17 @@ BEGIN_TEST(testIncrementalRoots) {
   // Give the leaf owner a second leaf.
   {
     JS::RootedObject leaf2(cx, JS_NewObject(cx, nullptr));
-    if (!leaf2) {
+    if (!leaf2) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!JS_DefineProperty(cx, leafOwner, "leaf2", leaf2, 0)) {
+    if (!JS_DefineProperty(cx, leafOwner, "leaf2", leaf2, 0)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // This is marked during markRuntime
   JS::RootedObjectVector vec(cx);
-  if (!vec.append(root)) {
+  if (!vec.append(root)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -400,11 +400,11 @@ BEGIN_TEST(testIncrementalRoots) {
   // 'leaf' out of the graph and stick it into an already-marked region (hang
   // it off the un-prebarriered root, in fact). The pre-barrier on the
   // overwrite of the source location should cause this object to be marked.
-  if (!JS_SetProperty(cx, leafOwnerHandle, "obj", JS::UndefinedHandleValue)) {
+  if (!JS_SetProperty(cx, leafOwnerHandle, "obj", JS::UndefinedHandleValue)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(rt->gc.gcNumber() == currentGCNumber);
-  if (!JS_SetProperty(cx, vec[0], "newobj", leafValueHandle)) {
+  if (!JS_SetProperty(cx, vec[0], "newobj", leafValueHandle)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(rt->gc.gcNumber() == currentGCNumber);
@@ -421,12 +421,12 @@ BEGIN_TEST(testIncrementalRoots) {
   // pointers.
   {
     JS::RootedValue leaf2(cx);
-    if (!JS_GetProperty(cx, leafOwnerHandle, "leaf2", &leaf2)) {
+    if (!JS_GetProperty(cx, leafOwnerHandle, "leaf2", &leaf2)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     MOZ_ASSERT(rt->gc.gcNumber() == currentGCNumber);
     MOZ_ASSERT(!leaf2.toObject().asTenured().isMarkedBlack());
-    if (!JS_SetProperty(cx, vec[0], "leafcopy", leaf2)) {
+    if (!JS_SetProperty(cx, vec[0], "leafcopy", leaf2)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     MOZ_ASSERT(rt->gc.gcNumber() == currentGCNumber);
diff --git a/js/src/jsapi-tests/testHashTable.cpp b/js/src/jsapi-tests/testHashTable.cpp
--- a/js/src/jsapi-tests/testHashTable.cpp
+++ b/js/src/jsapi-tests/testHashTable.cpp
@@ -63,13 +63,13 @@ struct LowToHighWithRemoval {
 
 static bool MapsAreEqual(IntMap& am, IntMap& bm) {
   bool equal = true;
-  if (am.count() != bm.count()) {
+  if (am.count() != bm.count()) {MOZ_RELEASE_ASSERT(0);
     equal = false;
     fprintf(stderr, "A.count() == %u and B.count() == %u\n", am.count(),
             bm.count());
   }
   for (auto iter = am.iter(); !iter.done(); iter.next()) {
-    if (!bm.has(iter.get().key())) {
+    if (!bm.has(iter.get().key())) {MOZ_RELEASE_ASSERT(0);
       equal = false;
       fprintf(stderr, "B does not have %x which is in A\n", iter.get().key());
     }
@@ -85,13 +85,13 @@ static bool MapsAreEqual(IntMap& am, Int
 
 static bool SetsAreEqual(IntSet& am, IntSet& bm) {
   bool equal = true;
-  if (am.count() != bm.count()) {
+  if (am.count() != bm.count()) {MOZ_RELEASE_ASSERT(0);
     equal = false;
     fprintf(stderr, "A.count() == %u and B.count() == %u\n", am.count(),
             bm.count());
   }
   for (auto iter = am.iter(); !iter.done(); iter.next()) {
-    if (!bm.has(iter.get())) {
+    if (!bm.has(iter.get())) {MOZ_RELEASE_ASSERT(0);
       equal = false;
       fprintf(stderr, "B does not have %x which is in A\n", iter.get());
     }
@@ -111,7 +111,7 @@ static bool AddLowKeys(IntMap* am, IntMa
   while (i < TestSize) {
     uint32_t n = rand() & 0x0000FFFF;
     if (!am->has(n)) {
-      if (bm->has(n)) {
+      if (bm->has(n)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -130,7 +130,7 @@ static bool AddLowKeys(IntSet* as, IntSe
   while (i < TestSize) {
     uint32_t n = rand() & 0x0000FFFF;
     if (!as->has(n)) {
-      if (bs->has(n)) {
+      if (bs->has(n)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (!as->putNew(n) || !bs->putNew(n)) {
@@ -151,10 +151,10 @@ static bool SlowRekey(IntMap* m) {
       continue;
     }
     uint32_t hi = NewKeyFunction::rekey(iter.get().key());
-    if (tmp.has(hi)) {
+    if (tmp.has(hi)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!tmp.putNew(hi, iter.get().value())) {
+    if (!tmp.putNew(hi, iter.get().value())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -178,10 +178,10 @@ static bool SlowRekey(IntSet* s) {
       continue;
     }
     uint32_t hi = NewKeyFunction::rekey(iter.get());
-    if (tmp.has(hi)) {
+    if (tmp.has(hi)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!tmp.putNew(hi)) {
+    if (!tmp.putNew(hi)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
diff --git a/js/src/jsapi-tests/testJitDCEinGVN.cpp b/js/src/jsapi-tests/testJitDCEinGVN.cpp
--- a/js/src/jsapi-tests/testJitDCEinGVN.cpp
+++ b/js/src/jsapi-tests/testJitDCEinGVN.cpp
@@ -27,18 +27,18 @@ BEGIN_TEST(testJitDCEinGVN_ins) {
   block->add(p);
   MMul* mul0 = MMul::New(func.alloc, p, p, MIRType::Double);
   block->add(mul0);
-  if (!mul0->typePolicy()->adjustInputs(func.alloc, mul0)) {
+  if (!mul0->typePolicy()->adjustInputs(func.alloc, mul0)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MMul* mul1 = MMul::New(func.alloc, mul0, mul0, MIRType::Double);
   block->add(mul1);
-  if (!mul1->typePolicy()->adjustInputs(func.alloc, mul1)) {
+  if (!mul1->typePolicy()->adjustInputs(func.alloc, mul1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MReturn* ret = MReturn::New(func.alloc, p);
   block->end(ret);
 
-  if (!func.runGVN()) {
+  if (!func.runGVN()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -134,7 +134,7 @@ BEGIN_TEST(testJitDCEinGVN_phi) {
   MReturn* ret = MReturn::New(func.alloc, y);
   joinBlock->end(ret);
 
-  if (!func.runGVN()) {
+  if (!func.runGVN()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/jsapi-tests/testJitFoldsTo.cpp b/js/src/jsapi-tests/testJitFoldsTo.cpp
--- a/js/src/jsapi-tests/testJitFoldsTo.cpp
+++ b/js/src/jsapi-tests/testJitFoldsTo.cpp
@@ -27,7 +27,7 @@ BEGIN_TEST(testJitFoldsTo_DivReciprocal)
   block->add(c);
   MDiv* div = MDiv::New(func.alloc, p, c, MIRType::Double);
   block->add(div);
-  if (!div->typePolicy()->adjustInputs(func.alloc, div)) {
+  if (!div->typePolicy()->adjustInputs(func.alloc, div)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MDefinition* left = div->getOperand(0);
@@ -59,7 +59,7 @@ BEGIN_TEST(testJitFoldsTo_NoDivReciproca
   block->add(c);
   MDiv* div = MDiv::New(func.alloc, p, c, MIRType::Double);
   block->add(div);
-  if (!div->typePolicy()->adjustInputs(func.alloc, div)) {
+  if (!div->typePolicy()->adjustInputs(func.alloc, div)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MDefinition* left = div->getOperand(0);
diff --git a/js/src/jsapi-tests/testJitGVN.cpp b/js/src/jsapi-tests/testJitGVN.cpp
--- a/js/src/jsapi-tests/testJitGVN.cpp
+++ b/js/src/jsapi-tests/testJitGVN.cpp
@@ -77,7 +77,7 @@ BEGIN_TEST(testJitGVN_FixupOSROnlyLoop) 
   outerHeader->setLoopHeader(outerBackedge);
   innerHeader->setLoopHeader(innerBackedge);
 
-  if (!func.runGVN()) {
+  if (!func.runGVN()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -178,7 +178,7 @@ BEGIN_TEST(testJitGVN_FixupOSROnlyLoopNe
   middleHeader->setLoopHeader(middleBackedge);
   innerHeader->setLoopHeader(innerBackedge);
 
-  if (!func.runGVN()) {
+  if (!func.runGVN()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/jsapi-tests/testJitMacroAssembler.cpp b/js/src/jsapi-tests/testJitMacroAssembler.cpp
--- a/js/src/jsapi-tests/testJitMacroAssembler.cpp
+++ b/js/src/jsapi-tests/testJitMacroAssembler.cpp
@@ -271,7 +271,7 @@ BEGIN_TEST(testJitMacroAssembler_flexibl
           masm.flexibleRshift32(rhs, lhsOutput);
         },
         &lhsInput, &rhsInput, &result);
-    if (!res) {
+    if (!res) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -310,7 +310,7 @@ BEGIN_TEST(testJitMacroAssembler_flexibl
           masm.flexibleRshift32Arithmetic(rhs, lhsOutput);
         },
         &lhsInput, &rhsInput, &result);
-    if (!res) {
+    if (!res) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -350,7 +350,7 @@ BEGIN_TEST(testJitMacroAssembler_flexibl
           masm.flexibleLshift32(rhs, lhsOutput);
         },
         &lhsInput, &rhsInput, &result);
-    if (!res) {
+    if (!res) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
diff --git a/js/src/jsapi-tests/testJitRangeAnalysis.cpp b/js/src/jsapi-tests/testJitRangeAnalysis.cpp
--- a/js/src/jsapi-tests/testJitRangeAnalysis.cpp
+++ b/js/src/jsapi-tests/testJitRangeAnalysis.cpp
@@ -17,28 +17,28 @@ using namespace js;
 using namespace js::jit;
 
 static bool EquivalentRanges(const Range* a, const Range* b) {
-  if (a->hasInt32UpperBound() != b->hasInt32UpperBound()) {
+  if (a->hasInt32UpperBound() != b->hasInt32UpperBound()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (a->hasInt32LowerBound() != b->hasInt32LowerBound()) {
+  if (a->hasInt32LowerBound() != b->hasInt32LowerBound()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (a->hasInt32UpperBound() && (a->upper() != b->upper())) {
+  if (a->hasInt32UpperBound() && (a->upper() != b->upper())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (a->hasInt32LowerBound() && (a->lower() != b->lower())) {
+  if (a->hasInt32LowerBound() && (a->lower() != b->lower())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (a->canHaveFractionalPart() != b->canHaveFractionalPart()) {
+  if (a->canHaveFractionalPart() != b->canHaveFractionalPart()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (a->canBeNegativeZero() != b->canBeNegativeZero()) {
+  if (a->canBeNegativeZero() != b->canBeNegativeZero()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (a->canBeNaN() != b->canBeNaN()) {
+  if (a->canBeNaN() != b->canBeNaN()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (a->canBeInfiniteOrNaN() != b->canBeInfiniteOrNaN()) {
+  if (a->canBeInfiniteOrNaN() != b->canBeInfiniteOrNaN()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!a->canBeInfiniteOrNaN() && (a->exponent() != b->exponent())) {
@@ -280,7 +280,7 @@ BEGIN_TEST(testJitRangeAnalysis_StrictCo
        {MCompare::Compare_Object, MCompare::Compare_String}) {
     replaceCompare(compareType);
 
-    if (!func.runRangeAnalysis()) {
+    if (!func.runRangeAnalysis()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     CHECK(!thenAdd->range() || thenAdd->range()->isUnknown());
@@ -326,7 +326,7 @@ static bool checkShiftRightRange(int32_t
       Range* lhsRange = Range::NewInt32Range(func.alloc, lhsLower, lhsUpper);
       for (rhsLower = rhsLow; rhsLower <= rhsHigh; rhsLower += rhsInc) {
         for (rhsUpper = rhsLower; rhsUpper <= rhsHigh; rhsUpper += rhsInc) {
-          if (!func.alloc.ensureBallast()) {
+          if (!func.alloc.ensureBallast()) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
 
diff --git a/js/src/jsapi-tests/testLookup.cpp b/js/src/jsapi-tests/testLookup.cpp
--- a/js/src/jsapi-tests/testLookup.cpp
+++ b/js/src/jsapi-tests/testLookup.cpp
@@ -43,19 +43,19 @@ bool document_resolve(JSContext* cx, JS:
                       bool* resolvedp) {
   // If id is "all", resolve document.all=true.
   JS::RootedValue v(cx);
-  if (!JS_IdToValue(cx, id, &v)) {
+  if (!JS_IdToValue(cx, id, &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (v.isString()) {
     JSString* str = v.toString();
     JSLinearString* linearStr = JS_EnsureLinearString(cx, str);
-    if (!linearStr) {
+    if (!linearStr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (JS_LinearStringEqualsLiteral(linearStr, "all")) {
       JS::Rooted<JSObject*> docAll(cx, JS_NewObject(cx, &DocumentAllClass));
-      if (!docAll) {
+      if (!docAll) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
diff --git a/js/src/jsapi-tests/testNewObject.cpp b/js/src/jsapi-tests/testNewObject.cpp
--- a/js/src/jsapi-tests/testNewObject.cpp
+++ b/js/src/jsapi-tests/testNewObject.cpp
@@ -15,23 +15,23 @@ static bool constructHook(JSContext* cx,
   // Check that arguments were passed properly from JS_New.
 
   JS::RootedObject obj(cx, JS_NewPlainObject(cx));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "test failed, could not construct object");
     return false;
   }
-  if (strcmp(JS::GetClass(obj)->name, "Object") != 0) {
+  if (strcmp(JS::GetClass(obj)->name, "Object") != 0) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "test failed, wrong class for 'this'");
     return false;
   }
-  if (args.length() != 3) {
+  if (args.length() != 3) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "test failed, argc == %d", args.length());
     return false;
   }
-  if (!args[0].isInt32() || args[2].toInt32() != 2) {
+  if (!args[0].isInt32() || args[2].toInt32() != 2) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "test failed, wrong value in args[2]");
     return false;
   }
-  if (!args.isConstructing()) {
+  if (!args.isConstructing()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "test failed, not constructing");
     return false;
   }
diff --git a/js/src/jsapi-tests/testNumberToString.cpp b/js/src/jsapi-tests/testNumberToString.cpp
--- a/js/src/jsapi-tests/testNumberToString.cpp
+++ b/js/src/jsapi-tests/testNumberToString.cpp
@@ -65,26 +65,26 @@ struct StorageForNumberToString {
 BEGIN_TEST(testNumberToString) {
   StorageForNumberToString storage;
 
-  if (!testNormalValues(false, storage)) {
+  if (!testNormalValues(false, storage)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!testNormalValues(true, storage)) {
+  if (!testNormalValues(true, storage)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   NumberToStringTest zeroTest = {0.0, REST("0")};
-  if (!testOne(zeroTest, false, storage)) {
+  if (!testOne(zeroTest, false, storage)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   NumberToStringTest negativeZeroTest = {-0.0, REST("0")};
-  if (!testOne(negativeZeroTest, false, storage)) {
+  if (!testOne(negativeZeroTest, false, storage)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   NumberToStringTest infTest = {mozilla::PositiveInfinity<double>(),
                                 REST("Infinity")};
-  if (!testOne(infTest, false, storage)) {
+  if (!testOne(infTest, false, storage)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!testOne(infTest, true, storage)) {
diff --git a/js/src/jsapi-tests/testPreserveJitCode.cpp b/js/src/jsapi-tests/testPreserveJitCode.cpp
--- a/js/src/jsapi-tests/testPreserveJitCode.cpp
+++ b/js/src/jsapi-tests/testPreserveJitCode.cpp
@@ -44,7 +44,7 @@ bool testPreserveJitCode(bool preserveJi
 
   // The Ion JIT may be unavailable due to --disable-jit or lack of support
   // for this platform.
-  if (!js::jit::IsIonEnabled(cx)) {
+  if (!js::jit::IsIonEnabled(cx)) {MOZ_RELEASE_ASSERT(0);
     knownFail = true;
   }
 
diff --git a/js/src/jsapi-tests/testPrintError.cpp b/js/src/jsapi-tests/testPrintError.cpp
--- a/js/src/jsapi-tests/testPrintError.cpp
+++ b/js/src/jsapi-tests/testPrintError.cpp
@@ -30,7 +30,7 @@ class AutoStreamBuffer {
   FILE* stream() { return fp; }
 
   bool contains(const char* str) {
-    if (fflush(fp) != 0) {
+    if (fflush(fp) != 0) {MOZ_RELEASE_ASSERT(0);
       fprintf(stderr, "Error flushing stream\n");
       return false;
     }
diff --git a/js/src/jsapi-tests/testPromise.cpp b/js/src/jsapi-tests/testPromise.cpp
--- a/js/src/jsapi-tests/testPromise.cpp
+++ b/js/src/jsapi-tests/testPromise.cpp
@@ -113,13 +113,13 @@ static bool PromiseCatchHandler(JSContex
 
 BEGIN_TEST(testPromise_PromiseThen) {
   RootedObject promise(cx, CreatePromise(cx));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedFunction thenHandler(
       cx, JS_NewFunction(cx, PromiseThenHandler, 1, 0, "thenHandler"));
-  if (!thenHandler) {
+  if (!thenHandler) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedFunction catchHandler(
@@ -142,13 +142,13 @@ END_TEST(testPromise_PromiseThen)
 
 BEGIN_TEST(testPromise_PromiseCatch) {
   RootedObject promise(cx, CreatePromise(cx));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedFunction thenHandler(
       cx, JS_NewFunction(cx, PromiseThenHandler, 1, 0, "thenHandler"));
-  if (!thenHandler) {
+  if (!thenHandler) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedFunction catchHandler(
diff --git a/js/src/jsapi-tests/testReadableStream.cpp b/js/src/jsapi-tests/testReadableStream.cpp
--- a/js/src/jsapi-tests/testReadableStream.cpp
+++ b/js/src/jsapi-tests/testReadableStream.cpp
@@ -118,20 +118,20 @@ static bool GetIterResult(JSContext* cx,
   RootedObject iterResult(cx, &GetPromiseResult(promise).toObject());
 
   bool found;
-  if (!JS_HasProperty(cx, iterResult, "value", &found)) {
+  if (!JS_HasProperty(cx, iterResult, "value", &found)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_RELEASE_ASSERT(found);
-  if (!JS_HasProperty(cx, iterResult, "done", &found)) {
+  if (!JS_HasProperty(cx, iterResult, "done", &found)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_RELEASE_ASSERT(found);
 
   RootedValue doneVal(cx);
-  if (!JS_GetProperty(cx, iterResult, "value", value)) {
+  if (!JS_GetProperty(cx, iterResult, "value", value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!JS_GetProperty(cx, iterResult, "done", &doneVal)) {
+  if (!JS_GetProperty(cx, iterResult, "done", &doneVal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/jsapi-tests/testScriptSourceCompression.cpp b/js/src/jsapi-tests/testScriptSourceCompression.cpp
--- a/js/src/jsapi-tests/testScriptSourceCompression.cpp
+++ b/js/src/jsapi-tests/testScriptSourceCompression.cpp
@@ -74,13 +74,13 @@ static JSFunction* EvaluateChars(JSConte
   // Evaluate the provided source text, containing a function named
   // |functionName|.
   JS::SourceText<Unit> sourceText;
-  if (!sourceText.init(cx, std::move(chars), len)) {
+  if (!sourceText.init(cx, std::move(chars), len)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   {
     JS::Rooted<JS::Value> dummy(cx);
-    if (!JS::Evaluate(cx, options, sourceText, &dummy)) {
+    if (!JS::Evaluate(cx, options, sourceText, &dummy)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -89,7 +89,7 @@ static JSFunction* EvaluateChars(JSConte
   JS::Rooted<JS::Value> rval(cx);
   const char16_t name[] = {char16_t(functionName)};
   JS::SourceText<char16_t> srcbuf;
-  if (!srcbuf.init(cx, name, std::size(name), JS::SourceOwnership::Borrowed)) {
+  if (!srcbuf.init(cx, name, std::size(name), JS::SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (!JS::Evaluate(cx, options, srcbuf, &rval)) {
@@ -162,7 +162,7 @@ static bool IsExpectedFunctionString(JS:
   MOZ_RELEASE_ASSERT(lstr);
 
   size_t len = JS_GetStringLength(str);
-  if (len < FunctionStartLength || len < FunctionEndLength) {
+  if (len < FunctionStartLength || len < FunctionEndLength) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/jsapi-tests/testTypedArrays.cpp b/js/src/jsapi-tests/testTypedArrays.cpp
--- a/js/src/jsapi-tests/testTypedArrays.cpp
+++ b/js/src/jsapi-tests/testTypedArrays.cpp
@@ -151,7 +151,7 @@ template <
     bool Shared, Element* GetData(JSObject*, bool*, const JS::AutoRequireNoGC&)>
 bool TestArrayFromBuffer(JSContext* cx) {
   if (Shared &&
-      !cx->realm()->creationOptions().getSharedMemoryAndAtomicsEnabled()) {
+      !cx->realm()->creationOptions().getSharedMemoryAndAtomicsEnabled()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
diff --git a/js/src/jsapi-tests/testUbiNode.cpp b/js/src/jsapi-tests/testUbiNode.cpp
--- a/js/src/jsapi-tests/testUbiNode.cpp
+++ b/js/src/jsapi-tests/testUbiNode.cpp
@@ -184,7 +184,7 @@ static bool checkString(const char* expe
   char16_t buf[1024];
   if (fillBufferFunction(mozilla::RangedPtr<char16_t>(buf, 1024), 1024) !=
           expectedLength ||
-      !EqualChars(buf, expected, expectedLength)) {
+      !EqualChars(buf, expected, expectedLength)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/jsapi-tests/testWasmLEB128.cpp b/js/src/jsapi-tests/testWasmLEB128.cpp
--- a/js/src/jsapi-tests/testWasmLEB128.cpp
+++ b/js/src/jsapi-tests/testWasmLEB128.cpp
@@ -10,27 +10,27 @@
 
 static bool WriteValidBytes(js::wasm::Encoder& encoder, bool* passed) {
   *passed = false;
-  if (!encoder.empty()) {
+  if (!encoder.empty()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   // These remain the same under LEB128 unsigned encoding
   if (!encoder.writeVarU32(0x0) || !encoder.writeVarU32(0x1) ||
-      !encoder.writeVarU32(0x42)) {
+      !encoder.writeVarU32(0x42)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // 0x01 0x80
-  if (!encoder.writeVarU32(0x80)) {
+  if (!encoder.writeVarU32(0x80)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // 0x03 0x80
-  if (!encoder.writeVarU32(0x180)) {
+  if (!encoder.writeVarU32(0x180)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (encoder.empty()) {
+  if (encoder.empty()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
   if (encoder.currentOffset() != 7) {
@@ -48,7 +48,7 @@ BEGIN_TEST(testWasmLEB128_encoding) {
   Encoder encoder(bytes);
 
   bool passed;
-  if (!WriteValidBytes(encoder, &passed)) {
+  if (!WriteValidBytes(encoder, &passed)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   CHECK(passed);
@@ -76,15 +76,15 @@ BEGIN_TEST(testWasmLEB128_valid_decoding
   using namespace wasm;
 
   Bytes bytes;
-  if (!bytes.append(0x0) || !bytes.append(0x1) || !bytes.append(0x42)) {
+  if (!bytes.append(0x0) || !bytes.append(0x1) || !bytes.append(0x42)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!bytes.append(0x80) || !bytes.append(0x01)) {
+  if (!bytes.append(0x80) || !bytes.append(0x01)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!bytes.append(0x80) || !bytes.append(0x03)) {
+  if (!bytes.append(0x80) || !bytes.append(0x03)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -131,12 +131,12 @@ BEGIN_TEST(testWasmLEB128_invalid_decodi
   Bytes bytes;
   // Fill bits as per 28 encoded bits
   if (!bytes.append(0x80) || !bytes.append(0x80) || !bytes.append(0x80) ||
-      !bytes.append(0x80)) {
+      !bytes.append(0x80)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Test last valid values
-  if (!bytes.append(0x00)) {
+  if (!bytes.append(0x00)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/jsapi-tests/testWeakMap.cpp b/js/src/jsapi-tests/testWeakMap.cpp
--- a/js/src/jsapi-tests/testWeakMap.cpp
+++ b/js/src/jsapi-tests/testWeakMap.cpp
@@ -75,7 +75,7 @@ BEGIN_TEST(testWeakMap_keyDelegates) {
 
   JS::RootedObject delegate(cx, newDelegate());
   JS::RootedObject key(cx, delegate);
-  if (!JS_WrapObject(cx, &key)) {
+  if (!JS_WrapObject(cx, &key)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   CHECK(key);
@@ -154,7 +154,7 @@ BEGIN_TEST(testWeakMap_keyDelegates) {
   return true;
 }
 
-static size_t DelegateObjectMoved(JSObject* obj, JSObject* old) {
+static size_t DelegateObjectMoved(JSObject* obj, JSObject* old) {MOZ_RELEASE_ASSERT(0);
   if (!keyDelegate) {
     return 0;  // Object got moved before we set keyDelegate to point to it.
   }
@@ -188,7 +188,7 @@ JSObject* newCCW(JS::HandleObject source
   {
     JSAutoRealm ar(cx, destZone);
     object = JS_NewPlainObject(cx);
-    if (!object) {
+    if (!object) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
diff --git a/js/src/jsapi-tests/testXDR.cpp b/js/src/jsapi-tests/testXDR.cpp
--- a/js/src/jsapi-tests/testXDR.cpp
+++ b/js/src/jsapi-tests/testXDR.cpp
@@ -31,7 +31,7 @@ static JSScript* FreezeThaw(JSContext* c
   // freeze
   JS::TranscodeBuffer buffer;
   JS::TranscodeResult rs = JS::EncodeScript(cx, buffer, script);
-  if (rs != JS::TranscodeResult::Ok) {
+  if (rs != JS::TranscodeResult::Ok) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/jsapi-tests/tests.cpp b/js/src/jsapi-tests/tests.cpp
--- a/js/src/jsapi-tests/tests.cpp
+++ b/js/src/jsapi-tests/tests.cpp
@@ -28,14 +28,14 @@ bool JSAPITest::init(JSContext* maybeReu
   MaybeFreeContext(maybeReusableContext);
 
   cx = createContext();
-  if (!cx) {
+  if (!cx) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   js::UseInternalJobQueues(cx);
   JS::SetLargeArrayBuffersEnabled(true);
 
-  if (!JS::InitSelfHostedCode(cx)) {
+  if (!JS::InitSelfHostedCode(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   global.init(cx);
@@ -133,15 +133,15 @@ int main(int argc, char* argv[]) {
   int failures = 0;
   const char* filter = (argc == 2) ? argv[1] : nullptr;
 
-  if (!JS_Init()) {
+  if (!JS_Init()) {MOZ_RELEASE_ASSERT(0);
     printf("TEST-UNEXPECTED-FAIL | jsapi-tests | JS_Init() failed.\n");
     return 1;
   }
 
   if (filter && strcmp(filter, "--list") == 0) {
-    for (JSAPITest* test = JSAPITest::list; test; test = test->next) {
+    for (JSAPITest* test = JSAPITest::list; test; test = test->next) {MOZ_RELEASE_ASSERT(0);
       printf("%s\n", test->name());
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return 0;
   }
 
@@ -151,14 +151,14 @@ int main(int argc, char* argv[]) {
   JSContext* maybeReusedContext = nullptr;
   for (JSAPITest* test = JSAPITest::list; test; test = test->next) {
     const char* name = test->name();
-    if (filter && strstr(name, filter) == nullptr) {
+    if (filter && strstr(name, filter) == nullptr) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
     total += 1;
 
     printf("%s\n", name);
-    if (!test->init(maybeReusedContext)) {
+    if (!test->init(maybeReusedContext)) {MOZ_RELEASE_ASSERT(0);
       printf("TEST-UNEXPECTED-FAIL | %s | Failed to initialize.\n", name);
       failures++;
       test->uninit();
@@ -167,14 +167,14 @@ int main(int argc, char* argv[]) {
 
     if (test->run(test->global)) {
       printf("TEST-PASS | %s | ok\n", name);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       JSAPITestString messages = test->messages();
       printf("%s | %s | %.*s\n",
              (test->knownFail ? "TEST-KNOWN-FAIL" : "TEST-UNEXPECTED-FAIL"),
              name, (int)messages.length(), messages.begin());
-      if (!test->knownFail) {
+      if (!test->knownFail) {MOZ_RELEASE_ASSERT(0);
         failures++;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
     // Return a non-nullptr pointer if the context & global can safely be
diff --git a/js/src/jsapi-tests/testsJit.cpp b/js/src/jsapi-tests/testsJit.cpp
--- a/js/src/jsapi-tests/testsJit.cpp
+++ b/js/src/jsapi-tests/testsJit.cpp
@@ -57,13 +57,13 @@ bool ExecuteJit(JSContext* cx, js::jit::
   masm.abiret();
 #endif
 
-  if (masm.oom()) {
+  if (masm.oom()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Linker linker(masm);
   JitCode* code = linker.newCode(cx, CodeKind::Other);
-  if (!code) {
+  if (!code) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!ExecutableAllocator::makeExecutableAndFlushICache(
diff --git a/js/src/jsapi.cpp b/js/src/jsapi.cpp
--- a/js/src/jsapi.cpp
+++ b/js/src/jsapi.cpp
@@ -182,7 +182,7 @@ bool JS::ObjectOpResult::reportError(JSC
   MOZ_ASSERT(!ok());
   cx->check(obj);
 
-  if (code_ == JSMSG_OBJECT_NOT_EXTENSIBLE) {
+  if (code_ == JSMSG_OBJECT_NOT_EXTENSIBLE) {MOZ_RELEASE_ASSERT(0);
     RootedValue val(cx, ObjectValue(*obj));
     return ReportValueError(cx, code_, JSDVG_IGNORE_STACK, val, nullptr);
   }
@@ -190,7 +190,7 @@ bool JS::ObjectOpResult::reportError(JSC
   if (ErrorTakesArguments(code_)) {
     UniqueChars propName =
         IdToPrintableUTF8(cx, id, IdToPrintableBehavior::IdIsPropertyKey);
-    if (!propName) {
+    if (!propName) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -198,7 +198,7 @@ bool JS::ObjectOpResult::reportError(JSC
       // We know that the original receiver was a primitive, so unbox it.
       RootedValue val(cx, ObjectValue(*obj));
       if (!obj->is<ProxyObject>()) {
-        if (!Unbox(cx, obj, &val)) {
+        if (!Unbox(cx, obj, &val)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -489,21 +489,21 @@ JS_PUBLIC_API bool JS::InitSelfHostedCod
 
   JSRuntime* rt = cx->runtime();
 
-  if (!rt->initializeAtoms(cx)) {
+  if (!rt->initializeAtoms(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!rt->initializeParserAtoms(cx)) {
+  if (!rt->initializeParserAtoms(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
 #ifndef JS_CODEGEN_NONE
-  if (!rt->createJitRuntime(cx)) {
+  if (!rt->createJitRuntime(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 #endif
 
-  if (!rt->initSelfHosting(cx)) {
+  if (!rt->initSelfHosting(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -785,7 +785,7 @@ JS_PUBLIC_API JSObject* JS_TransplantObj
   // even if origobj is in the same compartment as target and thus
   // `newIdentity == origobj`, because this process also clears out any
   // cached wrapper state.
-  if (!RemapAllWrappersForObject(cx, origobj, newIdentity)) {
+  if (!RemapAllWrappersForObject(cx, origobj, newIdentity)) {MOZ_RELEASE_ASSERT(0);
     oomUnsafe.crash("JS_TransplantObject");
   }
 
@@ -793,7 +793,7 @@ JS_PUBLIC_API JSObject* JS_TransplantObj
   if (origobj->compartment() != destination) {
     RootedObject newIdentityWrapper(cx, newIdentity);
     AutoRealm ar(cx, origobj);
-    if (!JS_WrapObject(cx, &newIdentityWrapper)) {
+    if (!JS_WrapObject(cx, &newIdentityWrapper)) {MOZ_RELEASE_ASSERT(0);
       MOZ_RELEASE_ASSERT(cx->isThrowingOutOfMemory() ||
                          cx->isThrowingOverRecursed());
       oomUnsafe.crash("JS_TransplantObject");
@@ -831,7 +831,7 @@ JS_FRIEND_API void js::RemapRemoteWindow
   AutoDisableProxyCheck adpc;
 
   AutoEnterOOMUnsafeRegion oomUnsafe;
-  if (!CheckSystemRecursionLimit(cx)) {
+  if (!CheckSystemRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     oomUnsafe.crash("js::RemapRemoteWindowProxies");
   }
 
@@ -858,7 +858,7 @@ JS_FRIEND_API void js::RemapRemoteWindow
 
     if (remoteProxy->compartment() == target->compartment()) {
       targetCompartmentProxy = remoteProxy;
-    } else if (!otherProxies.append(remoteProxy)) {
+    } else if (!otherProxies.append(remoteProxy)) {MOZ_RELEASE_ASSERT(0);
       oomUnsafe.crash("js::RemapRemoteWindowProxies");
     }
   }
@@ -1131,22 +1131,22 @@ static bool EnumerateStandardClasses(JSC
 
   // It's fine to always append |undefined| here, it's non-configurable and
   // the enumeration code filters duplicates.
-  if (!properties.append(NameToId(cx->names().undefined))) {
+  if (!properties.append(NameToId(cx->names().undefined))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   bool resolved = false;
-  if (!GlobalObject::maybeResolveGlobalThis(cx, global, &resolved)) {
+  if (!GlobalObject::maybeResolveGlobalThis(cx, global, &resolved)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (resolved || includeResolved) {
-    if (!properties.append(NameToId(cx->names().globalThis))) {
+    if (!properties.append(NameToId(cx->names().globalThis))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   if (!EnumerateStandardClassesInTable(cx, global, properties,
-                                       standard_class_names, includeResolved)) {
+                                       standard_class_names, includeResolved)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!EnumerateStandardClassesInTable(
@@ -1218,11 +1218,11 @@ JS_PUBLIC_API JSProtoKey JS_IdToProtoKey
     return JSProto_Null;
   }
 
-  if (GlobalObject::skipDeselectedConstructor(cx, stdnm->key)) {
+  if (GlobalObject::skipDeselectedConstructor(cx, stdnm->key)) {MOZ_RELEASE_ASSERT(0);
     return JSProto_Null;
   }
 
-  if (SkipSharedArrayBufferConstructor(stdnm->key, cx->global())) {
+  if (SkipSharedArrayBufferConstructor(stdnm->key, cx->global())) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(id == NameToId(cx->names().SharedArrayBuffer));
     return JSProto_Null;
   }
@@ -1478,7 +1478,7 @@ JS_PUBLIC_API uint32_t JS_GetGCParameter
 }
 
 JS_PUBLIC_API void JS_SetGCParametersBasedOnAvailableMemory(JSContext* cx,
-                                                            uint32_t availMem) {
+                                                            uint32_t availMem) {MOZ_RELEASE_ASSERT(0);
   struct JSGCConfig {
     JSGCParamKey key;
     uint32_t value;
@@ -1548,7 +1548,7 @@ static void SetNativeStackLimit(JSContex
     cx->nativeStackLimit[kind] = cx->nativeStackBase() + stackSize - 1;
   }
 #else
-  if (stackSize == 0) {
+  if (stackSize == 0) {MOZ_RELEASE_ASSERT(0);
     cx->nativeStackLimit[kind] = 0;
   } else {
     MOZ_ASSERT(cx->nativeStackBase() >= stackSize);
@@ -1638,7 +1638,7 @@ JS_PUBLIC_API bool JS::GetFirstArgumentA
   RootedString str(cx, args.get(0).toString());
   bool match;
 
-  if (!EqualStrings(cx, str, cx->names().default_, &match)) {
+  if (!EqualStrings(cx, str, cx->names().default_, &match)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (match) {
@@ -1646,7 +1646,7 @@ JS_PUBLIC_API bool JS::GetFirstArgumentA
     return true;
   }
 
-  if (!EqualStrings(cx, str, cx->names().string, &match)) {
+  if (!EqualStrings(cx, str, cx->names().string, &match)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (match) {
@@ -1654,7 +1654,7 @@ JS_PUBLIC_API bool JS::GetFirstArgumentA
     return true;
   }
 
-  if (!EqualStrings(cx, str, cx->names().number, &match)) {
+  if (!EqualStrings(cx, str, cx->names().number, &match)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (match) {
@@ -1696,7 +1696,7 @@ JS_PUBLIC_API bool JS_LinkConstructorAnd
 }
 
 JS_PUBLIC_API bool JS_InstanceOf(JSContext* cx, HandleObject obj,
-                                 const JSClass* clasp, CallArgs* args) {
+                                 const JSClass* clasp, CallArgs* args) {MOZ_RELEASE_ASSERT(0);
   AssertHeapIsIdle();
   CHECK_THREAD(cx);
 #ifdef DEBUG
@@ -1705,7 +1705,7 @@ JS_PUBLIC_API bool JS_InstanceOf(JSConte
     cx->check(args->thisv(), args->calleev());
   }
 #endif
-  if (!obj || obj->getClass() != clasp) {
+  if (!obj || obj->getClass() != clasp) {MOZ_RELEASE_ASSERT(0);
     if (args) {
       ReportIncompatibleMethod(cx, *args, clasp);
     }
@@ -1741,7 +1741,7 @@ JS_PUBLIC_API JSObject* JS_GetConstructo
   cx->check(proto);
 
   RootedValue cval(cx);
-  if (!GetProperty(cx, proto, proto, cx->names().constructor, &cval)) {
+  if (!GetProperty(cx, proto, proto, cx->names().constructor, &cval)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (!IsFunctionObject(cval)) {
@@ -2069,7 +2069,7 @@ JS_PUBLIC_API bool JS_GetPropertyDescrip
 
 JS_PUBLIC_API bool JS_GetUCPropertyDescriptor(
     JSContext* cx, HandleObject obj, const char16_t* name, size_t namelen,
-    MutableHandle<PropertyDescriptor> desc) {
+    MutableHandle<PropertyDescriptor> desc) {MOZ_RELEASE_ASSERT(0);
   JSAtom* atom = AtomizeChars(cx, name, namelen);
   if (!atom) {
     return false;
@@ -2139,7 +2139,7 @@ static bool DefineAccessorPropertyById(J
       return false;
     }
     getter = NewNativeFunction(cx, get.op, 0, atom);
-    if (!getter) {
+    if (!getter) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2153,11 +2153,11 @@ static bool DefineAccessorPropertyById(J
   RootedFunction setter(cx);
   if (set.op) {
     RootedAtom atom(cx, IdToFunctionName(cx, id, FunctionPrefixKind::Set));
-    if (!atom) {
+    if (!atom) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     setter = NewNativeFunction(cx, set.op, 1, atom);
-    if (!setter) {
+    if (!setter) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2335,7 +2335,7 @@ JS_PUBLIC_API bool JS_DefineProperty(JSC
 JS_PUBLIC_API bool JS_DefineUCProperty(JSContext* cx, HandleObject obj,
                                        const char16_t* name, size_t namelen,
                                        Handle<PropertyDescriptor> desc,
-                                       ObjectOpResult& result) {
+                                       ObjectOpResult& result) {MOZ_RELEASE_ASSERT(0);
   JSAtom* atom = AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
   if (!atom) {
     return false;
@@ -2346,7 +2346,7 @@ JS_PUBLIC_API bool JS_DefineUCProperty(J
 
 JS_PUBLIC_API bool JS_DefineUCProperty(JSContext* cx, HandleObject obj,
                                        const char16_t* name, size_t namelen,
-                                       Handle<PropertyDescriptor> desc) {
+                                       Handle<PropertyDescriptor> desc) {MOZ_RELEASE_ASSERT(0);
   JSAtom* atom = AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
   if (!atom) {
     return false;
@@ -2444,7 +2444,7 @@ JS_PUBLIC_API bool JS_DefineElement(JSCo
 
 JS_PUBLIC_API bool JS_DefineElement(JSContext* cx, HandleObject obj,
                                     uint32_t index, HandleObject getter,
-                                    HandleObject setter, unsigned attrs) {
+                                    HandleObject setter, unsigned attrs) {MOZ_RELEASE_ASSERT(0);
   RootedId id(cx);
   if (!IndexToId(cx, index, &id)) {
     return false;
@@ -2511,7 +2511,7 @@ JS_PUBLIC_API bool JS_HasProperty(JSCont
 
 JS_PUBLIC_API bool JS_HasUCProperty(JSContext* cx, HandleObject obj,
                                     const char16_t* name, size_t namelen,
-                                    bool* foundp) {
+                                    bool* foundp) {MOZ_RELEASE_ASSERT(0);
   JSAtom* atom = AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
   if (!atom) {
     return false;
@@ -2521,7 +2521,7 @@ JS_PUBLIC_API bool JS_HasUCProperty(JSCo
 }
 
 JS_PUBLIC_API bool JS_HasElement(JSContext* cx, HandleObject obj,
-                                 uint32_t index, bool* foundp) {
+                                 uint32_t index, bool* foundp) {MOZ_RELEASE_ASSERT(0);
   AssertHeapIsIdle();
   CHECK_THREAD(cx);
   RootedId id(cx);
@@ -2636,7 +2636,7 @@ JS_PUBLIC_API bool JS_SetProperty(JSCont
 
 JS_PUBLIC_API bool JS_SetUCProperty(JSContext* cx, HandleObject obj,
                                     const char16_t* name, size_t namelen,
-                                    HandleValue v) {
+                                    HandleValue v) {MOZ_RELEASE_ASSERT(0);
   JSAtom* atom = AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
   if (!atom) {
     return false;
@@ -2701,7 +2701,7 @@ JS_PUBLIC_API bool JS_DeletePropertyById
 }
 
 JS_PUBLIC_API bool JS_DeleteProperty(JSContext* cx, HandleObject obj,
-                                     const char* name, ObjectOpResult& result) {
+                                     const char* name, ObjectOpResult& result) {MOZ_RELEASE_ASSERT(0);
   CHECK_THREAD(cx);
   cx->check(obj);
 
@@ -2822,13 +2822,13 @@ JS_PUBLIC_API bool JS_CallFunctionName(J
   cx->check(obj, args);
 
   JSAtom* atom = Atomize(cx, name, strlen(name));
-  if (!atom) {
+  if (!atom) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedValue fval(cx);
   RootedId id(cx, AtomToId(atom));
-  if (!GetProperty(cx, obj, obj, id, &fval)) {
+  if (!GetProperty(cx, obj, obj, id, &fval)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2864,7 +2864,7 @@ JS_PUBLIC_API bool JS::Construct(JSConte
   CHECK_THREAD(cx);
   cx->check(fval, newTarget, args);
 
-  if (!IsConstructor(fval)) {
+  if (!IsConstructor(fval)) {MOZ_RELEASE_ASSERT(0);
     ReportValueError(cx, JSMSG_NOT_CONSTRUCTOR, JSDVG_IGNORE_STACK, fval,
                      nullptr);
     return false;
@@ -2892,7 +2892,7 @@ JS_PUBLIC_API bool JS::Construct(JSConte
   CHECK_THREAD(cx);
   cx->check(fval, args);
 
-  if (!IsConstructor(fval)) {
+  if (!IsConstructor(fval)) {MOZ_RELEASE_ASSERT(0);
     ReportValueError(cx, JSMSG_NOT_CONSTRUCTOR, JSDVG_IGNORE_STACK, fval,
                      nullptr);
     return false;
@@ -2914,7 +2914,7 @@ JS_PUBLIC_API bool JS_AlreadyHasOwnPrope
   CHECK_THREAD(cx);
   cx->check(obj, id);
 
-  if (!obj->is<NativeObject>()) {
+  if (!obj->is<NativeObject>()) {MOZ_RELEASE_ASSERT(0);
     return js::HasOwnProperty(cx, obj, id, foundp);
   }
 
@@ -2939,7 +2939,7 @@ JS_PUBLIC_API bool JS_AlreadyHasOwnPrope
 
 JS_PUBLIC_API bool JS_AlreadyHasOwnUCProperty(JSContext* cx, HandleObject obj,
                                               const char16_t* name,
-                                              size_t namelen, bool* foundp) {
+                                              size_t namelen, bool* foundp) {MOZ_RELEASE_ASSERT(0);
   JSAtom* atom = AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen));
   if (!atom) {
     return false;
@@ -2949,7 +2949,7 @@ JS_PUBLIC_API bool JS_AlreadyHasOwnUCPro
 }
 
 JS_PUBLIC_API bool JS_AlreadyHasOwnElement(JSContext* cx, HandleObject obj,
-                                           uint32_t index, bool* foundp) {
+                                           uint32_t index, bool* foundp) {MOZ_RELEASE_ASSERT(0);
   AssertHeapIsIdle();
   CHECK_THREAD(cx);
   RootedId id(cx);
@@ -2982,14 +2982,14 @@ JS_PUBLIC_API bool JS_DeepFreezeObject(J
   // Assume that non-extensible objects are already deep-frozen, to avoid
   // divergence.
   bool extensible;
-  if (!IsExtensible(cx, obj, &extensible)) {
+  if (!IsExtensible(cx, obj, &extensible)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!extensible) {
     return true;
   }
 
-  if (!FreezeObject(cx, obj)) {
+  if (!FreezeObject(cx, obj)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2997,7 +2997,7 @@ JS_PUBLIC_API bool JS_DeepFreezeObject(J
   if (obj->is<NativeObject>()) {
     RootedNativeObject nobj(cx, &obj->as<NativeObject>());
     for (uint32_t i = 0, n = nobj->slotSpan(); i < n; ++i) {
-      if (!DeepFreezeSlot(cx, nobj->getSlot(i))) {
+      if (!DeepFreezeSlot(cx, nobj->getSlot(i))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -3015,19 +3015,19 @@ static bool DefineSelfHostedProperty(JSC
                                      HandleId id, const char* getterName,
                                      const char* setterName, unsigned attrs) {
   JSAtom* getterNameAtom = Atomize(cx, getterName, strlen(getterName));
-  if (!getterNameAtom) {
+  if (!getterNameAtom) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedPropertyName getterNameName(cx, getterNameAtom->asPropertyName());
 
   RootedAtom name(cx, IdToFunctionName(cx, id));
-  if (!name) {
+  if (!name) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedValue getterValue(cx);
   if (!GlobalObject::getSelfHostedFunction(cx, cx->global(), getterNameName,
-                                           name, 0, &getterValue)) {
+                                           name, 0, &getterValue)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(getterValue.isObject() && getterValue.toObject().is<JSFunction>());
@@ -3036,7 +3036,7 @@ static bool DefineSelfHostedProperty(JSC
   RootedFunction setterFunc(cx);
   if (setterName) {
     JSAtom* setterNameAtom = Atomize(cx, setterName, strlen(setterName));
-    if (!setterNameAtom) {
+    if (!setterNameAtom) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     RootedPropertyName setterNameName(cx, setterNameAtom->asPropertyName());
@@ -3066,7 +3066,7 @@ JS_PUBLIC_API JSObject* JS_DefineObject(
   }
 
   RootedObject nobj(cx, NewBuiltinClassInstance(cx, clasp));
-  if (!nobj) {
+  if (!nobj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3135,7 +3135,7 @@ JS_PUBLIC_API bool JS_DefineProperties(J
   RootedId id(cx);
 
   for (; ps->name; ps++) {
-    if (!PropertySpecNameToId(cx, ps->name, &id)) {
+    if (!PropertySpecNameToId(cx, ps->name, &id)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3143,7 +3143,7 @@ JS_PUBLIC_API bool JS_DefineProperties(J
       if (ps->isSelfHosted()) {
         if (!DefineSelfHostedProperty(
                 cx, obj, id, ps->u.accessors.getter.selfHosted.funname,
-                ps->u.accessors.setter.selfHosted.funname, ps->attributes())) {
+                ps->u.accessors.setter.selfHosted.funname, ps->attributes())) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
@@ -3155,7 +3155,7 @@ JS_PUBLIC_API bool JS_DefineProperties(J
       }
     } else {
       RootedValue v(cx);
-      if (!ps->getValue(cx, &v)) {
+      if (!ps->getValue(cx, &v)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -3169,7 +3169,7 @@ JS_PUBLIC_API bool JS_DefineProperties(J
 
 JS_PUBLIC_API bool JS::ObjectToCompletePropertyDescriptor(
     JSContext* cx, HandleObject obj, HandleValue descObj,
-    MutableHandle<PropertyDescriptor> desc) {
+    MutableHandle<PropertyDescriptor> desc) {MOZ_RELEASE_ASSERT(0);
   // |obj| can be in a different compartment here. The caller is responsible
   // for wrapping it (see JS_WrapPropertyDescriptor).
   cx->check(descObj);
@@ -3182,7 +3182,7 @@ JS_PUBLIC_API bool JS::ObjectToCompleteP
 }
 
 JS_PUBLIC_API void JS_SetAllNonReservedSlotsToUndefined(JS::HandleObject obj) {
-  if (!obj->is<NativeObject>()) {
+  if (!obj->is<NativeObject>()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -3294,12 +3294,12 @@ JS_PUBLIC_API JSFunction* JS::GetSelfHos
   cx->check(id);
 
   RootedAtom name(cx, IdToFunctionName(cx, id));
-  if (!name) {
+  if (!name) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   JSAtom* shAtom = Atomize(cx, selfHostedName, strlen(selfHostedName));
-  if (!shAtom) {
+  if (!shAtom) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   RootedPropertyName shName(cx, shAtom->asPropertyName());
@@ -3336,36 +3336,36 @@ JS_PUBLIC_API JSFunction* JS::NewFunctio
 
     JSAtom* shAtom =
         Atomize(cx, fs->selfHostedName, strlen(fs->selfHostedName));
-    if (!shAtom) {
+    if (!shAtom) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     RootedPropertyName shName(cx, shAtom->asPropertyName());
     RootedAtom name(cx, IdToFunctionName(cx, id));
-    if (!name) {
+    if (!name) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     RootedValue funVal(cx);
     if (!GlobalObject::getSelfHostedFunction(cx, cx->global(), shName, name,
-                                             fs->nargs, &funVal)) {
+                                             fs->nargs, &funVal)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     return &funVal.toObject().as<JSFunction>();
   }
 
   RootedAtom atom(cx, IdToFunctionName(cx, id));
-  if (!atom) {
+  if (!atom) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   MOZ_ASSERT(fs->call.op);
 
   JSFunction* fun;
-  if (fs->flags & JSFUN_CONSTRUCTOR) {
+  if (fs->flags & JSFUN_CONSTRUCTOR) {MOZ_RELEASE_ASSERT(0);
     fun = NewNativeConstructor(cx, fs->call.op, fs->nargs, atom);
   } else {
     fun = NewNativeFunction(cx, fs->call.op, fs->nargs, atom);
   }
-  if (!fun) {
+  if (!fun) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3449,7 +3449,7 @@ JS_PUBLIC_API JSFunction* JS_DefineFunct
 JS_PUBLIC_API JSFunction* JS_DefineUCFunction(JSContext* cx, HandleObject obj,
                                               const char16_t* name,
                                               size_t namelen, JSNative call,
-                                              unsigned nargs, unsigned attrs) {
+                                              unsigned nargs, unsigned attrs) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(!cx->zone()->isAtomsZone());
   AssertHeapIsIdle();
   CHECK_THREAD(cx);
@@ -3548,16 +3548,16 @@ bool JS::OwningCompileOptions::copy(JSCo
 
   if (rhs.filename()) {
     filename_ = DuplicateString(cx, rhs.filename()).release();
-    if (!filename_) {
+    if (!filename_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (rhs.sourceMapURL()) {
+  if (rhs.sourceMapURL()) {MOZ_RELEASE_ASSERT(0);
     sourceMapURL_ = DuplicateString(cx, rhs.sourceMapURL()).release();
-    if (!sourceMapURL_) {
+    if (!sourceMapURL_) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   if (rhs.introducerFilename()) {
@@ -3833,12 +3833,12 @@ JS_PUBLIC_API void JS::SetSettledPromise
 
   mozilla::Maybe<AutoRealm> ar;
   Rooted<PromiseObject*> promiseObj(cx);
-  if (IsWrapper(promise)) {
+  if (IsWrapper(promise)) {MOZ_RELEASE_ASSERT(0);
     promiseObj = promise->maybeUnwrapAs<PromiseObject>();
-    if (!promiseObj) {
+    if (!promiseObj) {MOZ_RELEASE_ASSERT(0);
       ReportAccessDenied(cx);
       return;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     ar.emplace(cx, promiseObj);
   } else {
     promiseObj = promise.as<PromiseObject>();
@@ -3913,12 +3913,12 @@ static bool ResolveOrRejectPromise(JSCon
   RootedValue resultOrReason(cx, resultOrReason_);
   if (IsWrapper(promiseObj)) {
     promise = promiseObj->maybeUnwrapAs<PromiseObject>();
-    if (!promise) {
+    if (!promise) {MOZ_RELEASE_ASSERT(0);
       ReportAccessDenied(cx);
       return false;
     }
     ar.emplace(cx, promise);
-    if (!cx->compartment()->wrap(cx, &resultOrReason)) {
+    if (!cx->compartment()->wrap(cx, &resultOrReason)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -3969,7 +3969,7 @@ JS_PUBLIC_API JSObject* JS::CallOriginal
   {
     RootedValue promiseVal(cx, ObjectValue(*promiseObj));
     unwrappedPromise = UnwrapAndTypeCheckValue<PromiseObject>(
-        cx, promiseVal, [cx, promiseObj] {
+        cx, promiseVal, [cx, promiseObj] {MOZ_RELEASE_ASSERT(0);
           JS_ReportErrorNumberLatin1(cx, GetErrorMessage, nullptr,
                                      JSMSG_INCOMPATIBLE_PROTO, "Promise",
                                      "then", promiseObj->getClass()->name);
@@ -4019,7 +4019,7 @@ JS_PUBLIC_API bool JS::SetPromiseUserInp
     JS::HandleObject promiseObj_,
     JS::PromiseUserInputEventHandlingState state) {
   PromiseObject* promise = promiseObj_->maybeUnwrapIf<PromiseObject>();
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4340,7 +4340,7 @@ extern JS_PUBLIC_API JS::UniqueTwoByteCh
   CHECK_THREAD(cx);
 
   JSLinearString* linear = str->ensureLinear(cx);
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -4422,7 +4422,7 @@ JS_PUBLIC_API size_t JS_PutEscapedLinear
 
 JS_PUBLIC_API size_t JS_PutEscapedString(JSContext* cx, char* buffer,
                                          size_t size, JSString* str,
-                                         char quote) {
+                                         char quote) {MOZ_RELEASE_ASSERT(0);
   AssertHeapIsIdle();
   JSLinearString* linearStr = str->ensureLinear(cx);
   if (!linearStr) {
@@ -4446,14 +4446,14 @@ JS_PUBLIC_API JSString* JS_ConcatStrings
 }
 
 JS_PUBLIC_API bool JS_DecodeBytes(JSContext* cx, const char* src, size_t srclen,
-                                  char16_t* dst, size_t* dstlenp) {
+                                  char16_t* dst, size_t* dstlenp) {MOZ_RELEASE_ASSERT(0);
   AssertHeapIsIdle();
   CHECK_THREAD(cx);
 
-  if (!dst) {
+  if (!dst) {MOZ_RELEASE_ASSERT(0);
     *dstlenp = srclen;
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   size_t dstlen = *dstlenp;
 
@@ -4511,7 +4511,7 @@ JS_PUBLIC_API bool JS_EncodeStringToBuff
   CHECK_THREAD(cx);
 
   JSLinearString* linear = str->ensureLinear(cx);
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4606,7 +4606,7 @@ JS_PUBLIC_API bool JS_Stringify(JSContex
   CHECK_THREAD(cx);
   cx->check(replacer, space);
   StringBuffer sb(cx);
-  if (!sb.ensureTwoByteChars()) {
+  if (!sb.ensureTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!Stringify(cx, vp, replacer, space, sb, StringifyBehavior::Normal)) {
@@ -4626,9 +4626,9 @@ JS_PUBLIC_API bool JS::ToJSONMaybeSafely
   cx->check(input);
 
   StringBuffer sb(cx);
-  if (!sb.ensureTwoByteChars()) {
+  if (!sb.ensureTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedValue inputValue(cx, ObjectValue(*input));
   if (!Stringify(cx, &inputValue, nullptr, NullHandleValue, sb,
@@ -4912,7 +4912,7 @@ JS::AutoSaveExceptionState::AutoSaveExce
   if (wasPropagatingForcedReturn) {
     cx->clearPropagatingForcedReturn();
   }
-  if (wasOverRecursed) {
+  if (wasOverRecursed) {MOZ_RELEASE_ASSERT(0);
     cx->overRecursed_ = false;
   }
   if (wasThrowing) {
@@ -5010,7 +5010,7 @@ static UniquePtr<JSErrorNotes::Note> Cre
     unsigned column, JSErrorCallback errorCallback, void* userRef,
     const unsigned errorNumber, ErrorArgumentsType argumentsType, va_list ap) {
   auto note = MakeUnique<JSErrorNotes::Note>();
-  if (!note) {
+  if (!note) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -5041,7 +5041,7 @@ bool JSErrorNotes::addNoteASCII(JSContex
                         userRef, errorNumber, ArgumentsAreASCII, ap);
   va_end(ap);
 
-  if (!note) {
+  if (!note) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!notes_.append(std::move(note))) {
@@ -5055,7 +5055,7 @@ bool JSErrorNotes::addNoteLatin1(JSConte
                                  unsigned sourceId, unsigned lineno,
                                  unsigned column, JSErrorCallback errorCallback,
                                  void* userRef, const unsigned errorNumber,
-                                 ...) {
+                                 ...) {MOZ_RELEASE_ASSERT(0);
   va_list ap;
   va_start(ap, errorNumber);
   auto note =
@@ -5063,7 +5063,7 @@ bool JSErrorNotes::addNoteLatin1(JSConte
                         userRef, errorNumber, ArgumentsAreLatin1, ap);
   va_end(ap);
 
-  if (!note) {
+  if (!note) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!notes_.append(std::move(note))) {
@@ -5076,7 +5076,7 @@ bool JSErrorNotes::addNoteLatin1(JSConte
 bool JSErrorNotes::addNoteUTF8(JSContext* cx, const char* filename,
                                unsigned sourceId, unsigned lineno,
                                unsigned column, JSErrorCallback errorCallback,
-                               void* userRef, const unsigned errorNumber, ...) {
+                               void* userRef, const unsigned errorNumber, ...) {MOZ_RELEASE_ASSERT(0);
   va_list ap;
   va_start(ap, errorNumber);
   auto note =
@@ -5084,7 +5084,7 @@ bool JSErrorNotes::addNoteUTF8(JSContext
                         userRef, errorNumber, ArgumentsAreUTF8, ap);
   va_end(ap);
 
-  if (!note) {
+  if (!note) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!notes_.append(std::move(note))) {
@@ -5098,14 +5098,14 @@ JS_PUBLIC_API size_t JSErrorNotes::lengt
 
 UniquePtr<JSErrorNotes> JSErrorNotes::copy(JSContext* cx) {
   auto copiedNotes = MakeUnique<JSErrorNotes>();
-  if (!copiedNotes) {
+  if (!copiedNotes) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
 
   for (auto&& note : *this) {
     UniquePtr<JSErrorNotes::Note> copied = CopyErrorNote(cx, note.get());
-    if (!copied) {
+    if (!copied) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -5127,7 +5127,7 @@ JS_PUBLIC_API JSErrorNotes::iterator JSE
 
 extern MOZ_NEVER_INLINE JS_PUBLIC_API void JS_AbortIfWrongThread(
     JSContext* cx) {
-  if (!CurrentThreadCanAccessRuntime(cx->runtime())) {
+  if (!CurrentThreadCanAccessRuntime(cx->runtime())) {MOZ_RELEASE_ASSERT(0);
     MOZ_CRASH();
   }
   if (TlsContext.get() != cx) {
@@ -5435,7 +5435,7 @@ JS_PUBLIC_API bool JS_IndexToId(JSContex
 }
 
 JS_PUBLIC_API bool JS_CharsToId(JSContext* cx, JS::TwoByteChars chars,
-                                MutableHandleId idp) {
+                                MutableHandleId idp) {MOZ_RELEASE_ASSERT(0);
   RootedAtom atom(cx, AtomizeChars(cx, chars.begin().get(), chars.length()));
   if (!atom) {
     return false;
@@ -5448,7 +5448,7 @@ JS_PUBLIC_API bool JS_CharsToId(JSContex
 }
 
 JS_PUBLIC_API bool JS_IsIdentifier(JSContext* cx, HandleString str,
-                                   bool* isIdentifier) {
+                                   bool* isIdentifier) {MOZ_RELEASE_ASSERT(0);
   cx->check(str);
 
   JSLinearString* linearStr = str->ensureLinear(cx);
@@ -5517,7 +5517,7 @@ JS_PUBLIC_API bool DescribeScriptedCalle
     *column = 0;
   }
 
-  if (!cx->compartment()) {
+  if (!cx->compartment()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5536,7 +5536,7 @@ JS_PUBLIC_API bool DescribeScriptedCalle
     if (i.isWasm()) {
       // For Wasm, copy out the filename, there is no script source.
       UniqueChars copy = DuplicateString(i.filename() ? i.filename() : "");
-      if (!copy) {
+      if (!copy) {MOZ_RELEASE_ASSERT(0);
         filename->setUnowned("out of memory");
       } else {
         filename->setOwned(std::move(copy));
@@ -5713,7 +5713,7 @@ JS_PUBLIC_API JS::TranscodeResult JS::De
     TranscodeBuffer& buffer, JS::MutableHandleScript scriptp,
     size_t cursorIndex) {
   auto decoder = js::MakeUnique<XDRDecoder>(cx, &options, buffer, cursorIndex);
-  if (!decoder) {
+  if (!decoder) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return JS::TranscodeResult::Throw;
   }
@@ -5732,7 +5732,7 @@ static JS::TranscodeResult DecodeStencil
                                          size_t cursorIndex) {
   XDRStencilDecoder decoder(cx, buffer, cursorIndex);
 
-  if (!input.initForGlobal(cx)) {
+  if (!input.initForGlobal(cx)) {MOZ_RELEASE_ASSERT(0);
     return JS::TranscodeResult::Throw;
   }
 
@@ -5748,7 +5748,7 @@ JS_PUBLIC_API JS::TranscodeResult JS::De
     JSContext* cx, const ReadOnlyCompileOptions& options,
     TranscodeBuffer& buffer, JS::MutableHandleScript scriptp,
     size_t cursorIndex) {
-  if (!options.useStencilXDR) {
+  if (!options.useStencilXDR) {MOZ_RELEASE_ASSERT(0);
     // The buffer contains JSScript.
     return JS::DecodeScript(cx, options, buffer, scriptp, cursorIndex);
   }
@@ -5764,7 +5764,7 @@ JS_PUBLIC_API JS::TranscodeResult JS::De
 
   JS::TranscodeResult res =
       DecodeStencil(cx, buffer, input.get(), stencil, cursorIndex);
-  if (res != JS::TranscodeResult::Ok) {
+  if (res != JS::TranscodeResult::Ok) {MOZ_RELEASE_ASSERT(0);
     return res;
   }
 
@@ -5784,7 +5784,7 @@ JS_PUBLIC_API JS::TranscodeResult JS::De
     JSContext* cx, const ReadOnlyCompileOptions& options,
     const TranscodeRange& range, JS::MutableHandleScript scriptp) {
   auto decoder = js::MakeUnique<XDRDecoder>(cx, &options, range);
-  if (!decoder) {
+  if (!decoder) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return JS::TranscodeResult::Throw;
   }
@@ -5808,13 +5808,13 @@ JS_PUBLIC_API JS::TranscodeResult JS::De
 
   JS::TranscodeResult res =
       DecodeStencil(cx, buffer, input.get(), stencil, cursorIndex);
-  if (res != JS::TranscodeResult::Ok) {
+  if (res != JS::TranscodeResult::Ok) {MOZ_RELEASE_ASSERT(0);
     return res;
   }
 
   Rooted<frontend::CompilationGCOutput> gcOutput(cx);
   if (!frontend::InstantiateStencils(cx, input.get(), stencil,
-                                     gcOutput.get())) {
+                                     gcOutput.get())) {MOZ_RELEASE_ASSERT(0);
     return JS::TranscodeResult::Throw;
   }
 
@@ -5822,11 +5822,11 @@ JS_PUBLIC_API JS::TranscodeResult JS::De
 
   auto initial =
       js::MakeUnique<frontend::ExtensibleCompilationStencil>(cx, input.get());
-  if (!initial) {
+  if (!initial) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return JS::TranscodeResult::Throw;
   }
-  if (!initial->steal(cx, std::move(stencil))) {
+  if (!initial->steal(cx, std::move(stencil))) {MOZ_RELEASE_ASSERT(0);
     return JS::TranscodeResult::Throw;
   }
 
@@ -5843,7 +5843,7 @@ JS_PUBLIC_API JS::TranscodeResult JS::De
 JS_PUBLIC_API bool JS::FinishIncrementalEncoding(JSContext* cx,
                                                  JS::HandleScript script,
                                                  TranscodeBuffer& buffer) {
-  if (!script) {
+  if (!script) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!script->scriptSource()->xdrFinalizeEncoder(cx, buffer)) {
diff --git a/js/src/jsdate.cpp b/js/src/jsdate.cpp
--- a/js/src/jsdate.cpp
+++ b/js/src/jsdate.cpp
@@ -958,7 +958,7 @@ done_date:
     NEED_NDIGITS_OR_LESS(2, sec);
     if (PEEK('.')) {
       ++i;
-      if (!ParseFractional(&frac, s, &i, length)) {
+      if (!ParseFractional(&frac, s, &i, length)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1079,7 +1079,7 @@ static bool ParseDate(const CharT* s, si
     return true;
   }
 
-  if (length == 0) {
+  if (length == 0) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1133,12 +1133,12 @@ static bool ParseDate(const CharT* s, si
       while (index < length) {
         c = s[index];
         index++;
-        if (c == '(') {
+        if (c == '(') {MOZ_RELEASE_ASSERT(0);
           depth++;
         } else if (c == ')') {
           if (--depth <= 0) {
             break;
-          }
+          }MOZ_RELEASE_ASSERT(0);
         }
       }
       continue;
@@ -1203,7 +1203,7 @@ static bool ParseDate(const CharT* s, si
       } else if (prevc == '/' && mon >= 0 && mday >= 0 && year < 0) {
         if (c <= ' ' || c == ',' || c == '/' || index >= length) {
           year = n;
-        } else {
+        } else {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else if (c == ':') {
@@ -1211,7 +1211,7 @@ static bool ParseDate(const CharT* s, si
           hour = /*byte*/ n;
         } else if (min < 0) {
           min = /*byte*/ n;
-        } else {
+        } else {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else if (c == '/') {
@@ -1223,16 +1223,16 @@ static bool ParseDate(const CharT* s, si
           mon = /*byte*/ n;
         } else if (mday < 0) {
           mday = /*byte*/ n;
-        } else {
+        } else {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else if (index < length && c != ',' && c > ' ' && c != '-' &&
                  c != '(') {
         return false;
       } else if (seenPlusMinus && n < 60) { /* handle GMT-3:30 */
-        if (tzOffset < 0) {
+        if (tzOffset < 0) {MOZ_RELEASE_ASSERT(0);
           tzOffset -= n;
-        } else {
+        } else {MOZ_RELEASE_ASSERT(0);
           tzOffset += n;
         }
       } else if (hour >= 0 && min < 0) {
@@ -1314,7 +1314,7 @@ static bool ParseDate(const CharT* s, si
         // to treat 12:xx AM as 00:xx, 12:xx PM as 12:xx).
         if (action < 0) {
           MOZ_ASSERT(action == -1 || action == -2);
-          if (hour > 12 || hour < 0) {
+          if (hour > 12 || hour < 0) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
 
@@ -1332,7 +1332,7 @@ static bool ParseDate(const CharT* s, si
         // interpreted as a month, store that value to the actually appropriate
         // date component and set the month here.
         if (action <= 12) {
-          if (seenMonthName) {
+          if (seenMonthName) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
 
@@ -1355,7 +1355,7 @@ static bool ParseDate(const CharT* s, si
               year = mon;
             }
             mon = action;
-          } else {
+          } else {MOZ_RELEASE_ASSERT(0);
             return false;
           }
 
@@ -1404,7 +1404,7 @@ static bool ParseDate(const CharT* s, si
    *         interpreted as year/month/day
    */
   if (seenMonthName) {
-    if (mday >= 100 && mon >= 100) {
+    if (mday >= 100 && mon >= 100) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1480,18 +1480,18 @@ static bool ParseDate(JSLinearString* s,
 
 static bool date_parse(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (args.length() == 0) {
+  if (args.length() == 0) {MOZ_RELEASE_ASSERT(0);
     args.rval().setNaN();
     return true;
   }
 
   JSString* str = ToString<CanGC>(cx, args[0]);
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JSLinearString* linearStr = str->ensureLinear(cx);
-  if (!linearStr) {
+  if (!linearStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1510,10 +1510,10 @@ static ClippedTime NowAsMillis(JSContext
   bool clampAndJitter = cx->realm()->behaviors().clampAndJitterTime();
   if (clampAndJitter && sReduceMicrosecondTimePrecisionCallback) {
     now = sReduceMicrosecondTimePrecisionCallback(now, cx);
-  } else if (clampAndJitter && sResolutionUsec) {
+  } else if (clampAndJitter && sResolutionUsec) {MOZ_RELEASE_ASSERT(0);
     double clamped = floor(now / sResolutionUsec) * sResolutionUsec;
 
-    if (sJitter) {
+    if (sJitter) {MOZ_RELEASE_ASSERT(0);
       // Calculate a random midpoint for jittering. In the browser, we are
       // adversarial: Web Content may try to calculate the midpoint themselves
       // and use that to bypass it's security. In the JS Shell, we are not
@@ -1533,9 +1533,9 @@ static ClippedTime NowAsMillis(JSContext
       midpoint ^= midpoint >> 33;
       midpoint %= sResolutionUsec;
 
-      if (now > clamped + midpoint) {  // We're jittering up to the next step
+      if (now > clamped + midpoint) {MOZ_RELEASE_ASSERT(0);  // We're jittering up to the next step
         now = clamped + sResolutionUsec;
-      } else {  // We're staying at the clamped value
+      } else {MOZ_RELEASE_ASSERT(0);  // We're staying at the clamped value
         now = clamped;
       }
     } else {  // No jitter, only clamping
@@ -2192,7 +2192,7 @@ static bool date_setUTCSeconds(JSContext
 
   /* Step 2. */
   double s;
-  if (!ToNumber(cx, args.get(0), &s)) {
+  if (!ToNumber(cx, args.get(0), &s)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2235,7 +2235,7 @@ static bool date_setMinutes(JSContext* c
 
   // Steps 5-6.
   double s;
-  if (!GetSecsOrDefault(cx, args, 1, t, &s)) {
+  if (!GetSecsOrDefault(cx, args, 1, t, &s)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2271,13 +2271,13 @@ static bool date_setUTCMinutes(JSContext
 
   /* Step 2. */
   double m;
-  if (!ToNumber(cx, args.get(0), &m)) {
+  if (!ToNumber(cx, args.get(0), &m)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   /* Step 3. */
   double s;
-  if (!GetSecsOrDefault(cx, args, 1, t, &s)) {
+  if (!GetSecsOrDefault(cx, args, 1, t, &s)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2361,19 +2361,19 @@ static bool date_setUTCHours(JSContext* 
 
   /* Step 2. */
   double h;
-  if (!ToNumber(cx, args.get(0), &h)) {
+  if (!ToNumber(cx, args.get(0), &h)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   /* Step 3. */
   double m;
-  if (!GetMinsOrDefault(cx, args, 1, t, &m)) {
+  if (!GetMinsOrDefault(cx, args, 1, t, &m)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   /* Step 4. */
   double s;
-  if (!GetSecsOrDefault(cx, args, 2, t, &s)) {
+  if (!GetSecsOrDefault(cx, args, 2, t, &s)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2525,7 +2525,7 @@ static bool date_setUTCMonth(JSContext* 
 
   /* Step 2. */
   double m;
-  if (!ToNumber(cx, args.get(0), &m)) {
+  if (!ToNumber(cx, args.get(0), &m)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2617,13 +2617,13 @@ static bool date_setUTCFullYear(JSContex
 
   /* Step 2. */
   double y;
-  if (!ToNumber(cx, args.get(0), &y)) {
+  if (!ToNumber(cx, args.get(0), &y)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   /* Step 3. */
   double m;
-  if (!GetMonthOrDefault(cx, args, 1, t, &m)) {
+  if (!GetMonthOrDefault(cx, args, 1, t, &m)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2806,7 +2806,7 @@ static bool date_toJSON(JSContext* cx, u
 JSString* DateTimeHelper::timeZoneComment(JSContext* cx, double utcTime,
                                           double localTime) {
   const char* locale = cx->runtime()->getDefaultLocale();
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_DEFAULT_LOCALE_ERROR);
     return nullptr;
@@ -2823,7 +2823,7 @@ JSString* DateTimeHelper::timeZoneCommen
   int64_t utcMilliseconds = static_cast<int64_t>(utcTime);
   if (!DateTimeInfo::timeZoneDisplayName(timeZoneStart, remainingSpace,
                                          utcMilliseconds, locale)) {
-    { JS_ReportOutOfMemory(cx); }
+    { JS_ReportOutOfMemory(cx); }MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2952,7 +2952,7 @@ static bool FormatDate(JSContext* cx, do
 
     // Get a time zone string from the OS or ICU to include as a comment.
     timeZoneComment = TimeZoneComment(cx, utcTime, localTime);
-    if (!timeZoneComment) {
+    if (!timeZoneComment) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2984,7 +2984,7 @@ static bool FormatDate(JSContext* cx, do
   }
 
   RootedString str(cx, NewStringCopyZ<CanGC>(cx, buf));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3149,7 +3149,7 @@ static bool date_toSource(JSContext* cx,
   JSStringBuilder sb(cx);
   if (!sb.append("(new Date(") ||
       !NumberValueToStringBuffer(cx, unwrapped->UTCTime(), sb) ||
-      !sb.append("))")) {
+      !sb.append("))")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3310,13 +3310,13 @@ static bool DateOneArgument(JSContext* c
       RootedObject obj(cx, &args[0].toObject());
 
       ESClass cls;
-      if (!GetBuiltinClass(cx, obj, &cls)) {
+      if (!GetBuiltinClass(cx, obj, &cls)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       if (cls == ESClass::Date) {
         RootedValue unboxed(cx);
-        if (!Unbox(cx, obj, &unboxed)) {
+        if (!Unbox(cx, obj, &unboxed)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -3331,7 +3331,7 @@ static bool DateOneArgument(JSContext* c
     ClippedTime t;
     if (args[0].isString()) {
       JSLinearString* linearStr = args[0].toString()->ensureLinear(cx);
-      if (!linearStr) {
+      if (!linearStr) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -3513,7 +3513,7 @@ JS_FRIEND_API JSObject* js::NewDateObjec
 JS_FRIEND_API bool js::DateIsValid(JSContext* cx, HandleObject obj,
                                    bool* isValid) {
   ESClass cls;
-  if (!GetBuiltinClass(cx, obj, &cls)) {
+  if (!GetBuiltinClass(cx, obj, &cls)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3555,11 +3555,11 @@ JS_PUBLIC_API bool JS::ObjectIsDate(JSCo
 JS_FRIEND_API bool js::DateGetMsecSinceEpoch(JSContext* cx, HandleObject obj,
                                              double* msecsSinceEpoch) {
   ESClass cls;
-  if (!GetBuiltinClass(cx, obj, &cls)) {
+  if (!GetBuiltinClass(cx, obj, &cls)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (cls != ESClass::Date) {
+  if (cls != ESClass::Date) {MOZ_RELEASE_ASSERT(0);
     *msecsSinceEpoch = 0;
     return true;
   }
diff --git a/js/src/jsexn.cpp b/js/src/jsexn.cpp
--- a/js/src/jsexn.cpp
+++ b/js/src/jsexn.cpp
@@ -110,7 +110,7 @@ bool CopyExtraData(JSContext* cx, uint8_
   /* Deep copy notes. */
   if (report->notes) {
     auto copiedNotes = report->notes->copy(cx);
-    if (!copiedNotes) {
+    if (!copiedNotes) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     copy->notes = std::move(copiedNotes);
@@ -155,7 +155,7 @@ static UniquePtr<T> CopyErrorHelper(JSCo
   size_t mallocSize =
       sizeof(T) + messageSize + filenameSize + ExtraMallocSize(report);
   uint8_t* cursor = cx->pod_calloc<uint8_t>(mallocSize);
-  if (!cursor) {
+  if (!cursor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -228,7 +228,7 @@ JSString* js::ComputeStackString(JSConte
   SuppressErrorsGuard seg(cx);
 
   RootedObject stack(cx);
-  if (!CaptureStack(cx, &stack)) {
+  if (!CaptureStack(cx, &stack)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -291,7 +291,7 @@ void js::ErrorToException(JSContext* cx,
   // We cannot throw a proper object inside the self-hosting realm, as we
   // cannot construct the Error constructor without self-hosted code. Just
   // print the error to stderr to help debugging.
-  if (cx->realm()->isSelfHostingRealm()) {
+  if (cx->realm()->isSelfHostingRealm()) {MOZ_RELEASE_ASSERT(0);
     JS::PrintError(cx, stderr, reportp, true);
     return;
   }
@@ -307,7 +307,7 @@ void js::ErrorToException(JSContext* cx,
   MOZ_ASSERT(exnType < JSEXN_ERROR_LIMIT);
 
   // Prevent infinite recursion.
-  if (cx->generatingError) {
+  if (cx->generatingError) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -316,12 +316,12 @@ void js::ErrorToException(JSContext* cx,
 
   // Create an exception object.
   RootedString messageStr(cx, reportp->newMessageString(cx));
-  if (!messageStr) {
+  if (!messageStr) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
   RootedString fileName(cx, JS_NewStringCopyZ(cx, reportp->filename));
-  if (!fileName) {
+  if (!fileName) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -335,14 +335,14 @@ void js::ErrorToException(JSContext* cx,
   }
 
   UniquePtr<JSErrorReport> report = CopyErrorReport(cx, reportp);
-  if (!report) {
+  if (!report) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
   ErrorObject* errObject =
       ErrorObject::create(cx, exnType, stack, fileName, sourceId, lineNumber,
                           columnNumber, std::move(report), messageStr);
-  if (!errObject) {
+  if (!errObject) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -372,7 +372,7 @@ static bool IsDuckTypedErrorObject(JSCon
 
   // First try "filename".
   const char* filename_str = *filename_strp;
-  if (!JS_HasProperty(cx, exnObject, filename_str, &found)) {
+  if (!JS_HasProperty(cx, exnObject, filename_str, &found)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!found) {
@@ -444,11 +444,11 @@ static JSString* ErrorReportToString(JSC
   // "right thing" for JSEXN_INTERNALERR.  That is, the caller of this API
   // expects that "InternalError: " will be prepended but GetErrorTypeName
   // goes out of its way to avoid this.
-  if (!name) {
+  if (!name) {MOZ_RELEASE_ASSERT(0);
     JSExnType type = static_cast<JSExnType>(reportp->exnType);
-    if (type != JSEXN_WARN && type != JSEXN_NOTE) {
+    if (type != JSEXN_WARN && type != JSEXN_NOTE) {MOZ_RELEASE_ASSERT(0);
       name = ClassName(GetExceptionProtoKey(type), cx);
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   RootedString message(cx);
@@ -498,7 +498,7 @@ bool JS::ErrorReportBuilder::init(JSCont
     if (js::SymbolDescriptiveString(cx, exnStack.exception().toSymbol(),
                                     &strVal)) {
       str = strVal.toString();
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       str = nullptr;
     }
   } else if (exnObject && sniffingBehavior == NoSideEffects) {
@@ -535,7 +535,7 @@ bool JS::ErrorReportBuilder::init(JSCont
     RootedString msg(cx);
     if (JS_GetProperty(cx, exnObject, js_message_str, &val) && val.isString()) {
       msg = val.toString();
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       cx->clearPendingException();
     }
 
@@ -553,24 +553,24 @@ bool JS::ErrorReportBuilder::init(JSCont
         }
       }
     }
-    if (!filename) {
+    if (!filename) {MOZ_RELEASE_ASSERT(0);
       filename = DuplicateString("");
-      if (!filename) {
+      if (!filename) {MOZ_RELEASE_ASSERT(0);
         ReportOutOfMemory(cx);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
     uint32_t lineno;
     if (!JS_GetProperty(cx, exnObject, js_lineNumber_str, &val) ||
-        !ToUint32(cx, val, &lineno)) {
+        !ToUint32(cx, val, &lineno)) {MOZ_RELEASE_ASSERT(0);
       cx->clearPendingException();
       lineno = 0;
     }
 
     uint32_t column;
     if (!JS_GetProperty(cx, exnObject, js_columnNumber_str, &val) ||
-        !ToUint32(cx, val, &column)) {
+        !ToUint32(cx, val, &column)) {MOZ_RELEASE_ASSERT(0);
       cx->clearPendingException();
       column = 0;
     }
@@ -592,7 +592,7 @@ bool JS::ErrorReportBuilder::init(JSCont
       // If only this stuff could get specced one day...
       if (auto utf8 = JS_EncodeStringToUTF8(cx, str)) {
         ownedReport.initOwnedMessage(utf8.release());
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         cx->clearPendingException();
         str = nullptr;
       }
@@ -603,7 +603,7 @@ bool JS::ErrorReportBuilder::init(JSCont
   if (str) {
     toStringResultBytesStorage = JS_EncodeStringToUTF8(cx, str);
     utf8Message = toStringResultBytesStorage.get();
-    if (!utf8Message) {
+    if (!utf8Message) {MOZ_RELEASE_ASSERT(0);
       cx->clearPendingException();
     }
   }
@@ -620,7 +620,7 @@ bool JS::ErrorReportBuilder::init(JSCont
     // but without the reporting bits.  Instead it just puts all
     // the stuff we care about in our ownedReport and message_.
     if (!populateUncaughtExceptionReportUTF8(cx, exnStack.stack(),
-                                             utf8Message)) {
+                                             utf8Message)) {MOZ_RELEASE_ASSERT(0);
       // Just give up.  We're out of memory or something; not much we can
       // do here.
       return false;
@@ -653,7 +653,7 @@ bool JS::ErrorReportBuilder::populateUnc
                            SavedFrameSelfHosted::Exclude, skippedAsync));
   if (frame) {
     filename = StringToNewUTF8CharsZ(cx, *frame->getSource());
-    if (!filename) {
+    if (!filename) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -694,17 +694,17 @@ JSObject* js::CopyErrorObject(JSContext*
   UniquePtr<JSErrorReport> copyReport;
   if (JSErrorReport* errorReport = err->getErrorReport()) {
     copyReport = CopyErrorReport(cx, errorReport);
-    if (!copyReport) {
+    if (!copyReport) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
 
   RootedString message(cx, err->getMessage());
-  if (message && !cx->compartment()->wrap(cx, &message)) {
+  if (message && !cx->compartment()->wrap(cx, &message)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   RootedString fileName(cx, err->fileName(cx));
-  if (!cx->compartment()->wrap(cx, &fileName)) {
+  if (!cx->compartment()->wrap(cx, &fileName)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   RootedObject stack(cx, err->stack());
@@ -731,11 +731,11 @@ JS_PUBLIC_API bool JS::CreateError(JSCon
   AssertObjectIsSavedFrameOrWrapper(cx, stack);
 
   js::UniquePtr<JSErrorReport> rep;
-  if (report) {
+  if (report) {MOZ_RELEASE_ASSERT(0);
     rep = CopyErrorReport(cx, report);
-    if (!rep) {
+    if (!rep) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   JSObject* obj =
@@ -770,7 +770,7 @@ const char* js::ValueToSourceForError(JS
   if (val.isObject()) {
     RootedObject valObj(cx, val.toObjectOrNull());
     ESClass cls;
-    if (!JS::GetBuiltinClass(cx, valObj, &cls)) {
+    if (!JS::GetBuiltinClass(cx, valObj, &cls)) {MOZ_RELEASE_ASSERT(0);
       return "<<error determining class of value>>";
     }
     const char* s;
@@ -783,19 +783,19 @@ const char* js::ValueToSourceForError(JS
     } else {
       s = "the object ";
     }
-    if (!sb.append(s, strlen(s))) {
+    if (!sb.append(s, strlen(s))) {MOZ_RELEASE_ASSERT(0);
       return "<<error converting value to string>>";
     }
   } else if (val.isNumber()) {
-    if (!sb.append("the number ")) {
+    if (!sb.append("the number ")) {MOZ_RELEASE_ASSERT(0);
       return "<<error converting value to string>>";
     }
   } else if (val.isString()) {
-    if (!sb.append("the string ")) {
+    if (!sb.append("the string ")) {MOZ_RELEASE_ASSERT(0);
       return "<<error converting value to string>>";
     }
   } else if (val.isBigInt()) {
-    if (!sb.append("the BigInt ")) {
+    if (!sb.append("the BigInt ")) {MOZ_RELEASE_ASSERT(0);
       return "<<error converting value to string>>";
     }
   } else {
@@ -803,7 +803,7 @@ const char* js::ValueToSourceForError(JS
     bytes = StringToNewUTF8CharsZ(cx, *str);
     return bytes.get();
   }
-  if (!sb.append(str)) {
+  if (!sb.append(str)) {MOZ_RELEASE_ASSERT(0);
     return "<<error converting value to string>>";
   }
   str = sb.finishString();
diff --git a/js/src/jsfriendapi.cpp b/js/src/jsfriendapi.cpp
--- a/js/src/jsfriendapi.cpp
+++ b/js/src/jsfriendapi.cpp
@@ -191,14 +191,14 @@ JS_FRIEND_API bool JS_DefineFunctionsWit
   cx->check(obj);
   for (; fs->name; fs++) {
     JSAtom* atom = Atomize(cx, fs->name, strlen(fs->name));
-    if (!atom) {
+    if (!atom) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     Rooted<jsid> id(cx, AtomToId(atom));
     RootedFunction fun(cx, DefineFunction(cx, obj, id, fs->call, fs->nargs,
                                           fs->flags | JSPROP_RESOLVING));
-    if (!fun) {
+    if (!fun) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -207,7 +207,7 @@ JS_FRIEND_API bool JS_DefineFunctionsWit
     }
 
     if (fs->usage) {
-      if (!DefineHelpProperty(cx, fun, "usage", fs->usage)) {
+      if (!DefineHelpProperty(cx, fun, "usage", fs->usage)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -470,8 +470,8 @@ extern JS_FRIEND_API bool js::AreGCGrayB
   return rt->gc.areGrayBitsValid();
 }
 
-JS_FRIEND_API bool js::ZoneGlobalsAreAllGray(JS::Zone* zone) {
-  for (RealmsInZoneIter realm(zone); !realm.done(); realm.next()) {
+JS_FRIEND_API bool js::ZoneGlobalsAreAllGray(JS::Zone* zone) {MOZ_RELEASE_ASSERT(0);
+  for (RealmsInZoneIter realm(zone); !realm.done(); realm.next()) {MOZ_RELEASE_ASSERT(0);
     JSObject* obj = realm->unsafeUnbarrieredMaybeGlobal();
     if (!obj || !JS::ObjectIsMarkedGray(obj)) {
       return false;
@@ -486,11 +486,11 @@ JS_FRIEND_API bool js::IsCompartmentZone
   return comp->zone()->isGCSweepingOrCompacting();
 }
 
-JS_FRIEND_API void js::TraceGrayWrapperTargets(JSTracer* trc, Zone* zone) {
+JS_FRIEND_API void js::TraceGrayWrapperTargets(JSTracer* trc, Zone* zone) {MOZ_RELEASE_ASSERT(0);
   JS::AutoSuppressGCAnalysis nogc;
 
-  for (CompartmentsInZoneIter comp(zone); !comp.done(); comp.next()) {
-    for (Compartment::ObjectWrapperEnum e(comp); !e.empty(); e.popFront()) {
+  for (CompartmentsInZoneIter comp(zone); !comp.done(); comp.next()) {MOZ_RELEASE_ASSERT(0);
+    for (Compartment::ObjectWrapperEnum e(comp); !e.empty(); e.popFront()) {MOZ_RELEASE_ASSERT(0);
       JSObject* target = e.front().key();
       if (target->isMarkedGray()) {
         TraceManuallyBarrieredEdge(trc, &target, "gray CCW target");
@@ -510,11 +510,11 @@ static bool CopyProxyObject(JSContext* c
   MOZ_ASSERT(from->getClass() == to->getClass());
 
   if (from->is<WrapperObject>() &&
-      (Wrapper::wrapperHandler(from)->flags() & Wrapper::CROSS_COMPARTMENT)) {
+      (Wrapper::wrapperHandler(from)->flags() & Wrapper::CROSS_COMPARTMENT)) {MOZ_RELEASE_ASSERT(0);
     to->setCrossCompartmentPrivate(GetProxyPrivate(from));
   } else {
     RootedValue v(cx, GetProxyPrivate(from));
-    if (!cx->compartment()->wrap(cx, &v)) {
+    if (!cx->compartment()->wrap(cx, &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     to->setSameCompartmentPrivate(v);
@@ -539,7 +539,7 @@ JS_FRIEND_API JSObject* JS_CloneObject(J
   // |obj| might be in a different compartment.
   cx->check(proto);
 
-  if (!obj->is<NativeObject>() && !obj->is<ProxyObject>()) {
+  if (!obj->is<NativeObject>() && !obj->is<ProxyObject>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_CANT_CLONE_OBJECT);
     return nullptr;
@@ -550,18 +550,18 @@ JS_FRIEND_API JSObject* JS_CloneObject(J
     // JS_CloneObject is used to create the target object for JSObject::swap().
     // swap() requires its arguments are tenured, so ensure tenure allocation.
     clone = NewTenuredObjectWithGivenProto(cx, obj->getClass(), proto);
-    if (!clone) {
+    if (!clone) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     if (clone->is<JSFunction>() &&
-        (obj->compartment() != clone->compartment())) {
+        (obj->compartment() != clone->compartment())) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                 JSMSG_CANT_CLONE_OBJECT);
       return nullptr;
     }
 
-    if (obj->as<NativeObject>().hasPrivate()) {
+    if (obj->as<NativeObject>().hasPrivate()) {MOZ_RELEASE_ASSERT(0);
       clone->as<NativeObject>().setPrivate(
           obj->as<NativeObject>().getPrivate());
     }
@@ -570,7 +570,7 @@ JS_FRIEND_API JSObject* JS_CloneObject(J
 
     // Same as above, require tenure allocation of the clone. This means for
     // proxy objects we need to reject nursery allocatable proxies.
-    if (handler->canNurseryAllocate()) {
+    if (handler->canNurseryAllocate()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                 JSMSG_CANT_CLONE_OBJECT);
       return nullptr;
@@ -578,7 +578,7 @@ JS_FRIEND_API JSObject* JS_CloneObject(J
 
     clone = ProxyObject::New(cx, handler, JS::NullHandleValue,
                              AsTaggedProto(proto), obj->getClass());
-    if (!clone) {
+    if (!clone) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -655,7 +655,7 @@ JS_FRIEND_API bool js::IsSharableCompart
 
 JS_FRIEND_API JSObject* js::GetTestingFunctions(JSContext* cx) {
   RootedObject obj(cx, JS_NewPlainObject(cx));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/jsmath.cpp b/js/src/jsmath.cpp
--- a/js/src/jsmath.cpp
+++ b/js/src/jsmath.cpp
@@ -139,7 +139,7 @@ double js::ecmaAtan2(double y, double x)
 bool js::math_atan2_handle(JSContext* cx, HandleValue y, HandleValue x,
                            MutableHandleValue res) {
   double dy;
-  if (!ToNumber(cx, y, &dy)) {
+  if (!ToNumber(cx, y, &dy)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -194,7 +194,7 @@ bool js::math_clz32(JSContext* cx, unsig
   }
 
   uint32_t n;
-  if (!ToUint32(cx, args[0], &n)) {
+  if (!ToUint32(cx, args[0], &n)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -370,10 +370,10 @@ bool js::minmax_impl(JSContext* cx, bool
                      MutableHandleValue res) {
   double x, y;
 
-  if (!ToNumber(cx, a, &x)) {
+  if (!ToNumber(cx, a, &x)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!ToNumber(cx, b, &y)) {
+  if (!ToNumber(cx, b, &y)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -434,7 +434,7 @@ double js::ecmaPow(double x, double y) {
   }
 
   /* pow(x, +-0) is always 1, even for x = NaN (MSVC gets this wrong). */
-  if (y == 0) {
+  if (y == 0) {MOZ_RELEASE_ASSERT(0);
     return 1;
   }
 
@@ -457,7 +457,7 @@ bool js::math_pow(JSContext* cx, unsigne
   CallArgs args = CallArgsFromVp(argc, vp);
 
   double x;
-  if (!ToNumber(cx, args.get(0), &x)) {
+  if (!ToNumber(cx, args.get(0), &x)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -553,13 +553,13 @@ double js::math_round_impl(double x) {
   return std::copysign(fdlibm::floor(x + add), x);
 }
 
-float js::math_roundf_impl(float x) {
+float js::math_roundf_impl(float x) {MOZ_RELEASE_ASSERT(0);
   AutoUnsafeCallWithABI unsafe;
 
   int32_t ignored;
-  if (NumberEqualsInt32(x, &ignored)) {
+  if (NumberEqualsInt32(x, &ignored)) {MOZ_RELEASE_ASSERT(0);
     return x;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   /* Some numbers are so big that adding 0.5 would give the wrong number. */
   if (ExponentComponent(x) >=
@@ -766,10 +766,10 @@ bool js::math_hypot_handle(JSContext* cx
   // given. Do that here as well to get the same results.
   if (args.length() == 2) {
     double x, y;
-    if (!ToNumber(cx, args[0], &x)) {
+    if (!ToNumber(cx, args[0], &x)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!ToNumber(cx, args[1], &y)) {
+    if (!ToNumber(cx, args[1], &y)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -786,7 +786,7 @@ bool js::math_hypot_handle(JSContext* cx
 
   for (unsigned i = 0; i < args.length(); i++) {
     double x;
-    if (!ToNumber(cx, args[i], &x)) {
+    if (!ToNumber(cx, args[i], &x)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -933,7 +933,7 @@ UnaryMathFunctionType js::GetUnaryMathFu
   MOZ_CRASH("Unknown function");
 }
 
-const char* js::GetUnaryMathFunctionName(UnaryMathFunction fun) {
+const char* js::GetUnaryMathFunctionName(UnaryMathFunction fun) {MOZ_RELEASE_ASSERT(0);
   switch (fun) {
     case UnaryMathFunction::Log:
       return "Log";
diff --git a/js/src/jsnum.cpp b/js/src/jsnum.cpp
--- a/js/src/jsnum.cpp
+++ b/js/src/jsnum.cpp
@@ -110,14 +110,14 @@ static bool ComputeAccurateDecimalIntege
                                           const CharT* end, double* dp) {
   size_t length = end - start;
   auto cstr = cx->make_pod_array<char>(length + 1);
-  if (!cstr) {
+  if (!cstr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   size_t j = 0;
   for (size_t i = 0; i < length; i++) {
     char c = char(start[i]);
-    if (c == '_') {
+    if (c == '_') {MOZ_RELEASE_ASSERT(0);
       AssertWellPlacedNumericSeparator(start + i, start, end);
       continue;
     }
@@ -208,7 +208,7 @@ static double ComputeAccurateBinaryBaseI
   double value = 1.0;
   for (int j = 52; j > 0; j--) {
     bit = bdr.nextDigit();
-    if (bit < 0) {
+    if (bit < 0) {MOZ_RELEASE_ASSERT(0);
       return value;
     }
     value = value * 2 + bit;
@@ -388,7 +388,7 @@ bool js::GetDecimalNonInteger(JSContext*
 
   size_t length = end - start;
   Vector<char, 32> chars(cx);
-  if (!chars.growByUninitialized(length + 1)) {
+  if (!chars.growByUninitialized(length + 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -437,7 +437,7 @@ bool GetDecimalNonInteger<Utf8Unit>(JSCo
 static bool num_parseFloat(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() == 0) {
+  if (args.length() == 0) {MOZ_RELEASE_ASSERT(0);
     args.rval().setNaN();
     return true;
   }
@@ -463,7 +463,7 @@ static bool num_parseFloat(JSContext* cx
   }
 
   JSLinearString* linear = str->ensureLinear(cx);
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -472,7 +472,7 @@ static bool num_parseFloat(JSContext* cx
   if (linear->hasLatin1Chars()) {
     const Latin1Char* begin = linear->latin1Chars(nogc);
     const Latin1Char* end;
-    if (!js_strtod(cx, begin, begin + linear->length(), &end, &d)) {
+    if (!js_strtod(cx, begin, begin + linear->length(), &end, &d)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (end == begin) {
@@ -481,7 +481,7 @@ static bool num_parseFloat(JSContext* cx
   } else {
     const char16_t* begin = linear->twoByteChars(nogc);
     const char16_t* end;
-    if (!js_strtod(cx, begin, begin + linear->length(), &end, &d)) {
+    if (!js_strtod(cx, begin, begin + linear->length(), &end, &d)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (end == begin) {
@@ -523,7 +523,7 @@ static bool ParseIntImpl(JSContext* cx, 
   const CharT* actualEnd;
   double d;
   if (!GetPrefixInteger(cx, s, end, radix, IntegerSeparatorHandling::None,
-                        &actualEnd, &d)) {
+                        &actualEnd, &d)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -618,7 +618,7 @@ static bool num_parseInt(JSContext* cx, 
   }
 
   JSLinearString* linear = inputString->ensureLinear(cx);
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -627,7 +627,7 @@ static bool num_parseInt(JSContext* cx, 
   double number;
   if (linear->hasLatin1Chars()) {
     if (!ParseIntImpl(cx, linear->latin1Chars(nogc), length, stripPrefix, radix,
-                      &number)) {
+                      &number)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -736,7 +736,7 @@ static bool num_toSource(JSContext* cx, 
 
   JSStringBuilder sb(cx);
   if (!sb.append("(new Number(") ||
-      !NumberValueToStringBuffer(cx, NumberValue(d), sb) || !sb.append("))")) {
+      !NumberValueToStringBuffer(cx, NumberValue(d), sb) || !sb.append("))")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1163,7 +1163,7 @@ static bool num_toFixed(JSContext* cx, u
     precision = 0;
   } else {
     double prec = 0;
-    if (!ToInteger(cx, args[0], &prec)) {
+    if (!ToInteger(cx, args[0], &prec)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1190,7 +1190,7 @@ static bool num_toFixed(JSContext* cx, u
   // Steps 7-10 for very large numbers.
   if (d <= -1e21 || d >= 1e+21) {
     JSString* s = NumberToString<CanGC>(cx, d);
-    if (!s) {
+    if (!s) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1291,7 +1291,7 @@ static bool num_toPrecision(JSContext* c
   // Step 2.
   if (!args.hasDefined(0)) {
     JSString* str = NumberToStringWithBase<CanGC>(cx, d, 10);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       JS_ReportOutOfMemory(cx);
       return false;
     }
@@ -1471,7 +1471,7 @@ static bool NumberClassFinish(JSContext*
                               HandleObject proto) {
   Handle<GlobalObject*> global = cx->global();
 
-  if (!JS_DefineFunctions(cx, global, number_functions)) {
+  if (!JS_DefineFunctions(cx, global, number_functions)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1479,11 +1479,11 @@ static bool NumberClassFinish(JSContext*
   RootedId parseIntId(cx, NameToId(cx->names().parseInt));
   JSFunction* parseInt =
       DefineFunction(cx, global, parseIntId, num_parseInt, 2, JSPROP_RESOLVING);
-  if (!parseInt) {
+  if (!parseInt) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedValue parseIntValue(cx, ObjectValue(*parseInt));
-  if (!DefineDataProperty(cx, ctor, parseIntId, parseIntValue, 0)) {
+  if (!DefineDataProperty(cx, ctor, parseIntId, parseIntValue, 0)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1492,11 +1492,11 @@ static bool NumberClassFinish(JSContext*
   RootedId parseFloatId(cx, NameToId(cx->names().parseFloat));
   JSFunction* parseFloat = DefineFunction(cx, global, parseFloatId,
                                           num_parseFloat, 1, JSPROP_RESOLVING);
-  if (!parseFloat) {
+  if (!parseFloat) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedValue parseFloatValue(cx, ObjectValue(*parseFloat));
-  if (!DefineDataProperty(cx, ctor, parseFloatId, parseFloatValue, 0)) {
+  if (!DefineDataProperty(cx, ctor, parseFloatId, parseFloatValue, 0)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1505,7 +1505,7 @@ static bool NumberClassFinish(JSContext*
 
   if (!DefineDataProperty(
           cx, ctor, cx->names().NaN, valueNaN,
-          JSPROP_PERMANENT | JSPROP_READONLY | JSPROP_RESOLVING)) {
+          JSPROP_PERMANENT | JSPROP_READONLY | JSPROP_RESOLVING)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1697,7 +1697,7 @@ JSAtom* js::NumberToAtom(JSContext* cx, 
 
   ToCStringBuf cbuf;
   char* numStr = FracNumberToCString(cx, &cbuf, d);
-  if (!numStr) {
+  if (!numStr) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -1741,7 +1741,7 @@ JSLinearString* js::IndexToString(JSCont
   }
 
   Realm* realm = cx->realm();
-  if (JSLinearString* str = realm->dtoaCache.lookup(10, index)) {
+  if (JSLinearString* str = realm->dtoaCache.lookup(10, index)) {MOZ_RELEASE_ASSERT(0);
     return str;
   }
 
@@ -1853,7 +1853,7 @@ bool js::CharsToNumber(JSContext* cx, co
    */
   const CharT* ep;
   double d;
-  if (!js_strtod(cx, start, end, &ep, &d)) {
+  if (!js_strtod(cx, start, end, &ep, &d)) {MOZ_RELEASE_ASSERT(0);
     *result = GenericNaN();
     return false;
   }
@@ -1875,7 +1875,7 @@ template bool js::CharsToNumber(JSContex
 
 template <typename CharT>
 static bool CharsToNumber(const CharT* chars, size_t length, double* result) {
-  if (length == 1) {
+  if (length == 1) {MOZ_RELEASE_ASSERT(0);
     CharToNumber(chars[0], result);
     return true;
   }
@@ -1885,9 +1885,9 @@ static bool CharsToNumber(const CharT* c
 
   // ECMA doesn't allow signed non-decimal numbers (bug 273467).
   if (end - start >= 2 && start[0] == '0') {
-    if (CharsToNonDecimalNumber(start, end, result)) {
+    if (CharsToNonDecimalNumber(start, end, result)) {MOZ_RELEASE_ASSERT(0);
       return true;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   // It's probably a decimal number. Accept if no non-whitespace characters
@@ -1910,7 +1910,7 @@ static bool CharsToNumber(const CharT* c
 bool js::StringToNumber(JSContext* cx, JSString* str, double* result) {
   AutoCheckCannotGC nogc;
   JSLinearString* linearStr = str->ensureLinear(cx);
-  if (!linearStr) {
+  if (!linearStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1956,7 +1956,7 @@ JS_PUBLIC_API bool js::ToNumberSlow(JSCo
   MOZ_ASSERT(!v.isNumber());
 
   if (!v.isPrimitive()) {
-    if (cx->isHelperThreadContext()) {
+    if (cx->isHelperThreadContext()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2003,7 +2003,7 @@ bool js::ToNumericSlow(JSContext* cx, Mu
 
   // Step 1.
   if (!vp.isPrimitive()) {
-    if (cx->isHelperThreadContext()) {
+    if (cx->isHelperThreadContext()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!ToPrimitive(cx, JSTYPE_NUMBER, vp)) {
@@ -2025,10 +2025,10 @@ bool js::ToNumericSlow(JSContext* cx, Mu
  * conversion. Return converted value in *out on success, false on failure.
  */
 JS_PUBLIC_API bool js::ToInt8Slow(JSContext* cx, const HandleValue v,
-                                  int8_t* out) {
+                                  int8_t* out) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(!v.isInt32());
   double d;
-  if (v.isDouble()) {
+  if (v.isDouble()) {MOZ_RELEASE_ASSERT(0);
     d = v.toDouble();
   } else {
     if (!ToNumberSlow(cx, v, &d)) {
@@ -2045,10 +2045,10 @@ JS_PUBLIC_API bool js::ToInt8Slow(JSCont
  * failure.
  */
 JS_PUBLIC_API bool js::ToUint8Slow(JSContext* cx, const HandleValue v,
-                                   uint8_t* out) {
+                                   uint8_t* out) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(!v.isInt32());
   double d;
-  if (v.isDouble()) {
+  if (v.isDouble()) {MOZ_RELEASE_ASSERT(0);
     d = v.toDouble();
   } else {
     if (!ToNumberSlow(cx, v, &d)) {
@@ -2064,10 +2064,10 @@ JS_PUBLIC_API bool js::ToUint8Slow(JSCon
  * conversion. Return converted value in *out on success, false on failure.
  */
 JS_PUBLIC_API bool js::ToInt16Slow(JSContext* cx, const HandleValue v,
-                                   int16_t* out) {
+                                   int16_t* out) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(!v.isInt32());
   double d;
-  if (v.isDouble()) {
+  if (v.isDouble()) {MOZ_RELEASE_ASSERT(0);
     d = v.toDouble();
   } else {
     if (!ToNumberSlow(cx, v, &d)) {
@@ -2217,7 +2217,7 @@ bool js_strtod(JSContext* cx, const Char
   size_t length = end - s;
 
   Vector<char, 32> chars(cx);
-  if (!chars.growByUninitialized(length + 1)) {
+  if (!chars.growByUninitialized(length + 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2246,7 +2246,7 @@ bool js_strtod(JSContext* cx, const Char
     }
   }
 
-  if (!EnsureDtoaState(cx)) {
+  if (!EnsureDtoaState(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/proxy/BaseProxyHandler.cpp b/js/src/proxy/BaseProxyHandler.cpp
--- a/js/src/proxy/BaseProxyHandler.cpp
+++ b/js/src/proxy/BaseProxyHandler.cpp
@@ -35,7 +35,7 @@ bool BaseProxyHandler::has(JSContext* cx
 
   // Step 2. (Step 1 is a superfluous assertion.)
   // Non-standard: Use our faster hasOwn trap.
-  if (!hasOwn(cx, proxy, id, bp)) {
+  if (!hasOwn(cx, proxy, id, bp)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -48,7 +48,7 @@ bool BaseProxyHandler::has(JSContext* cx
   // connotations in SpiderMonkey, so let's go with "proto".
   // Step 4.
   RootedObject proto(cx);
-  if (!GetPrototype(cx, proxy, &proto)) {
+  if (!GetPrototype(cx, proxy, &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -94,7 +94,7 @@ bool BaseProxyHandler::get(JSContext* cx
     // connotations in SpiderMonkey, so let's go with "proto".
     // Step 3.a.
     RootedObject proto(cx);
-    if (!GetPrototype(cx, proxy, &proto)) {
+    if (!GetPrototype(cx, proxy, &proto)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -102,7 +102,7 @@ bool BaseProxyHandler::get(JSContext* cx
     if (!proto) {
       vp.setUndefined();
       return true;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Step 3.c.
     return GetProperty(cx, proto, receiver, id, vp);
@@ -112,7 +112,7 @@ bool BaseProxyHandler::get(JSContext* cx
   if (desc.isDataDescriptor()) {
     vp.set(desc.value());
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Step 5.
   MOZ_ASSERT(desc.isAccessorDescriptor());
@@ -163,7 +163,7 @@ bool js::SetPropertyIgnoringNamedGetter(
     // The spec calls this variable "parent", but that word has weird
     // connotations in SpiderMonkey, so let's go with "proto".
     RootedObject proto(cx);
-    if (!GetPrototype(cx, obj, &proto)) {
+    if (!GetPrototype(cx, obj, &proto)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (proto) {
@@ -180,26 +180,26 @@ bool js::SetPropertyIgnoringNamedGetter(
     if (!ownDesc.writable()) {
       return result.fail(JSMSG_READ_ONLY);
     }
-    if (!receiver.isObject()) {
+    if (!receiver.isObject()) {MOZ_RELEASE_ASSERT(0);
       return result.fail(JSMSG_SET_NON_OBJECT_RECEIVER);
     }
     RootedObject receiverObj(cx, &receiver.toObject());
 
     // Steps 5.c-d.
     Rooted<PropertyDescriptor> existingDescriptor(cx);
-    if (!GetOwnPropertyDescriptor(cx, receiverObj, id, &existingDescriptor)) {
+    if (!GetOwnPropertyDescriptor(cx, receiverObj, id, &existingDescriptor)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // Step 5.e.
     if (existingDescriptor.object()) {
       // Step 5.e.i.
-      if (existingDescriptor.isAccessorDescriptor()) {
+      if (existingDescriptor.isAccessorDescriptor()) {MOZ_RELEASE_ASSERT(0);
         return result.fail(JSMSG_OVERWRITING_ACCESSOR);
       }
 
       // Step 5.e.ii.
-      if (!existingDescriptor.writable()) {
+      if (!existingDescriptor.writable()) {MOZ_RELEASE_ASSERT(0);
         return result.fail(JSMSG_READ_ONLY);
       }
     }
diff --git a/js/src/proxy/CrossCompartmentWrapper.cpp b/js/src/proxy/CrossCompartmentWrapper.cpp
--- a/js/src/proxy/CrossCompartmentWrapper.cpp
+++ b/js/src/proxy/CrossCompartmentWrapper.cpp
@@ -101,7 +101,7 @@ bool CrossCompartmentWrapper::getPrototy
   {
     RootedObject wrapped(cx, wrappedObject(wrapper));
     AutoRealm call(cx, wrapped);
-    if (!GetPrototypeIfOrdinary(cx, wrapped, isOrdinary, protop)) {
+    if (!GetPrototypeIfOrdinary(cx, wrapped, isOrdinary, protop)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -170,7 +170,7 @@ bool CrossCompartmentWrapper::get(JSCont
   RootedValue receiverCopy(cx, receiver);
   {
     AutoRealm call(cx, wrappedObject(wrapper));
-    if (!MarkAtoms(cx, id) || !WrapReceiver(cx, wrapper, &receiverCopy)) {
+    if (!MarkAtoms(cx, id) || !WrapReceiver(cx, wrapper, &receiverCopy)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -214,7 +214,7 @@ bool CrossCompartmentWrapper::call(JSCon
     AutoRealm call(cx, wrapped);
 
     args.setCallee(ObjectValue(*wrapped));
-    if (!cx->compartment()->wrap(cx, args.mutableThisv())) {
+    if (!cx->compartment()->wrap(cx, args.mutableThisv())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -239,11 +239,11 @@ bool CrossCompartmentWrapper::construct(
     AutoRealm call(cx, wrapped);
 
     for (size_t n = 0; n < args.length(); ++n) {
-      if (!cx->compartment()->wrap(cx, args[n])) {
+      if (!cx->compartment()->wrap(cx, args[n])) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
-    if (!cx->compartment()->wrap(cx, args.newTarget())) {
+    if (!cx->compartment()->wrap(cx, args.newTarget())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!Wrapper::construct(cx, wrapper, args)) {
@@ -264,7 +264,7 @@ bool CrossCompartmentWrapper::nativeCall
   {
     AutoRealm call(cx, wrapped);
     InvokeArgs dstArgs(cx);
-    if (!dstArgs.init(cx, srcArgs.length())) {
+    if (!dstArgs.init(cx, srcArgs.length())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -275,7 +275,7 @@ bool CrossCompartmentWrapper::nativeCall
     RootedValue source(cx);
     for (; src < srcend; ++src, ++dst) {
       source = *src;
-      if (!cx->compartment()->wrap(cx, &source)) {
+      if (!cx->compartment()->wrap(cx, &source)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       *dst = source.get();
@@ -287,7 +287,7 @@ bool CrossCompartmentWrapper::nativeCall
       if ((src == srcArgs.base() + 1) && dst->isObject()) {
         RootedObject thisObj(cx, &dst->toObject());
         if (thisObj->is<WrapperObject>() &&
-            Wrapper::wrapperHandler(thisObj)->hasSecurityPolicy()) {
+            Wrapper::wrapperHandler(thisObj)->hasSecurityPolicy()) {MOZ_RELEASE_ASSERT(0);
           MOZ_ASSERT(!thisObj->is<CrossCompartmentWrapperObject>());
           *dst = ObjectValue(*Wrapper::wrappedObject(thisObj));
         }
@@ -326,7 +326,7 @@ JSString* CrossCompartmentWrapper::fun_t
   {
     AutoRealm call(cx, wrappedObject(wrapper));
     str = Wrapper::fun_toString(cx, wrapper, isToSource);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -373,7 +373,7 @@ JS_FRIEND_API void js::NukeCrossCompartm
 }
 
 JS_FRIEND_API void js::NukeCrossCompartmentWrapperIfExists(
-    JSContext* cx, JS::Compartment* source, JSObject* target) {
+    JSContext* cx, JS::Compartment* source, JSObject* target) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(source != target->compartment());
   MOZ_ASSERT(!target->is<CrossCompartmentWrapperObject>());
   auto ptr = source->lookupWrapper(target);
@@ -567,7 +567,7 @@ void js::RemapDeadWrapper(JSContext* cx,
   AutoRealmUnchecked ar(cx, wrealm);
   AutoEnterOOMUnsafeRegion oomUnsafe;
   JS::Compartment* wcompartment = wobj->compartment();
-  if (!wcompartment->rewrap(cx, &tobj, wobj)) {
+  if (!wcompartment->rewrap(cx, &tobj, wobj)) {MOZ_RELEASE_ASSERT(0);
     oomUnsafe.crash("js::RemapWrapper");
   }
 
@@ -614,7 +614,7 @@ JS_FRIEND_API bool js::RemapAllWrappersF
   for (CompartmentsIter c(cx->runtime()); !c.done(); c.next()) {
     if (ObjectWrapperMap::Ptr wp = c->lookupWrapper(oldTarget)) {
       // We found a wrapper. Remember and root it.
-      if (!toTransplant.append(WrapperValue(wp))) {
+      if (!toTransplant.append(WrapperValue(wp))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -649,7 +649,7 @@ JS_FRIEND_API bool js::RecomputeWrappers
     for (Compartment::ObjectWrapperEnum e(c, targetFilter); !e.empty();
          e.popFront()) {
       // Add the wrapper to the list.
-      if (!toRecompute.append(WrapperValue(e))) {
+      if (!toRecompute.append(WrapperValue(e))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
diff --git a/js/src/proxy/Proxy.cpp b/js/src/proxy/Proxy.cpp
--- a/js/src/proxy/Proxy.cpp
+++ b/js/src/proxy/Proxy.cpp
@@ -75,7 +75,7 @@ static bool ProxyGetOnExpando(JSContext*
   // proxy, and so can safely call internal methods on it without worrying about
   // exposing information about private names.
   Rooted<PropertyDescriptor> desc(cx);
-  if (!GetOwnPropertyDescriptor(cx, expando, id, &desc)) {
+  if (!GetOwnPropertyDescriptor(cx, expando, id, &desc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -130,7 +130,7 @@ static bool ProxyDefineOnExpando(JSConte
 
 void js::AutoEnterPolicy::reportErrorIfExceptionIsNotPending(JSContext* cx,
                                                              HandleId id) {
-  if (JS_IsExceptionPending(cx)) {
+  if (JS_IsExceptionPending(cx)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -206,7 +206,7 @@ bool Proxy::defineProperty(JSContext* cx
   if (!policy.allowed()) {
     if (!policy.returnValue()) {
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return result.succeed();
   }
 
@@ -224,7 +224,7 @@ bool Proxy::defineProperty(JSContext* cx
 
 bool Proxy::ownPropertyKeys(JSContext* cx, HandleObject proxy,
                             MutableHandleIdVector props) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   const BaseProxyHandler* handler = proxy->as<ProxyObject>().handler();
@@ -238,7 +238,7 @@ bool Proxy::ownPropertyKeys(JSContext* c
 
 bool Proxy::delete_(JSContext* cx, HandleObject proxy, HandleId id,
                     ObjectOpResult& result) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   const BaseProxyHandler* handler = proxy->as<ProxyObject>().handler();
@@ -261,7 +261,7 @@ bool Proxy::delete_(JSContext* cx, Handl
 JS_FRIEND_API bool js::AppendUnique(JSContext* cx, MutableHandleIdVector base,
                                     HandleIdVector others) {
   RootedIdVector uniqueOthers(cx);
-  if (!uniqueOthers.reserve(others.length())) {
+  if (!uniqueOthers.reserve(others.length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (size_t i = 0; i < others.length(); ++i) {
@@ -357,7 +357,7 @@ bool Proxy::has(JSContext* cx, HandleObj
   MOZ_ASSERT_IF(JSID_IS_SYMBOL(id), !JSID_TO_SYMBOL(id)->isPrivateName());
 
   if (handler->hasPrototype()) {
-    if (!handler->hasOwn(cx, proxy, id, bp)) {
+    if (!handler->hasOwn(cx, proxy, id, bp)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (*bp) {
@@ -365,7 +365,7 @@ bool Proxy::has(JSContext* cx, HandleObj
     }
 
     RootedObject proto(cx);
-    if (!GetPrototype(cx, proxy, &proto)) {
+    if (!GetPrototype(cx, proxy, &proto)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!proto) {
@@ -389,7 +389,7 @@ bool js::ProxyHas(JSContext* cx, HandleO
 }
 
 bool Proxy::hasOwn(JSContext* cx, HandleObject proxy, HandleId id, bool* bp) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   const BaseProxyHandler* handler = proxy->as<ProxyObject>().handler();
@@ -458,7 +458,7 @@ MOZ_ALWAYS_INLINE bool Proxy::getInterna
     }
     if (!own) {
       RootedObject proto(cx);
-      if (!GetPrototype(cx, proxy, &proto)) {
+      if (!GetPrototype(cx, proxy, &proto)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (!proto) {
@@ -511,7 +511,7 @@ MOZ_ALWAYS_INLINE bool Proxy::setInterna
   if (!policy.allowed()) {
     if (!policy.returnValue()) {
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return result.succeed();
   }
 
@@ -555,7 +555,7 @@ bool js::ProxySetPropertyByValue(JSConte
                                  HandleValue idVal, HandleValue val,
                                  bool strict) {
   RootedId id(cx);
-  if (!ToPropertyKey(cx, idVal, &id)) {
+  if (!ToPropertyKey(cx, idVal, &id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -583,18 +583,18 @@ bool Proxy::getOwnEnumerablePropertyKeys
 
 bool Proxy::enumerate(JSContext* cx, HandleObject proxy,
                       MutableHandleIdVector props) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   const BaseProxyHandler* handler = proxy->as<ProxyObject>().handler();
   if (handler->hasPrototype()) {
-    if (!Proxy::getOwnEnumerablePropertyKeys(cx, proxy, props)) {
+    if (!Proxy::getOwnEnumerablePropertyKeys(cx, proxy, props)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedObject proto(cx);
-    if (!GetPrototype(cx, proxy, &proto)) {
+    if (!GetPrototype(cx, proxy, &proto)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!proto) {
@@ -604,7 +604,7 @@ bool Proxy::enumerate(JSContext* cx, Han
     cx->check(proxy, proto);
 
     RootedIdVector protoProps(cx);
-    if (!GetPropertyKeys(cx, proto, 0, &protoProps)) {
+    if (!GetPropertyKeys(cx, proto, 0, &protoProps)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     return AppendUnique(cx, props, protoProps);
@@ -643,7 +643,7 @@ bool Proxy::call(JSContext* cx, HandleOb
 }
 
 bool Proxy::construct(JSContext* cx, HandleObject proxy, const CallArgs& args) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   const BaseProxyHandler* handler = proxy->as<ProxyObject>().handler();
@@ -675,7 +675,7 @@ bool Proxy::nativeCall(JSContext* cx, Is
 
 bool Proxy::hasInstance(JSContext* cx, HandleObject proxy, MutableHandleValue v,
                         bool* bp) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   const BaseProxyHandler* handler = proxy->as<ProxyObject>().handler();
@@ -707,7 +707,7 @@ const char* Proxy::className(JSContext* 
   // Check for unbounded recursion, but don't signal an error; className
   // needs to be infallible.
   int stackDummy;
-  if (!JS_CHECK_STACK_SIZE(GetNativeStackLimit(cx), &stackDummy)) {
+  if (!JS_CHECK_STACK_SIZE(GetNativeStackLimit(cx), &stackDummy)) {MOZ_RELEASE_ASSERT(0);
     return "too much recursion";
   }
 
@@ -723,7 +723,7 @@ const char* Proxy::className(JSContext* 
 
 JSString* Proxy::fun_toString(JSContext* cx, HandleObject proxy,
                               bool isToSource) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   const BaseProxyHandler* handler = proxy->as<ProxyObject>().handler();
@@ -756,7 +756,7 @@ JSObject* const TaggedProto::LazyProto =
 /* static */
 bool Proxy::getElements(JSContext* cx, HandleObject proxy, uint32_t begin,
                         uint32_t end, ElementAdder* adder) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   const BaseProxyHandler* handler = proxy->as<ProxyObject>().handler();
diff --git a/js/src/proxy/ScriptedProxyHandler.cpp b/js/src/proxy/ScriptedProxyHandler.cpp
--- a/js/src/proxy/ScriptedProxyHandler.cpp
+++ b/js/src/proxy/ScriptedProxyHandler.cpp
@@ -55,7 +55,7 @@ static bool IsCompatiblePropertyDescript
   // Step 3.
   if (!desc.hasValue() && !desc.hasWritable() && !desc.hasGetterObject() &&
       !desc.hasSetterObject() && !desc.hasEnumerable() &&
-      !desc.hasConfigurable()) {
+      !desc.hasConfigurable()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -76,7 +76,7 @@ static bool IsCompatiblePropertyDescript
     }
 
     bool same = false;
-    if (!SameValue(cx, desc.value(), current->value(), &same)) {
+    if (!SameValue(cx, desc.value(), current->value(), &same)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -107,7 +107,7 @@ static bool IsCompatiblePropertyDescript
   }
 
   // Step 6.
-  if (desc.isGenericDescriptor()) {
+  if (desc.isGenericDescriptor()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -137,7 +137,7 @@ static bool IsCompatiblePropertyDescript
 
       if (desc.hasValue()) {
         bool same;
-        if (!SameValue(cx, desc.value(), current->value(), &same)) {
+        if (!SameValue(cx, desc.value(), current->value(), &same)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         if (!same) {
@@ -147,7 +147,7 @@ static bool IsCompatiblePropertyDescript
           *errorDetails = DETAILS_DIFFERENT_VALUE;
           return true;
         }
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
     return true;
@@ -439,7 +439,7 @@ bool ScriptedProxyHandler::preventExtens
   if (booleanTrapResult) {
     // Step 8a.
     bool targetIsExtensible;
-    if (!IsExtensible(cx, target, &targetIsExtensible)) {
+    if (!IsExtensible(cx, target, &targetIsExtensible)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -544,7 +544,7 @@ bool ScriptedProxyHandler::getOwnPropert
 
   // Step 8.
   RootedValue propKey(cx);
-  if (!IdToStringOrSymbol(cx, id, &propKey)) {
+  if (!IdToStringOrSymbol(cx, id, &propKey)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -561,7 +561,7 @@ bool ScriptedProxyHandler::getOwnPropert
 
   // Step 10.
   Rooted<Maybe<PropertyDescriptor>> targetDesc(cx);
-  if (!GetOwnPropertyDescriptor(cx, target, id, &targetDesc)) {
+  if (!GetOwnPropertyDescriptor(cx, target, id, &targetDesc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -580,7 +580,7 @@ bool ScriptedProxyHandler::getOwnPropert
 
     // Steps 11c-d.
     bool extensibleTarget;
-    if (!IsExtensible(cx, target, &extensibleTarget)) {
+    if (!IsExtensible(cx, target, &extensibleTarget)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -596,15 +596,15 @@ bool ScriptedProxyHandler::getOwnPropert
 
   // Step 12.
   bool extensibleTarget;
-  if (!IsExtensible(cx, target, &extensibleTarget)) {
+  if (!IsExtensible(cx, target, &extensibleTarget)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Step 13.
   Rooted<PropertyDescriptor> resultDesc(cx);
-  if (!ToPropertyDescriptor(cx, trapResult, true, &resultDesc)) {
+  if (!ToPropertyDescriptor(cx, trapResult, true, &resultDesc)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Step 14.
   CompletePropertyDescriptor(&resultDesc);
@@ -674,13 +674,13 @@ bool ScriptedProxyHandler::definePropert
 
   // Step 8.
   RootedValue descObj(cx);
-  if (!FromPropertyDescriptorToObject(cx, desc, &descObj)) {
+  if (!FromPropertyDescriptorToObject(cx, desc, &descObj)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Step 9.
   RootedValue propKey(cx);
-  if (!IdToStringOrSymbol(cx, id, &propKey)) {
+  if (!IdToStringOrSymbol(cx, id, &propKey)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -705,13 +705,13 @@ bool ScriptedProxyHandler::definePropert
 
   // Step 11.
   Rooted<Maybe<PropertyDescriptor>> targetDesc(cx);
-  if (!GetOwnPropertyDescriptor(cx, target, id, &targetDesc)) {
+  if (!GetOwnPropertyDescriptor(cx, target, id, &targetDesc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Step 12.
   bool extensibleTarget;
-  if (!IsExtensible(cx, target, &extensibleTarget)) {
+  if (!IsExtensible(cx, target, &extensibleTarget)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -729,7 +729,7 @@ bool ScriptedProxyHandler::definePropert
     if (settingConfigFalse) {
       return js::Throw(cx, id, JSMSG_CANT_DEFINE_NE_AS_NC);
     }
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     // Step 16a.
     const char* errorDetails = nullptr;
     if (!IsCompatiblePropertyDescriptor(cx, extensibleTarget, desc, targetDesc,
@@ -778,7 +778,7 @@ static bool CreateFilteredListFromArrayL
 
   // Step 3.
   uint32_t len;
-  if (!GetLengthProperty(cx, obj, &len)) {
+  if (!GetLengthProperty(cx, obj, &len)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -788,7 +788,7 @@ static bool CreateFilteredListFromArrayL
   uint32_t index = 0;
   while (index < len) {
     // Steps 6a-b.
-    if (!GetElement(cx, obj, obj, index, &next)) {
+    if (!GetElement(cx, obj, obj, index, &next)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -799,7 +799,7 @@ static bool CreateFilteredListFromArrayL
       return false;
     }
 
-    if (!PrimitiveValueToId<CanGC>(cx, next, &id)) {
+    if (!PrimitiveValueToId<CanGC>(cx, next, &id)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -869,14 +869,14 @@ bool ScriptedProxyHandler::ownPropertyKe
       return js::Throw(cx, trapResult[i], JSMSG_OWNKEYS_DUPLICATE);
     }
 
-    if (!uncheckedResultKeys.add(ptr, trapResult[i])) {
+    if (!uncheckedResultKeys.add(ptr, trapResult[i])) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // Step 10.
   bool extensibleTarget;
-  if (!IsExtensible(cx, target, &extensibleTarget)) {
+  if (!IsExtensible(cx, target, &extensibleTarget)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -884,7 +884,7 @@ bool ScriptedProxyHandler::ownPropertyKe
   RootedIdVector targetKeys(cx);
   if (!GetPropertyKeys(cx, target,
                        JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS,
-                       &targetKeys)) {
+                       &targetKeys)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -896,17 +896,17 @@ bool ScriptedProxyHandler::ownPropertyKe
   Rooted<Maybe<PropertyDescriptor>> desc(cx);
   for (size_t i = 0; i < targetKeys.length(); ++i) {
     // Step 16.a.
-    if (!GetOwnPropertyDescriptor(cx, target, targetKeys[i], &desc)) {
+    if (!GetOwnPropertyDescriptor(cx, target, targetKeys[i], &desc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // Steps 16.b-c.
     if (desc.isSome() && !desc->configurable()) {
-      if (!targetNonconfigurableKeys.append(targetKeys[i])) {
+      if (!targetNonconfigurableKeys.append(targetKeys[i])) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
-      if (!targetConfigurableKeys.append(targetKeys[i])) {
+      if (!targetConfigurableKeys.append(targetKeys[i])) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -994,7 +994,7 @@ bool ScriptedProxyHandler::delete_(JSCon
   bool booleanTrapResult;
   {
     RootedValue value(cx);
-    if (!IdToStringOrSymbol(cx, id, &value)) {
+    if (!IdToStringOrSymbol(cx, id, &value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1014,7 +1014,7 @@ bool ScriptedProxyHandler::delete_(JSCon
 
   // Step 10.
   Rooted<Maybe<PropertyDescriptor>> desc(cx);
-  if (!GetOwnPropertyDescriptor(cx, target, id, &desc)) {
+  if (!GetOwnPropertyDescriptor(cx, target, id, &desc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1029,7 +1029,7 @@ bool ScriptedProxyHandler::delete_(JSCon
   }
 
   bool extensible;
-  if (!IsExtensible(cx, target, &extensible)) {
+  if (!IsExtensible(cx, target, &extensible)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1070,7 +1070,7 @@ bool ScriptedProxyHandler::has(JSContext
 
   // Step 8.
   RootedValue value(cx);
-  if (!IdToStringOrSymbol(cx, id, &value)) {
+  if (!IdToStringOrSymbol(cx, id, &value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1086,7 +1086,7 @@ bool ScriptedProxyHandler::has(JSContext
   if (!booleanTrapResult) {
     // Step 9a.
     Rooted<Maybe<PropertyDescriptor>> desc(cx);
-    if (!GetOwnPropertyDescriptor(cx, target, id, &desc)) {
+    if (!GetOwnPropertyDescriptor(cx, target, id, &desc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1099,7 +1099,7 @@ bool ScriptedProxyHandler::has(JSContext
 
       // Step 9b(ii).
       bool extensible;
-      if (!IsExtensible(cx, target, &extensible)) {
+      if (!IsExtensible(cx, target, &extensible)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -1145,7 +1145,7 @@ bool ScriptedProxyHandler::get(JSContext
 
   // Step 8.
   RootedValue value(cx);
-  if (!IdToStringOrSymbol(cx, id, &value)) {
+  if (!IdToStringOrSymbol(cx, id, &value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1165,7 +1165,7 @@ bool ScriptedProxyHandler::get(JSContext
 
   // Step 9.
   Rooted<Maybe<PropertyDescriptor>> desc(cx);
-  if (!GetOwnPropertyDescriptor(cx, target, id, &desc)) {
+  if (!GetOwnPropertyDescriptor(cx, target, id, &desc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1175,7 +1175,7 @@ bool ScriptedProxyHandler::get(JSContext
     if (desc->isDataDescriptor() && !desc->configurable() &&
         !desc->writable()) {
       bool same;
-      if (!SameValue(cx, trapResult, desc->value(), &same)) {
+      if (!SameValue(cx, trapResult, desc->value(), &same)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (!same) {
@@ -1225,7 +1225,7 @@ bool ScriptedProxyHandler::set(JSContext
 
   // Step 8.
   RootedValue value(cx);
-  if (!IdToStringOrSymbol(cx, id, &value)) {
+  if (!IdToStringOrSymbol(cx, id, &value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1251,7 +1251,7 @@ bool ScriptedProxyHandler::set(JSContext
 
   // Step 10.
   Rooted<Maybe<PropertyDescriptor>> desc(cx);
-  if (!GetOwnPropertyDescriptor(cx, target, id, &desc)) {
+  if (!GetOwnPropertyDescriptor(cx, target, id, &desc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1261,7 +1261,7 @@ bool ScriptedProxyHandler::set(JSContext
     if (desc->isDataDescriptor() && !desc->configurable() &&
         !desc->writable()) {
       bool same;
-      if (!SameValue(cx, v, desc->value(), &same)) {
+      if (!SameValue(cx, v, desc->value(), &same)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (!same) {
@@ -1305,7 +1305,7 @@ bool ScriptedProxyHandler::call(JSContex
   // Step 6.
   if (trap.isUndefined()) {
     InvokeArgs iargs(cx);
-    if (!FillArgumentsFromArraylike(cx, iargs, args)) {
+    if (!FillArgumentsFromArraylike(cx, iargs, args)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1356,7 +1356,7 @@ bool ScriptedProxyHandler::construct(JSC
   // Step 6.
   if (trap.isUndefined()) {
     ConstructArgs cargs(cx);
-    if (!FillArgumentsFromArraylike(cx, cargs, args)) {
+    if (!FillArgumentsFromArraylike(cx, cargs, args)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1373,7 +1373,7 @@ bool ScriptedProxyHandler::construct(JSC
   // Step 7.
   RootedObject argArray(cx,
                         NewDenseCopiedArray(cx, args.length(), args.array()));
-  if (!argArray) {
+  if (!argArray) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1557,7 +1557,7 @@ static bool RevokeProxy(JSContext* cx, u
 bool js::proxy_revocable(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (!ProxyCreate(cx, args, "Proxy.revocable")) {
+  if (!ProxyCreate(cx, args, "Proxy.revocable")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1567,14 +1567,14 @@ bool js::proxy_revocable(JSContext* cx, 
   RootedFunction revoker(
       cx, NewNativeFunction(cx, RevokeProxy, 0, nullptr,
                             gc::AllocKind::FUNCTION_EXTENDED, GenericObject));
-  if (!revoker) {
+  if (!revoker) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   revoker->initExtendedSlot(ScriptedProxyHandler::REVOKE_SLOT, proxyVal);
 
   RootedPlainObject result(cx, NewBuiltinClassInstance<PlainObject>(cx));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/proxy/Wrapper.cpp b/js/src/proxy/Wrapper.cpp
--- a/js/src/proxy/Wrapper.cpp
+++ b/js/src/proxy/Wrapper.cpp
@@ -26,7 +26,7 @@
 using namespace js;
 
 bool Wrapper::finalizeInBackground(const Value& priv) const {
-  if (!priv.isObject()) {
+  if (!priv.isObject()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -170,14 +170,14 @@ bool ForwardingProxyHandler::construct(J
   assertEnteredPolicy(cx, proxy, JSID_VOID, CALL);
 
   RootedValue target(cx, proxy->as<ProxyObject>().private_());
-  if (!IsConstructor(target)) {
+  if (!IsConstructor(target)) {MOZ_RELEASE_ASSERT(0);
     ReportValueError(cx, JSMSG_NOT_CONSTRUCTOR, JSDVG_IGNORE_STACK, target,
                      nullptr);
     return false;
   }
 
   ConstructArgs cargs(cx);
-  if (!FillArgumentsFromArraylike(cx, cargs, args)) {
+  if (!FillArgumentsFromArraylike(cx, cargs, args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/shell/ModuleLoader.cpp b/js/src/shell/ModuleLoader.cpp
--- a/js/src/shell/ModuleLoader.cpp
+++ b/js/src/shell/ModuleLoader.cpp
@@ -41,7 +41,7 @@ static JSString* ExtractJavaScriptURLSou
 
 bool ModuleLoader::init(JSContext* cx, HandleString loadPath) {
   loadPathStr = AtomizeString(cx, loadPath, PinAtom);
-  if (!loadPathStr) {
+  if (!loadPathStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -108,7 +108,7 @@ bool ModuleLoader::loadRootModule(JSCont
 bool ModuleLoader::registerTestModule(JSContext* cx, HandleString specifier,
                                       HandleModuleObject module) {
   RootedLinearString path(cx, resolve(cx, specifier, UndefinedHandleValue));
-  if (!path) {
+  if (!path) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -150,7 +150,7 @@ bool ModuleLoader::populateImportMeta(JS
                                       JS::HandleObject metaObject) {
   RootedLinearString path(cx);
   if (!privateValue.isUndefined()) {
-    if (!getScriptPath(cx, privateValue, &path)) {
+    if (!getScriptPath(cx, privateValue, &path)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -185,19 +185,19 @@ bool ModuleLoader::dynamicImport(JSConte
       !JS_DefineProperty(cx, closure, "specifier", specifierValue,
                          JSPROP_ENUMERATE) ||
       !JS_DefineProperty(cx, closure, "promise", promiseValue,
-                         JSPROP_ENUMERATE)) {
+                         JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedFunction onResolved(
       cx, NewNativeFunction(cx, DynamicImportDelayFulfilled, 1, nullptr));
-  if (!onResolved) {
+  if (!onResolved) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedFunction onRejected(
       cx, NewNativeFunction(cx, DynamicImportDelayRejected, 1, nullptr));
-  if (!onRejected) {
+  if (!onRejected) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -279,7 +279,7 @@ JSLinearString* ModuleLoader::resolve(JS
   }
 
   RootedLinearString name(cx, JS_EnsureLinearString(cx, nameArg));
-  if (!name) {
+  if (!name) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -298,17 +298,17 @@ JSLinearString* ModuleLoader::resolve(JS
   RootedString path(cx, loadPathStr);
 
   if (isRelative) {
-    if (referencingInfo.isUndefined()) {
+    if (referencingInfo.isUndefined()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "No referencing module for relative import");
       return nullptr;
     }
 
     RootedLinearString refPath(cx);
-    if (!getScriptPath(cx, referencingInfo, &refPath)) {
+    if (!getScriptPath(cx, referencingInfo, &refPath)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (!refPath) {
+    if (!refPath) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "No path set for referencing module");
       return nullptr;
     }
@@ -319,7 +319,7 @@ JSLinearString* ModuleLoader::resolve(JS
 #endif
     if (sepIndex >= 0) {
       path = SubString(cx, refPath, 0, sepIndex);
-      if (!path) {
+      if (!path) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -328,7 +328,7 @@ JSLinearString* ModuleLoader::resolve(JS
   RootedString result(cx);
   RootedString pathSep(cx, pathSeparatorStr);
   result = JS_ConcatStrings(cx, path, pathSep);
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -342,17 +342,17 @@ JSLinearString* ModuleLoader::resolve(JS
 
 JSObject* ModuleLoader::loadAndParse(JSContext* cx, HandleString pathArg) {
   RootedLinearString path(cx, JS_EnsureLinearString(cx, pathArg));
-  if (!path) {
+  if (!path) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   path = normalizePath(cx, path);
-  if (!path) {
+  if (!path) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedObject module(cx);
-  if (!lookupModuleInRegistry(cx, path, &module)) {
+  if (!lookupModuleInRegistry(cx, path, &module)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -361,7 +361,7 @@ JSObject* ModuleLoader::loadAndParse(JSC
   }
 
   UniqueChars filename = JS_EncodeStringToLatin1(cx, path);
-  if (!filename) {
+  if (!filename) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -374,14 +374,14 @@ JSObject* ModuleLoader::loadAndParse(JSC
   }
 
   JS::AutoStableStringChars stableChars(cx);
-  if (!stableChars.initTwoByte(cx, source)) {
+  if (!stableChars.initTwoByte(cx, source)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   const char16_t* chars = stableChars.twoByteRange().begin().get();
   JS::SourceText<char16_t> srcBuf;
   if (!srcBuf.init(cx, chars, source->length(),
-                   JS::SourceOwnership::Borrowed)) {
+                   JS::SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -391,7 +391,7 @@ JSObject* ModuleLoader::loadAndParse(JSC
   }
 
   RootedObject info(cx, CreateScriptPrivate(cx, path));
-  if (!info) {
+  if (!info) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -409,13 +409,13 @@ bool ModuleLoader::lookupModuleInRegistr
   moduleOut.set(nullptr);
 
   RootedObject registry(cx, getOrCreateModuleRegistry(cx));
-  if (!registry) {
+  if (!registry) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedValue pathValue(cx, StringValue(path));
   RootedValue moduleValue(cx);
-  if (!JS::MapGet(cx, registry, pathValue, &moduleValue)) {
+  if (!JS::MapGet(cx, registry, pathValue, &moduleValue)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -460,7 +460,7 @@ bool ModuleLoader::getScriptPath(JSConte
 
   RootedObject infoObj(cx, &privateValue.toObject());
   RootedValue pathValue(cx);
-  if (!JS_GetProperty(cx, infoObj, "path", &pathValue)) {
+  if (!JS_GetProperty(cx, infoObj, "path", &pathValue)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -484,7 +484,7 @@ JSLinearString* ModuleLoader::normalizeP
 #ifdef XP_WIN
   // Replace all forward slashes with backward slashes.
   path = ReplaceCharGlobally(cx, path, u'/', PathSeparator);
-  if (!path) {
+  if (!path) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -494,7 +494,7 @@ JSLinearString* ModuleLoader::normalizeP
       CharAt(path, 1) == u':' && CharAt(path, 2) == u'\\') {
     drive = SubString(cx, path, 0, 2);
     path = SubString(cx, path, 2);
-    if (!drive || !path) {
+    if (!drive || !path) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -510,7 +510,7 @@ JSLinearString* ModuleLoader::normalizeP
     }
 
     RootedLinearString part(cx, SubString(cx, path, lastSep, i));
-    if (!part) {
+    if (!part) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -523,7 +523,7 @@ JSLinearString* ModuleLoader::normalizeP
 
     if (StringEquals(part, u"..") && !components.empty()) {
       // Replace "./.." with "..".
-      if (StringEquals(components.back(), u".")) {
+      if (StringEquals(components.back(), u".")) {MOZ_RELEASE_ASSERT(0);
         components.back() = part;
         continue;
       }
@@ -534,17 +534,17 @@ JSLinearString* ModuleLoader::normalizeP
           !StringEquals(components.back(), u"..")) {
         components.popBack();
         continue;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
-    if (!components.append(part)) {
+    if (!components.append(part)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
 
   RootedLinearString pathSep(cx, pathSeparatorStr);
   RootedString normalized(cx, JoinStrings(cx, components, pathSep));
-  if (!normalized) {
+  if (!normalized) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/shell/OSObject.cpp b/js/src/shell/OSObject.cpp
--- a/js/src/shell/OSObject.cpp
+++ b/js/src/shell/OSObject.cpp
@@ -107,7 +107,7 @@ JSString* ResolvePath(JSContext* cx, Han
   }
 
   RootedLinearString str(cx, JS_EnsureLinearString(cx, filenameStr));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -116,23 +116,23 @@ JSString* ResolvePath(JSContext* cx, Han
   }
 
   UniqueChars filename = JS_EncodeStringToLatin1(cx, str);
-  if (!filename) {
+  if (!filename) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   JS::AutoFilename scriptFilename;
   if (resolveMode == ScriptRelative) {
     // Get the currently executing script's name.
-    if (!DescribeScriptedCaller(cx, &scriptFilename)) {
+    if (!DescribeScriptedCaller(cx, &scriptFilename)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (!scriptFilename.get()) {
+    if (!scriptFilename.get()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     if (strcmp(scriptFilename.get(), "-e") == 0 ||
-        strcmp(scriptFilename.get(), "typein") == 0) {
+        strcmp(scriptFilename.get(), "typein") == 0) {MOZ_RELEASE_ASSERT(0);
       resolveMode = RootRelative;
     }
   }
@@ -144,7 +144,7 @@ JSString* ResolvePath(JSContext* cx, Han
     _splitpath(scriptFilename.get(), nullptr, buffer, nullptr, nullptr);
 #else
     strncpy(buffer, scriptFilename.get(), PATH_MAX);
-    if (buffer[PATH_MAX - 1] != '\0') {
+    if (buffer[PATH_MAX - 1] != '\0') {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -154,7 +154,7 @@ JSString* ResolvePath(JSContext* cx, Han
 #endif
   } else {
     const char* cwd = getcwd(buffer, PATH_MAX);
-    if (!cwd) {
+    if (!cwd) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -171,12 +171,12 @@ JSString* ResolvePath(JSContext* cx, Han
 
 JSObject* FileAsTypedArray(JSContext* cx, JS::HandleString pathnameStr) {
   UniqueChars pathname = JS_EncodeStringToLatin1(cx, pathnameStr);
-  if (!pathname) {
+  if (!pathname) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   FILE* file = fopen(pathname.get(), "rb");
-  if (!file) {
+  if (!file) {MOZ_RELEASE_ASSERT(0);
     /*
      * Use Latin1 variant here because the encoding of the return value of
      * strerror function can be non-UTF-8.
@@ -188,32 +188,32 @@ JSObject* FileAsTypedArray(JSContext* cx
   AutoCloseFile autoClose(file);
 
   RootedObject obj(cx);
-  if (fseek(file, 0, SEEK_END) != 0) {
+  if (fseek(file, 0, SEEK_END) != 0) {MOZ_RELEASE_ASSERT(0);
     pathname = JS_EncodeStringToUTF8(cx, pathnameStr);
-    if (!pathname) {
+    if (!pathname) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorUTF8(cx, "can't seek end of %s", pathname.get());
   } else {
     size_t len = ftell(file);
-    if (fseek(file, 0, SEEK_SET) != 0) {
+    if (fseek(file, 0, SEEK_SET) != 0) {MOZ_RELEASE_ASSERT(0);
       pathname = JS_EncodeStringToUTF8(cx, pathnameStr);
-      if (!pathname) {
+      if (!pathname) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorUTF8(cx, "can't seek start of %s", pathname.get());
     } else {
-      if (len > ArrayBufferObject::maxBufferByteLength()) {
+      if (len > ArrayBufferObject::maxBufferByteLength()) {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorUTF8(cx, "file %s is too large for a Uint8Array",
                            pathname.get());
         return nullptr;
       }
       obj = JS_NewUint8Array(cx, len);
-      if (!obj) {
+      if (!obj) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       js::TypedArrayObject& ta = obj->as<js::TypedArrayObject>();
-      if (ta.isSharedMemory()) {
+      if (ta.isSharedMemory()) {MOZ_RELEASE_ASSERT(0);
         // Must opt in to use shared memory.  For now, don't.
         //
         // (It is incorrect to read into the buffer without
@@ -224,9 +224,9 @@ JSObject* FileAsTypedArray(JSContext* cx
         // race-safe primitive to copy memory into the
         // buffer.)
         pathname = JS_EncodeStringToUTF8(cx, pathnameStr);
-        if (!pathname) {
+        if (!pathname) {MOZ_RELEASE_ASSERT(0);
           return nullptr;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorUTF8(cx, "can't read %s: shared memory buffer",
                            pathname.get());
         return nullptr;
@@ -234,14 +234,14 @@ JSObject* FileAsTypedArray(JSContext* cx
       char* buf = static_cast<char*>(ta.dataPointerUnshared());
       size_t cc = fread(buf, 1, len, file);
       if (cc != len) {
-        if (ptrdiff_t(cc) < 0) {
+        if (ptrdiff_t(cc) < 0) {MOZ_RELEASE_ASSERT(0);
           /*
            * Use Latin1 variant here because the encoding of the return
            * value of strerror function can be non-UTF-8.
            */
           JS_ReportErrorLatin1(cx, "can't read %s: %s", pathname.get(),
                                strerror(errno));
-        } else {
+        } else {MOZ_RELEASE_ASSERT(0);
           pathname = JS_EncodeStringToUTF8(cx, pathnameStr);
           if (!pathname) {
             return nullptr;
@@ -258,7 +258,7 @@ JSObject* FileAsTypedArray(JSContext* cx
 /**
  * Return the current working directory or |null| on failure.
  */
-UniqueChars GetCWD() {
+UniqueChars GetCWD() {MOZ_RELEASE_ASSERT(0);
   char buffer[PATH_MAX + 1];
   const char* cwd = getcwd(buffer, PATH_MAX);
   if (!cwd) {
@@ -271,7 +271,7 @@ static bool ReadFile(JSContext* cx, unsi
                      bool scriptRelative) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() < 1 || args.length() > 2) {
+  if (args.length() < 1 || args.length() > 2) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(
         cx, js::shell::my_GetErrorMessage, nullptr,
         args.length() < 1 ? JSSMSG_NOT_ENOUGH_ARGS : JSSMSG_TOO_MANY_ARGS,
@@ -279,7 +279,7 @@ static bool ReadFile(JSContext* cx, unsi
     return false;
   }
 
-  if (!args[0].isString() || (args.length() == 2 && !args[1].isString())) {
+  if (!args[0].isString() || (args.length() == 2 && !args[1].isString())) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, js::shell::my_GetErrorMessage, nullptr,
                               JSSMSG_INVALID_ARGS, "snarf");
     return false;
@@ -289,22 +289,22 @@ static bool ReadFile(JSContext* cx, unsi
   RootedString str(
       cx, js::shell::ResolvePath(
               cx, givenPath, scriptRelative ? ScriptRelative : RootRelative));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (args.length() > 1) {
     JSString* opt = JS::ToString(cx, args[1]);
-    if (!opt) {
+    if (!opt) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     bool match;
-    if (!JS_StringEqualsLiteral(cx, opt, "binary", &match)) {
+    if (!JS_StringEqualsLiteral(cx, opt, "binary", &match)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (match) {
       JSObject* obj;
-      if (!(obj = FileAsTypedArray(cx, str))) {
+      if (!(obj = FileAsTypedArray(cx, str))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       args.rval().setObject(*obj);
@@ -329,31 +329,31 @@ static bool osfile_readRelativeToScript(
 }
 
 static bool ListDir(JSContext* cx, unsigned argc, Value* vp,
-                    PathResolutionMode resolveMode) {
+                    PathResolutionMode resolveMode) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() != 1) {
+  if (args.length() != 1) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "os.file.listDir requires 1 argument");
     return false;
   }
 
-  if (!args[0].isString()) {
+  if (!args[0].isString()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, js::shell::my_GetErrorMessage, nullptr,
                               JSSMSG_INVALID_ARGS, "os.file.listDir");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedString givenPath(cx, args[0].toString());
   RootedString str(cx, ResolvePath(cx, givenPath, resolveMode));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   UniqueChars pathname = JS_EncodeStringToLatin1(cx, str);
-  if (!pathname) {
+  if (!pathname) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "os.file.listDir cannot convert path to Latin1");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedValueVector elems(cx);
   auto append = [&](const char* name) -> bool {
@@ -368,9 +368,9 @@ static bool ListDir(JSContext* cx, unsig
   };
 
 #if defined(XP_UNIX)
-  {
+  {MOZ_RELEASE_ASSERT(0);
     DIR* dir = opendir(pathname.get());
-    if (!dir) {
+    if (!dir) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "os.file.listDir is unable to open: %s",
                           pathname.get());
       return false;
@@ -381,21 +381,21 @@ static bool ListDir(JSContext* cx, unsig
       }
     });
 
-    while (struct dirent* entry = readdir(dir)) {
-      if (!append(entry->d_name)) {
+    while (struct dirent* entry = readdir(dir)) {MOZ_RELEASE_ASSERT(0);
+      if (!append(entry->d_name)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
-    }
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
   }
 #elif defined(XP_WIN)
-  {
+  {MOZ_RELEASE_ASSERT(0);
     const size_t pathlen = strlen(pathname.get());
     Vector<char> pattern(cx);
     if (!pattern.append(pathname.get(), pathlen) ||
-        !pattern.append(PathSeparator) || !pattern.append("*", 2)) {
+        !pattern.append(PathSeparator) || !pattern.append("*", 2)) {MOZ_RELEASE_ASSERT(0);
       js::ReportOutOfMemory(cx);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     WIN32_FIND_DATA FindFileData;
     HANDLE hFind = FindFirstFile(pattern.begin(), &FindFileData);
@@ -405,12 +405,12 @@ static bool ListDir(JSContext* cx, unsig
       }
     });
     for (bool found = (hFind != INVALID_HANDLE_VALUE); found;
-         found = FindNextFile(hFind, &FindFileData)) {
-      if (!append(FindFileData.cFileName)) {
+         found = FindNextFile(hFind, &FindFileData)) {MOZ_RELEASE_ASSERT(0);
+      if (!append(FindFileData.cFileName)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
-    }
-  }
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
 #endif
 
   JSObject* array = JS::NewArrayObject(cx, elems);
@@ -432,29 +432,29 @@ static bool osfile_listDirRelativeToScri
 }
 
 static bool osfile_writeTypedArrayToFile(JSContext* cx, unsigned argc,
-                                         Value* vp) {
+                                         Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
   if (args.length() != 2 || !args[0].isString() || !args[1].isObject() ||
-      !args[1].toObject().is<TypedArrayObject>()) {
+      !args[1].toObject().is<TypedArrayObject>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,
                               JSSMSG_INVALID_ARGS, "writeTypedArrayToFile");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedString givenPath(cx, args[0].toString());
   RootedString str(cx, ResolvePath(cx, givenPath, RootRelative));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   UniqueChars filename = JS_EncodeStringToLatin1(cx, str);
-  if (!filename) {
+  if (!filename) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   FILE* file = fopen(filename.get(), "wb");
-  if (!file) {
+  if (!file) {MOZ_RELEASE_ASSERT(0);
     /*
      * Use Latin1 variant here because the encoding of the return value of
      * strerror function can be non-UTF-8.
@@ -462,27 +462,27 @@ static bool osfile_writeTypedArrayToFile
     JS_ReportErrorLatin1(cx, "can't open %s: %s", filename.get(),
                          strerror(errno));
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   AutoCloseFile autoClose(file);
 
   TypedArrayObject* obj = &args[1].toObject().as<TypedArrayObject>();
 
-  if (obj->isSharedMemory()) {
+  if (obj->isSharedMemory()) {MOZ_RELEASE_ASSERT(0);
     // Must opt in to use shared memory.  For now, don't.
     //
     // See further comments in FileAsTypedArray, above.
     filename = JS_EncodeStringToUTF8(cx, str);
-    if (!filename) {
+    if (!filename) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorUTF8(cx, "can't write %s: shared memory buffer",
                        filename.get());
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   void* buf = obj->dataPointerUnshared();
   size_t length = obj->length().get();
   if (fwrite(buf, obj->bytesPerElement(), length, file) != length ||
-      !autoClose.release()) {
+      !autoClose.release()) {MOZ_RELEASE_ASSERT(0);
     filename = JS_EncodeStringToUTF8(cx, str);
     if (!filename) {
       return false;
@@ -498,7 +498,7 @@ static bool osfile_writeTypedArrayToFile
 /* static */
 RCFile* RCFile::create(JSContext* cx, const char* filename, const char* mode) {
   FILE* fp = fopen(filename, mode);
-  if (!fp) {
+  if (!fp) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -511,7 +511,7 @@ RCFile* RCFile::create(JSContext* cx, co
   return file;
 }
 
-void RCFile::close() {
+void RCFile::close() {MOZ_RELEASE_ASSERT(0);
   if (fp) {
     fclose(fp);
   }
@@ -557,7 +557,7 @@ class FileObject : public NativeObject {
     return file && file->isOpen();
   }
 
-  void close() {
+  void close() {MOZ_RELEASE_ASSERT(0);
     if (!isOpen()) {
       return;
     }
@@ -593,15 +593,15 @@ const JSClass FileObject::class_ = {
 static FileObject* redirect(JSContext* cx, HandleString relFilename,
                             RCFile** globalFile) {
   RootedString filename(cx, ResolvePath(cx, relFilename, RootRelative));
-  if (!filename) {
+  if (!filename) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   UniqueChars filenameABS = JS_EncodeStringToLatin1(cx, filename);
-  if (!filenameABS) {
+  if (!filenameABS) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   RCFile* file = RCFile::create(cx, filenameABS.get(), "wb");
-  if (!file) {
+  if (!file) {MOZ_RELEASE_ASSERT(0);
     /*
      * Use Latin1 variant here because the encoding of the return value of
      * strerror function can be non-UTF-8.
@@ -629,7 +629,7 @@ static FileObject* redirect(JSContext* c
 }
 
 static bool Redirect(JSContext* cx, const CallArgs& args, RCFile** outFile) {
-  if (args.length() > 1) {
+  if (args.length() > 1) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, js::shell::my_GetErrorMessage, nullptr,
                               JSSMSG_INVALID_ARGS, "redirect");
     return false;
@@ -637,23 +637,23 @@ static bool Redirect(JSContext* cx, cons
 
   RCFile* oldFile = *outFile;
   RootedObject oldFileObj(cx, FileObject::create(cx, oldFile));
-  if (!oldFileObj) {
+  if (!oldFileObj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (args.get(0).isUndefined()) {
+  if (args.get(0).isUndefined()) {MOZ_RELEASE_ASSERT(0);
     args.rval().setObject(*oldFileObj);
     return true;
   }
 
-  if (args[0].isObject()) {
+  if (args[0].isObject()) {MOZ_RELEASE_ASSERT(0);
     Rooted<FileObject*> fileObj(cx,
                                 args[0].toObject().maybeUnwrapIf<FileObject>());
-    if (!fileObj) {
+    if (!fileObj) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx, js::shell::my_GetErrorMessage, nullptr,
                                 JSSMSG_INVALID_ARGS, "redirect");
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Passed in a FileObject. Create a FileObject for the previous
     // global file, and set the global file to the passed-in one.
@@ -666,11 +666,11 @@ static bool Redirect(JSContext* cx, cons
   }
 
   RootedString filename(cx);
-  if (!args[0].isNull()) {
+  if (!args[0].isNull()) {MOZ_RELEASE_ASSERT(0);
     filename = JS::ToString(cx, args[0]);
-    if (!filename) {
+    if (!filename) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   if (!redirect(cx, filename, outFile)) {
@@ -693,11 +693,11 @@ static bool osfile_redirectError(JSConte
   return Redirect(cx, args, scx->errFilePtr);
 }
 
-static bool osfile_close(JSContext* cx, unsigned argc, Value* vp) {
+static bool osfile_close(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
   Rooted<FileObject*> fileObj(cx);
-  if (args.get(0).isObject()) {
+  if (args.get(0).isObject()) {MOZ_RELEASE_ASSERT(0);
     fileObj = args[0].toObject().maybeUnwrapIf<FileObject>();
   }
 
@@ -765,14 +765,14 @@ static const JSFunctionSpecWithHelp osfi
 };
 // clang-format on
 
-static bool ospath_isAbsolute(JSContext* cx, unsigned argc, Value* vp) {
+static bool ospath_isAbsolute(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() != 1 || !args[0].isString()) {
+  if (args.length() != 1 || !args[0].isString()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,
                               JSSMSG_INVALID_ARGS, "isAbsolute");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedLinearString str(cx, JS_EnsureLinearString(cx, args[0].toString()));
   if (!str) {
@@ -783,48 +783,48 @@ static bool ospath_isAbsolute(JSContext*
   return true;
 }
 
-static bool ospath_join(JSContext* cx, unsigned argc, Value* vp) {
+static bool ospath_join(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() < 1) {
+  if (args.length() < 1) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,
                               JSSMSG_INVALID_ARGS, "join");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // This function doesn't take into account some aspects of Windows paths,
   // e.g. the drive letter is always reset when an absolute path is appended.
 
   JSStringBuilder buffer(cx);
 
-  for (unsigned i = 0; i < args.length(); i++) {
-    if (!args[i].isString()) {
+  for (unsigned i = 0; i < args.length(); i++) {MOZ_RELEASE_ASSERT(0);
+    if (!args[i].isString()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "join expects string arguments only");
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     RootedLinearString str(cx, JS_EnsureLinearString(cx, args[i].toString()));
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (IsAbsolutePath(str)) {
+    if (IsAbsolutePath(str)) {MOZ_RELEASE_ASSERT(0);
       MOZ_ALWAYS_TRUE(buffer.resize(0));
-    } else if (i != 0) {
+    } else if (i != 0) {MOZ_RELEASE_ASSERT(0);
       UniqueChars path = JS_EncodeStringToLatin1(cx, str);
-      if (!path) {
+      if (!path) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
-      if (!buffer.append(PathSeparator)) {
+      if (!buffer.append(PathSeparator)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
-    if (!buffer.append(args[i].toString())) {
+    if (!buffer.append(args[i].toString())) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
-  }
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
 
   JSString* result = buffer.finishString();
   if (!result) {
@@ -851,22 +851,22 @@ static const JSFunctionSpecWithHelp ospa
 
 static bool os_getenv(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (args.length() < 1) {
+  if (args.length() < 1) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "os.getenv requires 1 argument");
     return false;
   }
   RootedString key(cx, ToString(cx, args[0]));
-  if (!key) {
+  if (!key) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   UniqueChars keyBytes = JS_EncodeStringToUTF8(cx, key);
-  if (!keyBytes) {
+  if (!keyBytes) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (const char* valueBytes = getenv(keyBytes.get())) {
     RootedString value(cx, JS_NewStringCopyZ(cx, valueBytes));
-    if (!value) {
+    if (!value) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     args.rval().setString(value);
@@ -876,7 +876,7 @@ static bool os_getenv(JSContext* cx, uns
   return true;
 }
 
-static bool os_getpid(JSContext* cx, unsigned argc, Value* vp) {
+static bool os_getpid(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
   if (args.length() != 0) {
     JS_ReportErrorASCII(cx, "os.getpid takes no arguments");
@@ -901,7 +901,7 @@ inline char* strerror_message(char* resu
 
 #endif
 
-static void ReportSysError(JSContext* cx, const char* prefix) {
+static void ReportSysError(JSContext* cx, const char* prefix) {MOZ_RELEASE_ASSERT(0);
   char buffer[200];
 
 #if defined(XP_WIN)
@@ -923,23 +923,23 @@ static void ReportSysError(JSContext* cx
   JS_ReportErrorLatin1(cx, "%s: %s", prefix, errstr);
 }
 
-static bool os_system(JSContext* cx, unsigned argc, Value* vp) {
+static bool os_system(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() == 0) {
+  if (args.length() == 0) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "os.system requires 1 argument");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   JSString* str = JS::ToString(cx, args[0]);
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   UniqueChars command = JS_EncodeStringToLatin1(cx, str);
-  if (!command) {
+  if (!command) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   int result = system(command.get());
   if (result == -1) {
@@ -952,26 +952,26 @@ static bool os_system(JSContext* cx, uns
 }
 
 #ifndef XP_WIN
-static bool os_spawn(JSContext* cx, unsigned argc, Value* vp) {
+static bool os_spawn(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() == 0) {
+  if (args.length() == 0) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "os.spawn requires 1 argument");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   JSString* str = JS::ToString(cx, args[0]);
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   UniqueChars command = JS_EncodeStringToLatin1(cx, str);
-  if (!command) {
+  if (!command) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   int32_t childPid = fork();
-  if (childPid == -1) {
+  if (childPid == -1) {MOZ_RELEASE_ASSERT(0);
     ReportSysError(cx, "fork failed");
     return false;
   }
@@ -990,29 +990,29 @@ static bool os_spawn(JSContext* cx, unsi
   exit(1);
 }
 
-static bool os_kill(JSContext* cx, unsigned argc, Value* vp) {
+static bool os_kill(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
   int32_t pid;
-  if (args.length() < 1) {
+  if (args.length() < 1) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "os.kill requires 1 argument");
     return false;
   }
-  if (!JS::ToInt32(cx, args[0], &pid)) {
+  if (!JS::ToInt32(cx, args[0], &pid)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // It is too easy to kill yourself accidentally with os.kill("goose").
-  if (pid == 0 && !args[0].isInt32()) {
+  if (pid == 0 && !args[0].isInt32()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "os.kill requires numeric pid");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   int signal = SIGINT;
-  if (args.length() > 1) {
-    if (!JS::ToInt32(cx, args[1], &signal)) {
+  if (args.length() > 1) {MOZ_RELEASE_ASSERT(0);
+    if (!JS::ToInt32(cx, args[1], &signal)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
-  }
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
 
   int status = kill(pid, signal);
   if (status == -1) {
@@ -1025,42 +1025,42 @@ static bool os_kill(JSContext* cx, unsig
 }
 
 #  ifndef __wasi__
-static bool os_waitpid(JSContext* cx, unsigned argc, Value* vp) {
+static bool os_waitpid(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
   int32_t pid;
-  if (args.length() == 0) {
+  if (args.length() == 0) {MOZ_RELEASE_ASSERT(0);
     pid = -1;
   } else {
-    if (!JS::ToInt32(cx, args[0], &pid)) {
+    if (!JS::ToInt32(cx, args[0], &pid)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   bool nohang = false;
-  if (args.length() >= 2) {
+  if (args.length() >= 2) {MOZ_RELEASE_ASSERT(0);
     nohang = JS::ToBoolean(args[1]);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   int status = 0;
   pid_t result = waitpid(pid, &status, nohang ? WNOHANG : 0);
-  if (result == -1) {
+  if (result == -1) {MOZ_RELEASE_ASSERT(0);
     ReportSysError(cx, "os.waitpid failed");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedObject info(cx, JS_NewPlainObject(cx));
-  if (!info) {
+  if (!info) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedValue v(cx);
-  if (result != 0) {
+  if (result != 0) {MOZ_RELEASE_ASSERT(0);
     v.setInt32(result);
-    if (!JS_DefineProperty(cx, info, "pid", v, JSPROP_ENUMERATE)) {
+    if (!JS_DefineProperty(cx, info, "pid", v, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (WIFEXITED(status)) {
+    if (WIFEXITED(status)) {MOZ_RELEASE_ASSERT(0);
       v.setInt32(WEXITSTATUS(status));
       if (!JS_DefineProperty(cx, info, "exitStatus", v, JSPROP_ENUMERATE)) {
         return false;
@@ -1115,40 +1115,40 @@ static const JSFunctionSpecWithHelp os_f
 bool DefineOS(JSContext* cx, HandleObject global, bool fuzzingSafe,
               RCFile** shellOut, RCFile** shellErr) {
   RootedObject obj(cx, JS_NewPlainObject(cx));
-  if (!obj || !JS_DefineProperty(cx, global, "os", obj, 0)) {
+  if (!obj || !JS_DefineProperty(cx, global, "os", obj, 0)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (!fuzzingSafe) {
-    if (!JS_DefineFunctionsWithHelp(cx, obj, os_functions)) {
+    if (!JS_DefineFunctionsWithHelp(cx, obj, os_functions)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   RootedObject osfile(cx, JS_NewPlainObject(cx));
   if (!osfile || !JS_DefineFunctionsWithHelp(cx, osfile, osfile_functions) ||
-      !JS_DefineProperty(cx, obj, "file", osfile, 0)) {
+      !JS_DefineProperty(cx, obj, "file", osfile, 0)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (!fuzzingSafe) {
-    if (!JS_DefineFunctionsWithHelp(cx, osfile, osfile_unsafe_functions)) {
+    if (!JS_DefineFunctionsWithHelp(cx, osfile, osfile_unsafe_functions)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!GenerateInterfaceHelp(cx, osfile, "os.file")) {
+  if (!GenerateInterfaceHelp(cx, osfile, "os.file")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject ospath(cx, JS_NewPlainObject(cx));
   if (!ospath || !JS_DefineFunctionsWithHelp(cx, ospath, ospath_functions) ||
       !JS_DefineProperty(cx, obj, "path", ospath, 0) ||
-      !GenerateInterfaceHelp(cx, ospath, "os.path")) {
+      !GenerateInterfaceHelp(cx, ospath, "os.path")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!GenerateInterfaceHelp(cx, obj, "os")) {
+  if (!GenerateInterfaceHelp(cx, obj, "os")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1170,7 +1170,7 @@ bool DefineOS(JSContext* cx, HandleObjec
   };
 
   for (auto pair : osfile_exports) {
-    if (!CreateAlias(cx, pair.dst, osfile, pair.src)) {
+    if (!CreateAlias(cx, pair.dst, osfile, pair.src)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
diff --git a/js/src/shell/js.cpp b/js/src/shell/js.cpp
--- a/js/src/shell/js.cpp
+++ b/js/src/shell/js.cpp
@@ -395,7 +395,7 @@ static OffThreadJob* NewOffThreadJob(JSC
   ShellContext* sc = GetShellContext(cx);
   UniquePtr<OffThreadJob> job(cx->new_<OffThreadJob>(
       sc, kind, options.useOffThreadParseGlobal, std::move(source)));
-  if (!job) {
+  if (!job) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -800,13 +800,13 @@ static void TraceGrayRoots(JSTracer* trc
   }
 }
 
-static mozilla::UniqueFreePtr<char[]> GetLine(FILE* file, const char* prompt) {
+static mozilla::UniqueFreePtr<char[]> GetLine(FILE* file, const char* prompt) {MOZ_RELEASE_ASSERT(0);
 #ifdef EDITLINE
   /*
    * Use readline only if file is stdin, because there's no way to specify
    * another handle.  Are other filehandles interactive?
    */
-  if (file == stdin) {
+  if (file == stdin) {MOZ_RELEASE_ASSERT(0);
     mozilla::UniqueFreePtr<char[]> linep(readline(prompt));
     /*
      * We set it to zero to avoid complaining about inappropriate ioctl
@@ -814,51 +814,51 @@ static mozilla::UniqueFreePtr<char[]> Ge
      * finished with EOF and errno == 25 (EINVAL on Mac) if there is
      * nothing left to read.
      */
-    if (errno == 251 || errno == 25 || errno == EINVAL) {
+    if (errno == 251 || errno == 25 || errno == EINVAL) {MOZ_RELEASE_ASSERT(0);
       errno = 0;
     }
-    if (!linep) {
+    if (!linep) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (linep[0] != '\0') {
+    if (linep[0] != '\0') {MOZ_RELEASE_ASSERT(0);
       add_history(linep.get());
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return linep;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 #endif
 
   size_t len = 0;
-  if (*prompt != '\0' && gOutFile->isOpen()) {
+  if (*prompt != '\0' && gOutFile->isOpen()) {MOZ_RELEASE_ASSERT(0);
     fprintf(gOutFile->fp, "%s", prompt);
     fflush(gOutFile->fp);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   size_t size = 80;
   mozilla::UniqueFreePtr<char[]> buffer(static_cast<char*>(malloc(size)));
-  if (!buffer) {
+  if (!buffer) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   char* current = buffer.get();
-  do {
-    while (true) {
-      if (fgets(current, size - len, file)) {
+  do {MOZ_RELEASE_ASSERT(0);
+    while (true) {MOZ_RELEASE_ASSERT(0);
+      if (fgets(current, size - len, file)) {MOZ_RELEASE_ASSERT(0);
         break;
       }
-      if (errno != EINTR) {
+      if (errno != EINTR) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     len += strlen(current);
     char* t = buffer.get() + len - 1;
-    if (*t == '\n') {
+    if (*t == '\n') {MOZ_RELEASE_ASSERT(0);
       /* Line was read. We remove '\n' and exit. */
       *t = '\0';
       break;
     }
 
-    if (len + 1 == size) {
+    if (len + 1 == size) {MOZ_RELEASE_ASSERT(0);
       size = size * 2;
       char* raw = buffer.release();
       char* tmp = static_cast<char*>(realloc(raw, size));
@@ -939,7 +939,7 @@ static void SkipUTF8BOM(FILE* file) {
   int ch3 = fgetc(file);
 
   // Skip the BOM
-  if (ch1 == 0xEF && ch2 == 0xBB && ch3 == 0xBF) {
+  if (ch1 == 0xEF && ch2 == 0xBB && ch3 == 0xBF) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -970,7 +970,7 @@ void EnvironmentPreparer::invoke(HandleO
 
 JSObject* js::shell::CreateScriptPrivate(JSContext* cx, HandleString path) {
   RootedObject info(cx, JS_NewPlainObject(cx));
-  if (!info) {
+  if (!info) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -992,7 +992,7 @@ static bool RegisterScriptPathWithModule
   // relative imports.
 
   RootedString path(cx, JS_NewStringCopyZ(cx, filename));
-  if (!path) {
+  if (!path) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1028,13 +1028,13 @@ enum class CompileUtf8 {
 
     if (compileMethod == CompileUtf8::DontInflate) {
       script = JS::CompileUtf8File(cx, options, file);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       fprintf(stderr, "(compiling '%s' after inflating to UTF-16)\n", filename);
 
       FileContents buffer(cx);
-      if (!ReadCompleteFile(cx, file, buffer)) {
-        return false;
-      }
+      if (!ReadCompleteFile(cx, file, buffer)) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }MOZ_RELEASE_ASSERT(0);
 
       size_t length = buffer.length();
       auto chars = UniqueTwoByteChars(
@@ -1044,14 +1044,14 @@ enum class CompileUtf8 {
                             buffer.length()),
               &length, js::MallocArena)
               .get());
-      if (!chars) {
-        return false;
-      }
+      if (!chars) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }MOZ_RELEASE_ASSERT(0);
 
       JS::SourceText<char16_t> source;
-      if (!source.init(cx, std::move(chars), length)) {
-        return false;
-      }
+      if (!source.init(cx, std::move(chars), length)) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }MOZ_RELEASE_ASSERT(0);
 
       script = JS::Compile(cx, options, source);
     }
@@ -1061,7 +1061,7 @@ enum class CompileUtf8 {
     }
   }
 
-  if (!RegisterScriptPathWithModuleLoader(cx, script, filename)) {
+  if (!RegisterScriptPathWithModuleLoader(cx, script, filename)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1087,7 +1087,7 @@ enum class CompileUtf8 {
   ShellContext* sc = GetShellContext(cx);
 
   RootedString path(cx, JS_NewStringCopyZ(cx, filename));
-  if (!path) {
+  if (!path) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1184,7 +1184,7 @@ static void RunShellJobs(JSContext* cx) 
 static bool DrainJobQueue(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (GetShellContext(cx)->quitting) {
+  if (GetShellContext(cx)->quitting) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(
         cx, "Mustn't drain the job queue when the shell is quitting");
     return false;
@@ -1240,7 +1240,7 @@ static bool TrackUnhandledRejections(JSC
 
   if (!sc->unhandledRejectedPromises) {
     sc->unhandledRejectedPromises = SetObject::create(cx);
-    if (!sc->unhandledRejectedPromises) {
+    if (!sc->unhandledRejectedPromises) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1248,7 +1248,7 @@ static bool TrackUnhandledRejections(JSC
   RootedValue promiseVal(cx, ObjectValue(*promise));
 
   AutoRealm ar(cx, sc->unhandledRejectedPromises);
-  if (!cx->compartment()->wrap(cx, &promiseVal)) {
+  if (!cx->compartment()->wrap(cx, &promiseVal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1277,7 +1277,7 @@ static void ForwardingPromiseRejectionTr
     JS::PromiseRejectionHandlingState state, void* data) {
   AutoReportException are(cx);
 
-  if (!TrackUnhandledRejections(cx, promise, state)) {
+  if (!TrackUnhandledRejections(cx, promise, state)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -1342,7 +1342,7 @@ using TelemetryData = uint32_t;
 using TelemetryVec = Vector<TelemetryData, 0, SystemAllocPolicy>;
 static mozilla::Array<TelemetryVec, JS_TELEMETRY_END> telemetryResults;
 static void AccumulateTelemetryDataCallback(int id, uint32_t sample,
-                                            const char* key) {
+                                            const char* key) {MOZ_RELEASE_ASSERT(0);
   AutoLockTelemetry alt;
   // We ignore OOMs while writting teleemtry data.
   if (telemetryResults[id].append(sample)) {
@@ -1350,7 +1350,7 @@ static void AccumulateTelemetryDataCallb
   }
 }
 
-static void WriteTelemetryDataToDisk(const char* dir) {
+static void WriteTelemetryDataToDisk(const char* dir) {MOZ_RELEASE_ASSERT(0);
   const int pathLen = 260;
   char fileName[pathLen];
   Fprinter output;
@@ -1366,9 +1366,9 @@ static void WriteTelemetryDataToDisk(con
     return true;
   };
 
-  for (size_t id = 0; id < JS_TELEMETRY_END; id++) {
+  for (size_t id = 0; id < JS_TELEMETRY_END; id++) {MOZ_RELEASE_ASSERT(0);
     auto clear = MakeScopeExit([&] { telemetryResults[id].clearAndFree(); });
-    if (!initOutput(telemetryNames[id])) {
+    if (!initOutput(telemetryNames[id])) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
     for (uint32_t data : telemetryResults[id]) {
@@ -1392,27 +1392,27 @@ static bool BoundToAsyncStack(JSContext*
 
   RootedValue v(cx);
 
-  if (!JS_GetProperty(cx, options, "stack", &v)) {
-    return false;
-  }
-  if (!v.isObject() || !v.toObject().is<SavedFrame>()) {
+  if (!JS_GetProperty(cx, options, "stack", &v)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!v.isObject() || !v.toObject().is<SavedFrame>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx,
                         "The 'stack' property must be a SavedFrame object.");
     return false;
   }
   stack = &v.toObject().as<SavedFrame>();
 
-  if (!JS_GetProperty(cx, options, "cause", &v)) {
+  if (!JS_GetProperty(cx, options, "cause", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedString causeString(cx, ToString(cx, v));
-  if (!causeString) {
+  if (!causeString) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(cx->isExceptionPending());
     return false;
   }
 
   UniqueChars cause = JS_EncodeStringToUTF8(cx, causeString);
-  if (!cause) {
+  if (!cause) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(cx->isExceptionPending());
     return false;
   }
@@ -1439,13 +1439,13 @@ static bool BindToAsyncStack(JSContext* 
     return false;
   }
 
-  if (!args[0].isObject() || !IsCallable(args[0])) {
+  if (!args[0].isObject() || !IsCallable(args[0])) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(
         cx, "bindToAsyncStack's first argument should be a function.");
     return false;
   }
 
-  if (!args[1].isObject()) {
+  if (!args[1].isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(
         cx, "bindToAsyncStack's second argument should be an object.");
     return false;
@@ -1478,11 +1478,11 @@ static bool AddIntlExtras(JSContext* cx,
       JS_SELF_HOSTED_FN("getDisplayNames", "Intl_getDisplayNames", 2, 0),
       JS_FS_END};
 
-  if (!JS_DefineFunctions(cx, intl, funcs)) {
-    return false;
-  }
-
-  if (!JS::AddMozDateTimeFormatConstructor(cx, intl)) {
+  if (!JS_DefineFunctions(cx, intl, funcs)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!JS::AddMozDateTimeFormatConstructor(cx, intl)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1497,7 +1497,7 @@ static bool AddIntlExtras(JSContext* cx,
 
 [[nodiscard]] static bool EvalUtf8AndPrint(JSContext* cx, const char* bytes,
                                            size_t length, int lineno,
-                                           bool compileOnly) {
+                                           bool compileOnly) {MOZ_RELEASE_ASSERT(0);
   // Eval.
   JS::CompileOptions options(cx);
   options.setIntroductionType("js shell interactive")
@@ -1505,28 +1505,28 @@ static bool AddIntlExtras(JSContext* cx,
       .setFileAndLine("typein", lineno);
 
   JS::SourceText<Utf8Unit> srcBuf;
-  if (!srcBuf.init(cx, bytes, length, JS::SourceOwnership::Borrowed)) {
-    return false;
-  }
+  if (!srcBuf.init(cx, bytes, length, JS::SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedScript script(cx, JS::Compile(cx, options, srcBuf));
-  if (!script) {
-    return false;
-  }
-  if (compileOnly) {
+  if (!script) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (compileOnly) {MOZ_RELEASE_ASSERT(0);
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   RootedValue result(cx);
-  if (!JS_ExecuteScript(cx, script, &result)) {
-    return false;
-  }
-
-  if (!result.isUndefined() && gOutFile->isOpen()) {
+  if (!JS_ExecuteScript(cx, script, &result)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!result.isUndefined() && gOutFile->isOpen()) {MOZ_RELEASE_ASSERT(0);
     // Print.
     RootedString str(cx, JS_ValueToSource(cx, result));
-    if (!str) {
-      return false;
-    }
+    if (!str) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }MOZ_RELEASE_ASSERT(0);
 
     UniqueChars utf8chars = JS_EncodeStringToUTF8(cx, str);
     if (!utf8chars) {
@@ -1538,12 +1538,12 @@ static bool AddIntlExtras(JSContext* cx,
 }
 
 [[nodiscard]] static bool ReadEvalPrintLoop(JSContext* cx, FILE* in,
-                                            bool compileOnly) {
+                                            bool compileOnly) {MOZ_RELEASE_ASSERT(0);
   ShellContext* sc = GetShellContext(cx);
   int lineno = 1;
   bool hitEOF = false;
 
-  do {
+  do {MOZ_RELEASE_ASSERT(0);
     /*
      * Accumulate lines until we get a 'compilable unit' - one that either
      * generates an error (before running out of source) or that compiles
@@ -1554,63 +1554,63 @@ static bool AddIntlExtras(JSContext* cx,
     typedef Vector<char, 32> CharBuffer;
     RootedObject globalLexical(cx, &cx->global()->lexicalEnvironment());
     CharBuffer buffer(cx);
-    do {
+    do {MOZ_RELEASE_ASSERT(0);
       ScheduleWatchdog(cx, -1);
       sc->serviceInterrupt = false;
       errno = 0;
 
       mozilla::UniqueFreePtr<char[]> line =
           GetLine(in, startline == lineno ? "js> " : "");
-      if (!line) {
-        if (errno) {
+      if (!line) {MOZ_RELEASE_ASSERT(0);
+        if (errno) {MOZ_RELEASE_ASSERT(0);
           /*
            * Use Latin1 variant here because strerror(errno)'s
            * encoding depends on the user's C locale.
            */
           JS_ReportErrorLatin1(cx, "%s", strerror(errno));
           return false;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         hitEOF = true;
         break;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       if (!buffer.append(line.get(), strlen(line.get())) ||
-          !buffer.append('\n')) {
-        return false;
-      }
+          !buffer.append('\n')) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }MOZ_RELEASE_ASSERT(0);
 
       lineno++;
-      if (!ScheduleWatchdog(cx, sc->timeoutInterval)) {
+      if (!ScheduleWatchdog(cx, sc->timeoutInterval)) {MOZ_RELEASE_ASSERT(0);
         hitEOF = true;
         break;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     } while (!JS_Utf8BufferIsCompilableUnit(cx, cx->global(), buffer.begin(),
                                             buffer.length()));
 
-    if (hitEOF && buffer.empty()) {
+    if (hitEOF && buffer.empty()) {MOZ_RELEASE_ASSERT(0);
       break;
     }
 
-    {
+    {MOZ_RELEASE_ASSERT(0);
       // Report exceptions but keep going.
       AutoReportException are(cx);
       mozilla::Unused << EvalUtf8AndPrint(cx, buffer.begin(), buffer.length(),
                                           startline, compileOnly);
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // If a let or const fail to initialize they will remain in an unusable
     // without further intervention. This call cleans up the global scope,
     // setting uninitialized lexicals to undefined so that they may still
     // be used. This behavior is _only_ acceptable in the context of the repl.
     if (JS::ForceLexicalInitialization(cx, globalLexical) &&
-        gErrFile->isOpen()) {
+        gErrFile->isOpen()) {MOZ_RELEASE_ASSERT(0);
       fputs(
           "Warning: According to the standard, after the above exception,\n"
           "Warning: the global bindings should be permanently uninitialized.\n"
           "Warning: We have non-standard-ly initialized them to `undefined`"
           "for you.\nWarning: This nicety only happens in the JS shell.\n",
           stderr);
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     RunShellJobs(cx);
   } while (!hitEOF && !sc->quitting);
@@ -1647,11 +1647,11 @@ static void ReportCantOpenErrorUnknownEn
 [[nodiscard]] static bool Process(JSContext* cx, const char* filename,
                                   bool forceTTY, FileKind kind) {
   FILE* file;
-  if (forceTTY || !filename || strcmp(filename, "-") == 0) {
+  if (forceTTY || !filename || strcmp(filename, "-") == 0) {MOZ_RELEASE_ASSERT(0);
     file = stdin;
   } else {
     file = fopen(filename, "rb");
-    if (!file) {
+    if (!file) {MOZ_RELEASE_ASSERT(0);
       ReportCantOpenErrorUnknownEncoding(cx, filename);
       return false;
     }
@@ -1681,7 +1681,7 @@ static void ReportCantOpenErrorUnknownEn
       default:
         MOZ_CRASH("Impossible FileKind!");
     }
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     // It's an interactive filehandle; drop into read-eval-print loop.
     MOZ_ASSERT(kind == FileScript);
     if (!ReadEvalPrintLoop(cx, file, compileOnly)) {
@@ -1710,23 +1710,23 @@ static bool CreateExternalArrayBuffer(JS
         args.length() < 1 ? JSSMSG_NOT_ENOUGH_ARGS : JSSMSG_TOO_MANY_ARGS,
         "createExternalArrayBuffer");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   int32_t bytes = 0;
-  if (!ToInt32(cx, args[0], &bytes)) {
-    return false;
-  }
-
-  if (bytes <= 0) {
+  if (!ToInt32(cx, args[0], &bytes)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (bytes <= 0) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Size must be positive");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   void* buffer = js_malloc(bytes);
-  if (!buffer) {
+  if (!buffer) {MOZ_RELEASE_ASSERT(0);
     JS_ReportOutOfMemory(cx);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedObject arrayBuffer(
       cx, JS::NewExternalArrayBuffer(cx, bytes, buffer, &freeExternalCallback));
@@ -1750,7 +1750,7 @@ static bool CreateMappedArrayBuffer(JSCo
   }
 
   RootedString rawFilenameStr(cx, JS::ToString(cx, args[0]));
-  if (!rawFilenameStr) {
+  if (!rawFilenameStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   // It's a little bizarre to resolve relative to the script, but for testing
@@ -1758,33 +1758,33 @@ static bool CreateMappedArrayBuffer(JSCo
   // that right now is to include it in the repo alongside the test script.
   // Bug 944164 would introduce an alternative.
   JSString* filenameStr = ResolvePath(cx, rawFilenameStr, ScriptRelative);
-  if (!filenameStr) {
+  if (!filenameStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   UniqueChars filename = JS_EncodeStringToLatin1(cx, filenameStr);
-  if (!filename) {
+  if (!filename) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   uint32_t offset = 0;
   if (args.length() >= 2) {
-    if (!JS::ToUint32(cx, args[1], &offset)) {
-      return false;
-    }
+    if (!JS::ToUint32(cx, args[1], &offset)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   bool sizeGiven = false;
   uint32_t size;
   if (args.length() >= 3) {
-    if (!JS::ToUint32(cx, args[2], &size)) {
-      return false;
-    }
+    if (!JS::ToUint32(cx, args[2], &size)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }MOZ_RELEASE_ASSERT(0);
     sizeGiven = true;
-    if (size == 0) {
+    if (size == 0) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                 JSMSG_BAD_ARRAY_LENGTH);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   FILE* file = fopen(filename.get(), "rb");
@@ -1795,7 +1795,7 @@ static bool CreateMappedArrayBuffer(JSCo
   AutoCloseFile autoClose(file);
 
   struct stat st;
-  if (fstat(fileno(file), &st) < 0) {
+  if (fstat(fileno(file), &st) < 0) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Unable to stat file");
     return false;
   }
@@ -1805,23 +1805,23 @@ static bool CreateMappedArrayBuffer(JSCo
     return false;
   }
 
-  if (!sizeGiven) {
-    if (off_t(offset) >= st.st_size) {
+  if (!sizeGiven) {MOZ_RELEASE_ASSERT(0);
+    if (off_t(offset) >= st.st_size) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                 JSMSG_OFFSET_LARGER_THAN_FILESIZE);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     size = st.st_size - offset;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   void* contents =
       JS::CreateMappedArrayBufferContents(GET_FD_FROM_FILE(file), offset, size);
-  if (!contents) {
+  if (!contents) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx,
                         "failed to allocate mapped array buffer contents "
                         "(possibly due to bad alignment)");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedObject obj(cx,
                    JS::NewMappedArrayBufferWithContents(cx, size, contents));
@@ -1844,28 +1844,28 @@ static bool AddPromiseReactions(JSContex
         args.length() < 3 ? JSSMSG_NOT_ENOUGH_ARGS : JSSMSG_TOO_MANY_ARGS,
         "addPromiseReactions");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedObject promise(cx);
-  if (args[0].isObject()) {
+  if (args[0].isObject()) {MOZ_RELEASE_ASSERT(0);
     promise = &args[0].toObject();
   }
 
-  if (!promise || !JS::IsPromiseObject(promise)) {
+  if (!promise || !JS::IsPromiseObject(promise)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,
                               JSSMSG_INVALID_ARGS, "addPromiseReactions");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedObject onResolve(cx);
-  if (args[1].isObject()) {
+  if (args[1].isObject()) {MOZ_RELEASE_ASSERT(0);
     onResolve = &args[1].toObject();
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedObject onReject(cx);
-  if (args[2].isObject()) {
+  if (args[2].isObject()) {MOZ_RELEASE_ASSERT(0);
     onReject = &args[2].toObject();
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   if (!onResolve || !onResolve->is<JSFunction>() || !onReject ||
       !onReject->is<JSFunction>()) {
@@ -1893,12 +1893,12 @@ static bool Options(JSContext* cx, unsig
   JS::ContextOptions oldContextOptions = JS::ContextOptionsRef(cx);
   for (unsigned i = 0; i < args.length(); i++) {
     RootedString str(cx, JS::ToString(cx, args[i]));
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedLinearString opt(cx, str->ensureLinear(cx));
-    if (!opt) {
+    if (!opt) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1908,7 +1908,7 @@ static bool Options(JSContext* cx, unsig
       JS::ContextOptionsRef(cx).toggleStrictMode();
     } else {
       UniqueChars optChars = QuoteString(cx, opt, '"');
-      if (!optChars) {
+      if (!optChars) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -1933,7 +1933,7 @@ static bool Options(JSContext* cx, unsig
                               "strict_mode");
     found = true;
   }
-  if (!names) {
+  if (!names) {MOZ_RELEASE_ASSERT(0);
     JS_ReportOutOfMemory(cx);
     return false;
   }
@@ -1953,22 +1953,22 @@ static bool LoadScript(JSContext* cx, un
   RootedString str(cx);
   for (unsigned i = 0; i < args.length(); i++) {
     str = JS::ToString(cx, args[i]);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,
                                 JSSMSG_INVALID_ARGS, "load");
       return false;
     }
 
     str = ResolvePath(cx, str, scriptRelative ? ScriptRelative : RootRelative);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "unable to resolve path");
       return false;
     }
 
     UniqueChars filename = JS_EncodeStringToLatin1(cx, str);
-    if (!filename) {
-      return false;
-    }
+    if (!filename) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }MOZ_RELEASE_ASSERT(0);
 
     errno = 0;
 
@@ -2006,105 +2006,105 @@ static bool ParseCompileOptions(JSContex
   RootedValue v(cx);
   RootedString s(cx);
 
-  if (!JS_GetProperty(cx, opts, "isRunOnce", &v)) {
+  if (!JS_GetProperty(cx, opts, "isRunOnce", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!v.isUndefined()) {
     options.setIsRunOnce(ToBoolean(v));
   }
 
-  if (!JS_GetProperty(cx, opts, "noScriptRval", &v)) {
+  if (!JS_GetProperty(cx, opts, "noScriptRval", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!v.isUndefined()) {
     options.setNoScriptRval(ToBoolean(v));
   }
 
-  if (!JS_GetProperty(cx, opts, "fileName", &v)) {
+  if (!JS_GetProperty(cx, opts, "fileName", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (v.isNull()) {
     options.setFile(nullptr);
   } else if (!v.isUndefined()) {
     s = ToString(cx, v);
-    if (!s) {
+    if (!s) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (fileNameBytes) {
       *fileNameBytes = JS_EncodeStringToLatin1(cx, s);
-      if (!*fileNameBytes) {
+      if (!*fileNameBytes) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       options.setFile(fileNameBytes->get());
     }
   }
 
-  if (!JS_GetProperty(cx, opts, "skipFileNameValidation", &v)) {
+  if (!JS_GetProperty(cx, opts, "skipFileNameValidation", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!v.isUndefined()) {
     options.setSkipFilenameValidation(ToBoolean(v));
   }
 
-  if (!JS_GetProperty(cx, opts, "element", &v)) {
+  if (!JS_GetProperty(cx, opts, "element", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (v.isObject()) {
     RootedObject infoObject(cx, CreateScriptPrivate(cx));
-    if (!infoObject) {
+    if (!infoObject) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     RootedValue elementValue(cx, v);
-    if (!JS_WrapValue(cx, &elementValue)) {
-      return false;
-    }
-    if (!JS_DefineProperty(cx, infoObject, "element", elementValue, 0)) {
+    if (!JS_WrapValue(cx, &elementValue)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!JS_DefineProperty(cx, infoObject, "element", elementValue, 0)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     options.setPrivateValue(ObjectValue(*infoObject));
   }
 
-  if (!JS_GetProperty(cx, opts, "elementAttributeName", &v)) {
+  if (!JS_GetProperty(cx, opts, "elementAttributeName", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!v.isUndefined()) {
     s = ToString(cx, v);
-    if (!s) {
+    if (!s) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     options.setElementAttributeName(s);
   }
 
-  if (!JS_GetProperty(cx, opts, "lineNumber", &v)) {
+  if (!JS_GetProperty(cx, opts, "lineNumber", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!v.isUndefined()) {
     uint32_t u;
-    if (!ToUint32(cx, v, &u)) {
+    if (!ToUint32(cx, v, &u)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     options.setLine(u);
   }
 
-  if (!JS_GetProperty(cx, opts, "columnNumber", &v)) {
+  if (!JS_GetProperty(cx, opts, "columnNumber", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!v.isUndefined()) {
     int32_t c;
-    if (!ToInt32(cx, v, &c)) {
+    if (!ToInt32(cx, v, &c)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     options.setColumn(c);
   }
 
-  if (!JS_GetProperty(cx, opts, "sourceIsLazy", &v)) {
+  if (!JS_GetProperty(cx, opts, "sourceIsLazy", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (v.isBoolean()) {
     options.setSourceIsLazy(v.toBoolean());
   }
 
-  if (!JS_GetProperty(cx, opts, "forceFullParse", &v)) {
+  if (!JS_GetProperty(cx, opts, "forceFullParse", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (v.isBoolean() && v.toBoolean()) {
@@ -2357,12 +2357,12 @@ static bool Evaluate(JSContext* cx, unsi
              CacheEntry_isCacheEntry(&args[0].toObject())) {
     cacheEntry = &args[0].toObject();
     code = CacheEntry_getSource(cx, cacheEntry);
-    if (!code) {
-      return false;
-    }
-  }
-
-  if (!code || (args.length() == 2 && args[1].isPrimitive())) {
+    if (!code) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+  }
+
+  if (!code || (args.length() == 2 && args[1].isPrimitive())) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,
                               JSSMSG_INVALID_ARGS, "evaluate");
     return false;
@@ -2393,87 +2393,87 @@ static bool Evaluate(JSContext* cx, unsi
     RootedObject opts(cx, &args[1].toObject());
     RootedValue v(cx);
 
-    if (!ParseCompileOptions(cx, options, opts, &fileNameBytes)) {
-      return false;
-    }
-
-    if (!JS_GetProperty(cx, opts, "displayURL", &v)) {
+    if (!ParseCompileOptions(cx, options, opts, &fileNameBytes)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+
+    if (!JS_GetProperty(cx, opts, "displayURL", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!v.isUndefined()) {
       displayURL = ToString(cx, v);
-      if (!displayURL) {
-        return false;
-      }
-    }
-
-    if (!JS_GetProperty(cx, opts, "sourceMapURL", &v)) {
+      if (!displayURL) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }
+    }
+
+    if (!JS_GetProperty(cx, opts, "sourceMapURL", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!v.isUndefined()) {
       sourceMapURL = ToString(cx, v);
-      if (!sourceMapURL) {
-        return false;
-      }
-    }
-
-    if (!JS_GetProperty(cx, opts, "catchTermination", &v)) {
+      if (!sourceMapURL) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }
+    }
+
+    if (!JS_GetProperty(cx, opts, "catchTermination", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!v.isUndefined()) {
       catchTermination = ToBoolean(v);
     }
 
-    if (!JS_GetProperty(cx, opts, "loadBytecode", &v)) {
+    if (!JS_GetProperty(cx, opts, "loadBytecode", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!v.isUndefined()) {
       loadBytecode = ToBoolean(v);
     }
 
-    if (!JS_GetProperty(cx, opts, "saveBytecode", &v)) {
+    if (!JS_GetProperty(cx, opts, "saveBytecode", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!v.isUndefined()) {
       saveBytecode = ToBoolean(v);
     }
 
-    if (!JS_GetProperty(cx, opts, "saveIncrementalBytecode", &v)) {
+    if (!JS_GetProperty(cx, opts, "saveIncrementalBytecode", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!v.isUndefined()) {
       saveIncrementalBytecode = ToBoolean(v);
     }
 
-    if (!JS_GetProperty(cx, opts, "transcodeOnly", &v)) {
-      return false;
-    }
-    if (!v.isUndefined()) {
+    if (!JS_GetProperty(cx, opts, "transcodeOnly", &v)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!v.isUndefined()) {MOZ_RELEASE_ASSERT(0);
       transcodeOnly = ToBoolean(v);
     }
 
-    if (!JS_GetProperty(cx, opts, "assertEqBytecode", &v)) {
+    if (!JS_GetProperty(cx, opts, "assertEqBytecode", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!v.isUndefined()) {
       assertEqBytecode = ToBoolean(v);
     }
 
-    if (!JS_GetProperty(cx, opts, "envChainObject", &v)) {
+    if (!JS_GetProperty(cx, opts, "envChainObject", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!v.isUndefined()) {
-      if (!v.isObject()) {
+      if (!v.isObject()) {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorNumberASCII(
             cx, GetErrorMessage, nullptr, JSMSG_UNEXPECTED_TYPE,
             "\"envChainObject\" passed to evaluate()", "not an object");
         return false;
-      } else if (v.toObject().is<GlobalObject>()) {
+      } else if (v.toObject().is<GlobalObject>()) {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorASCII(
             cx,
             "\"envChainObject\" passed to evaluate() should not be a global");
         return false;
-      } else if (!envChain.append(&v.toObject())) {
+      } else if (!envChain.append(&v.toObject())) {MOZ_RELEASE_ASSERT(0);
         JS_ReportOutOfMemory(cx);
         return false;
       }
@@ -2482,26 +2482,26 @@ static bool Evaluate(JSContext* cx, unsi
     // We cannot load or save the bytecode if we have no object where the
     // bytecode cache is stored.
     if (loadBytecode || saveBytecode || saveIncrementalBytecode) {
-      if (!cacheEntry) {
+      if (!cacheEntry) {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,
                                   JSSMSG_INVALID_ARGS, "evaluate");
         return false;
       }
-      if (saveIncrementalBytecode && saveBytecode) {
+      if (saveIncrementalBytecode && saveBytecode) {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorASCII(
             cx,
             "saveIncrementalBytecode and saveBytecode cannot be used"
             " at the same time.");
         return false;
       }
-      if (saveIncrementalBytecode && js::UseOffThreadParseGlobal()) {
+      if (saveIncrementalBytecode && js::UseOffThreadParseGlobal()) {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorASCII(
             cx, "saveIncrementalBytecode cannot be used with legacy XDR.");
         return false;
       }
     }
 
-    if (saveIncrementalBytecode && assertEqBytecode) {
+    if (saveIncrementalBytecode && assertEqBytecode) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(
           cx, "saveIncrementalBytecode cannot be used with assertEqBytecode.");
       return false;
@@ -2509,18 +2509,18 @@ static bool Evaluate(JSContext* cx, unsi
 
     // NOTE: Check custom "global" after handling all CompileOption-related
     //       properties.
-    if (!JS_GetProperty(cx, opts, "global", &v)) {
+    if (!JS_GetProperty(cx, opts, "global", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!v.isUndefined()) {
       if (v.isObject()) {
         global = js::CheckedUnwrapDynamic(&v.toObject(), cx,
                                           /* stopAtWindowProxy = */ false);
-        if (!global) {
+        if (!global) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
-      if (!global || !(JS::GetClass(global)->flags & JSCLASS_IS_GLOBAL)) {
+      if (!global || !(JS::GetClass(global)->flags & JSCLASS_IS_GLOBAL)) {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorNumberASCII(
             cx, GetErrorMessage, nullptr, JSMSG_UNEXPECTED_TYPE,
             "\"global\" passed to evaluate()", "not a global object");
@@ -2553,7 +2553,7 @@ static bool Evaluate(JSContext* cx, unsi
       // Wrap the envChainObject list into target realm.
       JSAutoRealm ar(cx, global);
       for (size_t i = 0; i < envChain.length(); ++i) {
-        if (!JS_WrapObject(cx, envChain[i])) {
+        if (!JS_WrapObject(cx, envChain[i])) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -2565,7 +2565,7 @@ static bool Evaluate(JSContext* cx, unsi
   optionSet.initFromOptions(options);
 
   AutoStableStringChars codeChars(cx);
-  if (!codeChars.initTwoByte(cx, code)) {
+  if (!codeChars.initTwoByte(cx, code)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2583,10 +2583,10 @@ static bool Evaluate(JSContext* cx, unsi
     }
 
     loadData = CacheEntry_getBytecode(cx, cacheEntry, &loadLength);
-    if (!loadData) {
-      return false;
-    }
-    if (!loadBuffer.append(loadData, loadLength)) {
+    if (!loadData) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!loadBuffer.append(loadData, loadLength)) {MOZ_RELEASE_ASSERT(0);
       JS_ReportOutOfMemory(cx);
       return false;
     }
@@ -2604,7 +2604,7 @@ static bool Evaluate(JSContext* cx, unsi
           bool useStencilXDR = !options.useOffThreadParseGlobal;
           if (useStencilXDR) {
             if (CacheEntry_getKind(cx, cacheEntry) !=
-                BytecodeCacheKind::Stencil) {
+                BytecodeCacheKind::Stencil) {MOZ_RELEASE_ASSERT(0);
               // This can happen.
               JS_ReportErrorASCII(
                   cx,
@@ -2613,9 +2613,9 @@ static bool Evaluate(JSContext* cx, unsi
                   "have been saved with saveIncrementalBytecode");
               return false;
             }
-          } else {
+          } else {MOZ_RELEASE_ASSERT(0);
             if (CacheEntry_getKind(cx, cacheEntry) !=
-                BytecodeCacheKind::Script) {
+                BytecodeCacheKind::Script) {MOZ_RELEASE_ASSERT(0);
               // NOTE: This shouldn't happen unless the cache is used across
               // processes with different --no-off-thread-parse-global option.
               JS_ReportErrorASCII(
@@ -2629,7 +2629,7 @@ static bool Evaluate(JSContext* cx, unsi
 
           rv = JS::DecodeScriptAndStartIncrementalEncoding(cx, options,
                                                            loadBuffer, &script);
-          if (!ConvertTranscodeResultToJSException(cx, rv)) {
+          if (!ConvertTranscodeResultToJSException(cx, rv)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         } else if (loadCacheKind == BytecodeCacheKind::Script) {
@@ -2640,7 +2640,7 @@ static bool Evaluate(JSContext* cx, unsi
         } else {
           MOZ_ASSERT(loadCacheKind == BytecodeCacheKind::Stencil);
           rv = JS::DecodeScriptMaybeStencil(cx, options, loadBuffer, &script);
-          if (!ConvertTranscodeResultToJSException(cx, rv)) {
+          if (!ConvertTranscodeResultToJSException(cx, rv)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -2648,13 +2648,13 @@ static bool Evaluate(JSContext* cx, unsi
         mozilla::Range<const char16_t> chars = codeChars.twoByteRange();
         JS::SourceText<char16_t> srcBuf;
         if (!srcBuf.init(cx, chars.begin().get(), chars.length(),
-                         JS::SourceOwnership::Borrowed)) {
+                         JS::SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         if (saveIncrementalBytecode) {
           script = JS::CompileAndStartIncrementalEncoding(cx, options, srcBuf);
-          if (!script) {
+          if (!script) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         } else {
@@ -2668,19 +2668,19 @@ static bool Evaluate(JSContext* cx, unsi
 
     if (displayURL && !script->scriptSource()->hasDisplayURL()) {
       UniqueTwoByteChars chars = JS_CopyStringCharsZ(cx, displayURL);
-      if (!chars) {
-        return false;
-      }
-      if (!script->scriptSource()->setDisplayURL(cx, std::move(chars))) {
+      if (!chars) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }
+      if (!script->scriptSource()->setDisplayURL(cx, std::move(chars))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
     if (sourceMapURL && !script->scriptSource()->hasSourceMapURL()) {
       UniqueTwoByteChars chars = JS_CopyStringCharsZ(cx, sourceMapURL);
-      if (!chars) {
-        return false;
-      }
-      if (!script->scriptSource()->setSourceMapURL(cx, std::move(chars))) {
+      if (!chars) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }
+      if (!script->scriptSource()->setSourceMapURL(cx, std::move(chars))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2692,7 +2692,7 @@ static bool Evaluate(JSContext* cx, unsi
         if (catchTermination && !JS_IsExceptionPending(cx)) {
           JSAutoRealm ar1(cx, callerGlobal);
           JSString* str = JS_NewStringCopyZ(cx, "terminated");
-          if (!str) {
+          if (!str) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
           args.rval().setString(str);
@@ -2714,12 +2714,12 @@ static bool Evaluate(JSContext* cx, unsi
     // Serialize the encoded bytecode, recorded before the execution, into a
     // buffer which can be deserialized linearly.
     if (saveIncrementalBytecode) {
-      if (!FinishIncrementalEncoding(cx, script, saveBuffer)) {
+      if (!FinishIncrementalEncoding(cx, script, saveBuffer)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (options.useStencilXDR) {
         saveCacheKind = BytecodeCacheKind::Stencil;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         saveCacheKind = BytecodeCacheKind::Script;
       }
     }
@@ -2729,7 +2729,7 @@ static bool Evaluate(JSContext* cx, unsi
     // If we are both loading and saving, we assert that we are going to
     // replace the current bytecode by the same stream of bytes.
     if (loadBytecode && assertEqBytecode) {
-      if (saveBuffer.length() != loadBuffer.length()) {
+      if (saveBuffer.length() != loadBuffer.length()) {MOZ_RELEASE_ASSERT(0);
         char loadLengthStr[16];
         SprintfLiteral(loadLengthStr, "%zu", loadBuffer.length());
         char saveLengthStr[16];
@@ -2742,7 +2742,7 @@ static bool Evaluate(JSContext* cx, unsi
       }
 
       if (!ArrayEqual(loadBuffer.begin(), saveBuffer.begin(),
-                      loadBuffer.length())) {
+                      loadBuffer.length())) {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,
                                   JSSMSG_CACHE_EQ_CONTENT_FAILED);
         return false;
@@ -2750,7 +2750,7 @@ static bool Evaluate(JSContext* cx, unsi
     }
 
     size_t saveLength = saveBuffer.length();
-    if (saveLength >= INT32_MAX) {
+    if (saveLength >= INT32_MAX) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "Cannot save large cache entry content");
       return false;
     }
@@ -2769,7 +2769,7 @@ static bool Evaluate(JSContext* cx, unsi
 
 JSString* js::shell::FileAsString(JSContext* cx, JS::HandleString pathnameStr) {
   UniqueChars pathname = JS_EncodeStringToLatin1(cx, pathnameStr);
-  if (!pathname) {
+  if (!pathname) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2784,7 +2784,7 @@ JSString* js::shell::FileAsString(JSCont
   AutoCloseFile autoClose(file);
 
   struct stat st;
-  if (fstat(fileno(file), &st) != 0) {
+  if (fstat(fileno(file), &st) != 0) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorUTF8(cx, "can't stat %s", pathname.get());
     return nullptr;
   }
@@ -2794,48 +2794,48 @@ JSString* js::shell::FileAsString(JSCont
     return nullptr;
   }
 
-  if (fseek(file, 0, SEEK_END) != 0) {
+  if (fseek(file, 0, SEEK_END) != 0) {MOZ_RELEASE_ASSERT(0);
     pathname = JS_EncodeStringToUTF8(cx, pathnameStr);
-    if (!pathname) {
+    if (!pathname) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorUTF8(cx, "can't seek end of %s", pathname.get());
     return nullptr;
   }
 
   long endPos = ftell(file);
-  if (endPos < 0) {
+  if (endPos < 0) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorUTF8(cx, "can't read length of %s", pathname.get());
     return nullptr;
   }
 
   size_t len = endPos;
-  if (fseek(file, 0, SEEK_SET) != 0) {
+  if (fseek(file, 0, SEEK_SET) != 0) {MOZ_RELEASE_ASSERT(0);
     pathname = JS_EncodeStringToUTF8(cx, pathnameStr);
-    if (!pathname) {
+    if (!pathname) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorUTF8(cx, "can't seek start of %s", pathname.get());
     return nullptr;
   }
 
   UniqueChars buf(js_pod_malloc<char>(len + 1));
-  if (!buf) {
+  if (!buf) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorUTF8(cx, "out of memory reading %s", pathname.get());
     return nullptr;
   }
 
   size_t cc = fread(buf.get(), 1, len, file);
   if (cc != len) {
-    if (ptrdiff_t(cc) < 0) {
+    if (ptrdiff_t(cc) < 0) {MOZ_RELEASE_ASSERT(0);
       ReportCantOpenErrorUnknownEncoding(cx, pathname.get());
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       pathname = JS_EncodeStringToUTF8(cx, pathnameStr);
-      if (!pathname) {
+      if (!pathname) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorUTF8(cx, "can't read %s: short read", pathname.get());
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2843,7 +2843,7 @@ JSString* js::shell::FileAsString(JSCont
       JS::LossyUTF8CharsToNewTwoByteCharsZ(cx, JS::UTF8Chars(buf.get(), len),
                                            &len, js::MallocArena)
           .get());
-  if (!ucbuf) {
+  if (!ucbuf) {MOZ_RELEASE_ASSERT(0);
     pathname = JS_EncodeStringToUTF8(cx, pathnameStr);
     if (!pathname) {
       return nullptr;
@@ -2869,24 +2869,24 @@ static bool Run(JSContext* cx, unsigned 
   }
 
   RootedString str(cx, JS::ToString(cx, args[0]));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   args[0].setString(str);
 
   str = FileAsString(cx, str);
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   AutoStableStringChars chars(cx);
-  if (!chars.initTwoByte(cx, str)) {
+  if (!chars.initTwoByte(cx, str)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JS::SourceText<char16_t> srcBuf;
   if (!srcBuf.init(cx, chars.twoByteRange().begin().get(), str->length(),
-                   JS::SourceOwnership::Borrowed)) {
+                   JS::SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2895,7 +2895,7 @@ static bool Run(JSContext* cx, unsigned 
   {
     /* FIXME: This should use UTF-8 (bug 987069). */
     UniqueChars filename = JS_EncodeStringToLatin1(cx, str);
-    if (!filename) {
+    if (!filename) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2906,7 +2906,7 @@ static bool Run(JSContext* cx, unsigned 
         .setNoScriptRval(true);
 
     script = JS::Compile(cx, options, srcBuf);
-    if (!script) {
+    if (!script) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2921,14 +2921,14 @@ static bool Run(JSContext* cx, unsigned 
   return true;
 }
 
-static int js_fgets(char* buf, int size, FILE* file) {
+static int js_fgets(char* buf, int size, FILE* file) {MOZ_RELEASE_ASSERT(0);
   int n, i, c;
   bool crflag;
 
   n = size - 1;
-  if (n < 0) {
+  if (n < 0) {MOZ_RELEASE_ASSERT(0);
     return -1;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Use the fastest available getc.
   auto fast_getc =
@@ -2942,9 +2942,9 @@ static int js_fgets(char* buf, int size,
       ;
 
   crflag = false;
-  for (i = 0; i < n && (c = fast_getc(file)) != EOF; i++) {
+  for (i = 0; i < n && (c = fast_getc(file)) != EOF; i++) {MOZ_RELEASE_ASSERT(0);
     buf[i] = c;
-    if (c == '\n') {  // any \n ends a line
+    if (c == '\n') {MOZ_RELEASE_ASSERT(0);  // any \n ends a line
       i++;            // keep the \n; we know there is room for \0
       break;
     }
@@ -2963,7 +2963,7 @@ static int js_fgets(char* buf, int size,
  * function readline()
  * Provides a hook for scripts to read a line from stdin.
  */
-static bool ReadLine(JSContext* cx, unsigned argc, Value* vp) {
+static bool ReadLine(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
   static constexpr size_t BUFSIZE = 256;
@@ -2971,56 +2971,56 @@ static bool ReadLine(JSContext* cx, unsi
   size_t buflength = 0;
   size_t bufsize = BUFSIZE;
   char* buf = (char*)JS_malloc(cx, bufsize);
-  if (!buf) {
-    return false;
-  }
+  if (!buf) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
 
   bool sawNewline = false;
   size_t gotlength;
   while ((gotlength = js_fgets(buf + buflength, bufsize - buflength, from)) >
-         0) {
+         0) {MOZ_RELEASE_ASSERT(0);
     buflength += gotlength;
 
     /* Are we done? */
-    if (buf[buflength - 1] == '\n') {
+    if (buf[buflength - 1] == '\n') {MOZ_RELEASE_ASSERT(0);
       buf[buflength - 1] = '\0';
       sawNewline = true;
       break;
-    } else if (buflength < bufsize - 1) {
+    } else if (buflength < bufsize - 1) {MOZ_RELEASE_ASSERT(0);
       break;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     /* Else, grow our buffer for another pass. */
     char* tmp;
     bufsize *= 2;
-    if (bufsize > buflength) {
+    if (bufsize > buflength) {MOZ_RELEASE_ASSERT(0);
       tmp = static_cast<char*>(JS_realloc(cx, buf, bufsize / 2, bufsize));
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       JS_ReportOutOfMemory(cx);
       tmp = nullptr;
     }
 
-    if (!tmp) {
+    if (!tmp) {MOZ_RELEASE_ASSERT(0);
       JS_free(cx, buf);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     buf = tmp;
   }
 
   /* Treat the empty string specially. */
-  if (buflength == 0) {
+  if (buflength == 0) {MOZ_RELEASE_ASSERT(0);
     args.rval().set(feof(from) ? NullValue() : JS_GetEmptyStringValue(cx));
     JS_free(cx, buf);
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   /* Shrink the buffer to the real size. */
   char* tmp = static_cast<char*>(JS_realloc(cx, buf, bufsize, buflength));
-  if (!tmp) {
+  if (!tmp) {MOZ_RELEASE_ASSERT(0);
     JS_free(cx, buf);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   buf = tmp;
 
@@ -3072,7 +3072,7 @@ static bool ReadLineBuf(JSContext* cx, u
     }
 
     JSString* str = JS_NewStringCopyUTF8N(cx, JS::UTF8Chars(currentBuf, len));
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3091,7 +3091,7 @@ static bool ReadLineBuf(JSContext* cx, u
     sc->readLineBufPos = 0;
 
     RootedString str(cx, JS::ToString(cx, args[0]));
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     sc->readLineBuf = JS_EncodeStringToUTF8(cx, str);
@@ -3111,15 +3111,15 @@ static bool PutStr(JSContext* cx, unsign
   CallArgs args = CallArgsFromVp(argc, vp);
 
   if (args.length() != 0) {
-    if (!gOutFile->isOpen()) {
+    if (!gOutFile->isOpen()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "output file is closed");
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     RootedString str(cx, JS::ToString(cx, args[0]));
-    if (!str) {
-      return false;
-    }
+    if (!str) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }MOZ_RELEASE_ASSERT(0);
     UniqueChars bytes = JS_EncodeStringToUTF8(cx, str);
     if (!bytes) {
       return false;
@@ -3147,7 +3147,7 @@ static bool CpuNow(JSContext* cx, unsign
 }
 
 static bool PrintInternal(JSContext* cx, const CallArgs& args, RCFile* file) {
-  if (!file->isOpen()) {
+  if (!file->isOpen()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "output file is closed");
     return false;
   }
@@ -3197,13 +3197,13 @@ static bool Quit(JSContext* cx, unsigned
 
   // Print a message to stderr in differential testing to help jsfunfuzz
   // find uncatchable-exception bugs.
-  if (js::SupportDifferentialTesting()) {
+  if (js::SupportDifferentialTesting()) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "quit called\n");
   }
 
   CallArgs args = CallArgsFromVp(argc, vp);
   int32_t code;
-  if (!ToInt32(cx, args.get(0), &code)) {
+  if (!ToInt32(cx, args.get(0), &code)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3225,7 +3225,7 @@ static bool Quit(JSContext* cx, unsigned
 
 static bool StartTimingMutator(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (args.length() > 0) {
+  if (args.length() > 0) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,
                               JSSMSG_TOO_MANY_ARGS, "startTimingMutator");
     return false;
@@ -3243,14 +3243,14 @@ static bool StartTimingMutator(JSContext
 
 static bool StopTimingMutator(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (args.length() > 0) {
+  if (args.length() > 0) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,
                               JSSMSG_TOO_MANY_ARGS, "stopTimingMutator");
     return false;
   }
 
   double mutator_ms, gc_ms;
-  if (!cx->runtime()->gc.stats().stopTimingMutator(mutator_ms, gc_ms)) {
+  if (!cx->runtime()->gc.stats().stopTimingMutator(mutator_ms, gc_ms)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx,
                         "stopTimingMutator called when not timing the mutator");
     return false;
@@ -3280,7 +3280,7 @@ static const char* ToSource(JSContext* c
 
 static bool AssertEq(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (!(args.length() == 2 || (args.length() == 3 && args[2].isString()))) {
+  if (!(args.length() == 2 || (args.length() == 3 && args[2].isString()))) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,
                               (args.length() < 2)    ? JSSMSG_NOT_ENOUGH_ARGS
                               : (args.length() == 3) ? JSSMSG_INVALID_ARGS
@@ -3290,7 +3290,7 @@ static bool AssertEq(JSContext* cx, unsi
   }
 
   bool same;
-  if (!JS::SameValue(cx, args[0], args[1], &same)) {
+  if (!JS::SameValue(cx, args[0], args[1], &same)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!same) {
@@ -3300,7 +3300,7 @@ static bool AssertEq(JSContext* cx, unsi
     if (args.length() == 2) {
       JS_ReportErrorNumberUTF8(cx, my_GetErrorMessage, nullptr,
                                JSSMSG_ASSERT_EQ_FAILED, actual, expected);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       RootedString message(cx, args[2].toString());
       UniqueChars bytes2 = QuoteString(cx, message);
       if (!bytes2) {
@@ -3330,13 +3330,13 @@ static bool GetScriptAndPCArgs(JSContext
     unsigned intarg = 0;
     if (v.isObject() && JS::GetClass(&v.toObject()) == &JSFunction::class_) {
       script = TestingFunctionArgumentToScript(cx, v);
-      if (!script) {
+      if (!script) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       intarg++;
     }
     if (!args.get(intarg).isUndefined()) {
-      if (!JS::ToInt32(cx, args[intarg], ip)) {
+      if (!JS::ToInt32(cx, args[intarg], ip)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if ((uint32_t)*ip >= script->length()) {
@@ -3358,22 +3358,22 @@ static bool LineToPC(JSContext* cx, unsi
     JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,
                               JSSMSG_LINE2PC_USAGE);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedScript script(cx, GetTopScript(cx));
   int32_t lineArg = 0;
-  if (args[0].isObject() && args[0].toObject().is<JSFunction>()) {
+  if (args[0].isObject() && args[0].toObject().is<JSFunction>()) {MOZ_RELEASE_ASSERT(0);
     script = TestingFunctionArgumentToScript(cx, args[0]);
-    if (!script) {
-      return false;
-    }
+    if (!script) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }MOZ_RELEASE_ASSERT(0);
     lineArg++;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   uint32_t lineno;
-  if (!ToUint32(cx, args.get(lineArg), &lineno)) {
-    return false;
-  }
+  if (!ToUint32(cx, args.get(lineArg), &lineno)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
 
   jsbytecode* pc = LineNumberToPC(script, lineno);
   if (!pc) {
@@ -4085,7 +4085,7 @@ static bool DisassWithSrc(JSContext* cx,
 #endif /* defined(DEBUG) || defined(JS_JITSPEW) */
 
 #ifdef JS_CACHEIR_SPEW
-static bool RateMyCacheIR(JSContext* cx, unsigned argc, Value* vp) {
+static bool RateMyCacheIR(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
   js::jit::CacheIRHealth cih;
@@ -4096,24 +4096,24 @@ static bool RateMyCacheIR(JSContext* cx,
   // sets and unsets the proper channel for the duration of spewing
   // a health report.
   AutoSpewChannel channel(cx, SpewChannel::RateMyCacheIR, script);
-  if (!argc) {
+  if (!argc) {MOZ_RELEASE_ASSERT(0);
     // Calling RateMyCacheIR without any arguments will create health
     // reports for all scripts in the zone.
     for (auto base = cx->zone()->cellIter<BaseScript>(); !base.done();
-         base.next()) {
-      if (!base->hasJitScript() || base->selfHosted()) {
+         base.next()) {MOZ_RELEASE_ASSERT(0);
+      if (!base->hasJitScript() || base->selfHosted()) {MOZ_RELEASE_ASSERT(0);
         continue;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       script = base->asJSScript();
       cih.rateScript(cx, script, js::jit::SpewContext::Shell);
     }
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     RootedValue value(cx, args.get(0));
 
-    if (value.isObject() && value.toObject().is<ModuleObject>()) {
+    if (value.isObject() && value.toObject().is<ModuleObject>()) {MOZ_RELEASE_ASSERT(0);
       script = value.toObject().as<ModuleObject>().maybeScript();
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       script = TestingFunctionArgumentToScript(cx, args.get(0));
     }
 
@@ -4140,12 +4140,12 @@ static bool Intern(JSContext* cx, unsign
   CallArgs args = CallArgsFromVp(argc, vp);
 
   JSString* str = JS::ToString(cx, args.get(0));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   AutoStableStringChars strChars(cx);
-  if (!strChars.initTwoByte(cx, str)) {
+  if (!strChars.initTwoByte(cx, str)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4301,23 +4301,23 @@ static bool FuzzilliUseReprlMode(OptionP
 #endif /* FUZZING_JS_FUZZILLI */
 }
 
-static bool Crash(JSContext* cx, unsigned argc, Value* vp) {
-  CallArgs args = CallArgsFromVp(argc, vp);
-  if (args.length() == 0) {
+static bool Crash(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
+  CallArgs args = CallArgsFromVp(argc, vp);
+  if (args.length() == 0) {MOZ_RELEASE_ASSERT(0);
     MOZ_CRASH("forced crash");
-  }
+  }MOZ_RELEASE_ASSERT(0);
   RootedString message(cx, JS::ToString(cx, args[0]));
-  if (!message) {
-    return false;
-  }
+  if (!message) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
   UniqueChars utf8chars = JS_EncodeStringToUTF8(cx, message);
-  if (!utf8chars) {
-    return false;
-  }
-  if (args.get(1).isObject()) {
+  if (!utf8chars) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (args.get(1).isObject()) {MOZ_RELEASE_ASSERT(0);
     RootedValue v(cx);
     RootedObject opts(cx, &args[1].toObject());
-    if (!JS_GetProperty(cx, opts, "suppress_minidump", &v)) {
+    if (!JS_GetProperty(cx, opts, "suppress_minidump", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (v.isBoolean() && v.toBoolean()) {
@@ -4352,7 +4352,7 @@ static bool CopyErrorReportToObject(JSCo
   RootedString nameStr(cx);
   if (report->exnType == JSEXN_WARN) {
     nameStr = JS_NewStringCopyZ(cx, "Warning");
-    if (!nameStr) {
+    if (!nameStr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -4364,26 +4364,26 @@ static bool CopyErrorReportToObject(JSCo
     }
   }
   RootedValue nameVal(cx, StringValue(nameStr));
-  if (!DefineDataProperty(cx, obj, cx->names().name, nameVal)) {
+  if (!DefineDataProperty(cx, obj, cx->names().name, nameVal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedString messageStr(cx, report->newMessageString(cx));
-  if (!messageStr) {
+  if (!messageStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedValue messageVal(cx, StringValue(messageStr));
-  if (!DefineDataProperty(cx, obj, cx->names().message, messageVal)) {
+  if (!DefineDataProperty(cx, obj, cx->names().message, messageVal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedValue linenoVal(cx, Int32Value(report->lineno));
-  if (!DefineDataProperty(cx, obj, cx->names().lineNumber, linenoVal)) {
+  if (!DefineDataProperty(cx, obj, cx->names().lineNumber, linenoVal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedValue columnVal(cx, Int32Value(report->column));
-  if (!DefineDataProperty(cx, obj, cx->names().columnNumber, columnVal)) {
+  if (!DefineDataProperty(cx, obj, cx->names().columnNumber, columnVal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4402,25 +4402,25 @@ static bool CreateErrorReport(JSContext*
   // We don't have a stack here, so just initialize with null.
   JS::ExceptionStack exnStack(cx, args.get(0), nullptr);
   JS::ErrorReportBuilder report(cx);
-  if (!report.init(cx, exnStack, JS::ErrorReportBuilder::WithSideEffects)) {
+  if (!report.init(cx, exnStack, JS::ErrorReportBuilder::WithSideEffects)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MOZ_ASSERT(!report.report()->isWarning());
 
   RootedObject obj(cx, JS_NewPlainObject(cx));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedString toString(cx,
                         NewStringCopyUTF8Z<CanGC>(cx, report.toStringResult()));
-  if (!toString) {
+  if (!toString) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (!JS_DefineProperty(cx, obj, "toStringResult", toString,
-                         JSPROP_ENUMERATE)) {
+                         JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4447,7 +4447,7 @@ static bool sandbox_enumerate(JSContext*
                               bool enumerableOnly) {
   RootedValue v(cx);
 
-  if (!JS_GetProperty(cx, obj, "lazy", &v)) {
+  if (!JS_GetProperty(cx, obj, "lazy", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4461,7 +4461,7 @@ static bool sandbox_enumerate(JSContext*
 static bool sandbox_resolve(JSContext* cx, HandleObject obj, HandleId id,
                             bool* resolvedp) {
   RootedValue v(cx);
-  if (!JS_GetProperty(cx, obj, "lazy", &v)) {
+  if (!JS_GetProperty(cx, obj, "lazy", &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4556,19 +4556,19 @@ static JSObject* NewSandbox(JSContext* c
   RootedObject obj(cx,
                    JS_NewGlobalObject(cx, &sandbox_class, principals,
                                       JS::DontFireOnNewGlobalHook, options));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   {
     JSAutoRealm ar(cx, obj);
-    if (!lazy && !JS::InitRealmStandardClasses(cx)) {
+    if (!lazy && !JS::InitRealmStandardClasses(cx)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     RootedValue value(cx, BooleanValue(lazy));
     if (!JS_DefineProperty(cx, obj, "lazy", value,
-                           JSPROP_PERMANENT | JSPROP_READONLY)) {
+                           JSPROP_PERMANENT | JSPROP_READONLY)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -4588,20 +4588,20 @@ static bool EvalInContext(JSContext* cx,
   }
 
   RootedString str(cx, ToString(cx, args[0]));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject sobj(cx);
   if (args.hasDefined(1)) {
     sobj = ToObject(cx, args[1]);
-    if (!sobj) {
+    if (!sobj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   AutoStableStringChars strChars(cx);
-  if (!strChars.initTwoByte(cx, str)) {
+  if (!strChars.initTwoByte(cx, str)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4703,7 +4703,7 @@ static bool ShellBuildId(JS::BuildIdChar
 
 JSObject* GetElementCallback(JSContext* cx, JS::HandleValue value) {
   RootedValue privateValue(cx, value);
-  if (!privateValue.isObject()) {
+  if (!privateValue.isObject()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -4712,7 +4712,7 @@ JSObject* GetElementCallback(JSContext* 
   AutoRealm ar(cx, infoObject);
 
   RootedValue elementValue(cx);
-  if (!JS_GetProperty(cx, infoObject, "element", &elementValue)) {
+  if (!JS_GetProperty(cx, infoObject, "element", &elementValue)) {MOZ_RELEASE_ASSERT(0);
     // This shouldn't happen in the shell, as ParseCompileOptions always
     // creates the infoObject with this property. In any case, this callback
     // must not leave an exception pending, so:
@@ -4729,12 +4729,12 @@ static void WorkerMain(WorkerInput* inpu
   MOZ_ASSERT(input->parentRuntime);
 
   JSContext* cx = JS_NewContext(8L * 1024L * 1024L, input->parentRuntime);
-  if (!cx) {
+  if (!cx) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
   ShellContext* sc = js_new<ShellContext>(cx);
-  if (!sc) {
+  if (!sc) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -4768,7 +4768,7 @@ static void WorkerMain(WorkerInput* inpu
   JS::SetHostCleanupFinalizationRegistryCallback(
       cx, ShellCleanupFinalizationRegistryCallback, sc);
 
-  if (!JS::InitSelfHostedCode(cx)) {
+  if (!JS::InitSelfHostedCode(cx)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -4781,7 +4781,7 @@ static void WorkerMain(WorkerInput* inpu
     RootedObject global(cx, NewGlobalObject(cx, realmOptions, nullptr,
                                             ShellGlobalKind::WindowProxy,
                                             /* immutablePrototype = */ true));
-    if (!global) {
+    if (!global) {MOZ_RELEASE_ASSERT(0);
       break;
     }
 
@@ -4790,11 +4790,11 @@ static void WorkerMain(WorkerInput* inpu
     JS::ConstUTF8CharsZ path(processWideModuleLoadPath.get(),
                              strlen(processWideModuleLoadPath.get()));
     RootedString moduleLoadPath(cx, JS_NewStringCopyUTF8Z(cx, path));
-    if (!moduleLoadPath) {
+    if (!moduleLoadPath) {MOZ_RELEASE_ASSERT(0);
       return;
     }
     sc->moduleLoader = js::MakeUnique<ModuleLoader>();
-    if (!sc->moduleLoader || !sc->moduleLoader->init(cx, moduleLoadPath)) {
+    if (!sc->moduleLoader || !sc->moduleLoader->init(cx, moduleLoadPath)) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
@@ -4804,7 +4804,7 @@ static void WorkerMain(WorkerInput* inpu
     AutoReportException are(cx);
     JS::SourceText<char16_t> srcBuf;
     if (!srcBuf.init(cx, input->chars.get(), input->length,
-                     JS::SourceOwnership::Borrowed)) {
+                     JS::SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
       break;
     }
 
@@ -4853,13 +4853,13 @@ static bool EvalInWorker(JSContext* cx, 
   }
 #endif
 
-  if (!args[0].toString()->ensureLinear(cx)) {
+  if (!args[0].toString()->ensureLinear(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (!workerThreadsLock) {
     workerThreadsLock = js_new<Mutex>(mutexid::ShellWorkerThreads);
-    if (!workerThreadsLock) {
+    if (!workerThreadsLock) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
@@ -4868,7 +4868,7 @@ static bool EvalInWorker(JSContext* cx, 
   JSLinearString* str = &args[0].toString()->asLinear();
 
   UniqueTwoByteChars chars(js_pod_malloc<char16_t>(str->length()));
-  if (!chars) {
+  if (!chars) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -4877,7 +4877,7 @@ static bool EvalInWorker(JSContext* cx, 
 
   WorkerInput* input = js_new<WorkerInput>(JS_GetParentRuntime(cx),
                                            std::move(chars), str->length());
-  if (!input) {
+  if (!input) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -4887,7 +4887,7 @@ static bool EvalInWorker(JSContext* cx, 
     AutoEnterOOMUnsafeRegion oomUnsafe;
     thread = js_new<Thread>(
         Thread::Options().setStackSize(gMaxStackSize + 512 * 1024));
-    if (!thread || !thread->init(WorkerMain, input)) {
+    if (!thread || !thread->init(WorkerMain, input)) {MOZ_RELEASE_ASSERT(0);
       oomUnsafe.crash("EvalInWorker");
     }
   }
@@ -4922,7 +4922,7 @@ static bool Sleep_fn(JSContext* cx, unsi
   TimeDuration duration = TimeDuration::FromSeconds(0.0);
   if (args.length() > 0) {
     double t_secs;
-    if (!ToNumber(cx, args[0], &t_secs)) {
+    if (!ToNumber(cx, args[0], &t_secs)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (mozilla::IsNaN(t_secs)) {
@@ -4933,7 +4933,7 @@ static bool Sleep_fn(JSContext* cx, unsi
     duration = TimeDuration::FromSeconds(std::max(0.0, t_secs));
     const TimeDuration MAX_TIMEOUT_INTERVAL =
         TimeDuration::FromSeconds(MAX_TIMEOUT_SECONDS);
-    if (duration > MAX_TIMEOUT_INTERVAL) {
+    if (duration > MAX_TIMEOUT_INTERVAL) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "Excessive sleep interval");
       return false;
     }
@@ -4943,7 +4943,7 @@ static bool Sleep_fn(JSContext* cx, unsi
     TimeStamp toWakeup = TimeStamp::Now() + duration;
     for (;;) {
       sc->sleepWakeup.wait_for(guard, duration);
-      if (sc->serviceInterrupt) {
+      if (sc->serviceInterrupt) {MOZ_RELEASE_ASSERT(0);
         break;
       }
       auto now = TimeStamp::Now();
@@ -5019,7 +5019,7 @@ static void WatchdogMain(JSContext* cx) 
 static bool ScheduleWatchdog(JSContext* cx, double t) {
   ShellContext* sc = GetShellContext(cx);
 
-  if (t <= 0) {
+  if (t <= 0) {MOZ_RELEASE_ASSERT(0);
     LockGuard<Mutex> guard(sc->watchdogLock);
     sc->watchdogTimeout = Nothing();
     return true;
@@ -5032,7 +5032,7 @@ static bool ScheduleWatchdog(JSContext* 
     MOZ_ASSERT(!sc->watchdogTimeout);
     sc->watchdogThread.emplace();
     AutoEnterOOMUnsafeRegion oomUnsafe;
-    if (!sc->watchdogThread->init(WatchdogMain, cx)) {
+    if (!sc->watchdogThread->init(WatchdogMain, cx)) {MOZ_RELEASE_ASSERT(0);
       oomUnsafe.crash("watchdogThread.init");
     }
   } else if (!sc->watchdogTimeout || timeout < sc->watchdogTimeout.value()) {
@@ -5079,13 +5079,13 @@ static void CancelExecution(JSContext* c
 }
 
 static bool SetTimeoutValue(JSContext* cx, double t) {
-  if (mozilla::IsNaN(t)) {
+  if (mozilla::IsNaN(t)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "timeout is not a number");
     return false;
   }
   const TimeDuration MAX_TIMEOUT_INTERVAL =
       TimeDuration::FromSeconds(MAX_TIMEOUT_SECONDS);
-  if (TimeDuration::FromSeconds(t) > MAX_TIMEOUT_INTERVAL) {
+  if (TimeDuration::FromSeconds(t) > MAX_TIMEOUT_INTERVAL) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Excessive timeout value");
     return false;
   }
@@ -5106,13 +5106,13 @@ static bool Timeout(JSContext* cx, unsig
     return true;
   }
 
-  if (args.length() > 2) {
+  if (args.length() > 2) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Wrong number of arguments");
     return false;
   }
 
   double t;
-  if (!ToNumber(cx, args[0], &t)) {
+  if (!ToNumber(cx, args[0], &t)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5231,7 +5231,7 @@ static bool SetJitCompilerOption(JSConte
   }
 
   JSLinearString* strArg = JS_EnsureLinearString(cx, args[0].toString());
-  if (!strArg) {
+  if (!strArg) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5293,13 +5293,13 @@ static bool SetJitCompilerOption(JSConte
   // such as other options set and whether a debugger is present.
   if ((opt == JSJITCOMPILER_WASM_JIT_BASELINE ||
        opt == JSJITCOMPILER_WASM_JIT_OPTIMIZING) &&
-      number == 0) {
+      number == 0) {MOZ_RELEASE_ASSERT(0);
     uint32_t baseline, optimizing;
     MOZ_ALWAYS_TRUE(JS_GetGlobalJitCompilerOption(
         cx, JSJITCOMPILER_WASM_JIT_BASELINE, &baseline));
     MOZ_ALWAYS_TRUE(JS_GetGlobalJitCompilerOption(
         cx, JSJITCOMPILER_WASM_JIT_OPTIMIZING, &optimizing));
-    if (baseline + optimizing == 1) {
+    if (baseline + optimizing == 1) {MOZ_RELEASE_ASSERT(0);
       if ((opt == JSJITCOMPILER_WASM_JIT_BASELINE && baseline) ||
           (opt == JSJITCOMPILER_WASM_JIT_OPTIMIZING && optimizing)) {
         JS_ReportErrorASCII(
@@ -5430,19 +5430,19 @@ static bool Compile(JSContext* cx, unsig
   if (!args.requireAtLeast(cx, "compile", 1)) {
     return false;
   }
-  if (!args[0].isString()) {
+  if (!args[0].isString()) {MOZ_RELEASE_ASSERT(0);
     const char* typeName = InformalValueTypeName(args[0]);
     JS_ReportErrorASCII(cx, "expected string to compile, got %s", typeName);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedObject global(cx, JS::CurrentGlobalOrNull(cx));
   RootedString scriptContents(cx, args[0].toString());
 
   AutoStableStringChars stableChars(cx);
-  if (!stableChars.initTwoByte(cx, scriptContents)) {
-    return false;
-  }
+  if (!stableChars.initTwoByte(cx, scriptContents)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
 
   JS::CompileOptions options(cx);
   options.setIntroductionType("js shell compile")
@@ -5450,24 +5450,24 @@ static bool Compile(JSContext* cx, unsig
       .setIsRunOnce(true)
       .setNoScriptRval(true);
 
-  if (args.length() >= 2) {
-    if (args[1].isPrimitive()) {
+  if (args.length() >= 2) {MOZ_RELEASE_ASSERT(0);
+    if (args[1].isPrimitive()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,
                                 JSSMSG_INVALID_ARGS, "compile");
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     RootedObject opts(cx, &args[1].toObject());
-    if (!ParseCompileOptions(cx, options, opts, nullptr)) {
-      return false;
-    }
-  }
+    if (!ParseCompileOptions(cx, options, opts, nullptr)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
 
   JS::SourceText<char16_t> srcBuf;
   if (!srcBuf.init(cx, stableChars.twoByteRange().begin().get(),
-                   scriptContents->length(), JS::SourceOwnership::Borrowed)) {
-    return false;
-  }
+                   scriptContents->length(), JS::SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedScript script(cx, JS::Compile(cx, options, srcBuf));
   if (!script) {
@@ -5510,13 +5510,13 @@ static bool ParseModule(JSContext* cx, u
       const char* typeName = InformalValueTypeName(args[1]);
       JS_ReportErrorASCII(cx, "expected filename string, got %s", typeName);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     RootedString str(cx, args[1].toString());
     filename = JS_EncodeStringToLatin1(cx, str);
-    if (!filename) {
-      return false;
-    }
+    if (!filename) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }MOZ_RELEASE_ASSERT(0);
 
     options.setFileAndLine(filename.get(), 1);
   } else {
@@ -5525,14 +5525,14 @@ static bool ParseModule(JSContext* cx, u
   options.setModule();
 
   AutoStableStringChars stableChars(cx);
-  if (!stableChars.initTwoByte(cx, scriptContents)) {
+  if (!stableChars.initTwoByte(cx, scriptContents)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   const char16_t* chars = stableChars.twoByteRange().begin().get();
   JS::SourceText<char16_t> srcBuf;
   if (!srcBuf.init(cx, chars, scriptContents->length(),
-                   JS::SourceOwnership::Borrowed)) {
+                   JS::SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5596,7 +5596,7 @@ XDRBufferObject* XDRBufferObject::create
                                          JS::TranscodeBuffer&& buf) {
   XDRBufferObject* bufObj =
       NewObjectWithGivenProto<XDRBufferObject>(cx, nullptr);
-  if (!bufObj) {
+  if (!bufObj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -5626,7 +5626,7 @@ static bool CodeModule(JSContext* cx, un
     return false;
   }
 
-  if (!args[0].isObject() || !args[0].toObject().is<ModuleObject>()) {
+  if (!args[0].isObject() || !args[0].toObject().is<ModuleObject>()) {MOZ_RELEASE_ASSERT(0);
     const char* typeName = InformalValueTypeName(args[0]);
     JS_ReportErrorASCII(cx, "expected module object, got %s", typeName);
     return false;
@@ -5641,7 +5641,7 @@ static bool CodeModule(JSContext* cx, un
   JS::TranscodeBuffer buf;
   XDREncoder xdrEncoder_(cx, buf);
   XDRResult res = xdrEncoder_.codeModuleObject(&modObject);
-  if (res.isErr()) {
+  if (res.isErr()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5659,7 +5659,7 @@ static bool DecodeModule(JSContext* cx, 
     return false;
   }
 
-  if (!args[0].isObject() || !args[0].toObject().is<XDRBufferObject>()) {
+  if (!args[0].isObject() || !args[0].toObject().is<XDRBufferObject>()) {MOZ_RELEASE_ASSERT(0);
     const char* typeName = InformalValueTypeName(args[0]);
     JS_ReportErrorASCII(cx, "expected XDRBufferObject to compile, got %s",
                         typeName);
@@ -5673,7 +5673,7 @@ static bool DecodeModule(JSContext* cx, 
                          *args[0].toObject().as<XDRBufferObject>().data());
   RootedModuleObject modObject(cx, nullptr);
   XDRResult res = xdrDecoder_.codeModuleObject(&modObject);
-  if (res.isErr()) {
+  if (res.isErr()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5691,13 +5691,13 @@ static bool RegisterModule(JSContext* cx
     return false;
   }
 
-  if (!args[0].isString()) {
+  if (!args[0].isString()) {MOZ_RELEASE_ASSERT(0);
     const char* typeName = InformalValueTypeName(args[0]);
     JS_ReportErrorASCII(cx, "expected string, got %s", typeName);
     return false;
   }
 
-  if (!args[1].isObject() || !args[1].toObject().is<ModuleObject>()) {
+  if (!args[1].isObject() || !args[1].toObject().is<ModuleObject>()) {MOZ_RELEASE_ASSERT(0);
     const char* typeName = InformalValueTypeName(args[0]);
     JS_ReportErrorASCII(cx, "expected module, got %s", typeName);
     return false;
@@ -5731,14 +5731,14 @@ static bool DumpAST(JSContext* cx, const
                                         /* foldConstants = */ false,
                                         compilationState,
                                         /* syntaxParser = */ nullptr);
-  if (!parser.checkOptions()) {
+  if (!parser.checkOptions()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Emplace the top-level stencil.
   MOZ_ASSERT(compilationState.scriptData.length() ==
              CompilationStencil::TopLevelIndex);
-  if (!compilationState.appendScriptStencilAndData(cx)) {
+  if (!compilationState.appendScriptStencilAndData(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5746,7 +5746,7 @@ static bool DumpAST(JSContext* cx, const
   if (goal == frontend::ParseGoal::Script) {
     pn = parser.parse();
   } else {
-    if (!GlobalObject::ensureModulePrototypesCreated(cx, cx->global())) {
+    if (!GlobalObject::ensureModulePrototypesCreated(cx, cx->global())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5778,7 +5778,7 @@ template <typename Unit>
                                            frontend::CompilationInput(options));
 
   JS::SourceText<Unit> srcBuf;
-  if (!srcBuf.init(cx, units, length, JS::SourceOwnership::Borrowed)) {
+  if (!srcBuf.init(cx, units, length, JS::SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5790,7 +5790,7 @@ template <typename Unit>
     stencil = frontend::ParseModuleToExtensibleStencil(cx, input.get(), srcBuf);
   }
 
-  if (!stencil) {
+  if (!stencil) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5813,7 +5813,7 @@ static bool FrontendTest(JSContext* cx, 
   if (!args.requireAtLeast(cx, funcName, 1)) {
     return false;
   }
-  if (!args[0].isString()) {
+  if (!args[0].isString()) {MOZ_RELEASE_ASSERT(0);
     const char* typeName = InformalValueTypeName(args[0]);
     JS_ReportErrorASCII(cx, "expected string to parse, got %s", typeName);
     return false;
@@ -5831,7 +5831,7 @@ static bool FrontendTest(JSContext* cx, 
       .setNoScriptRval(true);
 
   if (args.length() >= 2) {
-    if (!args[1].isObject()) {
+    if (!args[1].isObject()) {MOZ_RELEASE_ASSERT(0);
       const char* typeName = InformalValueTypeName(args[1]);
       JS_ReportErrorASCII(cx, "expected object (options) to parse, got %s",
                           typeName);
@@ -5840,7 +5840,7 @@ static bool FrontendTest(JSContext* cx, 
     RootedObject objOptions(cx, &args[1].toObject());
 
     RootedValue optionModule(cx);
-    if (!JS_GetProperty(cx, objOptions, "module", &optionModule)) {
+    if (!JS_GetProperty(cx, objOptions, "module", &optionModule)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5848,14 +5848,14 @@ static bool FrontendTest(JSContext* cx, 
       if (optionModule.toBoolean()) {
         goal = frontend::ParseGoal::Module;
       }
-    } else if (!optionModule.isUndefined()) {
+    } else if (!optionModule.isUndefined()) {MOZ_RELEASE_ASSERT(0);
       const char* typeName = InformalValueTypeName(optionModule);
       JS_ReportErrorASCII(cx, "option `module` should be a boolean, got %s",
                           typeName);
       return false;
     }
 
-    if (!ParseCompileOptions(cx, options, objOptions, nullptr)) {
+    if (!ParseCompileOptions(cx, options, objOptions, nullptr)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5887,7 +5887,7 @@ static bool FrontendTest(JSContext* cx, 
 
   JSString* scriptContents = args[0].toString();
   RootedLinearString linearString(cx, scriptContents->ensureLinear(cx));
-  if (!linearString) {
+  if (!linearString) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5901,12 +5901,12 @@ static bool FrontendTest(JSContext* cx, 
 
   AutoStableStringChars stableChars(cx);
   if (isAscii) {
-    if (!stableChars.init(cx, scriptContents)) {
+    if (!stableChars.init(cx, scriptContents)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     MOZ_ASSERT(stableChars.isLatin1());
   } else {
-    if (!stableChars.initTwoByte(cx, scriptContents)) {
+    if (!stableChars.initTwoByte(cx, scriptContents)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -5990,15 +5990,15 @@ static bool FrontendTest(JSContext* cx, 
     if (isAscii) {
       const Latin1Char* latin1 = stableChars.latin1Range().begin().get();
       auto utf8 = reinterpret_cast<const mozilla::Utf8Unit*>(latin1);
-      if (!DumpStencil<mozilla::Utf8Unit>(cx, options, utf8, length, goal)) {
-        return false;
-      }
-    } else {
+      if (!DumpStencil<mozilla::Utf8Unit>(cx, options, utf8, length, goal)) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }
+    } else {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(stableChars.isTwoByte());
       const char16_t* chars = stableChars.twoByteRange().begin().get();
-      if (!DumpStencil<char16_t>(cx, options, chars, length, goal)) {
-        return false;
-      }
+      if (!DumpStencil<char16_t>(cx, options, chars, length, goal)) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }MOZ_RELEASE_ASSERT(0);
     }
 
     args.rval().setUndefined();
@@ -6008,18 +6008,18 @@ static bool FrontendTest(JSContext* cx, 
   Rooted<frontend::CompilationInput> input(cx,
                                            frontend::CompilationInput(options));
   if (goal == frontend::ParseGoal::Script) {
-    if (!input.get().initForGlobal(cx)) {
+    if (!input.get().initForGlobal(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
-    if (!input.get().initForModule(cx)) {
+    if (!input.get().initForModule(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   LifoAllocScope allocScope(&cx->tempLifoAlloc());
   frontend::CompilationState compilationState(cx, allocScope, input.get());
-  if (!compilationState.init(cx)) {
+  if (!compilationState.init(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6066,7 +6066,7 @@ static bool SyntaxParse(JSContext* cx, u
   if (!args.requireAtLeast(cx, "syntaxParse", 1)) {
     return false;
   }
-  if (!args[0].isString()) {
+  if (!args[0].isString()) {MOZ_RELEASE_ASSERT(0);
     const char* typeName = InformalValueTypeName(args[0]);
     JS_ReportErrorASCII(cx, "expected string to parse, got %s", typeName);
     return false;
@@ -6079,7 +6079,7 @@ static bool SyntaxParse(JSContext* cx, u
       .setFileAndLine("<string>", 1);
 
   AutoStableStringChars stableChars(cx);
-  if (!stableChars.initTwoByte(cx, scriptContents)) {
+  if (!stableChars.initTwoByte(cx, scriptContents)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6088,13 +6088,13 @@ static bool SyntaxParse(JSContext* cx, u
 
   Rooted<frontend::CompilationInput> input(cx,
                                            frontend::CompilationInput(options));
-  if (!input.get().initForGlobal(cx)) {
+  if (!input.get().initForGlobal(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   LifoAllocScope allocScope(&cx->tempLifoAlloc());
   frontend::CompilationState compilationState(cx, allocScope, input.get());
-  if (!compilationState.init(cx)) {
+  if (!compilationState.init(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6102,12 +6102,12 @@ static bool SyntaxParse(JSContext* cx, u
       cx, options, chars, length,
       /* foldConstants = */ false, compilationState,
       /* syntaxParser = */ nullptr);
-  if (!parser.checkOptions()) {
+  if (!parser.checkOptions()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   bool succeeded = parser.parse();
-  if (cx->isExceptionPending()) {
+  if (cx->isExceptionPending()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6140,7 +6140,7 @@ static bool OffThreadCompileScript(JSCon
   if (!args.requireAtLeast(cx, "offThreadCompileScript", 1)) {
     return false;
   }
-  if (!args[0].isString()) {
+  if (!args[0].isString()) {MOZ_RELEASE_ASSERT(0);
     const char* typeName = InformalValueTypeName(args[0]);
     JS_ReportErrorASCII(cx, "expected string to parse, got %s", typeName);
     return false;
@@ -6152,14 +6152,14 @@ static bool OffThreadCompileScript(JSCon
       .setFileAndLine("<string>", 1);
 
   if (args.length() >= 2) {
-    if (args[1].isPrimitive()) {
+    if (args[1].isPrimitive()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,
                                 JSSMSG_INVALID_ARGS, "evaluate");
       return false;
     }
 
     RootedObject opts(cx, &args[1].toObject());
-    if (!ParseCompileOptions(cx, options, opts, &fileNameBytes)) {
+    if (!ParseCompileOptions(cx, options, opts, &fileNameBytes)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -6173,7 +6173,7 @@ static bool OffThreadCompileScript(JSCon
 
   JSString* scriptContents = args[0].toString();
   AutoStableStringChars stableChars(cx);
-  if (!stableChars.initTwoByte(cx, scriptContents)) {
+  if (!stableChars.initTwoByte(cx, scriptContents)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6187,14 +6187,14 @@ static bool OffThreadCompileScript(JSCon
     ownedChars.reset(const_cast<char16_t*>(chars));
   } else {
     ownedChars.reset(cx->pod_malloc<char16_t>(length));
-    if (!ownedChars) {
+    if (!ownedChars) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     mozilla::PodCopy(ownedChars.get(), chars, length);
   }
 
-  if (!JS::CanCompileOffThread(cx, options, length)) {
+  if (!JS::CanCompileOffThread(cx, options, length)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "cannot compile code on worker thread");
     return false;
   }
@@ -6202,7 +6202,7 @@ static bool OffThreadCompileScript(JSCon
   OffThreadJob* job =
       NewOffThreadJob(cx, ScriptKind::Script, options,
                       OffThreadJob::Source(std::move(ownedChars)));
-  if (!job) {
+  if (!job) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6230,7 +6230,7 @@ static bool runOffThreadScript(JSContext
   }
 
   if (job->useOffThreadParseGlobal &&
-      OffThreadParsingMustWaitForGC(cx->runtime())) {
+      OffThreadParsingMustWaitForGC(cx->runtime())) {MOZ_RELEASE_ASSERT(0);
     gc::FinishGC(cx);
   }
 
@@ -6264,7 +6264,7 @@ static bool OffThreadCompileModule(JSCon
 
   JSString* scriptContents = args[0].toString();
   AutoStableStringChars stableChars(cx);
-  if (!stableChars.initTwoByte(cx, scriptContents)) {
+  if (!stableChars.initTwoByte(cx, scriptContents)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6278,14 +6278,14 @@ static bool OffThreadCompileModule(JSCon
     ownedChars.reset(const_cast<char16_t*>(chars));
   } else {
     ownedChars.reset(cx->pod_malloc<char16_t>(length));
-    if (!ownedChars) {
+    if (!ownedChars) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     mozilla::PodCopy(ownedChars.get(), chars, length);
   }
 
-  if (!JS::CanCompileOffThread(cx, options, length)) {
+  if (!JS::CanCompileOffThread(cx, options, length)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "cannot compile code on worker thread");
     return false;
   }
@@ -6293,7 +6293,7 @@ static bool OffThreadCompileModule(JSCon
   OffThreadJob* job =
       NewOffThreadJob(cx, ScriptKind::Module, options,
                       OffThreadJob::Source(std::move(ownedChars)));
-  if (!job) {
+  if (!job) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6321,7 +6321,7 @@ static bool FinishOffThreadModule(JSCont
   }
 
   if (job->useOffThreadParseGlobal &&
-      OffThreadParsingMustWaitForGC(cx->runtime())) {
+      OffThreadParsingMustWaitForGC(cx->runtime())) {MOZ_RELEASE_ASSERT(0);
     gc::FinishGC(cx);
   }
 
@@ -6350,7 +6350,7 @@ static bool OffThreadDecodeScript(JSCont
   if (!args.requireAtLeast(cx, "offThreadDecodeScript", 1)) {
     return false;
   }
-  if (!args[0].isObject() || !CacheEntry_isCacheEntry(&args[0].toObject())) {
+  if (!args[0].isObject() || !CacheEntry_isCacheEntry(&args[0].toObject())) {MOZ_RELEASE_ASSERT(0);
     const char* typeName = InformalValueTypeName(args[0]);
     JS_ReportErrorASCII(cx, "expected cache entry, got %s", typeName);
     return false;
@@ -6377,14 +6377,14 @@ static bool OffThreadDecodeScript(JSCont
   options.useOffThreadParseGlobal = true;
 
   if (args.length() >= 2) {
-    if (args[1].isPrimitive()) {
+    if (args[1].isPrimitive()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,
                                 JSSMSG_INVALID_ARGS, "evaluate");
       return false;
     }
 
     RootedObject opts(cx, &args[1].toObject());
-    if (!ParseCompileOptions(cx, options, opts, &fileNameBytes)) {
+    if (!ParseCompileOptions(cx, options, opts, &fileNameBytes)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -6404,12 +6404,12 @@ static bool OffThreadDecodeScript(JSCont
   if (!loadData) {
     return false;
   }
-  if (!loadBuffer.append(loadData, loadLength)) {
+  if (!loadBuffer.append(loadData, loadLength)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportOutOfMemory(cx);
     return false;
   }
 
-  if (!JS::CanDecodeOffThread(cx, options, loadLength)) {
+  if (!JS::CanDecodeOffThread(cx, options, loadLength)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "cannot compile code on worker thread");
     return false;
   }
@@ -6417,7 +6417,7 @@ static bool OffThreadDecodeScript(JSCont
   OffThreadJob* job =
       NewOffThreadJob(cx, ScriptKind::DecodeScript, options,
                       OffThreadJob::Source(std::move(loadBuffer)));
-  if (!job) {
+  if (!job) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6500,13 +6500,13 @@ static bool EscapeForShell(JSContext* cx
     size_t newLen = 3;  // quotes before and after and null-terminator
     for (char* p = argv[i]; *p; p++) {
       newLen++;
-      if (*p == '\"' || *p == '\\') {
+      if (*p == '\"' || *p == '\\') {MOZ_RELEASE_ASSERT(0);
         newLen++;
       }
     }
 
     auto escaped = cx->make_pod_array<char>(newLen);
-    if (!escaped) {
+    if (!escaped) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -6533,7 +6533,7 @@ static bool ReadAll(int fd, wasm::Bytes*
   size_t lastLength = bytes->length();
   while (true) {
     static const int ChunkSize = 64 * 1024;
-    if (!bytes->growBy(ChunkSize)) {
+    if (!bytes->growBy(ChunkSize)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -6543,7 +6543,7 @@ static bool ReadAll(int fd, wasm::Bytes*
       if (readCount >= 0) {
         break;
       }
-      if (errno != EINTR) {
+      if (errno != EINTR) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -6586,7 +6586,7 @@ class AutoPipe {
   }
 
   ~AutoPipe() {
-    if (fds_[0] != -1) {
+    if (fds_[0] != -1) {MOZ_RELEASE_ASSERT(0);
       close(fds_[0]);
     }
     if (fds_[1] != -1) {
@@ -6641,14 +6641,14 @@ static bool CompileAndSerializeInSeparat
   return false;
 #else
   AutoPipe stdIn, stdOut;
-  if (!stdIn.init() || !stdOut.init()) {
+  if (!stdIn.init() || !stdOut.init()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   AutoCStringVector argv(cx);
 
   UniqueChars argv0 = DuplicateString(cx, sArgv[0]);
-  if (!argv0 || !argv.append(std::move(argv0))) {
+  if (!argv0 || !argv.append(std::move(argv0))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6656,7 +6656,7 @@ static bool CompileAndSerializeInSeparat
   // file-descriptor args (passed on Windows, below).
   for (unsigned i = 0; i < sCompilerProcessFlags.length(); i++) {
     UniqueChars flags = DuplicateString(cx, sCompilerProcessFlags[i]);
-    if (!flags || !argv.append(std::move(flags))) {
+    if (!flags || !argv.append(std::move(flags))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -6664,7 +6664,7 @@ static bool CompileAndSerializeInSeparat
   UniqueChars arg;
 
   arg = DuplicateString(sWasmCompileAndSerializeFlag);
-  if (!arg || !argv.append(std::move(arg))) {
+  if (!arg || !argv.append(std::move(arg))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6676,38 +6676,38 @@ static bool CompileAndSerializeInSeparat
   // both pipes so the child process can closed the unused ends.
 
   arg = JS_smprintf("%d", stdIn.reader());
-  if (!arg || !argv.append(std::move(arg))) {
+  if (!arg || !argv.append(std::move(arg))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   arg = JS_smprintf("%d", stdIn.writer());
-  if (!arg || !argv.append(std::move(arg))) {
+  if (!arg || !argv.append(std::move(arg))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   arg = JS_smprintf("%d", stdOut.reader());
-  if (!arg || !argv.append(std::move(arg))) {
+  if (!arg || !argv.append(std::move(arg))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   arg = JS_smprintf("%d", stdOut.writer());
-  if (!arg || !argv.append(std::move(arg))) {
+  if (!arg || !argv.append(std::move(arg))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 #  endif
 
   // Required by both _spawnv and exec.
-  if (!argv.append(nullptr)) {
+  if (!argv.append(nullptr)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
 #  ifdef XP_WIN
-  if (!EscapeForShell(cx, argv)) {
+  if (!EscapeForShell(cx, argv)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   int childPid = _spawnv(P_NOWAIT, sArgv[0], argv.get());
-  if (childPid == -1) {
+  if (childPid == -1) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 #  else
@@ -6740,13 +6740,13 @@ static bool CompileAndSerializeInSeparat
   stdIn.closeReader();
   stdOut.closeWriter();
 
-  if (!WriteAll(stdIn.writer(), bytecode, bytecodeLength)) {
+  if (!WriteAll(stdIn.writer(), bytecode, bytecodeLength)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   stdIn.closeWriter();
 
-  if (!ReadAll(stdOut.reader(), serialized)) {
+  if (!ReadAll(stdOut.reader(), serialized)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6754,7 +6754,7 @@ static bool CompileAndSerializeInSeparat
 
   int status;
 #  ifdef XP_WIN
-  if (_cwait(&status, childPid, WAIT_CHILD) == -1) {
+  if (_cwait(&status, childPid, WAIT_CHILD) == -1) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 #  else
@@ -6805,12 +6805,12 @@ static bool WasmCompileAndSerialize(JSCo
 #endif
 
   wasm::MutableBytes bytecode = js_new<wasm::ShareableBytes>();
-  if (!ReadAll(stdIn, &bytecode->bytes)) {
+  if (!ReadAll(stdIn, &bytecode->bytes)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   wasm::Bytes serialized;
-  if (!wasm::CompileAndSerialize(*bytecode, &serialized)) {
+  if (!wasm::CompileAndSerialize(*bytecode, &serialized)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6836,7 +6836,7 @@ static bool WasmCompileInSeparateProcess
   SharedMem<uint8_t*> bytecode;
   size_t numBytes;
   if (!args[0].isObject() ||
-      !IsBufferSource(&args[0].toObject(), &bytecode, &numBytes)) {
+      !IsBufferSource(&args[0].toObject(), &bytecode, &numBytes)) {MOZ_RELEASE_ASSERT(0);
     RootedObject callee(cx, &args.callee());
     ReportUsageErrorASCII(cx, callee, "Argument must be a buffer source");
     return false;
@@ -6845,9 +6845,9 @@ static bool WasmCompileInSeparateProcess
   wasm::Bytes serialized;
   if (!CompileAndSerializeInSeparateProcess(cx, bytecode.unwrap(), numBytes,
                                             &serialized)) {
-    if (!cx->isExceptionPending()) {
+    if (!cx->isExceptionPending()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "creating and executing child process");
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6880,7 +6880,7 @@ static bool DecompileThisScript(JSContex
   CallArgs args = CallArgsFromVp(argc, vp);
 
   NonBuiltinScriptFrameIter iter(cx);
-  if (iter.done()) {
+  if (iter.done()) {MOZ_RELEASE_ASSERT(0);
     args.rval().setString(cx->runtime()->emptyString);
     return true;
   }
@@ -6916,7 +6916,7 @@ static bool ThisFilename(JSContext* cx, 
   CallArgs args = CallArgsFromVp(argc, vp);
 
   JS::AutoFilename filename;
-  if (!DescribeScriptedCaller(cx, &filename) || !filename.get()) {
+  if (!DescribeScriptedCaller(cx, &filename) || !filename.get()) {MOZ_RELEASE_ASSERT(0);
     args.rval().setString(cx->runtime()->emptyString);
     return true;
   }
@@ -6942,7 +6942,7 @@ static bool WrapWithProto(JSContext* cx,
 
   // Disallow constructing (deeply) nested wrapper chains, to avoid running
   // out of stack space in isCallable/isConstructor. See bug 1126105.
-  if (IsWrapper(&obj.toObject())) {
+  if (IsWrapper(&obj.toObject())) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "wrapWithProto cannot wrap a wrapper");
     return false;
   }
@@ -6983,14 +6983,14 @@ static bool NewGlobal(JSContext* cx, uns
     RootedObject opts(cx, &args[0].toObject());
     RootedValue v(cx);
 
-    if (!JS_GetProperty(cx, opts, "invisibleToDebugger", &v)) {
+    if (!JS_GetProperty(cx, opts, "invisibleToDebugger", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (v.isBoolean()) {
       creationOptions.setInvisibleToDebugger(v.toBoolean());
     }
 
-    if (!JS_GetProperty(cx, opts, "sameZoneAs", &v)) {
+    if (!JS_GetProperty(cx, opts, "sameZoneAs", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (v.isObject()) {
@@ -6998,28 +6998,28 @@ static bool NewGlobal(JSContext* cx, uns
           UncheckedUnwrap(&v.toObject()));
     }
 
-    if (!JS_GetProperty(cx, opts, "sameCompartmentAs", &v)) {
+    if (!JS_GetProperty(cx, opts, "sameCompartmentAs", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (v.isObject()) {
       creationOptions.setExistingCompartment(UncheckedUnwrap(&v.toObject()));
     }
 
-    if (!JS_GetProperty(cx, opts, "newCompartment", &v)) {
+    if (!JS_GetProperty(cx, opts, "newCompartment", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (v.isBoolean() && v.toBoolean()) {
       creationOptions.setNewCompartmentAndZone();
     }
 
-    if (!JS_GetProperty(cx, opts, "discardSource", &v)) {
+    if (!JS_GetProperty(cx, opts, "discardSource", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (v.isBoolean()) {
       behaviors.setDiscardSource(v.toBoolean());
     }
 
-    if (!JS_GetProperty(cx, opts, "useWindowProxy", &v)) {
+    if (!JS_GetProperty(cx, opts, "useWindowProxy", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (v.isBoolean()) {
@@ -7027,50 +7027,50 @@ static bool NewGlobal(JSContext* cx, uns
                            : ShellGlobalKind::GlobalObject;
     }
 
-    if (!JS_GetProperty(cx, opts, "immutablePrototype", &v)) {
+    if (!JS_GetProperty(cx, opts, "immutablePrototype", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (v.isBoolean()) {
       immutablePrototype = v.toBoolean();
     }
 
-    if (!JS_GetProperty(cx, opts, "enableWritableStreams", &v)) {
-      return false;
-    }
-    if (v.isBoolean()) {
+    if (!JS_GetProperty(cx, opts, "enableWritableStreams", &v)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (v.isBoolean()) {MOZ_RELEASE_ASSERT(0);
       creationOptions.setWritableStreamsEnabled(v.toBoolean());
     }
 
-    if (!JS_GetProperty(cx, opts, "enableReadableStreamPipeTo", &v)) {
-      return false;
-    }
-    if (v.isBoolean()) {
+    if (!JS_GetProperty(cx, opts, "enableReadableStreamPipeTo", &v)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (v.isBoolean()) {MOZ_RELEASE_ASSERT(0);
       creationOptions.setReadableStreamPipeToEnabled(v.toBoolean());
     }
 
-    if (!JS_GetProperty(cx, opts, "systemPrincipal", &v)) {
+    if (!JS_GetProperty(cx, opts, "systemPrincipal", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (v.isBoolean()) {
       principals.reset(&ShellPrincipals::fullyTrusted);
     }
 
-    if (!JS_GetProperty(cx, opts, "principal", &v)) {
+    if (!JS_GetProperty(cx, opts, "principal", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!v.isUndefined()) {
       uint32_t bits;
-      if (!ToUint32(cx, v, &bits)) {
+      if (!ToUint32(cx, v, &bits)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       JSPrincipals* newPrincipals = cx->new_<ShellPrincipals>(bits);
-      if (!newPrincipals) {
+      if (!newPrincipals) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       principals.reset(newPrincipals);
     }
 
-    if (!JS_GetProperty(cx, opts, "enableCoopAndCoep", &v)) {
+    if (!JS_GetProperty(cx, opts, "enableCoopAndCoep", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (v.isBoolean()) {
@@ -7081,10 +7081,10 @@ static bool NewGlobal(JSContext* cx, uns
     // global property in pages that aren't isolated in a separate process (and
     // thus can't allow the structured cloning of shared memory).  Specify false
     // for this option to reproduce this behavior.
-    if (!JS_GetProperty(cx, opts, "defineSharedArrayBufferConstructor", &v)) {
-      return false;
-    }
-    if (v.isBoolean()) {
+    if (!JS_GetProperty(cx, opts, "defineSharedArrayBufferConstructor", &v)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (v.isBoolean()) {MOZ_RELEASE_ASSERT(0);
       creationOptions.setDefineSharedArrayBufferConstructor(v.toBoolean());
     }
   }
@@ -7141,7 +7141,7 @@ static bool NukeAllCCWs(JSContext* cx, u
 static bool RecomputeWrappers(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() > 2) {
+  if (args.length() > 2) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, my_GetErrorMessage, nullptr,
                               JSSMSG_INVALID_ARGS, "recomputeWrappers");
     return false;
@@ -7218,7 +7218,7 @@ static bool GetMaxArgs(JSContext* cx, un
   return true;
 }
 
-static bool IsHTMLDDA_Call(JSContext* cx, unsigned argc, Value* vp) {
+static bool IsHTMLDDA_Call(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
   // These are the required conditions under which this object may be called
@@ -7294,7 +7294,7 @@ class ShellSourceHook : public SourceHoo
                "must be called requesting only one of UTF-8 or UTF-16 source");
 
     RootedString str(cx, JS_NewStringCopyZ(cx, filename));
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     RootedValue filenameValue(cx, StringValue(str));
@@ -7306,12 +7306,12 @@ class ShellSourceHook : public SourceHoo
     }
 
     str = JS::ToString(cx, result);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     Rooted<JSLinearString*> linear(cx, str->ensureLinear(cx));
-    if (!linear) {
+    if (!linear) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -7319,12 +7319,12 @@ class ShellSourceHook : public SourceHoo
       *length = JS_GetStringLength(linear);
 
       *twoByteSource = cx->pod_malloc<char16_t>(*length);
-      if (!*twoByteSource) {
+      if (!*twoByteSource) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       CopyChars(*twoByteSource, *linear);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(utf8Source != nullptr);
 
       *length = JS::GetDeflatedUTF8StringLength(linear);
@@ -7353,7 +7353,7 @@ static bool WithSourceHook(JSContext* cx
   }
 
   if (!args[0].isObject() || !args[0].toObject().is<JSFunction>() ||
-      !args[1].isObject() || !args[1].toObject().is<JSFunction>()) {
+      !args[1].isObject() || !args[1].toObject().is<JSFunction>()) {MOZ_RELEASE_ASSERT(0);
     ReportUsageErrorASCII(cx, callee,
                           "First and second arguments must be functions.");
     return false;
@@ -7528,7 +7528,7 @@ static bool EnableGeckoProfilingWithSlow
   if (cx->runtime()->geckoProfiler().enabled()) {
     // If profiling already enabled with slow assertions disabled,
     // this is a no-op.
-    if (cx->runtime()->geckoProfiler().slowAssertionsEnabled()) {
+    if (cx->runtime()->geckoProfiler().slowAssertionsEnabled()) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
 
@@ -7755,7 +7755,7 @@ static bool SetSharedObject(JSContext* c
       tag = MailboxTag::SharedArrayBuffer;
       value.sarb.buffer = sab->rawBufferObject();
       value.sarb.length = sab->byteLength();
-      if (!value.sarb.buffer->addReference()) {
+      if (!value.sarb.buffer->addReference()) {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorASCII(cx,
                             "Reference count overflow on SharedArrayBuffer");
         return false;
@@ -7771,29 +7771,29 @@ static bool SetSharedObject(JSContext* c
         tag = MailboxTag::WasmMemory;
         value.sarb.buffer = sab->rawBufferObject();
         value.sarb.length = sab->byteLength();
-        if (!value.sarb.buffer->addReference()) {
+        if (!value.sarb.buffer->addReference()) {MOZ_RELEASE_ASSERT(0);
           JS_ReportErrorASCII(cx,
                               "Reference count overflow on SharedArrayBuffer");
           return false;
         }
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorASCII(cx, "Invalid argument to SetSharedObject");
         return false;
       }
     } else if (JS::IsWasmModuleObject(obj)) {
       tag = MailboxTag::WasmModule;
       value.module = JS::GetWasmModule(obj).forget().take();
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "Invalid argument to SetSharedObject");
       return false;
     }
-  } else if (args.get(0).isNumber()) {
+  } else if (args.get(0).isNumber()) {MOZ_RELEASE_ASSERT(0);
     tag = MailboxTag::Number;
     value.number = args.get(0).toNumber();
     // Nothing
   } else if (args.get(0).isNullOrUndefined()) {
     // Nothing
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Invalid argument to SetSharedObject");
     return false;
   }
@@ -7857,7 +7857,7 @@ class StreamCacheEntry : public AtomicRe
     // Tolerate races since a single StreamCacheEntry object can be used as
     // the source of multiple streaming compilations.
     auto dstBytes = optimized_.lock();
-    if (dstBytes->length() > 0) {
+    if (dstBytes->length() > 0) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
@@ -7899,7 +7899,7 @@ class StreamCacheEntryObject : public Na
   static bool getBuffer(JSContext* cx, unsigned argc, Value* vp) {
     CallArgs args = CallArgsFromVp(argc, vp);
     if (!args.thisv().isObject() ||
-        !args.thisv().toObject().is<StreamCacheEntryObject>()) {
+        !args.thisv().toObject().is<StreamCacheEntryObject>()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -7931,14 +7931,14 @@ class StreamCacheEntryObject : public Na
     SharedMem<uint8_t*> ptr;
     size_t numBytes;
     if (!args[0].isObject() ||
-        !IsBufferSource(&args[0].toObject(), &ptr, &numBytes)) {
+        !IsBufferSource(&args[0].toObject(), &ptr, &numBytes)) {MOZ_RELEASE_ASSERT(0);
       RootedObject callee(cx, &args.callee());
       ReportUsageErrorASCII(cx, callee, "Argument must be an ArrayBuffer");
       return false;
     }
 
     Uint8Vector bytes;
-    if (!bytes.resize(numBytes)) {
+    if (!bytes.resize(numBytes)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -7946,19 +7946,19 @@ class StreamCacheEntryObject : public Na
 
     RefPtr<StreamCacheEntry> cache =
         cx->new_<StreamCacheEntry>(std::move(bytes));
-    if (!cache) {
+    if (!cache) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedNativeObject obj(
         cx, NewObjectWithGivenProto<StreamCacheEntryObject>(cx, nullptr));
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     obj->initReservedSlot(CACHE_ENTRY_SLOT,
                           PrivateValue(cache.forget().take()));
 
-    if (!JS_DefineProperty(cx, obj, "cached", cachedGetter, nullptr, 0)) {
+    if (!JS_DefineProperty(cx, obj, "cached", cachedGetter, nullptr, 0)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!JS_DefineFunction(cx, obj, "getBuffer", getBuffer, 0, 0)) {
@@ -8058,7 +8058,7 @@ static void BufferStreamMain(BufferStrea
       chunkSize = state->chunkSize;
     }
 
-    if (shutdown) {
+    if (shutdown) {MOZ_RELEASE_ASSERT(0);
       job->consumer->streamError(JSMSG_STREAM_CONSUME_ERROR);
       break;
     }
@@ -8067,7 +8067,7 @@ static void BufferStreamMain(BufferStrea
 
     chunkSize = std::min(chunkSize, byteLength - byteOffset);
 
-    if (!job->consumer->consumeChunk(bytes + byteOffset, chunkSize)) {
+    if (!job->consumer->consumeChunk(bytes + byteOffset, chunkSize)) {MOZ_RELEASE_ASSERT(0);
       break;
     }
 
@@ -8109,20 +8109,20 @@ static bool ConsumeBufferSource(JSContex
                                 JS::MimeType, JS::StreamConsumer* consumer) {
   {
     RootedValue url(cx);
-    if (!JS_GetProperty(cx, obj, "url", &url)) {
+    if (!JS_GetProperty(cx, obj, "url", &url)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     UniqueChars urlChars;
-    if (!EnsureLatin1CharsLinearString(cx, url, &urlChars)) {
+    if (!EnsureLatin1CharsLinearString(cx, url, &urlChars)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedValue mapUrl(cx);
-    if (!JS_GetProperty(cx, obj, "sourceMappingURL", &mapUrl)) {
+    if (!JS_GetProperty(cx, obj, "sourceMappingURL", &mapUrl)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     UniqueChars mapUrlChars;
-    if (!EnsureLatin1CharsLinearString(cx, mapUrl, &mapUrlChars)) {
+    if (!EnsureLatin1CharsLinearString(cx, mapUrl, &mapUrlChars)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -8135,7 +8135,7 @@ static bool ConsumeBufferSource(JSContex
   size_t byteLength;
   if (IsBufferSource(obj, &dataPointer, &byteLength)) {
     Uint8Vector bytes;
-    if (!bytes.resize(byteLength)) {
+    if (!bytes.resize(byteLength)) {MOZ_RELEASE_ASSERT(0);
       JS_ReportOutOfMemory(cx);
       return false;
     }
@@ -8145,14 +8145,14 @@ static bool ConsumeBufferSource(JSContex
   } else if (obj->is<StreamCacheEntryObject>()) {
     job = cx->make_unique<BufferStreamJob>(
         obj->as<StreamCacheEntryObject>().cache(), consumer);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(
         cx,
         "shell streaming consumes a buffer source (buffer or view) "
         "or StreamCacheEntryObject");
     return false;
   }
-  if (!job) {
+  if (!job) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -8161,7 +8161,7 @@ static bool ConsumeBufferSource(JSContex
   {
     auto state = bufferStreamState->lock();
     MOZ_ASSERT(!state->shutdown);
-    if (!state->jobs.append(std::move(job))) {
+    if (!state->jobs.append(std::move(job))) {MOZ_RELEASE_ASSERT(0);
       JS_ReportOutOfMemory(cx);
       return false;
     }
@@ -8188,12 +8188,12 @@ static bool SetBufferStreamParams(JSCont
   }
 
   double delayMillis;
-  if (!ToNumber(cx, args[0], &delayMillis)) {
+  if (!ToNumber(cx, args[0], &delayMillis)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   double chunkSize;
-  if (!ToNumber(cx, args[1], &chunkSize)) {
+  if (!ToNumber(cx, args[1], &chunkSize)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -8220,7 +8220,7 @@ static bool DumpScopeChain(JSContext* cx
   CallArgs args = CallArgsFromVp(argc, vp);
   RootedObject callee(cx, &args.callee());
 
-  if (js::SupportDifferentialTesting()) {
+  if (js::SupportDifferentialTesting()) {MOZ_RELEASE_ASSERT(0);
     ReportUsageErrorASCII(
         cx, callee, "Function not available in differential testing mode.");
     return false;
@@ -8229,30 +8229,30 @@ static bool DumpScopeChain(JSContext* cx
   if (args.length() != 1) {
     ReportUsageErrorASCII(cx, callee, "Wrong number of arguments");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   if (!args[0].isObject() || !(args[0].toObject().is<JSFunction>() ||
-                               args[0].toObject().is<ModuleObject>())) {
+                               args[0].toObject().is<ModuleObject>())) {MOZ_RELEASE_ASSERT(0);
     ReportUsageErrorASCII(
         cx, callee, "Argument must be an interpreted function or a module");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedObject obj(cx, &args[0].toObject());
   RootedScript script(cx);
 
-  if (obj->is<JSFunction>()) {
+  if (obj->is<JSFunction>()) {MOZ_RELEASE_ASSERT(0);
     RootedFunction fun(cx, &obj->as<JSFunction>());
-    if (!fun->isInterpreted()) {
+    if (!fun->isInterpreted()) {MOZ_RELEASE_ASSERT(0);
       ReportUsageErrorASCII(cx, callee,
                             "Argument must be an interpreted function");
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     script = JSFunction::getOrCreateScript(cx, fun);
-    if (!script) {
-      return false;
-    }
-  } else {
+    if (!script) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+  } else {MOZ_RELEASE_ASSERT(0);
     script = obj->as<ModuleObject>().maybeScript();
     if (!script) {
       JS_ReportErrorASCII(cx, "module does not have an associated script");
@@ -8288,7 +8288,7 @@ static bool EnsureGrayRoot(JSContext* cx
   CallArgs args = CallArgsFromVp(argc, vp);
 
   auto priv = EnsureShellCompartmentPrivate(cx);
-  if (!priv) {
+  if (!priv) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -8337,7 +8337,7 @@ static bool AddMarkObservers(JSContext* 
   CallArgs args = CallArgsFromVp(argc, vp);
 
   auto markObservers = EnsureMarkBitObservers(cx);
-  if (!markObservers) {
+  if (!markObservers) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -8348,18 +8348,18 @@ static bool AddMarkObservers(JSContext* 
 
   RootedObject observersArg(cx, &args[0].toObject());
   uint32_t length;
-  if (!GetLengthProperty(cx, observersArg, &length)) {
+  if (!GetLengthProperty(cx, observersArg, &length)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedValue value(cx);
   RootedObject object(cx);
   for (uint32_t i = 0; i < length; i++) {
-    if (!JS_GetElement(cx, observersArg, i, &value)) {
-      return false;
-    }
-
-    if (!value.isObject()) {
+    if (!JS_GetElement(cx, observersArg, i, &value)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+
+    if (!value.isObject()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "argument must be an Array of objects");
       return false;
     }
@@ -8387,21 +8387,21 @@ static bool GetMarks(JSContext* cx, unsi
   CallArgs args = CallArgsFromVp(argc, vp);
 
   auto& observers = GetShellContext(cx)->markObservers;
-  if (!observers) {
+  if (!observers) {MOZ_RELEASE_ASSERT(0);
     args.rval().setUndefined();
     return true;
   }
 
   size_t length = observers->get().length();
   Rooted<ArrayObject*> ret(cx, js::NewDenseEmptyArray(cx));
-  if (!ret) {
+  if (!ret) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   for (uint32_t i = 0; i < length; i++) {
     const char* color;
     JSObject* obj = observers->get()[i];
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       color = "dead";
     } else {
       gc::TenuredCell* cell = &obj->asTenured();
@@ -8409,12 +8409,12 @@ static bool GetMarks(JSContext* cx, unsi
         color = "gray";
       } else if (cell->isMarkedBlack()) {
         color = "black";
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         color = "unmarked";
       }
     }
     JSString* s = JS_NewStringCopyZ(cx, color);
-    if (!s) {
+    if (!s) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!NewbornArrayPush(cx, ret, StringValue(s))) {
@@ -8476,20 +8476,20 @@ class ShellAutoEntryMonitor : JS::dbg::A
   }
 
   bool buildResult(JSContext* cx, MutableHandleValue resultValue) {
-    if (oom) {
+    if (oom) {MOZ_RELEASE_ASSERT(0);
       JS_ReportOutOfMemory(cx);
       return false;
     }
 
     RootedObject result(cx, JS::NewArrayObject(cx, log.length()));
-    if (!result) {
+    if (!result) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     for (size_t i = 0; i < log.length(); i++) {
       char* name = log[i].get();
       RootedString string(cx, Atomize(cx, name, strlen(name)));
-      if (!string) {
+      if (!string) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       RootedValue value(cx, StringValue(string));
@@ -8515,7 +8515,7 @@ static bool EntryPoints(JSContext* cx, u
   }
 
   RootedObject opts(cx, ToObject(cx, args[0]));
-  if (!opts) {
+  if (!opts) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -8523,13 +8523,13 @@ static bool EntryPoints(JSContext* cx, u
   {
     RootedValue fun(cx), dummy(cx);
 
-    if (!JS_GetProperty(cx, opts, "function", &fun)) {
+    if (!JS_GetProperty(cx, opts, "function", &fun)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!fun.isUndefined()) {
       js::shell::ShellAutoEntryMonitor sarep(cx);
       if (!Call(cx, UndefinedHandleValue, fun, JS::HandleValueArray::empty(),
-                &dummy)) {
+                &dummy)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       return sarep.buildResult(cx, args.rval());
@@ -8538,7 +8538,7 @@ static bool EntryPoints(JSContext* cx, u
 
   // { object: o, property: p, value: v } --- Fetch o[p], or if
   // v is present, assign o[p] = v.
-  {
+  {MOZ_RELEASE_ASSERT(0);
     RootedValue objectv(cx), propv(cx), valuev(cx);
 
     if (!JS_GetProperty(cx, opts, "object", &objectv) ||
@@ -8546,31 +8546,31 @@ static bool EntryPoints(JSContext* cx, u
       return false;
     if (!objectv.isUndefined() && !propv.isUndefined()) {
       RootedObject object(cx, ToObject(cx, objectv));
-      if (!object) {
+      if (!object) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       RootedString string(cx, ToString(cx, propv));
-      if (!string) {
+      if (!string) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       RootedId id(cx);
-      if (!JS_StringToId(cx, string, &id)) {
-        return false;
-      }
-
-      if (!JS_GetProperty(cx, opts, "value", &valuev)) {
+      if (!JS_StringToId(cx, string, &id)) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }
+
+      if (!JS_GetProperty(cx, opts, "value", &valuev)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       js::shell::ShellAutoEntryMonitor sarep(cx);
 
       if (!valuev.isUndefined()) {
-        if (!JS_SetPropertyById(cx, object, id, valuev)) {
+        if (!JS_SetPropertyById(cx, object, id, valuev)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
-        if (!JS_GetPropertyById(cx, object, id, &valuev)) {
+        if (!JS_GetPropertyById(cx, object, id, &valuev)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -8583,12 +8583,12 @@ static bool EntryPoints(JSContext* cx, u
   {
     RootedValue v(cx);
 
-    if (!JS_GetProperty(cx, opts, "ToString", &v)) {
+    if (!JS_GetProperty(cx, opts, "ToString", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!v.isUndefined()) {
       js::shell::ShellAutoEntryMonitor sarep(cx);
-      if (!JS::ToString(cx, v)) {
+      if (!JS::ToString(cx, v)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       return sarep.buildResult(cx, args.rval());
@@ -8600,12 +8600,12 @@ static bool EntryPoints(JSContext* cx, u
     RootedValue v(cx);
     double dummy;
 
-    if (!JS_GetProperty(cx, opts, "ToNumber", &v)) {
+    if (!JS_GetProperty(cx, opts, "ToNumber", &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!v.isUndefined()) {
       js::shell::ShellAutoEntryMonitor sarep(cx);
-      if (!JS::ToNumber(cx, v, &dummy)) {
+      if (!JS::ToNumber(cx, v, &dummy)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       return sarep.buildResult(cx, args.rval());
@@ -8616,22 +8616,22 @@ static bool EntryPoints(JSContext* cx, u
   {
     RootedValue code(cx), dummy(cx);
 
-    if (!JS_GetProperty(cx, opts, "eval", &code)) {
+    if (!JS_GetProperty(cx, opts, "eval", &code)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!code.isUndefined()) {
       RootedString codeString(cx, ToString(cx, code));
-      if (!codeString) {
+      if (!codeString) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       AutoStableStringChars stableChars(cx);
-      if (!stableChars.initTwoByte(cx, codeString)) {
+      if (!stableChars.initTwoByte(cx, codeString)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       JS::SourceText<char16_t> srcBuf;
       if (!srcBuf.init(cx, stableChars.twoByteRange().begin().get(),
-                       codeString->length(), JS::SourceOwnership::Borrowed)) {
+                       codeString->length(), JS::SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -8659,7 +8659,7 @@ static bool WasmTextToBinary(JSContext* 
     return false;
   }
 
-  if (!args[0].isString()) {
+  if (!args[0].isString()) {MOZ_RELEASE_ASSERT(0);
     ReportUsageErrorASCII(cx, callee, "First argument must be a String");
     return false;
   }
@@ -8667,7 +8667,7 @@ static bool WasmTextToBinary(JSContext* 
   size_t textLen = args[0].toString()->length();
 
   AutoStableStringChars twoByteChars(cx);
-  if (!twoByteChars.initTwoByte(cx, args[0].toString())) {
+  if (!twoByteChars.initTwoByte(cx, args[0].toString())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -8700,7 +8700,7 @@ static bool WasmCodeOffsets(JSContext* c
     return false;
   }
 
-  if (!args.get(0).isObject()) {
+  if (!args.get(0).isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "argument is not an object");
     return false;
   }
@@ -8711,7 +8711,7 @@ static bool WasmCodeOffsets(JSContext* c
   JSObject* bufferObject = &args[0].toObject();
   JSObject* unwrappedBufferObject = CheckedUnwrapStatic(bufferObject);
   if (!unwrappedBufferObject ||
-      !IsBufferSource(unwrappedBufferObject, &bytes, &byteLength)) {
+      !IsBufferSource(unwrappedBufferObject, &bytes, &byteLength)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberUTF8(cx, GetErrorMessage, nullptr,
                              JSMSG_WASM_BAD_BUF_ARG);
     return false;
@@ -8721,7 +8721,7 @@ static bool WasmCodeOffsets(JSContext* c
   wasm::CodeOffsets(bytes.unwrap(), byteLength, &offsets);
 
   RootedObject jsOffsets(cx, JS::NewArrayObject(cx, offsets.length()));
-  if (!jsOffsets) {
+  if (!jsOffsets) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (size_t i = 0; i < offsets.length(); i++) {
@@ -8748,32 +8748,32 @@ static bool WasmLoop(JSContext* cx, unsi
     return false;
   }
 
-  if (!args[0].isString()) {
+  if (!args[0].isString()) {MOZ_RELEASE_ASSERT(0);
     ReportUsageErrorASCII(cx, callee, "First argument must be a String");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedObject importObj(cx);
-  if (!args.get(1).isUndefined()) {
-    if (!args.get(1).isObject()) {
+  if (!args.get(1).isUndefined()) {MOZ_RELEASE_ASSERT(0);
+    if (!args.get(1).isObject()) {MOZ_RELEASE_ASSERT(0);
       ReportUsageErrorASCII(cx, callee,
                             "Second argument, if present, must be an Object");
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     importObj = &args[1].toObject();
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedString givenPath(cx, args[0].toString());
   RootedString filename(cx, ResolvePath(cx, givenPath, RootRelative));
-  if (!filename) {
-    return false;
-  }
-
-  while (__AFL_LOOP(1000)) {
+  if (!filename) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  while (__AFL_LOOP(1000)) {MOZ_RELEASE_ASSERT(0);
     Rooted<JSObject*> ret(cx, FileAsTypedArray(cx, filename));
-    if (!ret) {
-      return false;
-    }
+    if (!ret) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }MOZ_RELEASE_ASSERT(0);
 
     Rooted<TypedArrayObject*> typedArray(cx, &ret->as<TypedArrayObject>());
     RootedWasmInstanceObject instanceObj(cx);
@@ -8835,7 +8835,7 @@ class TransplantableDOMProxyHandler fina
   // Simplified implementation of |DOMProxyHandler::EnsureExpandoObject|.
   static JSObject* EnsureExpandoObject(JSContext* cx, JS::HandleObject obj) {
     const Value& v = GetProxyPrivate(obj);
-    if (v.isObject()) {
+    if (v.isObject()) {MOZ_RELEASE_ASSERT(0);
       return &v.toObject();
     }
     MOZ_ASSERT(v.isUndefined());
@@ -8869,7 +8869,7 @@ static bool TransplantObject(JSContext* 
   RootedObject newGlobal(
       cx, js::CheckedUnwrapDynamic(&args[0].toObject(), cx,
                                    /* stopAtWindowProxy = */ false));
-  if (!newGlobal) {
+  if (!newGlobal) {MOZ_RELEASE_ASSERT(0);
     ReportAccessDenied(cx);
     return false;
   }
@@ -8883,7 +8883,7 @@ static bool TransplantObject(JSContext* 
   const Value& reserved =
       GetFunctionNativeReserved(callee, TransplantSourceObject);
   RootedObject source(cx, CheckedUnwrapStatic(&reserved.toObject()));
-  if (!source) {
+  if (!source) {MOZ_RELEASE_ASSERT(0);
     ReportAccessDenied(cx);
     return false;
   }
@@ -8904,7 +8904,7 @@ static bool TransplantObject(JSContext* 
   // to transplant an object into the same compartment as the source object to
   // cover all operations supported by JS_TransplantObject.
 
-  if (!CheckRecursionLimitConservative(cx)) {
+  if (!CheckRecursionLimitConservative(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -8928,7 +8928,7 @@ static bool TransplantObject(JSContext* 
   }
 
   RootedObject target(cx, JS_CloneObject(cx, source, proto));
-  if (!target) {
+  if (!target) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -8941,11 +8941,11 @@ static bool TransplantObject(JSContext* 
   RootedObject copyFrom(cx, isProxy ? expandoObject : source);
   RootedObject propertyHolder(cx,
                               JS_NewObjectWithGivenProto(cx, nullptr, nullptr));
-  if (!propertyHolder) {
-    return false;
-  }
-
-  if (!JS_CopyOwnPropertiesAndPrivateFields(cx, propertyHolder, copyFrom)) {
+  if (!propertyHolder) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!JS_CopyOwnPropertiesAndPrivateFields(cx, propertyHolder, copyFrom)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -8959,14 +8959,14 @@ static bool TransplantObject(JSContext* 
   }
 
   source = JS_TransplantObject(cx, source, target);
-  if (!source) {
+  if (!source) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject copyTo(cx);
   if (isProxy) {
     copyTo = TransplantableDOMProxyHandler::EnsureExpandoObject(cx, source);
-    if (!copyTo) {
+    if (!copyTo) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -8992,7 +8992,7 @@ static bool TransplantableObject(JSConte
   bool createProxy = false;
   RootedObject source(cx);
   if (args.length() == 1 && !args[0].isUndefined()) {
-    if (!args[0].isObject()) {
+    if (!args[0].isObject()) {MOZ_RELEASE_ASSERT(0);
       ReportUsageErrorASCII(cx, callee, "Argument must be an object");
       return false;
     }
@@ -9000,22 +9000,22 @@ static bool TransplantableObject(JSConte
     RootedObject options(cx, &args[0].toObject());
     RootedValue value(cx);
 
-    if (!JS_GetProperty(cx, options, "proxy", &value)) {
+    if (!JS_GetProperty(cx, options, "proxy", &value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     createProxy = JS::ToBoolean(value);
 
-    if (!JS_GetProperty(cx, options, "object", &value)) {
+    if (!JS_GetProperty(cx, options, "object", &value)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!value.isUndefined()) {
-      if (!value.isObject()) {
+      if (!value.isObject()) {MOZ_RELEASE_ASSERT(0);
         ReportUsageErrorASCII(cx, callee, "'object' option must be an object");
         return false;
       }
 
       source = &value.toObject();
-      if (JS::GetClass(source) != GetDomClass()) {
+      if (JS::GetClass(source) != GetDomClass()) {MOZ_RELEASE_ASSERT(0);
         ReportUsageErrorASCII(cx, callee, "Object not a FakeDOMObject");
         return false;
       }
@@ -9035,14 +9035,14 @@ static bool TransplantableObject(JSConte
     if (!createProxy) {
       source = NewBuiltinClassInstance(cx, &TransplantableDOMObjectClass,
                                        TenuredObject);
-      if (!source) {
+      if (!source) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       JS::SetReservedSlot(source, DOM_OBJECT_SLOT, JS::PrivateValue(nullptr));
     } else {
       JSObject* expando = JS_NewPlainObject(cx);
-      if (!expando) {
+      if (!expando) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       RootedValue expandoVal(cx, ObjectValue(*expando));
@@ -9053,7 +9053,7 @@ static bool TransplantableObject(JSConte
 
       source = NewProxyObject(cx, &TransplantableDOMProxyHandler::singleton,
                               expandoVal, nullptr, options);
-      if (!source) {
+      if (!source) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -9064,7 +9064,7 @@ static bool TransplantableObject(JSConte
   jsid emptyId = NameToId(cx->names().empty);
   RootedObject transplant(
       cx, NewFunctionByIdWithReserved(cx, TransplantObject, 0, 0, emptyId));
-  if (!transplant) {
+  if (!transplant) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -9072,7 +9072,7 @@ static bool TransplantableObject(JSConte
                             ObjectValue(*source));
 
   RootedObject result(cx, JS_NewPlainObject(cx));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -9887,11 +9887,11 @@ static bool PrintHelpString(JSContext* c
 
 static bool PrintHelp(JSContext* cx, HandleObject obj) {
   RootedValue usage(cx);
-  if (!JS_GetProperty(cx, obj, "usage", &usage)) {
+  if (!JS_GetProperty(cx, obj, "usage", &usage)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedValue help(cx);
-  if (!JS_GetProperty(cx, obj, "help", &help)) {
+  if (!JS_GetProperty(cx, obj, "help", &help)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -9905,19 +9905,19 @@ static bool PrintHelp(JSContext* cx, Han
 static bool PrintEnumeratedHelp(JSContext* cx, HandleObject obj,
                                 HandleObject pattern, bool brief) {
   RootedIdVector idv(cx);
-  if (!GetPropertyKeys(cx, obj, JSITER_OWNONLY | JSITER_HIDDEN, &idv)) {
+  if (!GetPropertyKeys(cx, obj, JSITER_OWNONLY | JSITER_HIDDEN, &idv)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Rooted<RegExpObject*> regex(cx);
-  if (pattern) {
+  if (pattern) {MOZ_RELEASE_ASSERT(0);
     regex = &UncheckedUnwrap(pattern)->as<RegExpObject>();
   }
 
   for (size_t i = 0; i < idv.length(); i++) {
     RootedValue v(cx);
     RootedId id(cx, idv[i]);
-    if (!JS_GetPropertyById(cx, obj, id, &v)) {
+    if (!JS_GetPropertyById(cx, obj, id, &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!v.isObject()) {
@@ -9928,38 +9928,38 @@ static bool PrintEnumeratedHelp(JSContex
     if (regex) {
       // Only pay attention to objects with a 'help' property, which will
       // either be documented functions or interface objects.
-      if (!JS_GetProperty(cx, funcObj, "help", &v)) {
-        return false;
-      }
-      if (!v.isString()) {
+      if (!JS_GetProperty(cx, funcObj, "help", &v)) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }
+      if (!v.isString()) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
 
       // For functions, match against the name. For interface objects,
       // match against the usage string.
-      if (!JS_GetProperty(cx, funcObj, "name", &v)) {
-        return false;
-      }
-      if (!v.isString()) {
-        if (!JS_GetProperty(cx, funcObj, "usage", &v)) {
+      if (!JS_GetProperty(cx, funcObj, "name", &v)) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }
+      if (!v.isString()) {MOZ_RELEASE_ASSERT(0);
+        if (!JS_GetProperty(cx, funcObj, "usage", &v)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
-        if (!v.isString()) {
+        if (!v.isString()) {MOZ_RELEASE_ASSERT(0);
           continue;
-        }
-      }
+        }MOZ_RELEASE_ASSERT(0);
+      }MOZ_RELEASE_ASSERT(0);
 
       size_t ignored = 0;
-      if (!JSString::ensureLinear(cx, v.toString())) {
-        return false;
-      }
+      if (!JSString::ensureLinear(cx, v.toString())) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }MOZ_RELEASE_ASSERT(0);
       RootedLinearString input(cx, &v.toString()->asLinear());
-      if (!ExecuteRegExpLegacy(cx, nullptr, regex, input, &ignored, true, &v)) {
-        return false;
-      }
-      if (v.isNull()) {
+      if (!ExecuteRegExpLegacy(cx, nullptr, regex, input, &ignored, true, &v)) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }
+      if (v.isNull()) {MOZ_RELEASE_ASSERT(0);
         continue;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
     if (!PrintHelp(cx, funcObj)) {
@@ -9971,7 +9971,7 @@ static bool PrintEnumeratedHelp(JSContex
 }
 
 static bool Help(JSContext* cx, unsigned argc, Value* vp) {
-  if (!gOutFile->isOpen()) {
+  if (!gOutFile->isOpen()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "output file is closed");
     return false;
   }
@@ -9985,26 +9985,26 @@ static bool Help(JSContext* cx, unsigned
   if (args.length() == 0) {
     fprintf(gOutFile->fp, "%s\n", JS_GetImplementationVersion());
 
-    if (!PrintEnumeratedHelp(cx, global, nullptr, false)) {
+    if (!PrintEnumeratedHelp(cx, global, nullptr, false)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedValue v(cx);
 
-  if (args[0].isPrimitive()) {
+  if (args[0].isPrimitive()) {MOZ_RELEASE_ASSERT(0);
     // help("foo")
     JS_ReportErrorASCII(cx, "primitive arg");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedObject obj(cx, &args[0].toObject());
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   bool isRegexp;
-  if (!JS::ObjectIsRegExp(cx, obj, &isRegexp)) {
+  if (!JS::ObjectIsRegExp(cx, obj, &isRegexp)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -10036,7 +10036,7 @@ const JSErrorFormatString* js::shell::my
 
 static bool CreateLastWarningObject(JSContext* cx, JSErrorReport* report) {
   RootedObject warningObj(cx, JS_NewObject(cx, nullptr));
-  if (!warningObj) {
+  if (!warningObj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -10064,7 +10064,7 @@ bool shell::PrintStackTrace(JSContext* c
 
   JSPrincipals* principals = stackObj->nonCCWRealm()->principals();
   RootedString stackStr(cx);
-  if (!BuildStackString(cx, principals, stackObj, &stackStr, 2)) {
+  if (!BuildStackString(cx, principals, stackObj, &stackStr, 2)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -10087,7 +10087,7 @@ js::shell::AutoReportException::~AutoRep
 
   // Get exception object and stack before printing and clearing exception.
   JS::ExceptionStack exnStack(cx);
-  if (!JS::StealPendingExceptionStack(cx, &exnStack)) {
+  if (!JS::StealPendingExceptionStack(cx, &exnStack)) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "out of memory while stealing exception\n");
     fflush(stderr);
     JS_ClearPendingException(cx);
@@ -10096,7 +10096,7 @@ js::shell::AutoReportException::~AutoRep
 
   ShellContext* sc = GetShellContext(cx);
   JS::ErrorReportBuilder report(cx);
-  if (!report.init(cx, exnStack, JS::ErrorReportBuilder::WithSideEffects)) {
+  if (!report.init(cx, exnStack, JS::ErrorReportBuilder::WithSideEffects)) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "out of memory initializing JS::ErrorReportBuilder\n");
     fflush(stderr);
     JS_ClearPendingException(cx);
@@ -10109,7 +10109,7 @@ js::shell::AutoReportException::~AutoRep
   JS::PrintError(cx, fp, report, reportWarnings);
   JS_ClearPendingException(cx);
 
-  if (!PrintStackTrace(cx, exnStack.stack())) {
+  if (!PrintStackTrace(cx, exnStack.stack())) {MOZ_RELEASE_ASSERT(0);
     fputs("(Unable to print stack trace)\n", fp);
     JS_ClearPendingException(cx);
   }
@@ -10122,7 +10122,7 @@ js::shell::AutoReportException::~AutoRep
   }
 #endif
 
-  if (report.report()->errorNumber == JSMSG_OUT_OF_MEMORY) {
+  if (report.report()->errorNumber == JSMSG_OUT_OF_MEMORY) {MOZ_RELEASE_ASSERT(0);
     sc->exitCode = EXITCODE_OUT_OF_MEMORY;
   } else {
     sc->exitCode = EXITCODE_RUNTIME_ERROR;
@@ -10399,7 +10399,7 @@ static const JSClass* GetDomClass() { re
 static bool dom_genericGetter(JSContext* cx, unsigned argc, JS::Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (!args.thisv().isObject()) {
+  if (!args.thisv().isObject()) {MOZ_RELEASE_ASSERT(0);
     args.rval().setUndefined();
     return true;
   }
@@ -10421,13 +10421,13 @@ static bool dom_genericGetter(JSContext*
 static bool dom_genericSetter(JSContext* cx, unsigned argc, JS::Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() < 1 || !args.thisv().isObject()) {
+  if (args.length() < 1 || !args.thisv().isObject()) {MOZ_RELEASE_ASSERT(0);
     args.rval().setUndefined();
     return true;
   }
 
   RootedObject obj(cx, &args.thisv().toObject());
-  if (JS::GetClass(obj) != &dom_class) {
+  if (JS::GetClass(obj) != &dom_class) {MOZ_RELEASE_ASSERT(0);
     args.rval().set(UndefinedValue());
     return true;
   }
@@ -10447,7 +10447,7 @@ static bool dom_genericSetter(JSContext*
 static bool dom_genericMethod(JSContext* cx, unsigned argc, JS::Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (!args.thisv().isObject()) {
+  if (!args.thisv().isObject()) {MOZ_RELEASE_ASSERT(0);
     args.rval().setUndefined();
     return true;
   }
@@ -10489,11 +10489,11 @@ static bool dom_constructor(JSContext* c
 
   RootedObject callee(cx, &args.callee());
   RootedValue protov(cx);
-  if (!GetProperty(cx, callee, callee, cx->names().prototype, &protov)) {
-    return false;
-  }
-
-  if (!protov.isObject()) {
+  if (!GetProperty(cx, callee, callee, cx->names().prototype, &protov)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!protov.isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr, JSMSG_BAD_PROTOTYPE,
                               "FakeDOMObject");
     return false;
@@ -10554,7 +10554,7 @@ static JSObject* NewGlobalObject(JSConte
 
     if (kind == ShellGlobalKind::WindowProxy) {
       RootedObject proxy(cx, NewShellWindowProxy(cx, glob));
-      if (!proxy) {
+      if (!proxy) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       js::SetWindowProxy(cx, glob, proxy);
@@ -10568,7 +10568,7 @@ static JSObject* NewGlobalObject(JSConte
 
     if (immutablePrototype) {
       bool succeeded;
-      if (!JS_SetImmutablePrototype(cx, glob, &succeeded)) {
+      if (!JS_SetImmutablePrototype(cx, glob, &succeeded)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       MOZ_ASSERT(succeeded,
@@ -10581,62 +10581,62 @@ static JSObject* NewGlobalObject(JSConte
       return nullptr;
     }
 #endif
-    if (!JS_InitReflectParse(cx, glob)) {
+    if (!JS_InitReflectParse(cx, glob)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (!JS_DefineDebuggerObject(cx, glob)) {
+    if (!JS_DefineDebuggerObject(cx, glob)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (!JS_DefineFunctionsWithHelp(cx, glob, shell_functions) ||
-        !JS_DefineProfilingFunctions(cx, glob)) {
+        !JS_DefineProfilingFunctions(cx, glob)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (!js::DefineTestingFunctions(cx, glob, fuzzingSafe,
-                                    disableOOMFunctions)) {
+                                    disableOOMFunctions)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (!JS_DefineProperties(cx, glob, TestingProperties)) {
+    if (!JS_DefineProperties(cx, glob, TestingProperties)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     if (!fuzzingSafe) {
-      if (!JS_DefineFunctionsWithHelp(cx, glob, fuzzing_unsafe_functions)) {
+      if (!JS_DefineFunctionsWithHelp(cx, glob, fuzzing_unsafe_functions)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
-      if (!DefineConsole(cx, glob)) {
+      if (!DefineConsole(cx, glob)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
 
-    if (!DefineOS(cx, glob, fuzzingSafe, &gOutFile, &gErrFile)) {
+    if (!DefineOS(cx, glob, fuzzingSafe, &gOutFile, &gErrFile)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     RootedObject performanceObj(cx, JS_NewObject(cx, nullptr));
-    if (!performanceObj) {
+    if (!performanceObj) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (!JS_DefineFunctionsWithHelp(cx, performanceObj,
-                                    performance_functions)) {
+                                    performance_functions)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     RootedObject mozMemoryObj(cx, JS_NewObject(cx, nullptr));
-    if (!mozMemoryObj) {
+    if (!mozMemoryObj) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     RootedObject gcObj(cx, gc::NewMemoryInfoObject(cx));
-    if (!gcObj) {
+    if (!gcObj) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (!JS_DefineProperty(cx, glob, "performance", performanceObj,
-                           JSPROP_ENUMERATE)) {
+                           JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (!JS_DefineProperty(cx, performanceObj, "mozMemory", mozMemoryObj,
-                           JSPROP_ENUMERATE)) {
+                           JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (!JS_DefineProperty(cx, mozMemoryObj, "gc", gcObj, JSPROP_ENUMERATE)) {
+    if (!JS_DefineProperty(cx, mozMemoryObj, "gc", gcObj, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -10647,7 +10647,7 @@ static JSObject* NewGlobalObject(JSConte
     RootedObject domProto(
         cx, JS_InitClass(cx, glob, nullptr, &dom_class, dom_constructor, 0,
                          dom_props, dom_methods, nullptr, nullptr));
-    if (!domProto) {
+    if (!domProto) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -10675,29 +10675,29 @@ static bool BindScriptArgs(JSContext* cx
   MultiStringRange msr = op->getMultiStringArg("scriptArgs");
   RootedObject scriptArgs(cx);
   scriptArgs = JS::NewArrayObject(cx, 0);
-  if (!scriptArgs) {
-    return false;
-  }
-
-  if (!JS_DefineProperty(cx, cx->global(), "scriptArgs", scriptArgs, 0)) {
-    return false;
-  }
-
-  for (size_t i = 0; !msr.empty(); msr.popFront(), ++i) {
+  if (!scriptArgs) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!JS_DefineProperty(cx, cx->global(), "scriptArgs", scriptArgs, 0)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  for (size_t i = 0; !msr.empty(); msr.popFront(), ++i) {MOZ_RELEASE_ASSERT(0);
     const char* scriptArg = msr.front();
     JS::RootedString str(cx, JS_NewStringCopyZ(cx, scriptArg));
-    if (!str || !JS_DefineElement(cx, scriptArgs, i, str, JSPROP_ENUMERATE)) {
-      return false;
-    }
+    if (!str || !JS_DefineElement(cx, scriptArgs, i, str, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   const char* scriptPath = op->getStringArg("script");
   RootedValue scriptPathValue(cx);
-  if (scriptPath) {
+  if (scriptPath) {MOZ_RELEASE_ASSERT(0);
     RootedString scriptPathString(cx, JS_NewStringCopyZ(cx, scriptPath));
-    if (!scriptPathString) {
-      return false;
-    }
+    if (!scriptPathString) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }MOZ_RELEASE_ASSERT(0);
     scriptPathValue = StringValue(scriptPathString);
   } else {
     scriptPathValue = UndefinedValue();
@@ -10734,35 +10734,35 @@ static bool OptionFailure(const char* op
 #endif
 
   /* |scriptArgs| gets bound on the global before any code is run. */
-  if (!BindScriptArgs(cx, op)) {
+  if (!BindScriptArgs(cx, op)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedString moduleLoadPath(cx);
   if (const char* option = op->getStringOption("module-load-path")) {
     RootedString jspath(cx, JS_NewStringCopyZ(cx, option));
-    if (!jspath) {
+    if (!jspath) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     moduleLoadPath = js::shell::ResolvePath(cx, jspath, RootRelative);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     UniqueChars cwd = js::shell::GetCWD();
     moduleLoadPath = JS_NewStringCopyZ(cx, cwd.get());
   }
 
-  if (!moduleLoadPath) {
+  if (!moduleLoadPath) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   processWideModuleLoadPath = JS_EncodeStringToUTF8(cx, moduleLoadPath);
-  if (!processWideModuleLoadPath) {
+  if (!processWideModuleLoadPath) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(cx->isExceptionPending());
     return false;
   }
 
   sc->moduleLoader = js::MakeUnique<ModuleLoader>();
-  if (!sc->moduleLoader || !sc->moduleLoader->init(cx, moduleLoadPath)) {
+  if (!sc->moduleLoader || !sc->moduleLoader->init(cx, moduleLoadPath)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -10779,7 +10779,7 @@ static bool OptionFailure(const char* op
 #endif /* FUZZING_JS_FUZZILLI */
 
   if (filePaths.empty() && utf16FilePaths.empty() && codeChunks.empty() &&
-      modulePaths.empty() && !op->getStringArg("script")) {
+      modulePaths.empty() && !op->getStringArg("script")) {MOZ_RELEASE_ASSERT(0);
     // Always use the interactive shell when -i is used. Without -i we let
     // Process figure it out based on isatty.
     bool forceTTY = op->getBoolOption('i');
@@ -10804,11 +10804,11 @@ static bool OptionFailure(const char* op
       continue;
     }
 
-    if (ufpArgno < fpArgno && ufpArgno < ccArgno && ufpArgno < mpArgno) {
+    if (ufpArgno < fpArgno && ufpArgno < ccArgno && ufpArgno < mpArgno) {MOZ_RELEASE_ASSERT(0);
       char* path = utf16FilePaths.front();
-      if (!Process(cx, path, false, FileScriptUtf16)) {
-        return false;
-      }
+      if (!Process(cx, path, false, FileScriptUtf16)) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }MOZ_RELEASE_ASSERT(0);
 
       utf16FilePaths.popFront();
       continue;
@@ -10821,7 +10821,7 @@ static bool OptionFailure(const char* op
       opts.setFileAndLine("-e", 1);
 
       JS::SourceText<Utf8Unit> srcBuf;
-      if (!srcBuf.init(cx, code, strlen(code), JS::SourceOwnership::Borrowed)) {
+      if (!srcBuf.init(cx, code, strlen(code), JS::SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -10831,7 +10831,7 @@ static bool OptionFailure(const char* op
       }
 
       codeChunks.popFront();
-      if (sc->quitting) {
+      if (sc->quitting) {MOZ_RELEASE_ASSERT(0);
         break;
       }
 
@@ -10848,15 +10848,15 @@ static bool OptionFailure(const char* op
     modulePaths.popFront();
   }
 
-  if (sc->quitting) {
+  if (sc->quitting) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   /* The |script| argument is processed after all options. */
   if (const char* path = op->getStringArg("script")) {
-    if (!Process(cx, path, false, FileScript)) {
-      return false;
-    }
+    if (!Process(cx, path, false, FileScript)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   if (op->getBoolOption('i')) {
@@ -10879,7 +10879,7 @@ static bool SetContextOptions(JSContext*
   bool commandLineRequestedWasmCranelift = false;
 
   if (const char* str = op.getStringOption("wasm-compiler")) {
-    if (strcmp(str, "none") == 0) {
+    if (strcmp(str, "none") == 0) {MOZ_RELEASE_ASSERT(0);
       enableWasm = false;
     } else if (strcmp(str, "baseline") == 0) {
       MOZ_ASSERT(enableWasmBaseline);
@@ -10889,7 +10889,7 @@ static bool SetContextOptions(JSContext*
       enableWasmBaseline = false;
       MOZ_ASSERT(enableWasmOptimizing);
     } else if (strcmp(str, "baseline+optimizing") == 0 ||
-               strcmp(str, "baseline+optimized") == 0) {
+               strcmp(str, "baseline+optimized") == 0) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(enableWasmBaseline);
       MOZ_ASSERT(enableWasmOptimizing);
 #ifdef ENABLE_WASM_CRANELIFT
@@ -10906,11 +10906,11 @@ static bool SetContextOptions(JSContext*
       enableWasmBaseline = false;
       enableWasmOptimizing = true;
       commandLineRequestedWasmIon = true;
-    } else if (strcmp(str, "baseline+ion") == 0) {
+    } else if (strcmp(str, "baseline+ion") == 0) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(enableWasmBaseline);
       enableWasmOptimizing = true;
       commandLineRequestedWasmIon = true;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       return OptionFailure("wasm-compiler", str);
     }
   }
@@ -11029,13 +11029,13 @@ static bool SetContextOptions(JSContext*
   }
 
   if (const char* str = op.getStringOption("cache-ir-stubs")) {
-    if (strcmp(str, "on") == 0) {
+    if (strcmp(str, "on") == 0) {MOZ_RELEASE_ASSERT(0);
       jit::JitOptions.disableCacheIR = false;
-    } else if (strcmp(str, "off") == 0) {
+    } else if (strcmp(str, "off") == 0) {MOZ_RELEASE_ASSERT(0);
       jit::JitOptions.disableCacheIR = true;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       return OptionFailure("cache-ir-stubs", str);
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   if (const char* str = op.getStringOption("spectre-mitigations")) {
@@ -11051,22 +11051,22 @@ static bool SetContextOptions(JSContext*
       jit::JitOptions.spectreStringMitigations = false;
       jit::JitOptions.spectreValueMasking = false;
       jit::JitOptions.spectreJitToCxxCalls = false;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       return OptionFailure("spectre-mitigations", str);
     }
   }
 
   if (const char* str = op.getStringOption("ion-scalar-replacement")) {
-    if (strcmp(str, "on") == 0) {
+    if (strcmp(str, "on") == 0) {MOZ_RELEASE_ASSERT(0);
       jit::JitOptions.disableScalarReplacement = false;
-    } else if (strcmp(str, "off") == 0) {
+    } else if (strcmp(str, "off") == 0) {MOZ_RELEASE_ASSERT(0);
       jit::JitOptions.disableScalarReplacement = true;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       return OptionFailure("ion-scalar-replacement", str);
-    }
-  }
-
-  if (op.getStringOption("ion-shared-stubs")) {
+    }MOZ_RELEASE_ASSERT(0);
+  }
+
+  if (op.getStringOption("ion-shared-stubs")) {MOZ_RELEASE_ASSERT(0);
     // Dead option, preserved for now for potential fuzzer interaction.
   }
 
@@ -11074,7 +11074,7 @@ static bool SetContextOptions(JSContext*
     if (strcmp(str, "off") == 0) {
       jit::JitOptions.disableGvn = true;
     } else if (strcmp(str, "on") != 0 && strcmp(str, "optimistic") != 0 &&
-               strcmp(str, "pessimistic") != 0) {
+               strcmp(str, "pessimistic") != 0) {MOZ_RELEASE_ASSERT(0);
       // We accept "pessimistic" and "optimistic" as synonyms for "on"
       // for backwards compatibility.
       return OptionFailure("ion-gvn", str);
@@ -11082,23 +11082,23 @@ static bool SetContextOptions(JSContext*
   }
 
   if (const char* str = op.getStringOption("ion-licm")) {
-    if (strcmp(str, "on") == 0) {
+    if (strcmp(str, "on") == 0) {MOZ_RELEASE_ASSERT(0);
       jit::JitOptions.disableLicm = false;
-    } else if (strcmp(str, "off") == 0) {
+    } else if (strcmp(str, "off") == 0) {MOZ_RELEASE_ASSERT(0);
       jit::JitOptions.disableLicm = true;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       return OptionFailure("ion-licm", str);
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   if (const char* str = op.getStringOption("ion-edgecase-analysis")) {
-    if (strcmp(str, "on") == 0) {
+    if (strcmp(str, "on") == 0) {MOZ_RELEASE_ASSERT(0);
       jit::JitOptions.disableEdgeCaseAnalysis = false;
-    } else if (strcmp(str, "off") == 0) {
+    } else if (strcmp(str, "off") == 0) {MOZ_RELEASE_ASSERT(0);
       jit::JitOptions.disableEdgeCaseAnalysis = true;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       return OptionFailure("ion-edgecase-analysis", str);
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   if (const char* str = op.getStringOption("ion-pruning")) {
@@ -11106,39 +11106,39 @@ static bool SetContextOptions(JSContext*
       jit::JitOptions.disablePruning = false;
     } else if (strcmp(str, "off") == 0) {
       jit::JitOptions.disablePruning = true;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       return OptionFailure("ion-pruning", str);
     }
   }
 
   if (const char* str = op.getStringOption("ion-range-analysis")) {
-    if (strcmp(str, "on") == 0) {
+    if (strcmp(str, "on") == 0) {MOZ_RELEASE_ASSERT(0);
       jit::JitOptions.disableRangeAnalysis = false;
-    } else if (strcmp(str, "off") == 0) {
+    } else if (strcmp(str, "off") == 0) {MOZ_RELEASE_ASSERT(0);
       jit::JitOptions.disableRangeAnalysis = true;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       return OptionFailure("ion-range-analysis", str);
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   if (const char* str = op.getStringOption("ion-sink")) {
     if (strcmp(str, "on") == 0) {
       jit::JitOptions.disableSink = false;
-    } else if (strcmp(str, "off") == 0) {
+    } else if (strcmp(str, "off") == 0) {MOZ_RELEASE_ASSERT(0);
       jit::JitOptions.disableSink = true;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       return OptionFailure("ion-sink", str);
     }
   }
 
   if (const char* str = op.getStringOption("ion-instruction-reordering")) {
-    if (strcmp(str, "on") == 0) {
+    if (strcmp(str, "on") == 0) {MOZ_RELEASE_ASSERT(0);
       jit::JitOptions.disableInstructionReordering = false;
-    } else if (strcmp(str, "off") == 0) {
+    } else if (strcmp(str, "off") == 0) {MOZ_RELEASE_ASSERT(0);
       jit::JitOptions.disableInstructionReordering = true;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       return OptionFailure("ion-instruction-reordering", str);
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   if (op.getBoolOption("ion-check-range-analysis")) {
@@ -11150,31 +11150,31 @@ static bool SetContextOptions(JSContext*
   }
 
   if (const char* str = op.getStringOption("ion-inlining")) {
-    if (strcmp(str, "on") == 0) {
+    if (strcmp(str, "on") == 0) {MOZ_RELEASE_ASSERT(0);
       jit::JitOptions.disableInlining = false;
-    } else if (strcmp(str, "off") == 0) {
+    } else if (strcmp(str, "off") == 0) {MOZ_RELEASE_ASSERT(0);
       jit::JitOptions.disableInlining = true;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       return OptionFailure("ion-inlining", str);
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   if (const char* str = op.getStringOption("ion-osr")) {
-    if (strcmp(str, "on") == 0) {
+    if (strcmp(str, "on") == 0) {MOZ_RELEASE_ASSERT(0);
       jit::JitOptions.osr = true;
     } else if (strcmp(str, "off") == 0) {
       jit::JitOptions.osr = false;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       return OptionFailure("ion-osr", str);
     }
   }
 
   if (const char* str = op.getStringOption("ion-limit-script-size")) {
-    if (strcmp(str, "on") == 0) {
+    if (strcmp(str, "on") == 0) {MOZ_RELEASE_ASSERT(0);
       jit::JitOptions.limitScriptSize = true;
     } else if (strcmp(str, "off") == 0) {
       jit::JitOptions.limitScriptSize = false;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       return OptionFailure("ion-limit-script-size", str);
     }
   }
@@ -11190,12 +11190,12 @@ static bool SetContextOptions(JSContext*
   }
 
   warmUpThreshold = op.getIntOption("trial-inlining-warmup-threshold");
-  if (warmUpThreshold >= 0) {
+  if (warmUpThreshold >= 0) {MOZ_RELEASE_ASSERT(0);
     jit::JitOptions.trialInliningWarmUpThreshold = warmUpThreshold;
   }
 
   warmUpThreshold = op.getIntOption("regexp-warmup-threshold");
-  if (warmUpThreshold >= 0) {
+  if (warmUpThreshold >= 0) {MOZ_RELEASE_ASSERT(0);
     jit::JitOptions.regexpWarmUpThreshold = warmUpThreshold;
   }
 
@@ -11203,7 +11203,7 @@ static bool SetContextOptions(JSContext*
     jit::JitOptions.setEagerBaselineCompilation();
   }
 
-  if (op.getBoolOption("blinterp")) {
+  if (op.getBoolOption("blinterp")) {MOZ_RELEASE_ASSERT(0);
     jit::JitOptions.baselineInterpreter = true;
   }
 
@@ -11224,11 +11224,11 @@ static bool SetContextOptions(JSContext*
     jit::JitOptions.baselineJit = false;
   }
 
-  if (op.getBoolOption("no-warp-async")) {
+  if (op.getBoolOption("no-warp-async")) {MOZ_RELEASE_ASSERT(0);
     jit::JitOptions.warpAsync = false;
   }
 
-  if (op.getBoolOption("no-warp-generator")) {
+  if (op.getBoolOption("no-warp-generator")) {MOZ_RELEASE_ASSERT(0);
     jit::JitOptions.warpGenerator = false;
   }
 
@@ -11236,7 +11236,7 @@ static bool SetContextOptions(JSContext*
     jit::JitOptions.warpAsync = true;
   }
 
-  if (op.getBoolOption("warp-generator")) {
+  if (op.getBoolOption("warp-generator")) {MOZ_RELEASE_ASSERT(0);
     jit::JitOptions.warpGenerator = true;
   }
 
@@ -11244,20 +11244,20 @@ static bool SetContextOptions(JSContext*
     jit::JitOptions.ion = false;
   }
 
-  if (op.getBoolOption("no-native-regexp")) {
+  if (op.getBoolOption("no-native-regexp")) {MOZ_RELEASE_ASSERT(0);
     jit::JitOptions.nativeRegExp = false;
   }
 
-  if (op.getBoolOption("trace-regexp-parser")) {
+  if (op.getBoolOption("trace-regexp-parser")) {MOZ_RELEASE_ASSERT(0);
     jit::JitOptions.traceRegExpParser = true;
   }
-  if (op.getBoolOption("trace-regexp-assembler")) {
+  if (op.getBoolOption("trace-regexp-assembler")) {MOZ_RELEASE_ASSERT(0);
     jit::JitOptions.traceRegExpAssembler = true;
   }
-  if (op.getBoolOption("trace-regexp-interpreter")) {
+  if (op.getBoolOption("trace-regexp-interpreter")) {MOZ_RELEASE_ASSERT(0);
     jit::JitOptions.traceRegExpInterpreter = true;
   }
-  if (op.getBoolOption("trace-regexp-peephole")) {
+  if (op.getBoolOption("trace-regexp-peephole")) {MOZ_RELEASE_ASSERT(0);
     jit::JitOptions.traceRegExpPeephole = true;
   }
 
@@ -11267,15 +11267,15 @@ static bool SetContextOptions(JSContext*
   }
 
   int32_t smallFunctionLength = op.getIntOption("small-function-length");
-  if (smallFunctionLength > 0) {
+  if (smallFunctionLength > 0) {MOZ_RELEASE_ASSERT(0);
     jit::JitOptions.smallFunctionMaxBytecodeLength = smallFunctionLength;
   }
 
-  if (const char* str = op.getStringOption("ion-regalloc")) {
+  if (const char* str = op.getStringOption("ion-regalloc")) {MOZ_RELEASE_ASSERT(0);
     jit::JitOptions.forcedRegisterAllocator = jit::LookupRegisterAllocator(str);
-    if (!jit::JitOptions.forcedRegisterAllocator.isSome()) {
+    if (!jit::JitOptions.forcedRegisterAllocator.isSome()) {MOZ_RELEASE_ASSERT(0);
       return OptionFailure("ion-regalloc", str);
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   if (op.getBoolOption("ion-eager")) {
@@ -11286,13 +11286,13 @@ static bool SetContextOptions(JSContext*
   if (const char* str = op.getStringOption("ion-offthread-compile")) {
     if (strcmp(str, "off") == 0) {
       offthreadCompilation = false;
-    } else if (strcmp(str, "on") != 0) {
+    } else if (strcmp(str, "on") != 0) {MOZ_RELEASE_ASSERT(0);
       return OptionFailure("ion-offthread-compile", str);
     }
   }
   cx->runtime()->setOffthreadIonCompilationEnabled(offthreadCompilation);
 
-  if (op.getStringOption("ion-parallel-compile")) {
+  if (op.getStringOption("ion-parallel-compile")) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr,
             "--ion-parallel-compile is deprecated. Please use "
             "--ion-offthread-compile instead.\n");
@@ -11302,9 +11302,9 @@ static bool SetContextOptions(JSContext*
   if (const char* str = op.getStringOption("shared-memory")) {
     if (strcmp(str, "off") == 0) {
       enableSharedMemory = false;
-    } else if (strcmp(str, "on") == 0) {
+    } else if (strcmp(str, "on") == 0) {MOZ_RELEASE_ASSERT(0);
       enableSharedMemory = true;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       return OptionFailure("shared-memory", str);
     }
   }
@@ -11313,7 +11313,7 @@ static bool SetContextOptions(JSContext*
     JS::SetLargeArrayBuffersEnabled(true);
   }
 
-  if (op.getBoolOption("disable-bailout-loop-check")) {
+  if (op.getBoolOption("disable-bailout-loop-check")) {MOZ_RELEASE_ASSERT(0);
     jit::JitOptions.disableBailoutLoopCheck = true;
   }
 
@@ -11444,7 +11444,7 @@ static void SetWorkerContextOptions(JSCo
   }
 
   UniqueChars utf8chars = JS_EncodeStringToUTF8(cx, str);
-  if (!utf8chars) {
+  if (!utf8chars) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11458,7 +11458,7 @@ static void SetWorkerContextOptions(JSCo
 
   JSPrincipals* principals = cx->realm()->principals();
   RootedString stackStr(cx);
-  if (!BuildStackString(cx, principals, site, &stackStr, 2)) {
+  if (!BuildStackString(cx, principals, site, &stackStr, 2)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11493,7 +11493,7 @@ static void SetWorkerContextOptions(JSCo
 
   RootedValue iter(cx);
   if (!SetObject::iterator(cx, SetObject::IteratorKind::Values,
-                           sc->unhandledRejectedPromises, &iter)) {
+                           sc->unhandledRejectedPromises, &iter)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11535,7 +11535,7 @@ static void SetWorkerContextOptions(JSCo
 }
 
 static int Shell(JSContext* cx, OptionParser* op, char** envp) {
-  if (JS::TraceLoggerSupported()) {
+  if (JS::TraceLoggerSupported()) {MOZ_RELEASE_ASSERT(0);
     JS::StartTraceLogger(cx);
   }
 #ifdef JS_STRUCTURED_SPEW
@@ -11553,7 +11553,7 @@ static int Shell(JSContext* cx, OptionPa
   });
 
   if (op->getBoolOption("wasm-compile-and-serialize")) {
-    if (!WasmCompileAndSerialize(cx)) {
+    if (!WasmCompileAndSerialize(cx)) {MOZ_RELEASE_ASSERT(0);
       // Errors have been printed directly to stderr.
       MOZ_ASSERT(!cx->isExceptionPending());
       return -1;
@@ -11588,7 +11588,7 @@ static int Shell(JSContext* cx, OptionPa
   }
 #endif
 
-  if (op->getBoolOption("disable-oom-functions")) {
+  if (op->getBoolOption("disable-oom-functions")) {MOZ_RELEASE_ASSERT(0);
     disableOOMFunctions = true;
   }
 
@@ -11606,7 +11606,7 @@ static int Shell(JSContext* cx, OptionPa
     RootedObject glob(
         cx, NewGlobalObject(cx, options, nullptr, ShellGlobalKind::WindowProxy,
                             /* immutablePrototype = */ true));
-    if (!glob) {
+    if (!glob) {MOZ_RELEASE_ASSERT(0);
       return 1;
     }
 
@@ -11681,7 +11681,7 @@ static void SetOutputFile(const char* co
 
   const char* outPath = getenv(envVar);
   FILE* newfp;
-  if (outPath && *outPath && (newfp = fopen(outPath, "w"))) {
+  if (outPath && *outPath && (newfp = fopen(outPath, "w"))) {MOZ_RELEASE_ASSERT(0);
     outFile = SystemAlloc_New<RCFile>(newfp);
   } else {
     outFile = defaultOut;
@@ -11719,7 +11719,7 @@ class AutoLibraryLoader {
     }
   }
 
-  PRLibrary* load(const char* path) {
+  PRLibrary* load(const char* path) {MOZ_RELEASE_ASSERT(0);
     PRLibSpec libSpec;
     libSpec.type = PR_LibSpec_Pathname;
     libSpec.value.pathname = path;
@@ -11738,25 +11738,25 @@ class AutoLibraryLoader {
 
 static bool ReadSelfHostedXDRFile(JSContext* cx, FileContents& buf) {
   FILE* file = fopen(selfHostedXDRPath, "rb");
-  if (!file) {
+  if (!file) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "Can't open self-hosted stencil XDR file.\n");
     return false;
   }
   AutoCloseFile autoClose(file);
 
   struct stat st;
-  if (fstat(fileno(file), &st) < 0) {
+  if (fstat(fileno(file), &st) < 0) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "Unable to stat self-hosted stencil XDR file.\n");
     return false;
   }
 
-  if (st.st_size >= INT32_MAX) {
+  if (st.st_size >= INT32_MAX) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "self-hosted stencil XDR file too large.\n");
     return false;
   }
   uint32_t filesize = uint32_t(st.st_size);
 
-  if (!buf.growBy(filesize)) {
+  if (!buf.growBy(filesize)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   size_t cc = fread(buf.begin(), 1, filesize, file);
@@ -11771,7 +11771,7 @@ static bool ReadSelfHostedXDRFile(JSCont
 static bool WriteSelfHostedXDRFile(JSContext* cx,
                                    const JS::TranscodeBuffer& buffer) {
   FILE* file = fopen(selfHostedXDRPath, "wb");
-  if (!file) {
+  if (!file) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorUTF8(cx, "Can't open self-hosted stencil XDR file.");
     return false;
   }
@@ -11807,7 +11807,7 @@ int main(int argc, char** argv, char** e
   SetOutputFile("JS_STDERR", &rcStderr, &gErrFile);
 
   // Start the engine.
-  if (const char* message = JS_InitWithFailureDiagnostic()) {
+  if (const char* message = JS_InitWithFailureDiagnostic()) {MOZ_RELEASE_ASSERT(0);
     fprintf(gErrFile->fp, "JS_Init failed: %s\n", message);
     return 1;
   }
@@ -12253,7 +12253,7 @@ int main(int argc, char** argv, char** e
   // that the telemetry is recording both before starting the context and after
   // closing it.
   if (op.getStringOption("telemetry-dir")) {
-    if (!telemetryLock) {
+    if (!telemetryLock) {MOZ_RELEASE_ASSERT(0);
       telemetryLock = js_new<Mutex>(mutexid::ShellTelemetry);
       if (!telemetryLock) {
         return EXIT_FAILURE;
@@ -12303,7 +12303,7 @@ int main(int argc, char** argv, char** e
       shell::encodeSelfHostedCode = true;
     } else if (strcmp(opt, "decode") == 0) {
       shell::encodeSelfHostedCode = false;
-    } else if (strcmp(opt, "off") == 0) {
+    } else if (strcmp(opt, "off") == 0) {MOZ_RELEASE_ASSERT(0);
       shell::selfHostedXDRPath = nullptr;
     } else {
       MOZ_CRASH(
@@ -12441,9 +12441,9 @@ int main(int argc, char** argv, char** e
   });
 
   if (const char* opt = op.getStringOption("nursery-strings")) {
-    if (strcmp(opt, "on") == 0) {
+    if (strcmp(opt, "on") == 0) {MOZ_RELEASE_ASSERT(0);
       cx->runtime()->gc.nursery().enableStrings();
-    } else if (strcmp(opt, "off") == 0) {
+    } else if (strcmp(opt, "off") == 0) {MOZ_RELEASE_ASSERT(0);
       cx->runtime()->gc.nursery().disableStrings();
     } else {
       MOZ_CRASH("invalid option value for --nursery-strings, must be on/off");
@@ -12451,9 +12451,9 @@ int main(int argc, char** argv, char** e
   }
 
   if (const char* opt = op.getStringOption("nursery-bigints")) {
-    if (strcmp(opt, "on") == 0) {
+    if (strcmp(opt, "on") == 0) {MOZ_RELEASE_ASSERT(0);
       cx->runtime()->gc.nursery().enableBigInts();
-    } else if (strcmp(opt, "off") == 0) {
+    } else if (strcmp(opt, "off") == 0) {MOZ_RELEASE_ASSERT(0);
       cx->runtime()->gc.nursery().disableBigInts();
     } else {
       MOZ_CRASH("invalid option value for --nursery-bigints, must be on/off");
@@ -12516,7 +12516,7 @@ int main(int argc, char** argv, char** e
       return EXIT_FAILURE;
     }
   }
-  if (op.getBoolOption("no-ssse3")) {
+  if (op.getBoolOption("no-ssse3")) {MOZ_RELEASE_ASSERT(0);
     js::jit::CPUInfo::SetSSSE3Disabled();
     if (!sCompilerProcessFlags.append("--no-ssse3")) {
       return EXIT_FAILURE;
@@ -12528,13 +12528,13 @@ int main(int argc, char** argv, char** e
       return EXIT_FAILURE;
     }
   }
-  if (op.getBoolOption("no-sse42")) {
+  if (op.getBoolOption("no-sse42")) {MOZ_RELEASE_ASSERT(0);
     js::jit::CPUInfo::SetSSE42Disabled();
     if (!sCompilerProcessFlags.append("--no-sse42")) {
       return EXIT_FAILURE;
     }
   }
-  if (op.getBoolOption("enable-avx")) {
+  if (op.getBoolOption("enable-avx")) {MOZ_RELEASE_ASSERT(0);
     js::jit::CPUInfo::SetAVXEnabled();
     if (!sCompilerProcessFlags.append("--enable-avx")) {
       return EXIT_FAILURE;
diff --git a/js/src/shell/jsoptparse.cpp b/js/src/shell/jsoptparse.cpp
--- a/js/src/shell/jsoptparse.cpp
+++ b/js/src/shell/jsoptparse.cpp
@@ -65,38 +65,38 @@ OptionParser::Result OptionParser::error
 
 /* Quick and dirty paragraph printer. */
 static void PrintParagraph(const char* text, unsigned startColno,
-                           const unsigned limitColno, bool padFirstLine) {
+                           const unsigned limitColno, bool padFirstLine) {MOZ_RELEASE_ASSERT(0);
   unsigned colno = startColno;
   unsigned indent = 0;
   const char* it = text;
 
-  if (padFirstLine) {
+  if (padFirstLine) {MOZ_RELEASE_ASSERT(0);
     printf("%*s", int(startColno), "");
   }
 
   /* Skip any leading spaces. */
-  while (*it != '\0' && unicode::IsSpace(*it)) {
+  while (*it != '\0' && unicode::IsSpace(*it)) {MOZ_RELEASE_ASSERT(0);
     ++it;
   }
 
-  while (*it != '\0') {
+  while (*it != '\0') {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(!unicode::IsSpace(*it) || *it == '\n');
 
     /* Delimit the current token. */
     const char* limit = it;
-    while (!unicode::IsSpace(*limit) && *limit != '\0') {
+    while (!unicode::IsSpace(*limit) && *limit != '\0') {MOZ_RELEASE_ASSERT(0);
       ++limit;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     /*
      * If the current token is longer than the available number of columns,
      * then make a line break before printing the token.
      */
     size_t tokLen = limit - it;
-    if (tokLen + colno >= limitColno) {
+    if (tokLen + colno >= limitColno) {MOZ_RELEASE_ASSERT(0);
       printf("\n%*s%.*s", int(startColno + indent), "", int(tokLen), it);
       colno = startColno + tokLen;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       printf("%.*s", int(tokLen), it);
       colno += tokLen;
     }
@@ -133,7 +133,7 @@ static void PrintParagraph(const char* t
 }
 
 static const char* OptionFlagsToFormatInfo(char shortflag, bool isValued,
-                                           size_t* length) {
+                                           size_t* length) {MOZ_RELEASE_ASSERT(0);
   static const char* const fmt[4] = {"  -%c --%s ", "  --%s ", "  -%c --%s=%s ",
                                      "  --%s=%s "};
 
@@ -149,81 +149,81 @@ static const char* OptionFlagsToFormatIn
   return fmt[index];
 }
 
-OptionParser::Result OptionParser::printHelp(const char* progname) {
+OptionParser::Result OptionParser::printHelp(const char* progname) {MOZ_RELEASE_ASSERT(0);
   const char* prefixEnd = strstr(usage, prognameMeta);
-  if (prefixEnd) {
+  if (prefixEnd) {MOZ_RELEASE_ASSERT(0);
     printf("%.*s%s%s\n", int(prefixEnd - usage), usage, progname,
            prefixEnd + sizeof(prognameMeta) - 1);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     puts(usage);
   }
 
-  if (descr) {
+  if (descr) {MOZ_RELEASE_ASSERT(0);
     putchar('\n');
     PrintParagraph(descr, 2, descrWidth, true);
     putchar('\n');
   }
 
-  if (version) {
+  if (version) {MOZ_RELEASE_ASSERT(0);
     printf("\nVersion: %s\n\n", version);
   }
 
-  if (!arguments.empty()) {
+  if (!arguments.empty()) {MOZ_RELEASE_ASSERT(0);
     printf("Arguments:\n");
 
     static const char fmt[] = "  %s ";
     size_t fmtChars = sizeof(fmt) - 2;
     size_t lhsLen = 0;
-    for (Option* arg : arguments) {
+    for (Option* arg : arguments) {MOZ_RELEASE_ASSERT(0);
       lhsLen = std::max(lhsLen, strlen(arg->longflag) + fmtChars);
     }
 
-    for (Option* arg : arguments) {
+    for (Option* arg : arguments) {MOZ_RELEASE_ASSERT(0);
       size_t chars = printf(fmt, arg->longflag);
-      for (; chars < lhsLen; ++chars) {
+      for (; chars < lhsLen; ++chars) {MOZ_RELEASE_ASSERT(0);
         putchar(' ');
-      }
+      }MOZ_RELEASE_ASSERT(0);
       PrintParagraph(arg->help, lhsLen, helpWidth, false);
       putchar('\n');
-    }
+    }MOZ_RELEASE_ASSERT(0);
     putchar('\n');
   }
 
-  if (!options.empty()) {
+  if (!options.empty()) {MOZ_RELEASE_ASSERT(0);
     printf("Options:\n");
 
     /* Calculate sizes for column alignment. */
     size_t lhsLen = 0;
-    for (Option* opt : options) {
+    for (Option* opt : options) {MOZ_RELEASE_ASSERT(0);
       size_t longflagLen = strlen(opt->longflag);
 
       size_t fmtLen;
       OptionFlagsToFormatInfo(opt->shortflag, opt->isValued(), &fmtLen);
 
       size_t len = fmtLen + longflagLen;
-      if (opt->isValued()) {
+      if (opt->isValued()) {MOZ_RELEASE_ASSERT(0);
         len += strlen(opt->asValued()->metavar);
-      }
+      }MOZ_RELEASE_ASSERT(0);
       lhsLen = std::max(lhsLen, len);
     }
 
     /* Print option help text. */
-    for (Option* opt : options) {
+    for (Option* opt : options) {MOZ_RELEASE_ASSERT(0);
       size_t fmtLen;
       const char* fmt =
           OptionFlagsToFormatInfo(opt->shortflag, opt->isValued(), &fmtLen);
       size_t chars;
-      if (opt->isValued()) {
-        if (opt->shortflag) {
+      if (opt->isValued()) {MOZ_RELEASE_ASSERT(0);
+        if (opt->shortflag) {MOZ_RELEASE_ASSERT(0);
           chars = printf(fmt, opt->shortflag, opt->longflag,
                          opt->asValued()->metavar);
-        } else {
+        } else {MOZ_RELEASE_ASSERT(0);
           chars = printf(fmt, opt->longflag, opt->asValued()->metavar);
         }
       } else {
-        if (opt->shortflag) {
+        if (opt->shortflag) {MOZ_RELEASE_ASSERT(0);
           chars = printf(fmt, opt->shortflag, opt->longflag);
-        } else {
+        } else {MOZ_RELEASE_ASSERT(0);
           chars = printf(fmt, opt->longflag);
         }
       }
@@ -250,7 +250,7 @@ OptionParser::Result OptionParser::extra
   char* eq = strchr(argv[*i], '=');
   if (eq) {
     *value = eq + 1;
-    if (*value[0] == '\0') {
+    if (*value[0] == '\0') {MOZ_RELEASE_ASSERT(0);
       return error("A value is required for option %.*s", (int)(eq - argv[*i]),
                    argv[*i]);
     }
@@ -269,7 +269,7 @@ OptionParser::Result OptionParser::extra
 OptionParser::Result OptionParser::handleOption(Option* opt, size_t argc,
                                                 char** argv, size_t* i,
                                                 bool* optionsAllowed) {
-  if (opt->getTerminatesOptions()) {
+  if (opt->getTerminatesOptions()) {MOZ_RELEASE_ASSERT(0);
     *optionsAllowed = false;
   }
 
@@ -319,7 +319,7 @@ OptionParser::Result OptionParser::handl
 
 OptionParser::Result OptionParser::handleArg(size_t argc, char** argv,
                                              size_t* i, bool* optionsAllowed) {
-  if (nextArgument >= arguments.length()) {
+  if (nextArgument >= arguments.length()) {MOZ_RELEASE_ASSERT(0);
     return error("Too many arguments provided");
   }
 
@@ -360,7 +360,7 @@ OptionParser::Result OptionParser::parse
       /* Option. */
       Option* opt;
       if (arg[1] == '-') {
-        if (arg[2] == '\0') {
+        if (arg[2] == '\0') {MOZ_RELEASE_ASSERT(0);
           /* End of options */
           optionsAllowed = false;
           nextArgument = restArgument;
@@ -368,17 +368,17 @@ OptionParser::Result OptionParser::parse
         } else {
           /* Long option. */
           opt = findOption(arg + 2);
-          if (!opt) {
+          if (!opt) {MOZ_RELEASE_ASSERT(0);
             return error("Invalid long option: %s", arg);
           }
         }
       } else {
         /* Short option */
-        if (arg[2] != '\0') {
+        if (arg[2] != '\0') {MOZ_RELEASE_ASSERT(0);
           return error("Short option followed by junk: %s", arg);
         }
         opt = findOption(arg[1]);
-        if (!opt) {
+        if (!opt) {MOZ_RELEASE_ASSERT(0);
           return error("Invalid short option: %s", arg);
         }
       }
@@ -534,7 +534,7 @@ MultiStringRange OptionParser::getMultiS
 bool OptionParser::addIntOption(char shortflag, const char* longflag,
                                 const char* metavar, const char* help,
                                 int defaultValue) {
-  if (!options.reserve(options.length() + 1)) {
+  if (!options.reserve(options.length() + 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   IntOption* io =
@@ -548,7 +548,7 @@ bool OptionParser::addIntOption(char sho
 
 bool OptionParser::addBoolOption(char shortflag, const char* longflag,
                                  const char* help) {
-  if (!options.reserve(options.length() + 1)) {
+  if (!options.reserve(options.length() + 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   BoolOption* bo = js_new<BoolOption>(shortflag, longflag, help);
@@ -561,7 +561,7 @@ bool OptionParser::addBoolOption(char sh
 
 bool OptionParser::addStringOption(char shortflag, const char* longflag,
                                    const char* metavar, const char* help) {
-  if (!options.reserve(options.length() + 1)) {
+  if (!options.reserve(options.length() + 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   StringOption* so = js_new<StringOption>(shortflag, longflag, help, metavar);
@@ -574,7 +574,7 @@ bool OptionParser::addStringOption(char 
 
 bool OptionParser::addMultiStringOption(char shortflag, const char* longflag,
                                         const char* metavar, const char* help) {
-  if (!options.reserve(options.length() + 1)) {
+  if (!options.reserve(options.length() + 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MultiStringOption* mso =
@@ -589,7 +589,7 @@ bool OptionParser::addMultiStringOption(
 /* Argument builders */
 
 bool OptionParser::addOptionalStringArg(const char* name, const char* help) {
-  if (!arguments.reserve(arguments.length() + 1)) {
+  if (!arguments.reserve(arguments.length() + 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   StringOption* so = js_new<StringOption>(1, name, help, (const char*)nullptr);
@@ -603,7 +603,7 @@ bool OptionParser::addOptionalStringArg(
 bool OptionParser::addOptionalMultiStringArg(const char* name,
                                              const char* help) {
   MOZ_ASSERT_IF(!arguments.empty(), !arguments.back()->isVariadic());
-  if (!arguments.reserve(arguments.length() + 1)) {
+  if (!arguments.reserve(arguments.length() + 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MultiStringOption* mso =
diff --git a/js/src/shell/jsshell.cpp b/js/src/shell/jsshell.cpp
--- a/js/src/shell/jsshell.cpp
+++ b/js/src/shell/jsshell.cpp
@@ -34,7 +34,7 @@ namespace shell {
 //
 bool GenerateInterfaceHelp(JSContext* cx, HandleObject obj, const char* name) {
   RootedIdVector idv(cx);
-  if (!GetPropertyKeys(cx, obj, JSITER_OWNONLY | JSITER_HIDDEN, &idv)) {
+  if (!GetPropertyKeys(cx, obj, JSITER_OWNONLY | JSITER_HIDDEN, &idv)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -43,54 +43,54 @@ bool GenerateInterfaceHelp(JSContext* cx
   for (size_t i = 0; i < idv.length(); i++) {
     RootedId id(cx, idv[i]);
     RootedValue v(cx);
-    if (!JS_GetPropertyById(cx, obj, id, &v)) {
+    if (!JS_GetPropertyById(cx, obj, id, &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!v.isObject()) {
+    if (!v.isObject()) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
     RootedObject prop(cx, &v.toObject());
 
     RootedValue usage(cx);
     RootedValue help(cx);
-    if (!JS_GetProperty(cx, prop, "usage", &usage)) {
+    if (!JS_GetProperty(cx, prop, "usage", &usage)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!JS_GetProperty(cx, prop, "help", &help)) {
+    if (!JS_GetProperty(cx, prop, "help", &help)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!usage.isString() && !help.isString()) {
+    if (!usage.isString() && !help.isString()) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
-    if (numEntries && !buf.append("\n")) {
+    if (numEntries && !buf.append("\n")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     numEntries++;
 
-    if (!buf.append("  ", 2)) {
+    if (!buf.append("  ", 2)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!buf.append(usage.isString() ? usage.toString() : JSID_TO_STRING(id))) {
+    if (!buf.append(usage.isString() ? usage.toString() : JSID_TO_STRING(id))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   RootedString s(cx, buf.finishString());
-  if (!s || !JS_DefineProperty(cx, obj, "help", s, 0)) {
+  if (!s || !JS_DefineProperty(cx, obj, "help", s, 0)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   buf.clear();
   if (!buf.append(name, strlen(name)) ||
-      !buf.append(" - interface object with ", 25)) {
+      !buf.append(" - interface object with ", 25)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   char cbuf[100];
   SprintfLiteral(cbuf, "%d %s", numEntries,
                  numEntries == 1 ? "entry" : "entries");
-  if (!buf.append(cbuf, strlen(cbuf))) {
+  if (!buf.append(cbuf, strlen(cbuf))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   s = buf.finishString();
@@ -106,11 +106,11 @@ bool CreateAlias(JSContext* cx, const ch
   RootedObject global(cx, JS::GetNonCCWObjectGlobal(namespaceObj));
 
   RootedValue val(cx);
-  if (!JS_GetProperty(cx, namespaceObj, srcName, &val)) {
+  if (!JS_GetProperty(cx, namespaceObj, srcName, &val)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!val.isObject()) {
+  if (!val.isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "attempted to alias nonexistent function");
     return false;
   }
diff --git a/js/src/threading/posix/PosixThread.cpp b/js/src/threading/posix/PosixThread.cpp
--- a/js/src/threading/posix/PosixThread.cpp
+++ b/js/src/threading/posix/PosixThread.cpp
@@ -42,7 +42,7 @@ bool ThreadId::operator==(const ThreadId
 bool Thread::create(void* (*aMain)(void*), void* aArg) {
   MOZ_RELEASE_ASSERT(!joinable());
 
-  if (oom::ShouldFailWithOOM()) {
+  if (oom::ShouldFailWithOOM()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -121,7 +121,7 @@ void ThisThread::SetName(const char* nam
   MOZ_RELEASE_ASSERT(!rv);
 }
 
-void ThisThread::GetName(char* nameBuffer, size_t len) {
+void ThisThread::GetName(char* nameBuffer, size_t len) {MOZ_RELEASE_ASSERT(0);
   MOZ_RELEASE_ASSERT(len >= 16);
 
   int rv = -1;
diff --git a/js/src/threading/windows/WindowsThread.cpp b/js/src/threading/windows/WindowsThread.cpp
--- a/js/src/threading/windows/WindowsThread.cpp
+++ b/js/src/threading/windows/WindowsThread.cpp
@@ -38,7 +38,7 @@ bool ThreadId::operator==(const ThreadId
 bool Thread::create(unsigned int(__stdcall* aMain)(void*), void* aArg) {
   MOZ_RELEASE_ASSERT(!joinable());
 
-  if (oom::ShouldFailWithOOM()) {
+  if (oom::ShouldFailWithOOM()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/util/CompleteFile.cpp b/js/src/util/CompleteFile.cpp
--- a/js/src/util/CompleteFile.cpp
+++ b/js/src/util/CompleteFile.cpp
@@ -18,20 +18,20 @@ bool js::ReadCompleteFile(JSContext* cx,
   /* Get the complete length of the file, if possible. */
   struct stat st;
   int ok = fstat(fileno(fp), &st);
-  if (ok != 0) {
+  if (ok != 0) {MOZ_RELEASE_ASSERT(0);
     // Use the Latin1 variant here (and below), because the encoding of
     // strerror() is platform-dependent.
     JS_ReportErrorLatin1(cx, "error reading file: %s", strerror(errno));
     errno = 0;
     return false;
   }
-  if ((st.st_mode & S_IFDIR) != 0) {
+  if ((st.st_mode & S_IFDIR) != 0) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorLatin1(cx, "error reading file: %s", strerror(EISDIR));
     return false;
   }
 
   if (st.st_size > 0) {
-    if (!buffer.reserve(st.st_size)) {
+    if (!buffer.reserve(st.st_size)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -56,7 +56,7 @@ bool js::ReadCompleteFile(JSContext* cx,
     if (c == EOF) {
       break;
     }
-    if (!buffer.append(c)) {
+    if (!buffer.append(c)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -76,7 +76,7 @@ bool js::ReadCompleteFile(JSContext* cx,
  * return value must be fclosed unless it is stdin.
  */
 bool js::AutoFile::open(JSContext* cx, const char* filename) {
-  if (!filename || std::strcmp(filename, "-") == 0) {
+  if (!filename || std::strcmp(filename, "-") == 0) {MOZ_RELEASE_ASSERT(0);
     fp_ = stdin;
   } else {
     fp_ = fopen(filename, "r");
diff --git a/js/src/util/DoubleToString.cpp b/js/src/util/DoubleToString.cpp
--- a/js/src/util/DoubleToString.cpp
+++ b/js/src/util/DoubleToString.cpp
@@ -188,7 +188,7 @@ char* js_dtobasestr(DtoaState* state, in
     Bigint* b = d2b(PASS_STATE di, &e, &bits);
     if (!b) goto nomem1;
     b = lshift(PASS_STATE b, e);
-    if (!b) {
+    if (!b) {MOZ_RELEASE_ASSERT(0);
     nomem1:
       Bfree(PASS_STATE b);
       js_free(buffer);
@@ -221,7 +221,7 @@ char* js_dtobasestr(DtoaState* state, in
 
     *p++ = '.';
     b = d2b(PASS_STATE df, &e, &bbits);
-    if (!b) {
+    if (!b) {MOZ_RELEASE_ASSERT(0);
     nomem2:
       Bfree(PASS_STATE b);
       Bfree(PASS_STATE s);
@@ -229,7 +229,7 @@ char* js_dtobasestr(DtoaState* state, in
       Bfree(PASS_STATE mhi);
       js_free(buffer);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(e < 0);
     /* At this point df = b * 2^e.  e must be less than zero because 0 < df < 1.
      */
@@ -248,7 +248,7 @@ char* js_dtobasestr(DtoaState* state, in
 #ifndef Sudden_Underflow
         && word0(d) & (Exp_mask & Exp_mask << 1)
 #endif
-    ) {
+    ) {MOZ_RELEASE_ASSERT(0);
       /* The special case.  Here we want to be within a quarter of the last
          input significant digit instead of one half of it when the output
          string's value is less than d.  */
@@ -279,7 +279,7 @@ char* js_dtobasestr(DtoaState* state, in
       if (mlo == mhi) {
         mlo = mhi = multadd(PASS_STATE mlo, base, 0);
         if (!mhi) goto nomem2;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         mlo = multadd(PASS_STATE mlo, base, 0);
         if (!mlo) goto nomem2;
         mhi = multadd(PASS_STATE mhi, base, 0);
diff --git a/js/src/util/DumpFunctions.cpp b/js/src/util/DumpFunctions.cpp
--- a/js/src/util/DumpFunctions.cpp
+++ b/js/src/util/DumpFunctions.cpp
@@ -118,7 +118,7 @@ void js::DumpChars(const char16_t* s, si
 #endif
 }
 
-void js::DumpObject(JSObject* obj, GenericPrinter& out) {
+void js::DumpObject(JSObject* obj, GenericPrinter& out) {MOZ_RELEASE_ASSERT(0);
 #if defined(DEBUG) || defined(JS_JITSPEW)
   if (!obj) {
     out.printf("NULL\n");
@@ -211,7 +211,7 @@ static const char* FormatValue(JSContext
     return "[function]";
   }
 
-  if (v.isObject() && js::IsCrossCompartmentWrapper(&v.toObject())) {
+  if (v.isObject() && js::IsCrossCompartmentWrapper(&v.toObject())) {MOZ_RELEASE_ASSERT(0);
     return "[cross-compartment wrapper]";
   }
 
@@ -255,7 +255,7 @@ static bool FormatFrame(JSContext* cx, c
   if (iter.hasUsableAbstractFramePtr() && iter.isFunctionFrame() && fun &&
       !fun->isArrow() && !fun->isDerivedClassConstructor() &&
       !(fun->isBoundFunction() && iter.isConstructing())) {
-    if (!GetFunctionThis(cx, iter.abstractFramePtr(), &thisVal)) {
+    if (!GetFunctionThis(cx, iter.abstractFramePtr(), &thisVal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -263,18 +263,18 @@ static bool FormatFrame(JSContext* cx, c
   // print the frame number and function name
   if (funname) {
     UniqueChars funbytes = js::QuoteString(cx, funname);
-    if (!funbytes) {
+    if (!funbytes) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!sp.printf("%d %s(", num, funbytes.get())) {
+    if (!sp.printf("%d %s(", num, funbytes.get())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else if (fun) {
-    if (!sp.printf("%d anonymous(", num)) {
+    if (!sp.printf("%d anonymous(", num)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
-    if (!sp.printf("%d <TOP LEVEL>", num)) {
+    if (!sp.printf("%d <TOP LEVEL>", num)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -304,9 +304,9 @@ static bool FormatFrame(JSContext* cx, c
       UniqueChars valueBytes;
       const char* value = FormatValue(cx, arg, valueBytes);
       if (!value) {
-        if (cx->isThrowingOutOfMemory()) {
+        if (cx->isThrowingOutOfMemory()) {MOZ_RELEASE_ASSERT(0);
           return false;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         cx->clearPendingException();
       }
 
@@ -318,7 +318,7 @@ static bool FormatFrame(JSContext* cx, c
         if (!fi.isDestructured()) {
           nameBytes = StringToNewUTF8CharsZ(cx, *fi.name());
           name = nameBytes.get();
-          if (!name) {
+          if (!name) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         } else {
@@ -330,14 +330,14 @@ static bool FormatFrame(JSContext* cx, c
       if (value) {
         if (!sp.printf("%s%s%s%s%s%s", !first ? ", " : "", name ? name : "",
                        name ? " = " : "", arg.isString() ? "\"" : "", value,
-                       arg.isString() ? "\"" : "")) {
+                       arg.isString() ? "\"" : "")) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         first = false;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         if (!sp.put("    <Failed to get argument while inspecting stack "
-                    "frame>\n")) {
+                    "frame>\n")) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -346,7 +346,7 @@ static bool FormatFrame(JSContext* cx, c
 
   // print filename, line number and column
   if (!sp.printf("%s [\"%s\":%u:%u]\n", fun ? ")" : "",
-                 filename ? filename : "<unknown>", lineno, column)) {
+                 filename ? filename : "<unknown>", lineno, column)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -358,21 +358,21 @@ static bool FormatFrame(JSContext* cx, c
     if (!thisVal.isUndefined()) {
       Rooted<JSString*> thisValStr(cx, ToString<CanGC>(cx, thisVal));
       if (!thisValStr) {
-        if (cx->isThrowingOutOfMemory()) {
+        if (cx->isThrowingOutOfMemory()) {MOZ_RELEASE_ASSERT(0);
           return false;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         cx->clearPendingException();
       }
       if (thisValStr) {
         UniqueChars thisValBytes = QuoteString(cx, thisValStr);
-        if (!thisValBytes) {
+        if (!thisValBytes) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
-        if (!sp.printf("    this = %s\n", thisValBytes.get())) {
+        if (!sp.printf("    this = %s\n", thisValBytes.get())) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
-        if (!sp.put("    <failed to get 'this' value>\n")) {
+        if (!sp.put("    <failed to get 'this' value>\n")) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -384,9 +384,9 @@ static bool FormatFrame(JSContext* cx, c
 
     RootedVector<JS::PropertyKey> keys(cx);
     if (!GetPropertyKeys(cx, obj, JSITER_OWNONLY, &keys)) {
-      if (cx->isThrowingOutOfMemory()) {
+      if (cx->isThrowingOutOfMemory()) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       cx->clearPendingException();
     }
 
@@ -396,41 +396,41 @@ static bool FormatFrame(JSContext* cx, c
       Rooted<Value> v(cx);
 
       if (!GetProperty(cx, obj, obj, id, &v)) {
-        if (cx->isThrowingOutOfMemory()) {
+        if (cx->isThrowingOutOfMemory()) {MOZ_RELEASE_ASSERT(0);
           return false;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         cx->clearPendingException();
         if (!sp.put("    <Failed to fetch property while inspecting stack "
-                    "frame>\n")) {
+                    "frame>\n")) {MOZ_RELEASE_ASSERT(0);
           return false;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         continue;
       }
 
       UniqueChars nameBytes;
       const char* name = FormatValue(cx, key, nameBytes);
       if (!name) {
-        if (cx->isThrowingOutOfMemory()) {
+        if (cx->isThrowingOutOfMemory()) {MOZ_RELEASE_ASSERT(0);
           return false;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         cx->clearPendingException();
       }
 
       UniqueChars valueBytes;
       const char* value = FormatValue(cx, v, valueBytes);
       if (!value) {
-        if (cx->isThrowingOutOfMemory()) {
+        if (cx->isThrowingOutOfMemory()) {MOZ_RELEASE_ASSERT(0);
           return false;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         cx->clearPendingException();
       }
 
       if (name && value) {
         if (!sp.printf("    this.%s = %s%s%s\n", name, v.isString() ? "\"" : "",
-                       value, v.isString() ? "\"" : "")) {
+                       value, v.isString() ? "\"" : "")) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         if (!sp.put("    <Failed to format values while inspecting stack "
                     "frame>\n")) {
           return false;
@@ -448,12 +448,12 @@ static bool FormatWasmFrame(JSContext* c
   UniqueChars nameStr;
   if (JSAtom* functionDisplayAtom = iter.maybeFunctionDisplayAtom()) {
     nameStr = StringToNewUTF8CharsZ(cx, *functionDisplayAtom);
-    if (!nameStr) {
+    if (!nameStr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!sp.printf("%d %s()", num, nameStr ? nameStr.get() : "<wasm-function>")) {
+  if (!sp.printf("%d %s()", num, nameStr ? nameStr.get() : "<wasm-function>")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -472,7 +472,7 @@ JS::UniqueChars JS::FormatStackDump(JSCo
   int num = 0;
 
   Sprinter sp(cx);
-  if (!sp.init()) {
+  if (!sp.init()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -480,7 +480,7 @@ JS::UniqueChars JS::FormatStackDump(JSCo
     bool ok = i.hasScript() ? FormatFrame(cx, i, sp, num, showArgs, showLocals,
                                           showThisProps)
                             : FormatWasmFrame(cx, i, sp, num);
-    if (!ok) {
+    if (!ok) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     num++;
@@ -575,7 +575,7 @@ static void DumpHeapVisitCell(JSRuntime*
 
   fprintf(dtrc->output, "%p %c %s", cellptr.asCell(),
           MarkDescriptor(cellptr.asCell()), cellDesc);
-  if (dtrc->mallocSizeOf) {
+  if (dtrc->mallocSizeOf) {MOZ_RELEASE_ASSERT(0);
     auto size = JS::ubi::Node(cellptr).size(dtrc->mallocSizeOf);
     fprintf(dtrc->output, " SIZE:: %" PRIu64 "\n", size);
   } else {
diff --git a/js/src/util/StringBuffer.cpp b/js/src/util/StringBuffer.cpp
--- a/js/src/util/StringBuffer.cpp
+++ b/js/src/util/StringBuffer.cpp
@@ -26,7 +26,7 @@ static CharT* ExtractWellSized(Buffer& c
   StringBufferAllocPolicy allocPolicy = cb.allocPolicy();
 
   CharT* buf = cb.extractOrCopyRawBuffer();
-  if (!buf) {
+  if (!buf) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -97,7 +97,7 @@ JSLinearString* StringBuffer::finishStri
   UniquePtr<CharT[], JS::FreePolicy> buf(
       ExtractWellSized<CharT>(chars<CharT>()));
 
-  if (!buf) {
+  if (!buf) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -130,7 +130,7 @@ JSLinearString* JSStringBuilder::finishS
 
 JSAtom* StringBuffer::finishAtom() {
   size_t len = length();
-  if (len == 0) {
+  if (len == 0) {MOZ_RELEASE_ASSERT(0);
     return cx_->names().empty;
   }
 
@@ -148,7 +148,7 @@ JSAtom* StringBuffer::finishAtom() {
 frontend::TaggedParserAtomIndex StringBuffer::finishParserAtom(
     frontend::ParserAtomsTable& parserAtoms) {
   size_t len = length();
-  if (len == 0) {
+  if (len == 0) {MOZ_RELEASE_ASSERT(0);
     return frontend::TaggedParserAtomIndex::WellKnown::empty();
   }
 
@@ -179,7 +179,7 @@ bool js::ValueToStringBufferSlow(JSConte
   if (v.isBoolean()) {
     return BooleanToStringBuffer(v.toBoolean(), sb);
   }
-  if (v.isNull()) {
+  if (v.isNull()) {MOZ_RELEASE_ASSERT(0);
     return sb.append(cx->names().null);
   }
   if (v.isSymbol()) {
diff --git a/js/src/util/StructuredSpewer.cpp b/js/src/util/StructuredSpewer.cpp
--- a/js/src/util/StructuredSpewer.cpp
+++ b/js/src/util/StructuredSpewer.cpp
@@ -37,13 +37,13 @@ const StructuredSpewer::NameArray Struct
 #    endif
 #  endif
 
-bool StructuredSpewer::ensureInitializationAttempted() {
-  if (!outputInitializationAttempted_) {
+bool StructuredSpewer::ensureInitializationAttempted() {MOZ_RELEASE_ASSERT(0);
+  if (!outputInitializationAttempted_) {MOZ_RELEASE_ASSERT(0);
     char filename[2048] = {0};
     // For ease of use with Treeherder
-    if (getenv("SPEW_UPLOAD") && getenv("MOZ_UPLOAD_DIR")) {
+    if (getenv("SPEW_UPLOAD") && getenv("MOZ_UPLOAD_DIR")) {MOZ_RELEASE_ASSERT(0);
       SprintfLiteral(filename, "%s/spew_output", getenv("MOZ_UPLOAD_DIR"));
-    } else if (getenv("SPEW_FILE")) {
+    } else if (getenv("SPEW_FILE")) {MOZ_RELEASE_ASSERT(0);
       SprintfLiteral(filename, "%s", getenv("SPEW_FILE"));
     } else {
       SprintfLiteral(filename, "%s/spew_output", DEFAULT_SPEW_DIRECTORY);
@@ -58,7 +58,7 @@ bool StructuredSpewer::ensureInitializat
   return json_.isSome();
 }
 
-void StructuredSpewer::tryToInitializeOutput(const char* path) {
+void StructuredSpewer::tryToInitializeOutput(const char* path) {MOZ_RELEASE_ASSERT(0);
   static mozilla::Atomic<uint32_t, mozilla::ReleaseAcquire> threadCounter;
 
   char suffix_path[2048] = {0};
@@ -81,7 +81,7 @@ void StructuredSpewer::tryToInitializeOu
 // in the script's name or filename or line number.
 //
 // This is the most basic matching I can imagine
-static bool MatchJSScript(JSScript* script, const char* pattern) {
+static bool MatchJSScript(JSScript* script, const char* pattern) {MOZ_RELEASE_ASSERT(0);
   if (!pattern) {
     return false;
   }
@@ -120,7 +120,7 @@ bool StructuredSpewer::enabled(JSContext
 //
 // Returns true if the spewer is prepared for more input
 void StructuredSpewer::startObject(JSContext* cx, const JSScript* script,
-                                   SpewChannel channel) {
+                                   SpewChannel channel) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(json_.isSome());
 
   JSONPrinter& json = json_.ref();
@@ -141,7 +141,7 @@ void StructuredSpewer::spew(JSContext* c
                             ...) {
   // Because we don't have a script here, use the singleton's
   // filter to determine if the channel is active.
-  if (!cx->spewer().enabled(channel)) {
+  if (!cx->spewer().enabled(channel)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -165,20 +165,20 @@ void StructuredSpewer::spew(JSContext* c
 }
 
 // Currently uses the exact spew flag representation as text.
-void StructuredSpewer::parseSpewFlags(const char* flags) {
+void StructuredSpewer::parseSpewFlags(const char* flags) {MOZ_RELEASE_ASSERT(0);
 #  define CHECK_CHANNEL(name)                            \
     if (ContainsFlag(flags, #name)) {                    \
       selectedChannel_.enableChannel(SpewChannel::name); \
       break;                                             \
     }
 
-  do {
+  do {MOZ_RELEASE_ASSERT(0);
     STRUCTURED_CHANNEL_LIST(CHECK_CHANNEL)
   } while (false);
 
 #  undef CHECK_CHANNEL
 
-  if (ContainsFlag(flags, "AtStartup")) {
+  if (ContainsFlag(flags, "AtStartup")) {MOZ_RELEASE_ASSERT(0);
     enableSpewing();
   }
 
@@ -231,8 +231,8 @@ void StructuredSpewer::parseSpewFlags(co
 
 AutoStructuredSpewer::AutoStructuredSpewer(JSContext* cx, SpewChannel channel,
                                            JSScript* script)
-    : printer_(mozilla::Nothing()) {
-  if (!cx->spewer().enabled(cx, script, channel)) {
+    : printer_(mozilla::Nothing()) {MOZ_RELEASE_ASSERT(0);
+  if (!cx->spewer().enabled(cx, script, channel)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -246,13 +246,13 @@ AutoStructuredSpewer::AutoStructuredSpew
 
 AutoSpewChannel::AutoSpewChannel(JSContext* cx, SpewChannel channel,
                                  JSScript* script)
-    : cx_(cx) {
+    : cx_(cx) {MOZ_RELEASE_ASSERT(0);
   if (!cx->spewer().enabled(cx, script, channel)) {
     wasChannelAutoSet = cx->spewer().selectedChannel_.enableChannel(channel);
   }
 }
 
-AutoSpewChannel::~AutoSpewChannel() {
+AutoSpewChannel::~AutoSpewChannel() {MOZ_RELEASE_ASSERT(0);
   if (wasChannelAutoSet) {
     cx_->spewer().selectedChannel_.disableAllChannels();
   }
diff --git a/js/src/util/Text.cpp b/js/src/util/Text.cpp
--- a/js/src/util/Text.cpp
+++ b/js/src/util/Text.cpp
@@ -47,8 +47,8 @@ template const Latin1Char* js_strchr_lim
 template const char16_t* js_strchr_limit(const char16_t* s, char16_t c,
                                          const char16_t* limit);
 
-int32_t js_fputs(const char16_t* s, FILE* f) {
-  while (*s != 0) {
+int32_t js_fputs(const char16_t* s, FILE* f) {MOZ_RELEASE_ASSERT(0);
+  while (*s != 0) {MOZ_RELEASE_ASSERT(0);
     if (fputwc(wchar_t(*s), f) == WEOF) {
       return WEOF;
     }
@@ -76,7 +76,7 @@ UniqueChars js::DuplicateStringToArena(a
 UniqueLatin1Chars js::DuplicateStringToArena(arena_id_t destArenaId,
                                              JSContext* cx,
                                              const JS::Latin1Char* s,
-                                             size_t n) {
+                                             size_t n) {MOZ_RELEASE_ASSERT(0);
   auto ret = cx->make_pod_arena_array<Latin1Char>(destArenaId, n + 1);
   if (!ret) {
     return nullptr;
@@ -121,7 +121,7 @@ UniqueChars js::DuplicateStringToArena(a
 
 UniqueLatin1Chars js::DuplicateStringToArena(arena_id_t destArenaId,
                                              const JS::Latin1Char* s,
-                                             size_t n) {
+                                             size_t n) {MOZ_RELEASE_ASSERT(0);
   UniqueLatin1Chars ret(
       js_pod_arena_malloc<JS::Latin1Char>(destArenaId, n + 1));
   if (!ret) {
@@ -351,9 +351,9 @@ size_t js::PutEscapedStringImpl(char* bu
         buffer = nullptr;
       }
     } else if (out) {
-      if (!out->put(&c, 1)) {
+      if (!out->put(&c, 1)) {MOZ_RELEASE_ASSERT(0);
         return size_t(-1);
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
     n++;
   }
@@ -364,10 +364,10 @@ stop:
   return n;
 }
 
-bool js::ContainsFlag(const char* str, const char* flag) {
+bool js::ContainsFlag(const char* str, const char* flag) {MOZ_RELEASE_ASSERT(0);
   size_t flaglen = strlen(flag);
   const char* index = strstr(str, flag);
-  while (index) {
+  while (index) {MOZ_RELEASE_ASSERT(0);
     if ((index == str || index[-1] == ',') &&
         (index[flaglen] == 0 || index[flaglen] == ',')) {
       return true;
diff --git a/js/src/util/Unicode.cpp b/js/src/util/Unicode.cpp
--- a/js/src/util/Unicode.cpp
+++ b/js/src/util/Unicode.cpp
@@ -1266,505 +1266,505 @@ const uint8_t unicode::folding_index2[] 
 bool
 js::unicode::IsIdentifierStartNonBMP(uint32_t codePoint)
 {
-    if (codePoint >= 0x10000 && codePoint <= 0x1000B) { // LINEAR B SYLLABLE B008 A .. LINEAR B SYLLABLE B046 JE
-        return true;
-    }
-    if (codePoint >= 0x1000D && codePoint <= 0x10026) { // LINEAR B SYLLABLE B036 JO .. LINEAR B SYLLABLE B032 QO
-        return true;
-    }
-    if (codePoint >= 0x10028 && codePoint <= 0x1003A) { // LINEAR B SYLLABLE B060 RA .. LINEAR B SYLLABLE B042 WO
-        return true;
-    }
-    if (codePoint >= 0x1003C && codePoint <= 0x1003D) { // LINEAR B SYLLABLE B017 ZA .. LINEAR B SYLLABLE B074 ZE
-        return true;
-    }
-    if (codePoint >= 0x1003F && codePoint <= 0x1004D) { // LINEAR B SYLLABLE B020 ZO .. LINEAR B SYLLABLE B091 TWO
-        return true;
-    }
-    if (codePoint >= 0x10050 && codePoint <= 0x1005D) { // LINEAR B SYMBOL B018 .. LINEAR B SYMBOL B089
-        return true;
-    }
-    if (codePoint >= 0x10080 && codePoint <= 0x100FA) { // LINEAR B IDEOGRAM B100 MAN .. LINEAR B IDEOGRAM VESSEL B305
+    if (codePoint >= 0x10000 && codePoint <= 0x1000B) {MOZ_RELEASE_ASSERT(0); // LINEAR B SYLLABLE B008 A .. LINEAR B SYLLABLE B046 JE
+        return true;
+    }
+    if (codePoint >= 0x1000D && codePoint <= 0x10026) {MOZ_RELEASE_ASSERT(0); // LINEAR B SYLLABLE B036 JO .. LINEAR B SYLLABLE B032 QO
+        return true;
+    }
+    if (codePoint >= 0x10028 && codePoint <= 0x1003A) {MOZ_RELEASE_ASSERT(0); // LINEAR B SYLLABLE B060 RA .. LINEAR B SYLLABLE B042 WO
+        return true;
+    }
+    if (codePoint >= 0x1003C && codePoint <= 0x1003D) {MOZ_RELEASE_ASSERT(0); // LINEAR B SYLLABLE B017 ZA .. LINEAR B SYLLABLE B074 ZE
+        return true;
+    }
+    if (codePoint >= 0x1003F && codePoint <= 0x1004D) {MOZ_RELEASE_ASSERT(0); // LINEAR B SYLLABLE B020 ZO .. LINEAR B SYLLABLE B091 TWO
+        return true;
+    }
+    if (codePoint >= 0x10050 && codePoint <= 0x1005D) {MOZ_RELEASE_ASSERT(0); // LINEAR B SYMBOL B018 .. LINEAR B SYMBOL B089
+        return true;
+    }
+    if (codePoint >= 0x10080 && codePoint <= 0x100FA) {MOZ_RELEASE_ASSERT(0); // LINEAR B IDEOGRAM B100 MAN .. LINEAR B IDEOGRAM VESSEL B305
         return true;
     }
     if (codePoint >= 0x10140 && codePoint <= 0x10174) { // GREEK ACROPHONIC ATTIC ONE QUARTER .. GREEK ACROPHONIC STRATIAN FIFTY MNAS
         return true;
     }
-    if (codePoint >= 0x10280 && codePoint <= 0x1029C) { // LYCIAN LETTER A .. LYCIAN LETTER X
-        return true;
-    }
-    if (codePoint >= 0x102A0 && codePoint <= 0x102D0) { // CARIAN LETTER A .. CARIAN LETTER UUU3
+    if (codePoint >= 0x10280 && codePoint <= 0x1029C) {MOZ_RELEASE_ASSERT(0); // LYCIAN LETTER A .. LYCIAN LETTER X
+        return true;
+    }
+    if (codePoint >= 0x102A0 && codePoint <= 0x102D0) {MOZ_RELEASE_ASSERT(0); // CARIAN LETTER A .. CARIAN LETTER UUU3
         return true;
     }
     if (codePoint >= 0x10300 && codePoint <= 0x1031F) { // OLD ITALIC LETTER A .. OLD ITALIC LETTER ESS
         return true;
     }
-    if (codePoint >= 0x1032D && codePoint <= 0x1034A) { // OLD ITALIC LETTER YE .. GOTHIC LETTER NINE HUNDRED
-        return true;
-    }
-    if (codePoint >= 0x10350 && codePoint <= 0x10375) { // OLD PERMIC LETTER AN .. OLD PERMIC LETTER IA
-        return true;
-    }
-    if (codePoint >= 0x10380 && codePoint <= 0x1039D) { // UGARITIC LETTER ALPA .. UGARITIC LETTER SSU
-        return true;
-    }
-    if (codePoint >= 0x103A0 && codePoint <= 0x103C3) { // OLD PERSIAN SIGN A .. OLD PERSIAN SIGN HA
-        return true;
-    }
-    if (codePoint >= 0x103C8 && codePoint <= 0x103CF) { // OLD PERSIAN SIGN AURAMAZDAA .. OLD PERSIAN SIGN BUUMISH
-        return true;
-    }
-    if (codePoint >= 0x103D1 && codePoint <= 0x103D5) { // OLD PERSIAN NUMBER ONE .. OLD PERSIAN NUMBER HUNDRED
+    if (codePoint >= 0x1032D && codePoint <= 0x1034A) {MOZ_RELEASE_ASSERT(0); // OLD ITALIC LETTER YE .. GOTHIC LETTER NINE HUNDRED
+        return true;
+    }
+    if (codePoint >= 0x10350 && codePoint <= 0x10375) {MOZ_RELEASE_ASSERT(0); // OLD PERMIC LETTER AN .. OLD PERMIC LETTER IA
+        return true;
+    }
+    if (codePoint >= 0x10380 && codePoint <= 0x1039D) {MOZ_RELEASE_ASSERT(0); // UGARITIC LETTER ALPA .. UGARITIC LETTER SSU
+        return true;
+    }
+    if (codePoint >= 0x103A0 && codePoint <= 0x103C3) {MOZ_RELEASE_ASSERT(0); // OLD PERSIAN SIGN A .. OLD PERSIAN SIGN HA
+        return true;
+    }
+    if (codePoint >= 0x103C8 && codePoint <= 0x103CF) {MOZ_RELEASE_ASSERT(0); // OLD PERSIAN SIGN AURAMAZDAA .. OLD PERSIAN SIGN BUUMISH
+        return true;
+    }
+    if (codePoint >= 0x103D1 && codePoint <= 0x103D5) {MOZ_RELEASE_ASSERT(0); // OLD PERSIAN NUMBER ONE .. OLD PERSIAN NUMBER HUNDRED
         return true;
     }
     if (codePoint >= 0x10400 && codePoint <= 0x1049D) { // DESERET CAPITAL LETTER LONG I .. OSMANYA LETTER OO
         return true;
     }
-    if (codePoint >= 0x104B0 && codePoint <= 0x104D3) { // OSAGE CAPITAL LETTER A .. OSAGE CAPITAL LETTER ZHA
-        return true;
-    }
-    if (codePoint >= 0x104D8 && codePoint <= 0x104FB) { // OSAGE SMALL LETTER A .. OSAGE SMALL LETTER ZHA
-        return true;
-    }
-    if (codePoint >= 0x10500 && codePoint <= 0x10527) { // ELBASAN LETTER A .. ELBASAN LETTER KHE
-        return true;
-    }
-    if (codePoint >= 0x10530 && codePoint <= 0x10563) { // CAUCASIAN ALBANIAN LETTER ALT .. CAUCASIAN ALBANIAN LETTER KIW
-        return true;
-    }
-    if (codePoint >= 0x10600 && codePoint <= 0x10736) { // LINEAR A SIGN AB001 .. LINEAR A SIGN A664
-        return true;
-    }
-    if (codePoint >= 0x10740 && codePoint <= 0x10755) { // LINEAR A SIGN A701 A .. LINEAR A SIGN A732 JE
-        return true;
-    }
-    if (codePoint >= 0x10760 && codePoint <= 0x10767) { // LINEAR A SIGN A800 .. LINEAR A SIGN A807
-        return true;
-    }
-    if (codePoint >= 0x10800 && codePoint <= 0x10805) { // CYPRIOT SYLLABLE A .. CYPRIOT SYLLABLE JA
-        return true;
-    }
-    if (codePoint >= 0x10808 && codePoint <= 0x10808) { // CYPRIOT SYLLABLE JO .. CYPRIOT SYLLABLE JO
-        return true;
-    }
-    if (codePoint >= 0x1080A && codePoint <= 0x10835) { // CYPRIOT SYLLABLE KA .. CYPRIOT SYLLABLE WO
-        return true;
-    }
-    if (codePoint >= 0x10837 && codePoint <= 0x10838) { // CYPRIOT SYLLABLE XA .. CYPRIOT SYLLABLE XE
-        return true;
-    }
-    if (codePoint >= 0x1083C && codePoint <= 0x1083C) { // CYPRIOT SYLLABLE ZA .. CYPRIOT SYLLABLE ZA
-        return true;
-    }
-    if (codePoint >= 0x1083F && codePoint <= 0x10855) { // CYPRIOT SYLLABLE ZO .. IMPERIAL ARAMAIC LETTER TAW
-        return true;
-    }
-    if (codePoint >= 0x10860 && codePoint <= 0x10876) { // PALMYRENE LETTER ALEPH .. PALMYRENE LETTER TAW
-        return true;
-    }
-    if (codePoint >= 0x10880 && codePoint <= 0x1089E) { // NABATAEAN LETTER FINAL ALEPH .. NABATAEAN LETTER TAW
-        return true;
-    }
-    if (codePoint >= 0x108E0 && codePoint <= 0x108F2) { // HATRAN LETTER ALEPH .. HATRAN LETTER QOPH
-        return true;
-    }
-    if (codePoint >= 0x108F4 && codePoint <= 0x108F5) { // HATRAN LETTER SHIN .. HATRAN LETTER TAW
-        return true;
-    }
-    if (codePoint >= 0x10900 && codePoint <= 0x10915) { // PHOENICIAN LETTER ALF .. PHOENICIAN LETTER TAU
-        return true;
-    }
-    if (codePoint >= 0x10920 && codePoint <= 0x10939) { // LYDIAN LETTER A .. LYDIAN LETTER C
-        return true;
-    }
-    if (codePoint >= 0x10980 && codePoint <= 0x109B7) { // MEROITIC HIEROGLYPHIC LETTER A .. MEROITIC CURSIVE LETTER DA
-        return true;
-    }
-    if (codePoint >= 0x109BE && codePoint <= 0x109BF) { // MEROITIC CURSIVE LOGOGRAM RMT .. MEROITIC CURSIVE LOGOGRAM IMN
-        return true;
-    }
-    if (codePoint >= 0x10A00 && codePoint <= 0x10A00) { // KHAROSHTHI LETTER A .. KHAROSHTHI LETTER A
-        return true;
-    }
-    if (codePoint >= 0x10A10 && codePoint <= 0x10A13) { // KHAROSHTHI LETTER KA .. KHAROSHTHI LETTER GHA
-        return true;
-    }
-    if (codePoint >= 0x10A15 && codePoint <= 0x10A17) { // KHAROSHTHI LETTER CA .. KHAROSHTHI LETTER JA
-        return true;
-    }
-    if (codePoint >= 0x10A19 && codePoint <= 0x10A35) { // KHAROSHTHI LETTER NYA .. KHAROSHTHI LETTER VHA
-        return true;
-    }
-    if (codePoint >= 0x10A60 && codePoint <= 0x10A7C) { // OLD SOUTH ARABIAN LETTER HE .. OLD SOUTH ARABIAN LETTER THETH
-        return true;
-    }
-    if (codePoint >= 0x10A80 && codePoint <= 0x10A9C) { // OLD NORTH ARABIAN LETTER HEH .. OLD NORTH ARABIAN LETTER ZAH
-        return true;
-    }
-    if (codePoint >= 0x10AC0 && codePoint <= 0x10AC7) { // MANICHAEAN LETTER ALEPH .. MANICHAEAN LETTER WAW
-        return true;
-    }
-    if (codePoint >= 0x10AC9 && codePoint <= 0x10AE4) { // MANICHAEAN LETTER ZAYIN .. MANICHAEAN LETTER TAW
-        return true;
-    }
-    if (codePoint >= 0x10B00 && codePoint <= 0x10B35) { // AVESTAN LETTER A .. AVESTAN LETTER HE
-        return true;
-    }
-    if (codePoint >= 0x10B40 && codePoint <= 0x10B55) { // INSCRIPTIONAL PARTHIAN LETTER ALEPH .. INSCRIPTIONAL PARTHIAN LETTER TAW
-        return true;
-    }
-    if (codePoint >= 0x10B60 && codePoint <= 0x10B72) { // INSCRIPTIONAL PAHLAVI LETTER ALEPH .. INSCRIPTIONAL PAHLAVI LETTER TAW
-        return true;
-    }
-    if (codePoint >= 0x10B80 && codePoint <= 0x10B91) { // PSALTER PAHLAVI LETTER ALEPH .. PSALTER PAHLAVI LETTER TAW
-        return true;
-    }
-    if (codePoint >= 0x10C00 && codePoint <= 0x10C48) { // OLD TURKIC LETTER ORKHON A .. OLD TURKIC LETTER ORKHON BASH
-        return true;
-    }
-    if (codePoint >= 0x10C80 && codePoint <= 0x10CB2) { // OLD HUNGARIAN CAPITAL LETTER A .. OLD HUNGARIAN CAPITAL LETTER US
-        return true;
-    }
-    if (codePoint >= 0x10CC0 && codePoint <= 0x10CF2) { // OLD HUNGARIAN SMALL LETTER A .. OLD HUNGARIAN SMALL LETTER US
-        return true;
-    }
-    if (codePoint >= 0x10D00 && codePoint <= 0x10D23) { // HANIFI ROHINGYA LETTER A .. HANIFI ROHINGYA MARK NA KHONNA
-        return true;
-    }
-    if (codePoint >= 0x10E80 && codePoint <= 0x10EA9) { // YEZIDI LETTER ELIF .. YEZIDI LETTER ET
-        return true;
-    }
-    if (codePoint >= 0x10EB0 && codePoint <= 0x10EB1) { // YEZIDI LETTER LAM WITH DOT ABOVE .. YEZIDI LETTER YOT WITH CIRCUMFLEX ABOVE
-        return true;
-    }
-    if (codePoint >= 0x10F00 && codePoint <= 0x10F1C) { // OLD SOGDIAN LETTER ALEPH .. OLD SOGDIAN LETTER FINAL TAW WITH VERTICAL TAIL
-        return true;
-    }
-    if (codePoint >= 0x10F27 && codePoint <= 0x10F27) { // OLD SOGDIAN LIGATURE AYIN-DALETH .. OLD SOGDIAN LIGATURE AYIN-DALETH
-        return true;
-    }
-    if (codePoint >= 0x10F30 && codePoint <= 0x10F45) { // SOGDIAN LETTER ALEPH .. SOGDIAN INDEPENDENT SHIN
-        return true;
-    }
-    if (codePoint >= 0x10FB0 && codePoint <= 0x10FC4) { // CHORASMIAN LETTER ALEPH .. CHORASMIAN LETTER TAW
-        return true;
-    }
-    if (codePoint >= 0x10FE0 && codePoint <= 0x10FF6) { // ELYMAIC LETTER ALEPH .. ELYMAIC LIGATURE ZAYIN-YODH
-        return true;
-    }
-    if (codePoint >= 0x11003 && codePoint <= 0x11037) { // BRAHMI SIGN JIHVAMULIYA .. BRAHMI LETTER OLD TAMIL NNNA
-        return true;
-    }
-    if (codePoint >= 0x11083 && codePoint <= 0x110AF) { // KAITHI LETTER A .. KAITHI LETTER HA
-        return true;
-    }
-    if (codePoint >= 0x110D0 && codePoint <= 0x110E8) { // SORA SOMPENG LETTER SAH .. SORA SOMPENG LETTER MAE
-        return true;
-    }
-    if (codePoint >= 0x11103 && codePoint <= 0x11126) { // CHAKMA LETTER AA .. CHAKMA LETTER HAA
-        return true;
-    }
-    if (codePoint >= 0x11144 && codePoint <= 0x11144) { // CHAKMA LETTER LHAA .. CHAKMA LETTER LHAA
-        return true;
-    }
-    if (codePoint >= 0x11147 && codePoint <= 0x11147) { // CHAKMA LETTER VAA .. CHAKMA LETTER VAA
-        return true;
-    }
-    if (codePoint >= 0x11150 && codePoint <= 0x11172) { // MAHAJANI LETTER A .. MAHAJANI LETTER RRA
-        return true;
-    }
-    if (codePoint >= 0x11176 && codePoint <= 0x11176) { // MAHAJANI LIGATURE SHRI .. MAHAJANI LIGATURE SHRI
-        return true;
-    }
-    if (codePoint >= 0x11183 && codePoint <= 0x111B2) { // SHARADA LETTER A .. SHARADA LETTER HA
-        return true;
-    }
-    if (codePoint >= 0x111C1 && codePoint <= 0x111C4) { // SHARADA SIGN AVAGRAHA .. SHARADA OM
-        return true;
-    }
-    if (codePoint >= 0x111DA && codePoint <= 0x111DA) { // SHARADA EKAM .. SHARADA EKAM
-        return true;
-    }
-    if (codePoint >= 0x111DC && codePoint <= 0x111DC) { // SHARADA HEADSTROKE .. SHARADA HEADSTROKE
-        return true;
-    }
-    if (codePoint >= 0x11200 && codePoint <= 0x11211) { // KHOJKI LETTER A .. KHOJKI LETTER JJA
-        return true;
-    }
-    if (codePoint >= 0x11213 && codePoint <= 0x1122B) { // KHOJKI LETTER NYA .. KHOJKI LETTER LLA
-        return true;
-    }
-    if (codePoint >= 0x11280 && codePoint <= 0x11286) { // MULTANI LETTER A .. MULTANI LETTER GA
-        return true;
-    }
-    if (codePoint >= 0x11288 && codePoint <= 0x11288) { // MULTANI LETTER GHA .. MULTANI LETTER GHA
-        return true;
-    }
-    if (codePoint >= 0x1128A && codePoint <= 0x1128D) { // MULTANI LETTER CA .. MULTANI LETTER JJA
-        return true;
-    }
-    if (codePoint >= 0x1128F && codePoint <= 0x1129D) { // MULTANI LETTER NYA .. MULTANI LETTER BA
-        return true;
-    }
-    if (codePoint >= 0x1129F && codePoint <= 0x112A8) { // MULTANI LETTER BHA .. MULTANI LETTER RHA
-        return true;
-    }
-    if (codePoint >= 0x112B0 && codePoint <= 0x112DE) { // KHUDAWADI LETTER A .. KHUDAWADI LETTER HA
-        return true;
-    }
-    if (codePoint >= 0x11305 && codePoint <= 0x1130C) { // GRANTHA LETTER A .. GRANTHA LETTER VOCALIC L
-        return true;
-    }
-    if (codePoint >= 0x1130F && codePoint <= 0x11310) { // GRANTHA LETTER EE .. GRANTHA LETTER AI
-        return true;
-    }
-    if (codePoint >= 0x11313 && codePoint <= 0x11328) { // GRANTHA LETTER OO .. GRANTHA LETTER NA
-        return true;
-    }
-    if (codePoint >= 0x1132A && codePoint <= 0x11330) { // GRANTHA LETTER PA .. GRANTHA LETTER RA
-        return true;
-    }
-    if (codePoint >= 0x11332 && codePoint <= 0x11333) { // GRANTHA LETTER LA .. GRANTHA LETTER LLA
-        return true;
-    }
-    if (codePoint >= 0x11335 && codePoint <= 0x11339) { // GRANTHA LETTER VA .. GRANTHA LETTER HA
-        return true;
-    }
-    if (codePoint >= 0x1133D && codePoint <= 0x1133D) { // GRANTHA SIGN AVAGRAHA .. GRANTHA SIGN AVAGRAHA
-        return true;
-    }
-    if (codePoint >= 0x11350 && codePoint <= 0x11350) { // GRANTHA OM .. GRANTHA OM
-        return true;
-    }
-    if (codePoint >= 0x1135D && codePoint <= 0x11361) { // GRANTHA SIGN PLUTA .. GRANTHA LETTER VOCALIC LL
-        return true;
-    }
-    if (codePoint >= 0x11400 && codePoint <= 0x11434) { // NEWA LETTER A .. NEWA LETTER HA
-        return true;
-    }
-    if (codePoint >= 0x11447 && codePoint <= 0x1144A) { // NEWA SIGN AVAGRAHA .. NEWA SIDDHI
-        return true;
-    }
-    if (codePoint >= 0x1145F && codePoint <= 0x11461) { // NEWA LETTER VEDIC ANUSVARA .. NEWA SIGN UPADHMANIYA
-        return true;
-    }
-    if (codePoint >= 0x11480 && codePoint <= 0x114AF) { // TIRHUTA ANJI .. TIRHUTA LETTER HA
-        return true;
-    }
-    if (codePoint >= 0x114C4 && codePoint <= 0x114C5) { // TIRHUTA SIGN AVAGRAHA .. TIRHUTA GVANG
-        return true;
-    }
-    if (codePoint >= 0x114C7 && codePoint <= 0x114C7) { // TIRHUTA OM .. TIRHUTA OM
-        return true;
-    }
-    if (codePoint >= 0x11580 && codePoint <= 0x115AE) { // SIDDHAM LETTER A .. SIDDHAM LETTER HA
-        return true;
-    }
-    if (codePoint >= 0x115D8 && codePoint <= 0x115DB) { // SIDDHAM LETTER THREE-CIRCLE ALTERNATE I .. SIDDHAM LETTER ALTERNATE U
-        return true;
-    }
-    if (codePoint >= 0x11600 && codePoint <= 0x1162F) { // MODI LETTER A .. MODI LETTER LLA
-        return true;
-    }
-    if (codePoint >= 0x11644 && codePoint <= 0x11644) { // MODI SIGN HUVA .. MODI SIGN HUVA
-        return true;
-    }
-    if (codePoint >= 0x11680 && codePoint <= 0x116AA) { // TAKRI LETTER A .. TAKRI LETTER RRA
-        return true;
-    }
-    if (codePoint >= 0x116B8 && codePoint <= 0x116B8) { // TAKRI LETTER ARCHAIC KHA .. TAKRI LETTER ARCHAIC KHA
-        return true;
-    }
-    if (codePoint >= 0x11700 && codePoint <= 0x1171A) { // AHOM LETTER KA .. AHOM LETTER ALTERNATE BA
-        return true;
-    }
-    if (codePoint >= 0x11800 && codePoint <= 0x1182B) { // DOGRA LETTER A .. DOGRA LETTER RRA
-        return true;
-    }
-    if (codePoint >= 0x118A0 && codePoint <= 0x118DF) { // WARANG CITI CAPITAL LETTER NGAA .. WARANG CITI SMALL LETTER VIYO
-        return true;
-    }
-    if (codePoint >= 0x118FF && codePoint <= 0x11906) { // WARANG CITI OM .. DIVES AKURU LETTER E
-        return true;
-    }
-    if (codePoint >= 0x11909 && codePoint <= 0x11909) { // DIVES AKURU LETTER O .. DIVES AKURU LETTER O
-        return true;
-    }
-    if (codePoint >= 0x1190C && codePoint <= 0x11913) { // DIVES AKURU LETTER KA .. DIVES AKURU LETTER JA
-        return true;
-    }
-    if (codePoint >= 0x11915 && codePoint <= 0x11916) { // DIVES AKURU LETTER NYA .. DIVES AKURU LETTER TTA
-        return true;
-    }
-    if (codePoint >= 0x11918 && codePoint <= 0x1192F) { // DIVES AKURU LETTER DDA .. DIVES AKURU LETTER ZA
-        return true;
-    }
-    if (codePoint >= 0x1193F && codePoint <= 0x1193F) { // DIVES AKURU PREFIXED NASAL SIGN .. DIVES AKURU PREFIXED NASAL SIGN
-        return true;
-    }
-    if (codePoint >= 0x11941 && codePoint <= 0x11941) { // DIVES AKURU INITIAL RA .. DIVES AKURU INITIAL RA
-        return true;
-    }
-    if (codePoint >= 0x119A0 && codePoint <= 0x119A7) { // NANDINAGARI LETTER A .. NANDINAGARI LETTER VOCALIC RR
-        return true;
-    }
-    if (codePoint >= 0x119AA && codePoint <= 0x119D0) { // NANDINAGARI LETTER E .. NANDINAGARI LETTER RRA
-        return true;
-    }
-    if (codePoint >= 0x119E1 && codePoint <= 0x119E1) { // NANDINAGARI SIGN AVAGRAHA .. NANDINAGARI SIGN AVAGRAHA
-        return true;
-    }
-    if (codePoint >= 0x119E3 && codePoint <= 0x119E3) { // NANDINAGARI HEADSTROKE .. NANDINAGARI HEADSTROKE
-        return true;
-    }
-    if (codePoint >= 0x11A00 && codePoint <= 0x11A00) { // ZANABAZAR SQUARE LETTER A .. ZANABAZAR SQUARE LETTER A
-        return true;
-    }
-    if (codePoint >= 0x11A0B && codePoint <= 0x11A32) { // ZANABAZAR SQUARE LETTER KA .. ZANABAZAR SQUARE LETTER KSSA
-        return true;
-    }
-    if (codePoint >= 0x11A3A && codePoint <= 0x11A3A) { // ZANABAZAR SQUARE CLUSTER-INITIAL LETTER RA .. ZANABAZAR SQUARE CLUSTER-INITIAL LETTER RA
-        return true;
-    }
-    if (codePoint >= 0x11A50 && codePoint <= 0x11A50) { // SOYOMBO LETTER A .. SOYOMBO LETTER A
-        return true;
-    }
-    if (codePoint >= 0x11A5C && codePoint <= 0x11A89) { // SOYOMBO LETTER KA .. SOYOMBO CLUSTER-INITIAL LETTER SA
-        return true;
-    }
-    if (codePoint >= 0x11A9D && codePoint <= 0x11A9D) { // SOYOMBO MARK PLUTA .. SOYOMBO MARK PLUTA
-        return true;
-    }
-    if (codePoint >= 0x11AC0 && codePoint <= 0x11AF8) { // PAU CIN HAU LETTER PA .. PAU CIN HAU GLOTTAL STOP FINAL
-        return true;
-    }
-    if (codePoint >= 0x11C00 && codePoint <= 0x11C08) { // BHAIKSUKI LETTER A .. BHAIKSUKI LETTER VOCALIC L
-        return true;
-    }
-    if (codePoint >= 0x11C0A && codePoint <= 0x11C2E) { // BHAIKSUKI LETTER E .. BHAIKSUKI LETTER HA
-        return true;
-    }
-    if (codePoint >= 0x11C40 && codePoint <= 0x11C40) { // BHAIKSUKI SIGN AVAGRAHA .. BHAIKSUKI SIGN AVAGRAHA
-        return true;
-    }
-    if (codePoint >= 0x11C72 && codePoint <= 0x11C8F) { // MARCHEN LETTER KA .. MARCHEN LETTER A
-        return true;
-    }
-    if (codePoint >= 0x11D00 && codePoint <= 0x11D06) { // MASARAM GONDI LETTER A .. MASARAM GONDI LETTER E
-        return true;
-    }
-    if (codePoint >= 0x11D08 && codePoint <= 0x11D09) { // MASARAM GONDI LETTER AI .. MASARAM GONDI LETTER O
-        return true;
-    }
-    if (codePoint >= 0x11D0B && codePoint <= 0x11D30) { // MASARAM GONDI LETTER AU .. MASARAM GONDI LETTER TRA
-        return true;
-    }
-    if (codePoint >= 0x11D46 && codePoint <= 0x11D46) { // MASARAM GONDI REPHA .. MASARAM GONDI REPHA
-        return true;
-    }
-    if (codePoint >= 0x11D60 && codePoint <= 0x11D65) { // GUNJALA GONDI LETTER A .. GUNJALA GONDI LETTER UU
-        return true;
-    }
-    if (codePoint >= 0x11D67 && codePoint <= 0x11D68) { // GUNJALA GONDI LETTER EE .. GUNJALA GONDI LETTER AI
-        return true;
-    }
-    if (codePoint >= 0x11D6A && codePoint <= 0x11D89) { // GUNJALA GONDI LETTER OO .. GUNJALA GONDI LETTER SA
-        return true;
-    }
-    if (codePoint >= 0x11D98 && codePoint <= 0x11D98) { // GUNJALA GONDI OM .. GUNJALA GONDI OM
-        return true;
-    }
-    if (codePoint >= 0x11EE0 && codePoint <= 0x11EF2) { // MAKASAR LETTER KA .. MAKASAR ANGKA
-        return true;
-    }
-    if (codePoint >= 0x11FB0 && codePoint <= 0x11FB0) { // LISU LETTER YHA .. LISU LETTER YHA
-        return true;
-    }
-    if (codePoint >= 0x12000 && codePoint <= 0x12399) { // CUNEIFORM SIGN A .. CUNEIFORM SIGN U U
-        return true;
-    }
-    if (codePoint >= 0x12400 && codePoint <= 0x1246E) { // CUNEIFORM NUMERIC SIGN TWO ASH .. CUNEIFORM NUMERIC SIGN NINE U VARIANT FORM
-        return true;
-    }
-    if (codePoint >= 0x12480 && codePoint <= 0x12543) { // CUNEIFORM SIGN AB TIMES NUN TENU .. CUNEIFORM SIGN ZU5 TIMES THREE DISH TENU
-        return true;
-    }
-    if (codePoint >= 0x13000 && codePoint <= 0x1342E) { // EGYPTIAN HIEROGLYPH A001 .. EGYPTIAN HIEROGLYPH AA032
-        return true;
-    }
-    if (codePoint >= 0x14400 && codePoint <= 0x14646) { // ANATOLIAN HIEROGLYPH A001 .. ANATOLIAN HIEROGLYPH A530
-        return true;
-    }
-    if (codePoint >= 0x16800 && codePoint <= 0x16A38) { // BAMUM LETTER PHASE-A NGKUE MFON .. BAMUM LETTER PHASE-F VUEQ
-        return true;
-    }
-    if (codePoint >= 0x16A40 && codePoint <= 0x16A5E) { // MRO LETTER TA .. MRO LETTER TEK
-        return true;
-    }
-    if (codePoint >= 0x16AD0 && codePoint <= 0x16AED) { // BASSA VAH LETTER ENNI .. BASSA VAH LETTER I
-        return true;
-    }
-    if (codePoint >= 0x16B00 && codePoint <= 0x16B2F) { // PAHAWH HMONG VOWEL KEEB .. PAHAWH HMONG CONSONANT CAU
+    if (codePoint >= 0x104B0 && codePoint <= 0x104D3) {MOZ_RELEASE_ASSERT(0); // OSAGE CAPITAL LETTER A .. OSAGE CAPITAL LETTER ZHA
+        return true;
+    }
+    if (codePoint >= 0x104D8 && codePoint <= 0x104FB) {MOZ_RELEASE_ASSERT(0); // OSAGE SMALL LETTER A .. OSAGE SMALL LETTER ZHA
+        return true;
+    }
+    if (codePoint >= 0x10500 && codePoint <= 0x10527) {MOZ_RELEASE_ASSERT(0); // ELBASAN LETTER A .. ELBASAN LETTER KHE
+        return true;
+    }
+    if (codePoint >= 0x10530 && codePoint <= 0x10563) {MOZ_RELEASE_ASSERT(0); // CAUCASIAN ALBANIAN LETTER ALT .. CAUCASIAN ALBANIAN LETTER KIW
+        return true;
+    }
+    if (codePoint >= 0x10600 && codePoint <= 0x10736) {MOZ_RELEASE_ASSERT(0); // LINEAR A SIGN AB001 .. LINEAR A SIGN A664
+        return true;
+    }
+    if (codePoint >= 0x10740 && codePoint <= 0x10755) {MOZ_RELEASE_ASSERT(0); // LINEAR A SIGN A701 A .. LINEAR A SIGN A732 JE
+        return true;
+    }
+    if (codePoint >= 0x10760 && codePoint <= 0x10767) {MOZ_RELEASE_ASSERT(0); // LINEAR A SIGN A800 .. LINEAR A SIGN A807
+        return true;
+    }
+    if (codePoint >= 0x10800 && codePoint <= 0x10805) {MOZ_RELEASE_ASSERT(0); // CYPRIOT SYLLABLE A .. CYPRIOT SYLLABLE JA
+        return true;
+    }
+    if (codePoint >= 0x10808 && codePoint <= 0x10808) {MOZ_RELEASE_ASSERT(0); // CYPRIOT SYLLABLE JO .. CYPRIOT SYLLABLE JO
+        return true;
+    }
+    if (codePoint >= 0x1080A && codePoint <= 0x10835) {MOZ_RELEASE_ASSERT(0); // CYPRIOT SYLLABLE KA .. CYPRIOT SYLLABLE WO
+        return true;
+    }
+    if (codePoint >= 0x10837 && codePoint <= 0x10838) {MOZ_RELEASE_ASSERT(0); // CYPRIOT SYLLABLE XA .. CYPRIOT SYLLABLE XE
+        return true;
+    }
+    if (codePoint >= 0x1083C && codePoint <= 0x1083C) {MOZ_RELEASE_ASSERT(0); // CYPRIOT SYLLABLE ZA .. CYPRIOT SYLLABLE ZA
+        return true;
+    }
+    if (codePoint >= 0x1083F && codePoint <= 0x10855) {MOZ_RELEASE_ASSERT(0); // CYPRIOT SYLLABLE ZO .. IMPERIAL ARAMAIC LETTER TAW
+        return true;
+    }
+    if (codePoint >= 0x10860 && codePoint <= 0x10876) {MOZ_RELEASE_ASSERT(0); // PALMYRENE LETTER ALEPH .. PALMYRENE LETTER TAW
+        return true;
+    }
+    if (codePoint >= 0x10880 && codePoint <= 0x1089E) {MOZ_RELEASE_ASSERT(0); // NABATAEAN LETTER FINAL ALEPH .. NABATAEAN LETTER TAW
+        return true;
+    }
+    if (codePoint >= 0x108E0 && codePoint <= 0x108F2) {MOZ_RELEASE_ASSERT(0); // HATRAN LETTER ALEPH .. HATRAN LETTER QOPH
+        return true;
+    }
+    if (codePoint >= 0x108F4 && codePoint <= 0x108F5) {MOZ_RELEASE_ASSERT(0); // HATRAN LETTER SHIN .. HATRAN LETTER TAW
+        return true;
+    }
+    if (codePoint >= 0x10900 && codePoint <= 0x10915) {MOZ_RELEASE_ASSERT(0); // PHOENICIAN LETTER ALF .. PHOENICIAN LETTER TAU
+        return true;
+    }
+    if (codePoint >= 0x10920 && codePoint <= 0x10939) {MOZ_RELEASE_ASSERT(0); // LYDIAN LETTER A .. LYDIAN LETTER C
+        return true;
+    }
+    if (codePoint >= 0x10980 && codePoint <= 0x109B7) {MOZ_RELEASE_ASSERT(0); // MEROITIC HIEROGLYPHIC LETTER A .. MEROITIC CURSIVE LETTER DA
+        return true;
+    }
+    if (codePoint >= 0x109BE && codePoint <= 0x109BF) {MOZ_RELEASE_ASSERT(0); // MEROITIC CURSIVE LOGOGRAM RMT .. MEROITIC CURSIVE LOGOGRAM IMN
+        return true;
+    }
+    if (codePoint >= 0x10A00 && codePoint <= 0x10A00) {MOZ_RELEASE_ASSERT(0); // KHAROSHTHI LETTER A .. KHAROSHTHI LETTER A
+        return true;
+    }
+    if (codePoint >= 0x10A10 && codePoint <= 0x10A13) {MOZ_RELEASE_ASSERT(0); // KHAROSHTHI LETTER KA .. KHAROSHTHI LETTER GHA
+        return true;
+    }
+    if (codePoint >= 0x10A15 && codePoint <= 0x10A17) {MOZ_RELEASE_ASSERT(0); // KHAROSHTHI LETTER CA .. KHAROSHTHI LETTER JA
+        return true;
+    }
+    if (codePoint >= 0x10A19 && codePoint <= 0x10A35) {MOZ_RELEASE_ASSERT(0); // KHAROSHTHI LETTER NYA .. KHAROSHTHI LETTER VHA
+        return true;
+    }
+    if (codePoint >= 0x10A60 && codePoint <= 0x10A7C) {MOZ_RELEASE_ASSERT(0); // OLD SOUTH ARABIAN LETTER HE .. OLD SOUTH ARABIAN LETTER THETH
+        return true;
+    }
+    if (codePoint >= 0x10A80 && codePoint <= 0x10A9C) {MOZ_RELEASE_ASSERT(0); // OLD NORTH ARABIAN LETTER HEH .. OLD NORTH ARABIAN LETTER ZAH
+        return true;
+    }
+    if (codePoint >= 0x10AC0 && codePoint <= 0x10AC7) {MOZ_RELEASE_ASSERT(0); // MANICHAEAN LETTER ALEPH .. MANICHAEAN LETTER WAW
+        return true;
+    }
+    if (codePoint >= 0x10AC9 && codePoint <= 0x10AE4) {MOZ_RELEASE_ASSERT(0); // MANICHAEAN LETTER ZAYIN .. MANICHAEAN LETTER TAW
+        return true;
+    }
+    if (codePoint >= 0x10B00 && codePoint <= 0x10B35) {MOZ_RELEASE_ASSERT(0); // AVESTAN LETTER A .. AVESTAN LETTER HE
+        return true;
+    }
+    if (codePoint >= 0x10B40 && codePoint <= 0x10B55) {MOZ_RELEASE_ASSERT(0); // INSCRIPTIONAL PARTHIAN LETTER ALEPH .. INSCRIPTIONAL PARTHIAN LETTER TAW
+        return true;
+    }
+    if (codePoint >= 0x10B60 && codePoint <= 0x10B72) {MOZ_RELEASE_ASSERT(0); // INSCRIPTIONAL PAHLAVI LETTER ALEPH .. INSCRIPTIONAL PAHLAVI LETTER TAW
+        return true;
+    }
+    if (codePoint >= 0x10B80 && codePoint <= 0x10B91) {MOZ_RELEASE_ASSERT(0); // PSALTER PAHLAVI LETTER ALEPH .. PSALTER PAHLAVI LETTER TAW
+        return true;
+    }
+    if (codePoint >= 0x10C00 && codePoint <= 0x10C48) {MOZ_RELEASE_ASSERT(0); // OLD TURKIC LETTER ORKHON A .. OLD TURKIC LETTER ORKHON BASH
+        return true;
+    }
+    if (codePoint >= 0x10C80 && codePoint <= 0x10CB2) {MOZ_RELEASE_ASSERT(0); // OLD HUNGARIAN CAPITAL LETTER A .. OLD HUNGARIAN CAPITAL LETTER US
+        return true;
+    }
+    if (codePoint >= 0x10CC0 && codePoint <= 0x10CF2) {MOZ_RELEASE_ASSERT(0); // OLD HUNGARIAN SMALL LETTER A .. OLD HUNGARIAN SMALL LETTER US
+        return true;
+    }
+    if (codePoint >= 0x10D00 && codePoint <= 0x10D23) {MOZ_RELEASE_ASSERT(0); // HANIFI ROHINGYA LETTER A .. HANIFI ROHINGYA MARK NA KHONNA
+        return true;
+    }
+    if (codePoint >= 0x10E80 && codePoint <= 0x10EA9) {MOZ_RELEASE_ASSERT(0); // YEZIDI LETTER ELIF .. YEZIDI LETTER ET
+        return true;
+    }
+    if (codePoint >= 0x10EB0 && codePoint <= 0x10EB1) {MOZ_RELEASE_ASSERT(0); // YEZIDI LETTER LAM WITH DOT ABOVE .. YEZIDI LETTER YOT WITH CIRCUMFLEX ABOVE
+        return true;
+    }
+    if (codePoint >= 0x10F00 && codePoint <= 0x10F1C) {MOZ_RELEASE_ASSERT(0); // OLD SOGDIAN LETTER ALEPH .. OLD SOGDIAN LETTER FINAL TAW WITH VERTICAL TAIL
+        return true;
+    }
+    if (codePoint >= 0x10F27 && codePoint <= 0x10F27) {MOZ_RELEASE_ASSERT(0); // OLD SOGDIAN LIGATURE AYIN-DALETH .. OLD SOGDIAN LIGATURE AYIN-DALETH
+        return true;
+    }
+    if (codePoint >= 0x10F30 && codePoint <= 0x10F45) {MOZ_RELEASE_ASSERT(0); // SOGDIAN LETTER ALEPH .. SOGDIAN INDEPENDENT SHIN
+        return true;
+    }
+    if (codePoint >= 0x10FB0 && codePoint <= 0x10FC4) {MOZ_RELEASE_ASSERT(0); // CHORASMIAN LETTER ALEPH .. CHORASMIAN LETTER TAW
+        return true;
+    }
+    if (codePoint >= 0x10FE0 && codePoint <= 0x10FF6) {MOZ_RELEASE_ASSERT(0); // ELYMAIC LETTER ALEPH .. ELYMAIC LIGATURE ZAYIN-YODH
+        return true;
+    }
+    if (codePoint >= 0x11003 && codePoint <= 0x11037) {MOZ_RELEASE_ASSERT(0); // BRAHMI SIGN JIHVAMULIYA .. BRAHMI LETTER OLD TAMIL NNNA
+        return true;
+    }
+    if (codePoint >= 0x11083 && codePoint <= 0x110AF) {MOZ_RELEASE_ASSERT(0); // KAITHI LETTER A .. KAITHI LETTER HA
+        return true;
+    }
+    if (codePoint >= 0x110D0 && codePoint <= 0x110E8) {MOZ_RELEASE_ASSERT(0); // SORA SOMPENG LETTER SAH .. SORA SOMPENG LETTER MAE
+        return true;
+    }
+    if (codePoint >= 0x11103 && codePoint <= 0x11126) {MOZ_RELEASE_ASSERT(0); // CHAKMA LETTER AA .. CHAKMA LETTER HAA
+        return true;
+    }
+    if (codePoint >= 0x11144 && codePoint <= 0x11144) {MOZ_RELEASE_ASSERT(0); // CHAKMA LETTER LHAA .. CHAKMA LETTER LHAA
+        return true;
+    }
+    if (codePoint >= 0x11147 && codePoint <= 0x11147) {MOZ_RELEASE_ASSERT(0); // CHAKMA LETTER VAA .. CHAKMA LETTER VAA
+        return true;
+    }
+    if (codePoint >= 0x11150 && codePoint <= 0x11172) {MOZ_RELEASE_ASSERT(0); // MAHAJANI LETTER A .. MAHAJANI LETTER RRA
+        return true;
+    }
+    if (codePoint >= 0x11176 && codePoint <= 0x11176) {MOZ_RELEASE_ASSERT(0); // MAHAJANI LIGATURE SHRI .. MAHAJANI LIGATURE SHRI
+        return true;
+    }
+    if (codePoint >= 0x11183 && codePoint <= 0x111B2) {MOZ_RELEASE_ASSERT(0); // SHARADA LETTER A .. SHARADA LETTER HA
+        return true;
+    }
+    if (codePoint >= 0x111C1 && codePoint <= 0x111C4) {MOZ_RELEASE_ASSERT(0); // SHARADA SIGN AVAGRAHA .. SHARADA OM
+        return true;
+    }
+    if (codePoint >= 0x111DA && codePoint <= 0x111DA) {MOZ_RELEASE_ASSERT(0); // SHARADA EKAM .. SHARADA EKAM
+        return true;
+    }
+    if (codePoint >= 0x111DC && codePoint <= 0x111DC) {MOZ_RELEASE_ASSERT(0); // SHARADA HEADSTROKE .. SHARADA HEADSTROKE
+        return true;
+    }
+    if (codePoint >= 0x11200 && codePoint <= 0x11211) {MOZ_RELEASE_ASSERT(0); // KHOJKI LETTER A .. KHOJKI LETTER JJA
+        return true;
+    }
+    if (codePoint >= 0x11213 && codePoint <= 0x1122B) {MOZ_RELEASE_ASSERT(0); // KHOJKI LETTER NYA .. KHOJKI LETTER LLA
+        return true;
+    }
+    if (codePoint >= 0x11280 && codePoint <= 0x11286) {MOZ_RELEASE_ASSERT(0); // MULTANI LETTER A .. MULTANI LETTER GA
+        return true;
+    }
+    if (codePoint >= 0x11288 && codePoint <= 0x11288) {MOZ_RELEASE_ASSERT(0); // MULTANI LETTER GHA .. MULTANI LETTER GHA
+        return true;
+    }
+    if (codePoint >= 0x1128A && codePoint <= 0x1128D) {MOZ_RELEASE_ASSERT(0); // MULTANI LETTER CA .. MULTANI LETTER JJA
+        return true;
+    }
+    if (codePoint >= 0x1128F && codePoint <= 0x1129D) {MOZ_RELEASE_ASSERT(0); // MULTANI LETTER NYA .. MULTANI LETTER BA
+        return true;
+    }
+    if (codePoint >= 0x1129F && codePoint <= 0x112A8) {MOZ_RELEASE_ASSERT(0); // MULTANI LETTER BHA .. MULTANI LETTER RHA
+        return true;
+    }
+    if (codePoint >= 0x112B0 && codePoint <= 0x112DE) {MOZ_RELEASE_ASSERT(0); // KHUDAWADI LETTER A .. KHUDAWADI LETTER HA
+        return true;
+    }
+    if (codePoint >= 0x11305 && codePoint <= 0x1130C) {MOZ_RELEASE_ASSERT(0); // GRANTHA LETTER A .. GRANTHA LETTER VOCALIC L
+        return true;
+    }
+    if (codePoint >= 0x1130F && codePoint <= 0x11310) {MOZ_RELEASE_ASSERT(0); // GRANTHA LETTER EE .. GRANTHA LETTER AI
+        return true;
+    }
+    if (codePoint >= 0x11313 && codePoint <= 0x11328) {MOZ_RELEASE_ASSERT(0); // GRANTHA LETTER OO .. GRANTHA LETTER NA
+        return true;
+    }
+    if (codePoint >= 0x1132A && codePoint <= 0x11330) {MOZ_RELEASE_ASSERT(0); // GRANTHA LETTER PA .. GRANTHA LETTER RA
+        return true;
+    }
+    if (codePoint >= 0x11332 && codePoint <= 0x11333) {MOZ_RELEASE_ASSERT(0); // GRANTHA LETTER LA .. GRANTHA LETTER LLA
+        return true;
+    }
+    if (codePoint >= 0x11335 && codePoint <= 0x11339) {MOZ_RELEASE_ASSERT(0); // GRANTHA LETTER VA .. GRANTHA LETTER HA
+        return true;
+    }
+    if (codePoint >= 0x1133D && codePoint <= 0x1133D) {MOZ_RELEASE_ASSERT(0); // GRANTHA SIGN AVAGRAHA .. GRANTHA SIGN AVAGRAHA
+        return true;
+    }
+    if (codePoint >= 0x11350 && codePoint <= 0x11350) {MOZ_RELEASE_ASSERT(0); // GRANTHA OM .. GRANTHA OM
+        return true;
+    }
+    if (codePoint >= 0x1135D && codePoint <= 0x11361) {MOZ_RELEASE_ASSERT(0); // GRANTHA SIGN PLUTA .. GRANTHA LETTER VOCALIC LL
+        return true;
+    }
+    if (codePoint >= 0x11400 && codePoint <= 0x11434) {MOZ_RELEASE_ASSERT(0); // NEWA LETTER A .. NEWA LETTER HA
+        return true;
+    }
+    if (codePoint >= 0x11447 && codePoint <= 0x1144A) {MOZ_RELEASE_ASSERT(0); // NEWA SIGN AVAGRAHA .. NEWA SIDDHI
+        return true;
+    }
+    if (codePoint >= 0x1145F && codePoint <= 0x11461) {MOZ_RELEASE_ASSERT(0); // NEWA LETTER VEDIC ANUSVARA .. NEWA SIGN UPADHMANIYA
+        return true;
+    }
+    if (codePoint >= 0x11480 && codePoint <= 0x114AF) {MOZ_RELEASE_ASSERT(0); // TIRHUTA ANJI .. TIRHUTA LETTER HA
+        return true;
+    }
+    if (codePoint >= 0x114C4 && codePoint <= 0x114C5) {MOZ_RELEASE_ASSERT(0); // TIRHUTA SIGN AVAGRAHA .. TIRHUTA GVANG
+        return true;
+    }
+    if (codePoint >= 0x114C7 && codePoint <= 0x114C7) {MOZ_RELEASE_ASSERT(0); // TIRHUTA OM .. TIRHUTA OM
+        return true;
+    }
+    if (codePoint >= 0x11580 && codePoint <= 0x115AE) {MOZ_RELEASE_ASSERT(0); // SIDDHAM LETTER A .. SIDDHAM LETTER HA
+        return true;
+    }
+    if (codePoint >= 0x115D8 && codePoint <= 0x115DB) {MOZ_RELEASE_ASSERT(0); // SIDDHAM LETTER THREE-CIRCLE ALTERNATE I .. SIDDHAM LETTER ALTERNATE U
+        return true;
+    }
+    if (codePoint >= 0x11600 && codePoint <= 0x1162F) {MOZ_RELEASE_ASSERT(0); // MODI LETTER A .. MODI LETTER LLA
+        return true;
+    }
+    if (codePoint >= 0x11644 && codePoint <= 0x11644) {MOZ_RELEASE_ASSERT(0); // MODI SIGN HUVA .. MODI SIGN HUVA
+        return true;
+    }
+    if (codePoint >= 0x11680 && codePoint <= 0x116AA) {MOZ_RELEASE_ASSERT(0); // TAKRI LETTER A .. TAKRI LETTER RRA
+        return true;
+    }
+    if (codePoint >= 0x116B8 && codePoint <= 0x116B8) {MOZ_RELEASE_ASSERT(0); // TAKRI LETTER ARCHAIC KHA .. TAKRI LETTER ARCHAIC KHA
+        return true;
+    }
+    if (codePoint >= 0x11700 && codePoint <= 0x1171A) {MOZ_RELEASE_ASSERT(0); // AHOM LETTER KA .. AHOM LETTER ALTERNATE BA
+        return true;
+    }
+    if (codePoint >= 0x11800 && codePoint <= 0x1182B) {MOZ_RELEASE_ASSERT(0); // DOGRA LETTER A .. DOGRA LETTER RRA
+        return true;
+    }
+    if (codePoint >= 0x118A0 && codePoint <= 0x118DF) {MOZ_RELEASE_ASSERT(0); // WARANG CITI CAPITAL LETTER NGAA .. WARANG CITI SMALL LETTER VIYO
+        return true;
+    }
+    if (codePoint >= 0x118FF && codePoint <= 0x11906) {MOZ_RELEASE_ASSERT(0); // WARANG CITI OM .. DIVES AKURU LETTER E
+        return true;
+    }
+    if (codePoint >= 0x11909 && codePoint <= 0x11909) {MOZ_RELEASE_ASSERT(0); // DIVES AKURU LETTER O .. DIVES AKURU LETTER O
+        return true;
+    }
+    if (codePoint >= 0x1190C && codePoint <= 0x11913) {MOZ_RELEASE_ASSERT(0); // DIVES AKURU LETTER KA .. DIVES AKURU LETTER JA
+        return true;
+    }
+    if (codePoint >= 0x11915 && codePoint <= 0x11916) {MOZ_RELEASE_ASSERT(0); // DIVES AKURU LETTER NYA .. DIVES AKURU LETTER TTA
+        return true;
+    }
+    if (codePoint >= 0x11918 && codePoint <= 0x1192F) {MOZ_RELEASE_ASSERT(0); // DIVES AKURU LETTER DDA .. DIVES AKURU LETTER ZA
+        return true;
+    }
+    if (codePoint >= 0x1193F && codePoint <= 0x1193F) {MOZ_RELEASE_ASSERT(0); // DIVES AKURU PREFIXED NASAL SIGN .. DIVES AKURU PREFIXED NASAL SIGN
+        return true;
+    }
+    if (codePoint >= 0x11941 && codePoint <= 0x11941) {MOZ_RELEASE_ASSERT(0); // DIVES AKURU INITIAL RA .. DIVES AKURU INITIAL RA
+        return true;
+    }
+    if (codePoint >= 0x119A0 && codePoint <= 0x119A7) {MOZ_RELEASE_ASSERT(0); // NANDINAGARI LETTER A .. NANDINAGARI LETTER VOCALIC RR
+        return true;
+    }
+    if (codePoint >= 0x119AA && codePoint <= 0x119D0) {MOZ_RELEASE_ASSERT(0); // NANDINAGARI LETTER E .. NANDINAGARI LETTER RRA
+        return true;
+    }
+    if (codePoint >= 0x119E1 && codePoint <= 0x119E1) {MOZ_RELEASE_ASSERT(0); // NANDINAGARI SIGN AVAGRAHA .. NANDINAGARI SIGN AVAGRAHA
+        return true;
+    }
+    if (codePoint >= 0x119E3 && codePoint <= 0x119E3) {MOZ_RELEASE_ASSERT(0); // NANDINAGARI HEADSTROKE .. NANDINAGARI HEADSTROKE
+        return true;
+    }
+    if (codePoint >= 0x11A00 && codePoint <= 0x11A00) {MOZ_RELEASE_ASSERT(0); // ZANABAZAR SQUARE LETTER A .. ZANABAZAR SQUARE LETTER A
+        return true;
+    }
+    if (codePoint >= 0x11A0B && codePoint <= 0x11A32) {MOZ_RELEASE_ASSERT(0); // ZANABAZAR SQUARE LETTER KA .. ZANABAZAR SQUARE LETTER KSSA
+        return true;
+    }
+    if (codePoint >= 0x11A3A && codePoint <= 0x11A3A) {MOZ_RELEASE_ASSERT(0); // ZANABAZAR SQUARE CLUSTER-INITIAL LETTER RA .. ZANABAZAR SQUARE CLUSTER-INITIAL LETTER RA
+        return true;
+    }
+    if (codePoint >= 0x11A50 && codePoint <= 0x11A50) {MOZ_RELEASE_ASSERT(0); // SOYOMBO LETTER A .. SOYOMBO LETTER A
+        return true;
+    }
+    if (codePoint >= 0x11A5C && codePoint <= 0x11A89) {MOZ_RELEASE_ASSERT(0); // SOYOMBO LETTER KA .. SOYOMBO CLUSTER-INITIAL LETTER SA
+        return true;
+    }
+    if (codePoint >= 0x11A9D && codePoint <= 0x11A9D) {MOZ_RELEASE_ASSERT(0); // SOYOMBO MARK PLUTA .. SOYOMBO MARK PLUTA
+        return true;
+    }
+    if (codePoint >= 0x11AC0 && codePoint <= 0x11AF8) {MOZ_RELEASE_ASSERT(0); // PAU CIN HAU LETTER PA .. PAU CIN HAU GLOTTAL STOP FINAL
+        return true;
+    }
+    if (codePoint >= 0x11C00 && codePoint <= 0x11C08) {MOZ_RELEASE_ASSERT(0); // BHAIKSUKI LETTER A .. BHAIKSUKI LETTER VOCALIC L
+        return true;
+    }
+    if (codePoint >= 0x11C0A && codePoint <= 0x11C2E) {MOZ_RELEASE_ASSERT(0); // BHAIKSUKI LETTER E .. BHAIKSUKI LETTER HA
+        return true;
+    }
+    if (codePoint >= 0x11C40 && codePoint <= 0x11C40) {MOZ_RELEASE_ASSERT(0); // BHAIKSUKI SIGN AVAGRAHA .. BHAIKSUKI SIGN AVAGRAHA
+        return true;
+    }
+    if (codePoint >= 0x11C72 && codePoint <= 0x11C8F) {MOZ_RELEASE_ASSERT(0); // MARCHEN LETTER KA .. MARCHEN LETTER A
+        return true;
+    }
+    if (codePoint >= 0x11D00 && codePoint <= 0x11D06) {MOZ_RELEASE_ASSERT(0); // MASARAM GONDI LETTER A .. MASARAM GONDI LETTER E
+        return true;
+    }
+    if (codePoint >= 0x11D08 && codePoint <= 0x11D09) {MOZ_RELEASE_ASSERT(0); // MASARAM GONDI LETTER AI .. MASARAM GONDI LETTER O
+        return true;
+    }
+    if (codePoint >= 0x11D0B && codePoint <= 0x11D30) {MOZ_RELEASE_ASSERT(0); // MASARAM GONDI LETTER AU .. MASARAM GONDI LETTER TRA
+        return true;
+    }
+    if (codePoint >= 0x11D46 && codePoint <= 0x11D46) {MOZ_RELEASE_ASSERT(0); // MASARAM GONDI REPHA .. MASARAM GONDI REPHA
+        return true;
+    }
+    if (codePoint >= 0x11D60 && codePoint <= 0x11D65) {MOZ_RELEASE_ASSERT(0); // GUNJALA GONDI LETTER A .. GUNJALA GONDI LETTER UU
+        return true;
+    }
+    if (codePoint >= 0x11D67 && codePoint <= 0x11D68) {MOZ_RELEASE_ASSERT(0); // GUNJALA GONDI LETTER EE .. GUNJALA GONDI LETTER AI
+        return true;
+    }
+    if (codePoint >= 0x11D6A && codePoint <= 0x11D89) {MOZ_RELEASE_ASSERT(0); // GUNJALA GONDI LETTER OO .. GUNJALA GONDI LETTER SA
+        return true;
+    }
+    if (codePoint >= 0x11D98 && codePoint <= 0x11D98) {MOZ_RELEASE_ASSERT(0); // GUNJALA GONDI OM .. GUNJALA GONDI OM
+        return true;
+    }
+    if (codePoint >= 0x11EE0 && codePoint <= 0x11EF2) {MOZ_RELEASE_ASSERT(0); // MAKASAR LETTER KA .. MAKASAR ANGKA
+        return true;
+    }
+    if (codePoint >= 0x11FB0 && codePoint <= 0x11FB0) {MOZ_RELEASE_ASSERT(0); // LISU LETTER YHA .. LISU LETTER YHA
+        return true;
+    }
+    if (codePoint >= 0x12000 && codePoint <= 0x12399) {MOZ_RELEASE_ASSERT(0); // CUNEIFORM SIGN A .. CUNEIFORM SIGN U U
+        return true;
+    }
+    if (codePoint >= 0x12400 && codePoint <= 0x1246E) {MOZ_RELEASE_ASSERT(0); // CUNEIFORM NUMERIC SIGN TWO ASH .. CUNEIFORM NUMERIC SIGN NINE U VARIANT FORM
+        return true;
+    }
+    if (codePoint >= 0x12480 && codePoint <= 0x12543) {MOZ_RELEASE_ASSERT(0); // CUNEIFORM SIGN AB TIMES NUN TENU .. CUNEIFORM SIGN ZU5 TIMES THREE DISH TENU
+        return true;
+    }
+    if (codePoint >= 0x13000 && codePoint <= 0x1342E) {MOZ_RELEASE_ASSERT(0); // EGYPTIAN HIEROGLYPH A001 .. EGYPTIAN HIEROGLYPH AA032
+        return true;
+    }
+    if (codePoint >= 0x14400 && codePoint <= 0x14646) {MOZ_RELEASE_ASSERT(0); // ANATOLIAN HIEROGLYPH A001 .. ANATOLIAN HIEROGLYPH A530
+        return true;
+    }
+    if (codePoint >= 0x16800 && codePoint <= 0x16A38) {MOZ_RELEASE_ASSERT(0); // BAMUM LETTER PHASE-A NGKUE MFON .. BAMUM LETTER PHASE-F VUEQ
+        return true;
+    }
+    if (codePoint >= 0x16A40 && codePoint <= 0x16A5E) {MOZ_RELEASE_ASSERT(0); // MRO LETTER TA .. MRO LETTER TEK
+        return true;
+    }
+    if (codePoint >= 0x16AD0 && codePoint <= 0x16AED) {MOZ_RELEASE_ASSERT(0); // BASSA VAH LETTER ENNI .. BASSA VAH LETTER I
+        return true;
+    }
+    if (codePoint >= 0x16B00 && codePoint <= 0x16B2F) {MOZ_RELEASE_ASSERT(0); // PAHAWH HMONG VOWEL KEEB .. PAHAWH HMONG CONSONANT CAU
         return true;
     }
     if (codePoint >= 0x16B40 && codePoint <= 0x16B43) { // PAHAWH HMONG SIGN VOS SEEV .. PAHAWH HMONG SIGN IB YAM
         return true;
     }
-    if (codePoint >= 0x16B63 && codePoint <= 0x16B77) { // PAHAWH HMONG SIGN VOS LUB .. PAHAWH HMONG SIGN CIM NRES TOS
-        return true;
-    }
-    if (codePoint >= 0x16B7D && codePoint <= 0x16B8F) { // PAHAWH HMONG CLAN SIGN TSHEEJ .. PAHAWH HMONG CLAN SIGN VWJ
-        return true;
-    }
-    if (codePoint >= 0x16E40 && codePoint <= 0x16E7F) { // MEDEFAIDRIN CAPITAL LETTER M .. MEDEFAIDRIN SMALL LETTER Y
-        return true;
-    }
-    if (codePoint >= 0x16F00 && codePoint <= 0x16F4A) { // MIAO LETTER PA .. MIAO LETTER RTE
-        return true;
-    }
-    if (codePoint >= 0x16F50 && codePoint <= 0x16F50) { // MIAO LETTER NASALIZATION .. MIAO LETTER NASALIZATION
-        return true;
-    }
-    if (codePoint >= 0x16F93 && codePoint <= 0x16F9F) { // MIAO LETTER TONE-2 .. MIAO LETTER REFORMED TONE-8
-        return true;
-    }
-    if (codePoint >= 0x16FE0 && codePoint <= 0x16FE1) { // TANGUT ITERATION MARK .. NUSHU ITERATION MARK
-        return true;
-    }
-    if (codePoint >= 0x16FE3 && codePoint <= 0x16FE3) { // OLD CHINESE ITERATION MARK .. OLD CHINESE ITERATION MARK
-        return true;
-    }
-    if (codePoint >= 0x17000 && codePoint <= 0x187F7) { // Tangut Ideograph .. Tangut Ideograph
-        return true;
-    }
-    if (codePoint >= 0x18800 && codePoint <= 0x18CD5) { // TANGUT COMPONENT-001 .. KHITAN SMALL SCRIPT CHARACTER-18CD5
-        return true;
-    }
-    if (codePoint >= 0x18D00 && codePoint <= 0x18D08) { // Tangut Ideograph Supplement .. Tangut Ideograph Supplement
-        return true;
-    }
-    if (codePoint >= 0x1B000 && codePoint <= 0x1B11E) { // KATAKANA LETTER ARCHAIC E .. HENTAIGANA LETTER N-MU-MO-2
-        return true;
-    }
-    if (codePoint >= 0x1B150 && codePoint <= 0x1B152) { // HIRAGANA LETTER SMALL WI .. HIRAGANA LETTER SMALL WO
-        return true;
-    }
-    if (codePoint >= 0x1B164 && codePoint <= 0x1B167) { // KATAKANA LETTER SMALL WI .. KATAKANA LETTER SMALL N
-        return true;
-    }
-    if (codePoint >= 0x1B170 && codePoint <= 0x1B2FB) { // NUSHU CHARACTER-1B170 .. NUSHU CHARACTER-1B2FB
-        return true;
-    }
-    if (codePoint >= 0x1BC00 && codePoint <= 0x1BC6A) { // DUPLOYAN LETTER H .. DUPLOYAN LETTER VOCALIC M
-        return true;
-    }
-    if (codePoint >= 0x1BC70 && codePoint <= 0x1BC7C) { // DUPLOYAN AFFIX LEFT HORIZONTAL SECANT .. DUPLOYAN AFFIX ATTACHED TANGENT HOOK
-        return true;
-    }
-    if (codePoint >= 0x1BC80 && codePoint <= 0x1BC88) { // DUPLOYAN AFFIX HIGH ACUTE .. DUPLOYAN AFFIX HIGH VERTICAL
-        return true;
-    }
-    if (codePoint >= 0x1BC90 && codePoint <= 0x1BC99) { // DUPLOYAN AFFIX LOW ACUTE .. DUPLOYAN AFFIX LOW ARROW
+    if (codePoint >= 0x16B63 && codePoint <= 0x16B77) {MOZ_RELEASE_ASSERT(0); // PAHAWH HMONG SIGN VOS LUB .. PAHAWH HMONG SIGN CIM NRES TOS
+        return true;
+    }
+    if (codePoint >= 0x16B7D && codePoint <= 0x16B8F) {MOZ_RELEASE_ASSERT(0); // PAHAWH HMONG CLAN SIGN TSHEEJ .. PAHAWH HMONG CLAN SIGN VWJ
+        return true;
+    }
+    if (codePoint >= 0x16E40 && codePoint <= 0x16E7F) {MOZ_RELEASE_ASSERT(0); // MEDEFAIDRIN CAPITAL LETTER M .. MEDEFAIDRIN SMALL LETTER Y
+        return true;
+    }
+    if (codePoint >= 0x16F00 && codePoint <= 0x16F4A) {MOZ_RELEASE_ASSERT(0); // MIAO LETTER PA .. MIAO LETTER RTE
+        return true;
+    }
+    if (codePoint >= 0x16F50 && codePoint <= 0x16F50) {MOZ_RELEASE_ASSERT(0); // MIAO LETTER NASALIZATION .. MIAO LETTER NASALIZATION
+        return true;
+    }
+    if (codePoint >= 0x16F93 && codePoint <= 0x16F9F) {MOZ_RELEASE_ASSERT(0); // MIAO LETTER TONE-2 .. MIAO LETTER REFORMED TONE-8
+        return true;
+    }
+    if (codePoint >= 0x16FE0 && codePoint <= 0x16FE1) {MOZ_RELEASE_ASSERT(0); // TANGUT ITERATION MARK .. NUSHU ITERATION MARK
+        return true;
+    }
+    if (codePoint >= 0x16FE3 && codePoint <= 0x16FE3) {MOZ_RELEASE_ASSERT(0); // OLD CHINESE ITERATION MARK .. OLD CHINESE ITERATION MARK
+        return true;
+    }
+    if (codePoint >= 0x17000 && codePoint <= 0x187F7) {MOZ_RELEASE_ASSERT(0); // Tangut Ideograph .. Tangut Ideograph
+        return true;
+    }
+    if (codePoint >= 0x18800 && codePoint <= 0x18CD5) {MOZ_RELEASE_ASSERT(0); // TANGUT COMPONENT-001 .. KHITAN SMALL SCRIPT CHARACTER-18CD5
+        return true;
+    }
+    if (codePoint >= 0x18D00 && codePoint <= 0x18D08) {MOZ_RELEASE_ASSERT(0); // Tangut Ideograph Supplement .. Tangut Ideograph Supplement
+        return true;
+    }
+    if (codePoint >= 0x1B000 && codePoint <= 0x1B11E) {MOZ_RELEASE_ASSERT(0); // KATAKANA LETTER ARCHAIC E .. HENTAIGANA LETTER N-MU-MO-2
+        return true;
+    }
+    if (codePoint >= 0x1B150 && codePoint <= 0x1B152) {MOZ_RELEASE_ASSERT(0); // HIRAGANA LETTER SMALL WI .. HIRAGANA LETTER SMALL WO
+        return true;
+    }
+    if (codePoint >= 0x1B164 && codePoint <= 0x1B167) {MOZ_RELEASE_ASSERT(0); // KATAKANA LETTER SMALL WI .. KATAKANA LETTER SMALL N
+        return true;
+    }
+    if (codePoint >= 0x1B170 && codePoint <= 0x1B2FB) {MOZ_RELEASE_ASSERT(0); // NUSHU CHARACTER-1B170 .. NUSHU CHARACTER-1B2FB
+        return true;
+    }
+    if (codePoint >= 0x1BC00 && codePoint <= 0x1BC6A) {MOZ_RELEASE_ASSERT(0); // DUPLOYAN LETTER H .. DUPLOYAN LETTER VOCALIC M
+        return true;
+    }
+    if (codePoint >= 0x1BC70 && codePoint <= 0x1BC7C) {MOZ_RELEASE_ASSERT(0); // DUPLOYAN AFFIX LEFT HORIZONTAL SECANT .. DUPLOYAN AFFIX ATTACHED TANGENT HOOK
+        return true;
+    }
+    if (codePoint >= 0x1BC80 && codePoint <= 0x1BC88) {MOZ_RELEASE_ASSERT(0); // DUPLOYAN AFFIX HIGH ACUTE .. DUPLOYAN AFFIX HIGH VERTICAL
+        return true;
+    }
+    if (codePoint >= 0x1BC90 && codePoint <= 0x1BC99) {MOZ_RELEASE_ASSERT(0); // DUPLOYAN AFFIX LOW ACUTE .. DUPLOYAN AFFIX LOW ARROW
         return true;
     }
     if (codePoint >= 0x1D400 && codePoint <= 0x1D454) { // MATHEMATICAL BOLD CAPITAL A .. MATHEMATICAL ITALIC SMALL G
@@ -1773,226 +1773,226 @@ js::unicode::IsIdentifierStartNonBMP(uin
     if (codePoint >= 0x1D456 && codePoint <= 0x1D49C) { // MATHEMATICAL ITALIC SMALL I .. MATHEMATICAL SCRIPT CAPITAL A
         return true;
     }
-    if (codePoint >= 0x1D49E && codePoint <= 0x1D49F) { // MATHEMATICAL SCRIPT CAPITAL C .. MATHEMATICAL SCRIPT CAPITAL D
-        return true;
-    }
-    if (codePoint >= 0x1D4A2 && codePoint <= 0x1D4A2) { // MATHEMATICAL SCRIPT CAPITAL G .. MATHEMATICAL SCRIPT CAPITAL G
-        return true;
-    }
-    if (codePoint >= 0x1D4A5 && codePoint <= 0x1D4A6) { // MATHEMATICAL SCRIPT CAPITAL J .. MATHEMATICAL SCRIPT CAPITAL K
-        return true;
-    }
-    if (codePoint >= 0x1D4A9 && codePoint <= 0x1D4AC) { // MATHEMATICAL SCRIPT CAPITAL N .. MATHEMATICAL SCRIPT CAPITAL Q
-        return true;
-    }
-    if (codePoint >= 0x1D4AE && codePoint <= 0x1D4B9) { // MATHEMATICAL SCRIPT CAPITAL S .. MATHEMATICAL SCRIPT SMALL D
-        return true;
-    }
-    if (codePoint >= 0x1D4BB && codePoint <= 0x1D4BB) { // MATHEMATICAL SCRIPT SMALL F .. MATHEMATICAL SCRIPT SMALL F
-        return true;
-    }
-    if (codePoint >= 0x1D4BD && codePoint <= 0x1D4C3) { // MATHEMATICAL SCRIPT SMALL H .. MATHEMATICAL SCRIPT SMALL N
+    if (codePoint >= 0x1D49E && codePoint <= 0x1D49F) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SCRIPT CAPITAL C .. MATHEMATICAL SCRIPT CAPITAL D
+        return true;
+    }
+    if (codePoint >= 0x1D4A2 && codePoint <= 0x1D4A2) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SCRIPT CAPITAL G .. MATHEMATICAL SCRIPT CAPITAL G
+        return true;
+    }
+    if (codePoint >= 0x1D4A5 && codePoint <= 0x1D4A6) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SCRIPT CAPITAL J .. MATHEMATICAL SCRIPT CAPITAL K
+        return true;
+    }
+    if (codePoint >= 0x1D4A9 && codePoint <= 0x1D4AC) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SCRIPT CAPITAL N .. MATHEMATICAL SCRIPT CAPITAL Q
+        return true;
+    }
+    if (codePoint >= 0x1D4AE && codePoint <= 0x1D4B9) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SCRIPT CAPITAL S .. MATHEMATICAL SCRIPT SMALL D
+        return true;
+    }
+    if (codePoint >= 0x1D4BB && codePoint <= 0x1D4BB) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SCRIPT SMALL F .. MATHEMATICAL SCRIPT SMALL F
+        return true;
+    }
+    if (codePoint >= 0x1D4BD && codePoint <= 0x1D4C3) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SCRIPT SMALL H .. MATHEMATICAL SCRIPT SMALL N
         return true;
     }
     if (codePoint >= 0x1D4C5 && codePoint <= 0x1D505) { // MATHEMATICAL SCRIPT SMALL P .. MATHEMATICAL FRAKTUR CAPITAL B
         return true;
     }
-    if (codePoint >= 0x1D507 && codePoint <= 0x1D50A) { // MATHEMATICAL FRAKTUR CAPITAL D .. MATHEMATICAL FRAKTUR CAPITAL G
-        return true;
-    }
-    if (codePoint >= 0x1D50D && codePoint <= 0x1D514) { // MATHEMATICAL FRAKTUR CAPITAL J .. MATHEMATICAL FRAKTUR CAPITAL Q
-        return true;
-    }
-    if (codePoint >= 0x1D516 && codePoint <= 0x1D51C) { // MATHEMATICAL FRAKTUR CAPITAL S .. MATHEMATICAL FRAKTUR CAPITAL Y
-        return true;
-    }
-    if (codePoint >= 0x1D51E && codePoint <= 0x1D539) { // MATHEMATICAL FRAKTUR SMALL A .. MATHEMATICAL DOUBLE-STRUCK CAPITAL B
-        return true;
-    }
-    if (codePoint >= 0x1D53B && codePoint <= 0x1D53E) { // MATHEMATICAL DOUBLE-STRUCK CAPITAL D .. MATHEMATICAL DOUBLE-STRUCK CAPITAL G
-        return true;
-    }
-    if (codePoint >= 0x1D540 && codePoint <= 0x1D544) { // MATHEMATICAL DOUBLE-STRUCK CAPITAL I .. MATHEMATICAL DOUBLE-STRUCK CAPITAL M
-        return true;
-    }
-    if (codePoint >= 0x1D546 && codePoint <= 0x1D546) { // MATHEMATICAL DOUBLE-STRUCK CAPITAL O .. MATHEMATICAL DOUBLE-STRUCK CAPITAL O
-        return true;
-    }
-    if (codePoint >= 0x1D54A && codePoint <= 0x1D550) { // MATHEMATICAL DOUBLE-STRUCK CAPITAL S .. MATHEMATICAL DOUBLE-STRUCK CAPITAL Y
+    if (codePoint >= 0x1D507 && codePoint <= 0x1D50A) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL FRAKTUR CAPITAL D .. MATHEMATICAL FRAKTUR CAPITAL G
+        return true;
+    }
+    if (codePoint >= 0x1D50D && codePoint <= 0x1D514) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL FRAKTUR CAPITAL J .. MATHEMATICAL FRAKTUR CAPITAL Q
+        return true;
+    }
+    if (codePoint >= 0x1D516 && codePoint <= 0x1D51C) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL FRAKTUR CAPITAL S .. MATHEMATICAL FRAKTUR CAPITAL Y
+        return true;
+    }
+    if (codePoint >= 0x1D51E && codePoint <= 0x1D539) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL FRAKTUR SMALL A .. MATHEMATICAL DOUBLE-STRUCK CAPITAL B
+        return true;
+    }
+    if (codePoint >= 0x1D53B && codePoint <= 0x1D53E) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL DOUBLE-STRUCK CAPITAL D .. MATHEMATICAL DOUBLE-STRUCK CAPITAL G
+        return true;
+    }
+    if (codePoint >= 0x1D540 && codePoint <= 0x1D544) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL DOUBLE-STRUCK CAPITAL I .. MATHEMATICAL DOUBLE-STRUCK CAPITAL M
+        return true;
+    }
+    if (codePoint >= 0x1D546 && codePoint <= 0x1D546) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL DOUBLE-STRUCK CAPITAL O .. MATHEMATICAL DOUBLE-STRUCK CAPITAL O
+        return true;
+    }
+    if (codePoint >= 0x1D54A && codePoint <= 0x1D550) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL DOUBLE-STRUCK CAPITAL S .. MATHEMATICAL DOUBLE-STRUCK CAPITAL Y
         return true;
     }
     if (codePoint >= 0x1D552 && codePoint <= 0x1D6A5) { // MATHEMATICAL DOUBLE-STRUCK SMALL A .. MATHEMATICAL ITALIC SMALL DOTLESS J
         return true;
     }
-    if (codePoint >= 0x1D6A8 && codePoint <= 0x1D6C0) { // MATHEMATICAL BOLD CAPITAL ALPHA .. MATHEMATICAL BOLD CAPITAL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D6C2 && codePoint <= 0x1D6DA) { // MATHEMATICAL BOLD SMALL ALPHA .. MATHEMATICAL BOLD SMALL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D6DC && codePoint <= 0x1D6FA) { // MATHEMATICAL BOLD EPSILON SYMBOL .. MATHEMATICAL ITALIC CAPITAL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D6FC && codePoint <= 0x1D714) { // MATHEMATICAL ITALIC SMALL ALPHA .. MATHEMATICAL ITALIC SMALL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D716 && codePoint <= 0x1D734) { // MATHEMATICAL ITALIC EPSILON SYMBOL .. MATHEMATICAL BOLD ITALIC CAPITAL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D736 && codePoint <= 0x1D74E) { // MATHEMATICAL BOLD ITALIC SMALL ALPHA .. MATHEMATICAL BOLD ITALIC SMALL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D750 && codePoint <= 0x1D76E) { // MATHEMATICAL BOLD ITALIC EPSILON SYMBOL .. MATHEMATICAL SANS-SERIF BOLD CAPITAL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D770 && codePoint <= 0x1D788) { // MATHEMATICAL SANS-SERIF BOLD SMALL ALPHA .. MATHEMATICAL SANS-SERIF BOLD SMALL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D78A && codePoint <= 0x1D7A8) { // MATHEMATICAL SANS-SERIF BOLD EPSILON SYMBOL .. MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D7AA && codePoint <= 0x1D7C2) { // MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL ALPHA .. MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D7C4 && codePoint <= 0x1D7CB) { // MATHEMATICAL SANS-SERIF BOLD ITALIC EPSILON SYMBOL .. MATHEMATICAL BOLD SMALL DIGAMMA
-        return true;
-    }
-    if (codePoint >= 0x1E100 && codePoint <= 0x1E12C) { // NYIAKENG PUACHUE HMONG LETTER MA .. NYIAKENG PUACHUE HMONG LETTER W
-        return true;
-    }
-    if (codePoint >= 0x1E137 && codePoint <= 0x1E13D) { // NYIAKENG PUACHUE HMONG SIGN FOR PERSON .. NYIAKENG PUACHUE HMONG SYLLABLE LENGTHENER
-        return true;
-    }
-    if (codePoint >= 0x1E14E && codePoint <= 0x1E14E) { // NYIAKENG PUACHUE HMONG LOGOGRAM NYAJ .. NYIAKENG PUACHUE HMONG LOGOGRAM NYAJ
-        return true;
-    }
-    if (codePoint >= 0x1E2C0 && codePoint <= 0x1E2EB) { // WANCHO LETTER AA .. WANCHO LETTER YIH
-        return true;
-    }
-    if (codePoint >= 0x1E800 && codePoint <= 0x1E8C4) { // MENDE KIKAKUI SYLLABLE M001 KI .. MENDE KIKAKUI SYLLABLE M060 NYON
-        return true;
-    }
-    if (codePoint >= 0x1E900 && codePoint <= 0x1E943) { // ADLAM CAPITAL LETTER ALIF .. ADLAM SMALL LETTER SHA
-        return true;
-    }
-    if (codePoint >= 0x1E94B && codePoint <= 0x1E94B) { // ADLAM NASALIZATION MARK .. ADLAM NASALIZATION MARK
-        return true;
-    }
-    if (codePoint >= 0x1EE00 && codePoint <= 0x1EE03) { // ARABIC MATHEMATICAL ALEF .. ARABIC MATHEMATICAL DAL
-        return true;
-    }
-    if (codePoint >= 0x1EE05 && codePoint <= 0x1EE1F) { // ARABIC MATHEMATICAL WAW .. ARABIC MATHEMATICAL DOTLESS QAF
-        return true;
-    }
-    if (codePoint >= 0x1EE21 && codePoint <= 0x1EE22) { // ARABIC MATHEMATICAL INITIAL BEH .. ARABIC MATHEMATICAL INITIAL JEEM
-        return true;
-    }
-    if (codePoint >= 0x1EE24 && codePoint <= 0x1EE24) { // ARABIC MATHEMATICAL INITIAL HEH .. ARABIC MATHEMATICAL INITIAL HEH
-        return true;
-    }
-    if (codePoint >= 0x1EE27 && codePoint <= 0x1EE27) { // ARABIC MATHEMATICAL INITIAL HAH .. ARABIC MATHEMATICAL INITIAL HAH
-        return true;
-    }
-    if (codePoint >= 0x1EE29 && codePoint <= 0x1EE32) { // ARABIC MATHEMATICAL INITIAL YEH .. ARABIC MATHEMATICAL INITIAL QAF
-        return true;
-    }
-    if (codePoint >= 0x1EE34 && codePoint <= 0x1EE37) { // ARABIC MATHEMATICAL INITIAL SHEEN .. ARABIC MATHEMATICAL INITIAL KHAH
-        return true;
-    }
-    if (codePoint >= 0x1EE39 && codePoint <= 0x1EE39) { // ARABIC MATHEMATICAL INITIAL DAD .. ARABIC MATHEMATICAL INITIAL DAD
-        return true;
-    }
-    if (codePoint >= 0x1EE3B && codePoint <= 0x1EE3B) { // ARABIC MATHEMATICAL INITIAL GHAIN .. ARABIC MATHEMATICAL INITIAL GHAIN
-        return true;
-    }
-    if (codePoint >= 0x1EE42 && codePoint <= 0x1EE42) { // ARABIC MATHEMATICAL TAILED JEEM .. ARABIC MATHEMATICAL TAILED JEEM
-        return true;
-    }
-    if (codePoint >= 0x1EE47 && codePoint <= 0x1EE47) { // ARABIC MATHEMATICAL TAILED HAH .. ARABIC MATHEMATICAL TAILED HAH
-        return true;
-    }
-    if (codePoint >= 0x1EE49 && codePoint <= 0x1EE49) { // ARABIC MATHEMATICAL TAILED YEH .. ARABIC MATHEMATICAL TAILED YEH
-        return true;
-    }
-    if (codePoint >= 0x1EE4B && codePoint <= 0x1EE4B) { // ARABIC MATHEMATICAL TAILED LAM .. ARABIC MATHEMATICAL TAILED LAM
-        return true;
-    }
-    if (codePoint >= 0x1EE4D && codePoint <= 0x1EE4F) { // ARABIC MATHEMATICAL TAILED NOON .. ARABIC MATHEMATICAL TAILED AIN
-        return true;
-    }
-    if (codePoint >= 0x1EE51 && codePoint <= 0x1EE52) { // ARABIC MATHEMATICAL TAILED SAD .. ARABIC MATHEMATICAL TAILED QAF
-        return true;
-    }
-    if (codePoint >= 0x1EE54 && codePoint <= 0x1EE54) { // ARABIC MATHEMATICAL TAILED SHEEN .. ARABIC MATHEMATICAL TAILED SHEEN
-        return true;
-    }
-    if (codePoint >= 0x1EE57 && codePoint <= 0x1EE57) { // ARABIC MATHEMATICAL TAILED KHAH .. ARABIC MATHEMATICAL TAILED KHAH
-        return true;
-    }
-    if (codePoint >= 0x1EE59 && codePoint <= 0x1EE59) { // ARABIC MATHEMATICAL TAILED DAD .. ARABIC MATHEMATICAL TAILED DAD
-        return true;
-    }
-    if (codePoint >= 0x1EE5B && codePoint <= 0x1EE5B) { // ARABIC MATHEMATICAL TAILED GHAIN .. ARABIC MATHEMATICAL TAILED GHAIN
-        return true;
-    }
-    if (codePoint >= 0x1EE5D && codePoint <= 0x1EE5D) { // ARABIC MATHEMATICAL TAILED DOTLESS NOON .. ARABIC MATHEMATICAL TAILED DOTLESS NOON
-        return true;
-    }
-    if (codePoint >= 0x1EE5F && codePoint <= 0x1EE5F) { // ARABIC MATHEMATICAL TAILED DOTLESS QAF .. ARABIC MATHEMATICAL TAILED DOTLESS QAF
-        return true;
-    }
-    if (codePoint >= 0x1EE61 && codePoint <= 0x1EE62) { // ARABIC MATHEMATICAL STRETCHED BEH .. ARABIC MATHEMATICAL STRETCHED JEEM
-        return true;
-    }
-    if (codePoint >= 0x1EE64 && codePoint <= 0x1EE64) { // ARABIC MATHEMATICAL STRETCHED HEH .. ARABIC MATHEMATICAL STRETCHED HEH
-        return true;
-    }
-    if (codePoint >= 0x1EE67 && codePoint <= 0x1EE6A) { // ARABIC MATHEMATICAL STRETCHED HAH .. ARABIC MATHEMATICAL STRETCHED KAF
-        return true;
-    }
-    if (codePoint >= 0x1EE6C && codePoint <= 0x1EE72) { // ARABIC MATHEMATICAL STRETCHED MEEM .. ARABIC MATHEMATICAL STRETCHED QAF
-        return true;
-    }
-    if (codePoint >= 0x1EE74 && codePoint <= 0x1EE77) { // ARABIC MATHEMATICAL STRETCHED SHEEN .. ARABIC MATHEMATICAL STRETCHED KHAH
-        return true;
-    }
-    if (codePoint >= 0x1EE79 && codePoint <= 0x1EE7C) { // ARABIC MATHEMATICAL STRETCHED DAD .. ARABIC MATHEMATICAL STRETCHED DOTLESS BEH
-        return true;
-    }
-    if (codePoint >= 0x1EE7E && codePoint <= 0x1EE7E) { // ARABIC MATHEMATICAL STRETCHED DOTLESS FEH .. ARABIC MATHEMATICAL STRETCHED DOTLESS FEH
-        return true;
-    }
-    if (codePoint >= 0x1EE80 && codePoint <= 0x1EE89) { // ARABIC MATHEMATICAL LOOPED ALEF .. ARABIC MATHEMATICAL LOOPED YEH
-        return true;
-    }
-    if (codePoint >= 0x1EE8B && codePoint <= 0x1EE9B) { // ARABIC MATHEMATICAL LOOPED LAM .. ARABIC MATHEMATICAL LOOPED GHAIN
-        return true;
-    }
-    if (codePoint >= 0x1EEA1 && codePoint <= 0x1EEA3) { // ARABIC MATHEMATICAL DOUBLE-STRUCK BEH .. ARABIC MATHEMATICAL DOUBLE-STRUCK DAL
-        return true;
-    }
-    if (codePoint >= 0x1EEA5 && codePoint <= 0x1EEA9) { // ARABIC MATHEMATICAL DOUBLE-STRUCK WAW .. ARABIC MATHEMATICAL DOUBLE-STRUCK YEH
-        return true;
-    }
-    if (codePoint >= 0x1EEAB && codePoint <= 0x1EEBB) { // ARABIC MATHEMATICAL DOUBLE-STRUCK LAM .. ARABIC MATHEMATICAL DOUBLE-STRUCK GHAIN
-        return true;
-    }
-    if (codePoint >= 0x20000 && codePoint <= 0x2A6DD) { // CJK Ideograph Extension B .. CJK Ideograph Extension B
-        return true;
-    }
-    if (codePoint >= 0x2A700 && codePoint <= 0x2B734) { // CJK Ideograph Extension C .. CJK Ideograph Extension C
-        return true;
-    }
-    if (codePoint >= 0x2B740 && codePoint <= 0x2B81D) { // CJK Ideograph Extension D .. CJK Ideograph Extension D
-        return true;
-    }
-    if (codePoint >= 0x2B820 && codePoint <= 0x2CEA1) { // CJK Ideograph Extension E .. CJK Ideograph Extension E
-        return true;
-    }
-    if (codePoint >= 0x2CEB0 && codePoint <= 0x2EBE0) { // CJK Ideograph Extension F .. CJK Ideograph Extension F
-        return true;
-    }
-    if (codePoint >= 0x2F800 && codePoint <= 0x2FA1D) { // CJK COMPATIBILITY IDEOGRAPH-2F800 .. CJK COMPATIBILITY IDEOGRAPH-2FA1D
+    if (codePoint >= 0x1D6A8 && codePoint <= 0x1D6C0) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL BOLD CAPITAL ALPHA .. MATHEMATICAL BOLD CAPITAL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D6C2 && codePoint <= 0x1D6DA) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL BOLD SMALL ALPHA .. MATHEMATICAL BOLD SMALL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D6DC && codePoint <= 0x1D6FA) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL BOLD EPSILON SYMBOL .. MATHEMATICAL ITALIC CAPITAL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D6FC && codePoint <= 0x1D714) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL ITALIC SMALL ALPHA .. MATHEMATICAL ITALIC SMALL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D716 && codePoint <= 0x1D734) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL ITALIC EPSILON SYMBOL .. MATHEMATICAL BOLD ITALIC CAPITAL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D736 && codePoint <= 0x1D74E) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL BOLD ITALIC SMALL ALPHA .. MATHEMATICAL BOLD ITALIC SMALL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D750 && codePoint <= 0x1D76E) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL BOLD ITALIC EPSILON SYMBOL .. MATHEMATICAL SANS-SERIF BOLD CAPITAL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D770 && codePoint <= 0x1D788) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SANS-SERIF BOLD SMALL ALPHA .. MATHEMATICAL SANS-SERIF BOLD SMALL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D78A && codePoint <= 0x1D7A8) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SANS-SERIF BOLD EPSILON SYMBOL .. MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D7AA && codePoint <= 0x1D7C2) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL ALPHA .. MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D7C4 && codePoint <= 0x1D7CB) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SANS-SERIF BOLD ITALIC EPSILON SYMBOL .. MATHEMATICAL BOLD SMALL DIGAMMA
+        return true;
+    }
+    if (codePoint >= 0x1E100 && codePoint <= 0x1E12C) {MOZ_RELEASE_ASSERT(0); // NYIAKENG PUACHUE HMONG LETTER MA .. NYIAKENG PUACHUE HMONG LETTER W
+        return true;
+    }
+    if (codePoint >= 0x1E137 && codePoint <= 0x1E13D) {MOZ_RELEASE_ASSERT(0); // NYIAKENG PUACHUE HMONG SIGN FOR PERSON .. NYIAKENG PUACHUE HMONG SYLLABLE LENGTHENER
+        return true;
+    }
+    if (codePoint >= 0x1E14E && codePoint <= 0x1E14E) {MOZ_RELEASE_ASSERT(0); // NYIAKENG PUACHUE HMONG LOGOGRAM NYAJ .. NYIAKENG PUACHUE HMONG LOGOGRAM NYAJ
+        return true;
+    }
+    if (codePoint >= 0x1E2C0 && codePoint <= 0x1E2EB) {MOZ_RELEASE_ASSERT(0); // WANCHO LETTER AA .. WANCHO LETTER YIH
+        return true;
+    }
+    if (codePoint >= 0x1E800 && codePoint <= 0x1E8C4) {MOZ_RELEASE_ASSERT(0); // MENDE KIKAKUI SYLLABLE M001 KI .. MENDE KIKAKUI SYLLABLE M060 NYON
+        return true;
+    }
+    if (codePoint >= 0x1E900 && codePoint <= 0x1E943) {MOZ_RELEASE_ASSERT(0); // ADLAM CAPITAL LETTER ALIF .. ADLAM SMALL LETTER SHA
+        return true;
+    }
+    if (codePoint >= 0x1E94B && codePoint <= 0x1E94B) {MOZ_RELEASE_ASSERT(0); // ADLAM NASALIZATION MARK .. ADLAM NASALIZATION MARK
+        return true;
+    }
+    if (codePoint >= 0x1EE00 && codePoint <= 0x1EE03) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL ALEF .. ARABIC MATHEMATICAL DAL
+        return true;
+    }
+    if (codePoint >= 0x1EE05 && codePoint <= 0x1EE1F) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL WAW .. ARABIC MATHEMATICAL DOTLESS QAF
+        return true;
+    }
+    if (codePoint >= 0x1EE21 && codePoint <= 0x1EE22) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL INITIAL BEH .. ARABIC MATHEMATICAL INITIAL JEEM
+        return true;
+    }
+    if (codePoint >= 0x1EE24 && codePoint <= 0x1EE24) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL INITIAL HEH .. ARABIC MATHEMATICAL INITIAL HEH
+        return true;
+    }
+    if (codePoint >= 0x1EE27 && codePoint <= 0x1EE27) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL INITIAL HAH .. ARABIC MATHEMATICAL INITIAL HAH
+        return true;
+    }
+    if (codePoint >= 0x1EE29 && codePoint <= 0x1EE32) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL INITIAL YEH .. ARABIC MATHEMATICAL INITIAL QAF
+        return true;
+    }
+    if (codePoint >= 0x1EE34 && codePoint <= 0x1EE37) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL INITIAL SHEEN .. ARABIC MATHEMATICAL INITIAL KHAH
+        return true;
+    }
+    if (codePoint >= 0x1EE39 && codePoint <= 0x1EE39) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL INITIAL DAD .. ARABIC MATHEMATICAL INITIAL DAD
+        return true;
+    }
+    if (codePoint >= 0x1EE3B && codePoint <= 0x1EE3B) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL INITIAL GHAIN .. ARABIC MATHEMATICAL INITIAL GHAIN
+        return true;
+    }
+    if (codePoint >= 0x1EE42 && codePoint <= 0x1EE42) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL TAILED JEEM .. ARABIC MATHEMATICAL TAILED JEEM
+        return true;
+    }
+    if (codePoint >= 0x1EE47 && codePoint <= 0x1EE47) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL TAILED HAH .. ARABIC MATHEMATICAL TAILED HAH
+        return true;
+    }
+    if (codePoint >= 0x1EE49 && codePoint <= 0x1EE49) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL TAILED YEH .. ARABIC MATHEMATICAL TAILED YEH
+        return true;
+    }
+    if (codePoint >= 0x1EE4B && codePoint <= 0x1EE4B) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL TAILED LAM .. ARABIC MATHEMATICAL TAILED LAM
+        return true;
+    }
+    if (codePoint >= 0x1EE4D && codePoint <= 0x1EE4F) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL TAILED NOON .. ARABIC MATHEMATICAL TAILED AIN
+        return true;
+    }
+    if (codePoint >= 0x1EE51 && codePoint <= 0x1EE52) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL TAILED SAD .. ARABIC MATHEMATICAL TAILED QAF
+        return true;
+    }
+    if (codePoint >= 0x1EE54 && codePoint <= 0x1EE54) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL TAILED SHEEN .. ARABIC MATHEMATICAL TAILED SHEEN
+        return true;
+    }
+    if (codePoint >= 0x1EE57 && codePoint <= 0x1EE57) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL TAILED KHAH .. ARABIC MATHEMATICAL TAILED KHAH
+        return true;
+    }
+    if (codePoint >= 0x1EE59 && codePoint <= 0x1EE59) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL TAILED DAD .. ARABIC MATHEMATICAL TAILED DAD
+        return true;
+    }
+    if (codePoint >= 0x1EE5B && codePoint <= 0x1EE5B) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL TAILED GHAIN .. ARABIC MATHEMATICAL TAILED GHAIN
+        return true;
+    }
+    if (codePoint >= 0x1EE5D && codePoint <= 0x1EE5D) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL TAILED DOTLESS NOON .. ARABIC MATHEMATICAL TAILED DOTLESS NOON
+        return true;
+    }
+    if (codePoint >= 0x1EE5F && codePoint <= 0x1EE5F) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL TAILED DOTLESS QAF .. ARABIC MATHEMATICAL TAILED DOTLESS QAF
+        return true;
+    }
+    if (codePoint >= 0x1EE61 && codePoint <= 0x1EE62) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL STRETCHED BEH .. ARABIC MATHEMATICAL STRETCHED JEEM
+        return true;
+    }
+    if (codePoint >= 0x1EE64 && codePoint <= 0x1EE64) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL STRETCHED HEH .. ARABIC MATHEMATICAL STRETCHED HEH
+        return true;
+    }
+    if (codePoint >= 0x1EE67 && codePoint <= 0x1EE6A) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL STRETCHED HAH .. ARABIC MATHEMATICAL STRETCHED KAF
+        return true;
+    }
+    if (codePoint >= 0x1EE6C && codePoint <= 0x1EE72) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL STRETCHED MEEM .. ARABIC MATHEMATICAL STRETCHED QAF
+        return true;
+    }
+    if (codePoint >= 0x1EE74 && codePoint <= 0x1EE77) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL STRETCHED SHEEN .. ARABIC MATHEMATICAL STRETCHED KHAH
+        return true;
+    }
+    if (codePoint >= 0x1EE79 && codePoint <= 0x1EE7C) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL STRETCHED DAD .. ARABIC MATHEMATICAL STRETCHED DOTLESS BEH
+        return true;
+    }
+    if (codePoint >= 0x1EE7E && codePoint <= 0x1EE7E) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL STRETCHED DOTLESS FEH .. ARABIC MATHEMATICAL STRETCHED DOTLESS FEH
+        return true;
+    }
+    if (codePoint >= 0x1EE80 && codePoint <= 0x1EE89) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL LOOPED ALEF .. ARABIC MATHEMATICAL LOOPED YEH
+        return true;
+    }
+    if (codePoint >= 0x1EE8B && codePoint <= 0x1EE9B) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL LOOPED LAM .. ARABIC MATHEMATICAL LOOPED GHAIN
+        return true;
+    }
+    if (codePoint >= 0x1EEA1 && codePoint <= 0x1EEA3) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL DOUBLE-STRUCK BEH .. ARABIC MATHEMATICAL DOUBLE-STRUCK DAL
+        return true;
+    }
+    if (codePoint >= 0x1EEA5 && codePoint <= 0x1EEA9) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL DOUBLE-STRUCK WAW .. ARABIC MATHEMATICAL DOUBLE-STRUCK YEH
+        return true;
+    }
+    if (codePoint >= 0x1EEAB && codePoint <= 0x1EEBB) {MOZ_RELEASE_ASSERT(0); // ARABIC MATHEMATICAL DOUBLE-STRUCK LAM .. ARABIC MATHEMATICAL DOUBLE-STRUCK GHAIN
+        return true;
+    }
+    if (codePoint >= 0x20000 && codePoint <= 0x2A6DD) {MOZ_RELEASE_ASSERT(0); // CJK Ideograph Extension B .. CJK Ideograph Extension B
+        return true;
+    }
+    if (codePoint >= 0x2A700 && codePoint <= 0x2B734) {MOZ_RELEASE_ASSERT(0); // CJK Ideograph Extension C .. CJK Ideograph Extension C
+        return true;
+    }
+    if (codePoint >= 0x2B740 && codePoint <= 0x2B81D) {MOZ_RELEASE_ASSERT(0); // CJK Ideograph Extension D .. CJK Ideograph Extension D
+        return true;
+    }
+    if (codePoint >= 0x2B820 && codePoint <= 0x2CEA1) {MOZ_RELEASE_ASSERT(0); // CJK Ideograph Extension E .. CJK Ideograph Extension E
+        return true;
+    }
+    if (codePoint >= 0x2CEB0 && codePoint <= 0x2EBE0) {MOZ_RELEASE_ASSERT(0); // CJK Ideograph Extension F .. CJK Ideograph Extension F
+        return true;
+    }
+    if (codePoint >= 0x2F800 && codePoint <= 0x2FA1D) {MOZ_RELEASE_ASSERT(0); // CJK COMPATIBILITY IDEOGRAPH-2F800 .. CJK COMPATIBILITY IDEOGRAPH-2FA1D
         return true;
     }
     if (codePoint >= 0x30000 && codePoint <= 0x3134A) { // CJK Ideograph Extension G .. CJK Ideograph Extension G
@@ -2004,25 +2004,25 @@ js::unicode::IsIdentifierStartNonBMP(uin
 bool
 js::unicode::IsIdentifierPartNonBMP(uint32_t codePoint)
 {
-    if (codePoint >= 0x10000 && codePoint <= 0x1000B) { // LINEAR B SYLLABLE B008 A .. LINEAR B SYLLABLE B046 JE
-        return true;
-    }
-    if (codePoint >= 0x1000D && codePoint <= 0x10026) { // LINEAR B SYLLABLE B036 JO .. LINEAR B SYLLABLE B032 QO
-        return true;
-    }
-    if (codePoint >= 0x10028 && codePoint <= 0x1003A) { // LINEAR B SYLLABLE B060 RA .. LINEAR B SYLLABLE B042 WO
-        return true;
-    }
-    if (codePoint >= 0x1003C && codePoint <= 0x1003D) { // LINEAR B SYLLABLE B017 ZA .. LINEAR B SYLLABLE B074 ZE
-        return true;
-    }
-    if (codePoint >= 0x1003F && codePoint <= 0x1004D) { // LINEAR B SYLLABLE B020 ZO .. LINEAR B SYLLABLE B091 TWO
-        return true;
-    }
-    if (codePoint >= 0x10050 && codePoint <= 0x1005D) { // LINEAR B SYMBOL B018 .. LINEAR B SYMBOL B089
-        return true;
-    }
-    if (codePoint >= 0x10080 && codePoint <= 0x100FA) { // LINEAR B IDEOGRAM B100 MAN .. LINEAR B IDEOGRAM VESSEL B305
+    if (codePoint >= 0x10000 && codePoint <= 0x1000B) {MOZ_RELEASE_ASSERT(0); // LINEAR B SYLLABLE B008 A .. LINEAR B SYLLABLE B046 JE
+        return true;
+    }
+    if (codePoint >= 0x1000D && codePoint <= 0x10026) {MOZ_RELEASE_ASSERT(0); // LINEAR B SYLLABLE B036 JO .. LINEAR B SYLLABLE B032 QO
+        return true;
+    }
+    if (codePoint >= 0x10028 && codePoint <= 0x1003A) {MOZ_RELEASE_ASSERT(0); // LINEAR B SYLLABLE B060 RA .. LINEAR B SYLLABLE B042 WO
+        return true;
+    }
+    if (codePoint >= 0x1003C && codePoint <= 0x1003D) {MOZ_RELEASE_ASSERT(0); // LINEAR B SYLLABLE B017 ZA .. LINEAR B SYLLABLE B074 ZE
+        return true;
+    }
+    if (codePoint >= 0x1003F && codePoint <= 0x1004D) {MOZ_RELEASE_ASSERT(0); // LINEAR B SYLLABLE B020 ZO .. LINEAR B SYLLABLE B091 TWO
+        return true;
+    }
+    if (codePoint >= 0x10050 && codePoint <= 0x1005D) {MOZ_RELEASE_ASSERT(0); // LINEAR B SYMBOL B018 .. LINEAR B SYMBOL B089
+        return true;
+    }
+    if (codePoint >= 0x10080 && codePoint <= 0x100FA) {MOZ_RELEASE_ASSERT(0); // LINEAR B IDEOGRAM B100 MAN .. LINEAR B IDEOGRAM VESSEL B305
         return true;
     }
     if (codePoint >= 0x10140 && codePoint <= 0x10174) { // GREEK ACROPHONIC ATTIC ONE QUARTER .. GREEK ACROPHONIC STRATIAN FIFTY MNAS
@@ -2031,10 +2031,10 @@ js::unicode::IsIdentifierPartNonBMP(uint
     if (codePoint >= 0x101FD && codePoint <= 0x101FD) { // PHAISTOS DISC SIGN COMBINING OBLIQUE STROKE .. PHAISTOS DISC SIGN COMBINING OBLIQUE STROKE
         return true;
     }
-    if (codePoint >= 0x10280 && codePoint <= 0x1029C) { // LYCIAN LETTER A .. LYCIAN LETTER X
-        return true;
-    }
-    if (codePoint >= 0x102A0 && codePoint <= 0x102D0) { // CARIAN LETTER A .. CARIAN LETTER UUU3
+    if (codePoint >= 0x10280 && codePoint <= 0x1029C) {MOZ_RELEASE_ASSERT(0); // LYCIAN LETTER A .. LYCIAN LETTER X
+        return true;
+    }
+    if (codePoint >= 0x102A0 && codePoint <= 0x102D0) {MOZ_RELEASE_ASSERT(0); // CARIAN LETTER A .. CARIAN LETTER UUU3
         return true;
     }
     if (codePoint >= 0x102E0 && codePoint <= 0x102E0) { // COPTIC EPACT THOUSANDS MARK .. COPTIC EPACT THOUSANDS MARK
@@ -2049,16 +2049,16 @@ js::unicode::IsIdentifierPartNonBMP(uint
     if (codePoint >= 0x10350 && codePoint <= 0x1037A) { // OLD PERMIC LETTER AN .. COMBINING OLD PERMIC LETTER SII
         return true;
     }
-    if (codePoint >= 0x10380 && codePoint <= 0x1039D) { // UGARITIC LETTER ALPA .. UGARITIC LETTER SSU
-        return true;
-    }
-    if (codePoint >= 0x103A0 && codePoint <= 0x103C3) { // OLD PERSIAN SIGN A .. OLD PERSIAN SIGN HA
-        return true;
-    }
-    if (codePoint >= 0x103C8 && codePoint <= 0x103CF) { // OLD PERSIAN SIGN AURAMAZDAA .. OLD PERSIAN SIGN BUUMISH
-        return true;
-    }
-    if (codePoint >= 0x103D1 && codePoint <= 0x103D5) { // OLD PERSIAN NUMBER ONE .. OLD PERSIAN NUMBER HUNDRED
+    if (codePoint >= 0x10380 && codePoint <= 0x1039D) {MOZ_RELEASE_ASSERT(0); // UGARITIC LETTER ALPA .. UGARITIC LETTER SSU
+        return true;
+    }
+    if (codePoint >= 0x103A0 && codePoint <= 0x103C3) {MOZ_RELEASE_ASSERT(0); // OLD PERSIAN SIGN A .. OLD PERSIAN SIGN HA
+        return true;
+    }
+    if (codePoint >= 0x103C8 && codePoint <= 0x103CF) {MOZ_RELEASE_ASSERT(0); // OLD PERSIAN SIGN AURAMAZDAA .. OLD PERSIAN SIGN BUUMISH
+        return true;
+    }
+    if (codePoint >= 0x103D1 && codePoint <= 0x103D5) {MOZ_RELEASE_ASSERT(0); // OLD PERSIAN NUMBER ONE .. OLD PERSIAN NUMBER HUNDRED
         return true;
     }
     if (codePoint >= 0x10400 && codePoint <= 0x1049D) { // DESERET CAPITAL LETTER LONG I .. OSMANYA LETTER OO
@@ -2088,19 +2088,19 @@ js::unicode::IsIdentifierPartNonBMP(uint
     if (codePoint >= 0x10760 && codePoint <= 0x10767) { // LINEAR A SIGN A800 .. LINEAR A SIGN A807
         return true;
     }
-    if (codePoint >= 0x10800 && codePoint <= 0x10805) { // CYPRIOT SYLLABLE A .. CYPRIOT SYLLABLE JA
-        return true;
-    }
-    if (codePoint >= 0x10808 && codePoint <= 0x10808) { // CYPRIOT SYLLABLE JO .. CYPRIOT SYLLABLE JO
-        return true;
-    }
-    if (codePoint >= 0x1080A && codePoint <= 0x10835) { // CYPRIOT SYLLABLE KA .. CYPRIOT SYLLABLE WO
-        return true;
-    }
-    if (codePoint >= 0x10837 && codePoint <= 0x10838) { // CYPRIOT SYLLABLE XA .. CYPRIOT SYLLABLE XE
-        return true;
-    }
-    if (codePoint >= 0x1083C && codePoint <= 0x1083C) { // CYPRIOT SYLLABLE ZA .. CYPRIOT SYLLABLE ZA
+    if (codePoint >= 0x10800 && codePoint <= 0x10805) {MOZ_RELEASE_ASSERT(0); // CYPRIOT SYLLABLE A .. CYPRIOT SYLLABLE JA
+        return true;
+    }
+    if (codePoint >= 0x10808 && codePoint <= 0x10808) {MOZ_RELEASE_ASSERT(0); // CYPRIOT SYLLABLE JO .. CYPRIOT SYLLABLE JO
+        return true;
+    }
+    if (codePoint >= 0x1080A && codePoint <= 0x10835) {MOZ_RELEASE_ASSERT(0); // CYPRIOT SYLLABLE KA .. CYPRIOT SYLLABLE WO
+        return true;
+    }
+    if (codePoint >= 0x10837 && codePoint <= 0x10838) {MOZ_RELEASE_ASSERT(0); // CYPRIOT SYLLABLE XA .. CYPRIOT SYLLABLE XE
+        return true;
+    }
+    if (codePoint >= 0x1083C && codePoint <= 0x1083C) {MOZ_RELEASE_ASSERT(0); // CYPRIOT SYLLABLE ZA .. CYPRIOT SYLLABLE ZA
         return true;
     }
     if (codePoint >= 0x1083F && codePoint <= 0x10855) { // CYPRIOT SYLLABLE ZO .. IMPERIAL ARAMAIC LETTER TAW
@@ -2118,10 +2118,10 @@ js::unicode::IsIdentifierPartNonBMP(uint
     if (codePoint >= 0x108F4 && codePoint <= 0x108F5) { // HATRAN LETTER SHIN .. HATRAN LETTER TAW
         return true;
     }
-    if (codePoint >= 0x10900 && codePoint <= 0x10915) { // PHOENICIAN LETTER ALF .. PHOENICIAN LETTER TAU
-        return true;
-    }
-    if (codePoint >= 0x10920 && codePoint <= 0x10939) { // LYDIAN LETTER A .. LYDIAN LETTER C
+    if (codePoint >= 0x10900 && codePoint <= 0x10915) {MOZ_RELEASE_ASSERT(0); // PHOENICIAN LETTER ALF .. PHOENICIAN LETTER TAU
+        return true;
+    }
+    if (codePoint >= 0x10920 && codePoint <= 0x10939) {MOZ_RELEASE_ASSERT(0); // LYDIAN LETTER A .. LYDIAN LETTER C
         return true;
     }
     if (codePoint >= 0x10980 && codePoint <= 0x109B7) { // MEROITIC HIEROGLYPHIC LETTER A .. MEROITIC CURSIVE LETTER DA
@@ -2130,25 +2130,25 @@ js::unicode::IsIdentifierPartNonBMP(uint
     if (codePoint >= 0x109BE && codePoint <= 0x109BF) { // MEROITIC CURSIVE LOGOGRAM RMT .. MEROITIC CURSIVE LOGOGRAM IMN
         return true;
     }
-    if (codePoint >= 0x10A00 && codePoint <= 0x10A03) { // KHAROSHTHI LETTER A .. KHAROSHTHI VOWEL SIGN VOCALIC R
-        return true;
-    }
-    if (codePoint >= 0x10A05 && codePoint <= 0x10A06) { // KHAROSHTHI VOWEL SIGN E .. KHAROSHTHI VOWEL SIGN O
-        return true;
-    }
-    if (codePoint >= 0x10A0C && codePoint <= 0x10A13) { // KHAROSHTHI VOWEL LENGTH MARK .. KHAROSHTHI LETTER GHA
-        return true;
-    }
-    if (codePoint >= 0x10A15 && codePoint <= 0x10A17) { // KHAROSHTHI LETTER CA .. KHAROSHTHI LETTER JA
+    if (codePoint >= 0x10A00 && codePoint <= 0x10A03) {MOZ_RELEASE_ASSERT(0); // KHAROSHTHI LETTER A .. KHAROSHTHI VOWEL SIGN VOCALIC R
+        return true;
+    }
+    if (codePoint >= 0x10A05 && codePoint <= 0x10A06) {MOZ_RELEASE_ASSERT(0); // KHAROSHTHI VOWEL SIGN E .. KHAROSHTHI VOWEL SIGN O
+        return true;
+    }
+    if (codePoint >= 0x10A0C && codePoint <= 0x10A13) {MOZ_RELEASE_ASSERT(0); // KHAROSHTHI VOWEL LENGTH MARK .. KHAROSHTHI LETTER GHA
+        return true;
+    }
+    if (codePoint >= 0x10A15 && codePoint <= 0x10A17) {MOZ_RELEASE_ASSERT(0); // KHAROSHTHI LETTER CA .. KHAROSHTHI LETTER JA
         return true;
     }
     if (codePoint >= 0x10A19 && codePoint <= 0x10A35) { // KHAROSHTHI LETTER NYA .. KHAROSHTHI LETTER VHA
         return true;
     }
-    if (codePoint >= 0x10A38 && codePoint <= 0x10A3A) { // KHAROSHTHI SIGN BAR ABOVE .. KHAROSHTHI SIGN DOT BELOW
-        return true;
-    }
-    if (codePoint >= 0x10A3F && codePoint <= 0x10A3F) { // KHAROSHTHI VIRAMA .. KHAROSHTHI VIRAMA
+    if (codePoint >= 0x10A38 && codePoint <= 0x10A3A) {MOZ_RELEASE_ASSERT(0); // KHAROSHTHI SIGN BAR ABOVE .. KHAROSHTHI SIGN DOT BELOW
+        return true;
+    }
+    if (codePoint >= 0x10A3F && codePoint <= 0x10A3F) {MOZ_RELEASE_ASSERT(0); // KHAROSHTHI VIRAMA .. KHAROSHTHI VIRAMA
         return true;
     }
     if (codePoint >= 0x10A60 && codePoint <= 0x10A7C) { // OLD SOUTH ARABIAN LETTER HE .. OLD SOUTH ARABIAN LETTER THETH
@@ -2607,112 +2607,112 @@ js::unicode::IsIdentifierPartNonBMP(uint
     if (codePoint >= 0x1BC9D && codePoint <= 0x1BC9E) { // DUPLOYAN THICK LETTER SELECTOR .. DUPLOYAN DOUBLE MARK
         return true;
     }
-    if (codePoint >= 0x1D165 && codePoint <= 0x1D169) { // MUSICAL SYMBOL COMBINING STEM .. MUSICAL SYMBOL COMBINING TREMOLO-3
-        return true;
-    }
-    if (codePoint >= 0x1D16D && codePoint <= 0x1D172) { // MUSICAL SYMBOL COMBINING AUGMENTATION DOT .. MUSICAL SYMBOL COMBINING FLAG-5
-        return true;
-    }
-    if (codePoint >= 0x1D17B && codePoint <= 0x1D182) { // MUSICAL SYMBOL COMBINING ACCENT .. MUSICAL SYMBOL COMBINING LOURE
-        return true;
-    }
-    if (codePoint >= 0x1D185 && codePoint <= 0x1D18B) { // MUSICAL SYMBOL COMBINING DOIT .. MUSICAL SYMBOL COMBINING TRIPLE TONGUE
-        return true;
-    }
-    if (codePoint >= 0x1D1AA && codePoint <= 0x1D1AD) { // MUSICAL SYMBOL COMBINING DOWN BOW .. MUSICAL SYMBOL COMBINING SNAP PIZZICATO
-        return true;
-    }
-    if (codePoint >= 0x1D242 && codePoint <= 0x1D244) { // COMBINING GREEK MUSICAL TRISEME .. COMBINING GREEK MUSICAL PENTASEME
-        return true;
-    }
-    if (codePoint >= 0x1D400 && codePoint <= 0x1D454) { // MATHEMATICAL BOLD CAPITAL A .. MATHEMATICAL ITALIC SMALL G
+    if (codePoint >= 0x1D165 && codePoint <= 0x1D169) {MOZ_RELEASE_ASSERT(0); // MUSICAL SYMBOL COMBINING STEM .. MUSICAL SYMBOL COMBINING TREMOLO-3
+        return true;
+    }
+    if (codePoint >= 0x1D16D && codePoint <= 0x1D172) {MOZ_RELEASE_ASSERT(0); // MUSICAL SYMBOL COMBINING AUGMENTATION DOT .. MUSICAL SYMBOL COMBINING FLAG-5
+        return true;
+    }
+    if (codePoint >= 0x1D17B && codePoint <= 0x1D182) {MOZ_RELEASE_ASSERT(0); // MUSICAL SYMBOL COMBINING ACCENT .. MUSICAL SYMBOL COMBINING LOURE
+        return true;
+    }
+    if (codePoint >= 0x1D185 && codePoint <= 0x1D18B) {MOZ_RELEASE_ASSERT(0); // MUSICAL SYMBOL COMBINING DOIT .. MUSICAL SYMBOL COMBINING TRIPLE TONGUE
+        return true;
+    }
+    if (codePoint >= 0x1D1AA && codePoint <= 0x1D1AD) {MOZ_RELEASE_ASSERT(0); // MUSICAL SYMBOL COMBINING DOWN BOW .. MUSICAL SYMBOL COMBINING SNAP PIZZICATO
+        return true;
+    }
+    if (codePoint >= 0x1D242 && codePoint <= 0x1D244) {MOZ_RELEASE_ASSERT(0); // COMBINING GREEK MUSICAL TRISEME .. COMBINING GREEK MUSICAL PENTASEME
+        return true;
+    }
+    if (codePoint >= 0x1D400 && codePoint <= 0x1D454) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL BOLD CAPITAL A .. MATHEMATICAL ITALIC SMALL G
         return true;
     }
     if (codePoint >= 0x1D456 && codePoint <= 0x1D49C) { // MATHEMATICAL ITALIC SMALL I .. MATHEMATICAL SCRIPT CAPITAL A
         return true;
     }
-    if (codePoint >= 0x1D49E && codePoint <= 0x1D49F) { // MATHEMATICAL SCRIPT CAPITAL C .. MATHEMATICAL SCRIPT CAPITAL D
-        return true;
-    }
-    if (codePoint >= 0x1D4A2 && codePoint <= 0x1D4A2) { // MATHEMATICAL SCRIPT CAPITAL G .. MATHEMATICAL SCRIPT CAPITAL G
-        return true;
-    }
-    if (codePoint >= 0x1D4A5 && codePoint <= 0x1D4A6) { // MATHEMATICAL SCRIPT CAPITAL J .. MATHEMATICAL SCRIPT CAPITAL K
-        return true;
-    }
-    if (codePoint >= 0x1D4A9 && codePoint <= 0x1D4AC) { // MATHEMATICAL SCRIPT CAPITAL N .. MATHEMATICAL SCRIPT CAPITAL Q
-        return true;
-    }
-    if (codePoint >= 0x1D4AE && codePoint <= 0x1D4B9) { // MATHEMATICAL SCRIPT CAPITAL S .. MATHEMATICAL SCRIPT SMALL D
-        return true;
-    }
-    if (codePoint >= 0x1D4BB && codePoint <= 0x1D4BB) { // MATHEMATICAL SCRIPT SMALL F .. MATHEMATICAL SCRIPT SMALL F
-        return true;
-    }
-    if (codePoint >= 0x1D4BD && codePoint <= 0x1D4C3) { // MATHEMATICAL SCRIPT SMALL H .. MATHEMATICAL SCRIPT SMALL N
+    if (codePoint >= 0x1D49E && codePoint <= 0x1D49F) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SCRIPT CAPITAL C .. MATHEMATICAL SCRIPT CAPITAL D
+        return true;
+    }
+    if (codePoint >= 0x1D4A2 && codePoint <= 0x1D4A2) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SCRIPT CAPITAL G .. MATHEMATICAL SCRIPT CAPITAL G
+        return true;
+    }
+    if (codePoint >= 0x1D4A5 && codePoint <= 0x1D4A6) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SCRIPT CAPITAL J .. MATHEMATICAL SCRIPT CAPITAL K
+        return true;
+    }
+    if (codePoint >= 0x1D4A9 && codePoint <= 0x1D4AC) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SCRIPT CAPITAL N .. MATHEMATICAL SCRIPT CAPITAL Q
+        return true;
+    }
+    if (codePoint >= 0x1D4AE && codePoint <= 0x1D4B9) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SCRIPT CAPITAL S .. MATHEMATICAL SCRIPT SMALL D
+        return true;
+    }
+    if (codePoint >= 0x1D4BB && codePoint <= 0x1D4BB) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SCRIPT SMALL F .. MATHEMATICAL SCRIPT SMALL F
+        return true;
+    }
+    if (codePoint >= 0x1D4BD && codePoint <= 0x1D4C3) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SCRIPT SMALL H .. MATHEMATICAL SCRIPT SMALL N
         return true;
     }
     if (codePoint >= 0x1D4C5 && codePoint <= 0x1D505) { // MATHEMATICAL SCRIPT SMALL P .. MATHEMATICAL FRAKTUR CAPITAL B
         return true;
     }
-    if (codePoint >= 0x1D507 && codePoint <= 0x1D50A) { // MATHEMATICAL FRAKTUR CAPITAL D .. MATHEMATICAL FRAKTUR CAPITAL G
-        return true;
-    }
-    if (codePoint >= 0x1D50D && codePoint <= 0x1D514) { // MATHEMATICAL FRAKTUR CAPITAL J .. MATHEMATICAL FRAKTUR CAPITAL Q
-        return true;
-    }
-    if (codePoint >= 0x1D516 && codePoint <= 0x1D51C) { // MATHEMATICAL FRAKTUR CAPITAL S .. MATHEMATICAL FRAKTUR CAPITAL Y
-        return true;
-    }
-    if (codePoint >= 0x1D51E && codePoint <= 0x1D539) { // MATHEMATICAL FRAKTUR SMALL A .. MATHEMATICAL DOUBLE-STRUCK CAPITAL B
-        return true;
-    }
-    if (codePoint >= 0x1D53B && codePoint <= 0x1D53E) { // MATHEMATICAL DOUBLE-STRUCK CAPITAL D .. MATHEMATICAL DOUBLE-STRUCK CAPITAL G
-        return true;
-    }
-    if (codePoint >= 0x1D540 && codePoint <= 0x1D544) { // MATHEMATICAL DOUBLE-STRUCK CAPITAL I .. MATHEMATICAL DOUBLE-STRUCK CAPITAL M
-        return true;
-    }
-    if (codePoint >= 0x1D546 && codePoint <= 0x1D546) { // MATHEMATICAL DOUBLE-STRUCK CAPITAL O .. MATHEMATICAL DOUBLE-STRUCK CAPITAL O
-        return true;
-    }
-    if (codePoint >= 0x1D54A && codePoint <= 0x1D550) { // MATHEMATICAL DOUBLE-STRUCK CAPITAL S .. MATHEMATICAL DOUBLE-STRUCK CAPITAL Y
+    if (codePoint >= 0x1D507 && codePoint <= 0x1D50A) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL FRAKTUR CAPITAL D .. MATHEMATICAL FRAKTUR CAPITAL G
+        return true;
+    }
+    if (codePoint >= 0x1D50D && codePoint <= 0x1D514) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL FRAKTUR CAPITAL J .. MATHEMATICAL FRAKTUR CAPITAL Q
+        return true;
+    }
+    if (codePoint >= 0x1D516 && codePoint <= 0x1D51C) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL FRAKTUR CAPITAL S .. MATHEMATICAL FRAKTUR CAPITAL Y
+        return true;
+    }
+    if (codePoint >= 0x1D51E && codePoint <= 0x1D539) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL FRAKTUR SMALL A .. MATHEMATICAL DOUBLE-STRUCK CAPITAL B
+        return true;
+    }
+    if (codePoint >= 0x1D53B && codePoint <= 0x1D53E) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL DOUBLE-STRUCK CAPITAL D .. MATHEMATICAL DOUBLE-STRUCK CAPITAL G
+        return true;
+    }
+    if (codePoint >= 0x1D540 && codePoint <= 0x1D544) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL DOUBLE-STRUCK CAPITAL I .. MATHEMATICAL DOUBLE-STRUCK CAPITAL M
+        return true;
+    }
+    if (codePoint >= 0x1D546 && codePoint <= 0x1D546) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL DOUBLE-STRUCK CAPITAL O .. MATHEMATICAL DOUBLE-STRUCK CAPITAL O
+        return true;
+    }
+    if (codePoint >= 0x1D54A && codePoint <= 0x1D550) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL DOUBLE-STRUCK CAPITAL S .. MATHEMATICAL DOUBLE-STRUCK CAPITAL Y
         return true;
     }
     if (codePoint >= 0x1D552 && codePoint <= 0x1D6A5) { // MATHEMATICAL DOUBLE-STRUCK SMALL A .. MATHEMATICAL ITALIC SMALL DOTLESS J
         return true;
     }
-    if (codePoint >= 0x1D6A8 && codePoint <= 0x1D6C0) { // MATHEMATICAL BOLD CAPITAL ALPHA .. MATHEMATICAL BOLD CAPITAL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D6C2 && codePoint <= 0x1D6DA) { // MATHEMATICAL BOLD SMALL ALPHA .. MATHEMATICAL BOLD SMALL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D6DC && codePoint <= 0x1D6FA) { // MATHEMATICAL BOLD EPSILON SYMBOL .. MATHEMATICAL ITALIC CAPITAL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D6FC && codePoint <= 0x1D714) { // MATHEMATICAL ITALIC SMALL ALPHA .. MATHEMATICAL ITALIC SMALL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D716 && codePoint <= 0x1D734) { // MATHEMATICAL ITALIC EPSILON SYMBOL .. MATHEMATICAL BOLD ITALIC CAPITAL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D736 && codePoint <= 0x1D74E) { // MATHEMATICAL BOLD ITALIC SMALL ALPHA .. MATHEMATICAL BOLD ITALIC SMALL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D750 && codePoint <= 0x1D76E) { // MATHEMATICAL BOLD ITALIC EPSILON SYMBOL .. MATHEMATICAL SANS-SERIF BOLD CAPITAL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D770 && codePoint <= 0x1D788) { // MATHEMATICAL SANS-SERIF BOLD SMALL ALPHA .. MATHEMATICAL SANS-SERIF BOLD SMALL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D78A && codePoint <= 0x1D7A8) { // MATHEMATICAL SANS-SERIF BOLD EPSILON SYMBOL .. MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D7AA && codePoint <= 0x1D7C2) { // MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL ALPHA .. MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL OMEGA
-        return true;
-    }
-    if (codePoint >= 0x1D7C4 && codePoint <= 0x1D7CB) { // MATHEMATICAL SANS-SERIF BOLD ITALIC EPSILON SYMBOL .. MATHEMATICAL BOLD SMALL DIGAMMA
+    if (codePoint >= 0x1D6A8 && codePoint <= 0x1D6C0) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL BOLD CAPITAL ALPHA .. MATHEMATICAL BOLD CAPITAL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D6C2 && codePoint <= 0x1D6DA) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL BOLD SMALL ALPHA .. MATHEMATICAL BOLD SMALL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D6DC && codePoint <= 0x1D6FA) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL BOLD EPSILON SYMBOL .. MATHEMATICAL ITALIC CAPITAL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D6FC && codePoint <= 0x1D714) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL ITALIC SMALL ALPHA .. MATHEMATICAL ITALIC SMALL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D716 && codePoint <= 0x1D734) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL ITALIC EPSILON SYMBOL .. MATHEMATICAL BOLD ITALIC CAPITAL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D736 && codePoint <= 0x1D74E) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL BOLD ITALIC SMALL ALPHA .. MATHEMATICAL BOLD ITALIC SMALL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D750 && codePoint <= 0x1D76E) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL BOLD ITALIC EPSILON SYMBOL .. MATHEMATICAL SANS-SERIF BOLD CAPITAL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D770 && codePoint <= 0x1D788) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SANS-SERIF BOLD SMALL ALPHA .. MATHEMATICAL SANS-SERIF BOLD SMALL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D78A && codePoint <= 0x1D7A8) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SANS-SERIF BOLD EPSILON SYMBOL .. MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D7AA && codePoint <= 0x1D7C2) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL ALPHA .. MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL OMEGA
+        return true;
+    }
+    if (codePoint >= 0x1D7C4 && codePoint <= 0x1D7CB) {MOZ_RELEASE_ASSERT(0); // MATHEMATICAL SANS-SERIF BOLD ITALIC EPSILON SYMBOL .. MATHEMATICAL BOLD SMALL DIGAMMA
         return true;
     }
     if (codePoint >= 0x1D7CE && codePoint <= 0x1D7FF) { // MATHEMATICAL BOLD DIGIT ZERO .. MATHEMATICAL MONOSPACE DIGIT NINE
@@ -2895,7 +2895,7 @@ js::unicode::IsIdentifierPartNonBMP(uint
     if (codePoint >= 0x2CEB0 && codePoint <= 0x2EBE0) { // CJK Ideograph Extension F .. CJK Ideograph Extension F
         return true;
     }
-    if (codePoint >= 0x2F800 && codePoint <= 0x2FA1D) { // CJK COMPATIBILITY IDEOGRAPH-2F800 .. CJK COMPATIBILITY IDEOGRAPH-2FA1D
+    if (codePoint >= 0x2F800 && codePoint <= 0x2FA1D) {MOZ_RELEASE_ASSERT(0); // CJK COMPATIBILITY IDEOGRAPH-2F800 .. CJK COMPATIBILITY IDEOGRAPH-2FA1D
         return true;
     }
     if (codePoint >= 0x30000 && codePoint <= 0x3134A) { // CJK Ideograph Extension G .. CJK Ideograph Extension G
diff --git a/js/src/util/Utility.cpp b/js/src/util/Utility.cpp
--- a/js/src/util/Utility.cpp
+++ b/js/src/util/Utility.cpp
@@ -120,7 +120,7 @@ void js::ShutDownMallocAllocator() {
   // moz_dispose_arena(ArrayBufferContentsArena);
 }
 
-extern void js::AssertJSStringBufferInCorrectArena(const void* ptr) {
+extern void js::AssertJSStringBufferInCorrectArena(const void* ptr) {MOZ_RELEASE_ASSERT(0);
 //  `jemalloc_ptr_info()` only exists if MOZ_MEMORY is defined, and it only
 //  returns an arenaId if MOZ_DEBUG is defined. Otherwise, this function is
 //  a no-op.
diff --git a/js/src/vm/ArgumentsObject.cpp b/js/src/vm/ArgumentsObject.cpp
--- a/js/src/vm/ArgumentsObject.cpp
+++ b/js/src/vm/ArgumentsObject.cpp
@@ -268,7 +268,7 @@ ArgumentsObject* ArgumentsObject::create
 
   RootedObject proto(
       cx, GlobalObject::getOrCreateObjectPrototype(cx, cx->global()));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -321,7 +321,7 @@ ArgumentsObject* ArgumentsObject::create
   bool mapped = callee->baseScript()->hasMappedArgsObj();
   ArgumentsObject* templateObj =
       cx->realm()->getOrCreateArgumentsTemplateObject(cx, mapped);
-  if (!templateObj) {
+  if (!templateObj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -346,7 +346,7 @@ ArgumentsObject* ArgumentsObject::create
 
     data = reinterpret_cast<ArgumentsData*>(
         AllocateObjectBuffer<uint8_t>(cx, obj, numBytes));
-    if (!data) {
+    if (!data) {MOZ_RELEASE_ASSERT(0);
       // Make the object safe for GC.
       obj->initFixedSlot(DATA_SLOT, PrivateValue(nullptr));
       return nullptr;
@@ -462,7 +462,7 @@ ArgumentsObject* ArgumentsObject::finish
 
   ArgumentsData* data = reinterpret_cast<ArgumentsData*>(
       AllocateObjectBuffer<uint8_t>(cx, obj, numBytes));
-  if (!data) {
+  if (!data) {MOZ_RELEASE_ASSERT(0);
     // Make the object safe for GC. Don't report OOM, the slow path will
     // retry the allocation.
     cx->recoverFromOutOfMemory();
@@ -498,7 +498,7 @@ bool ArgumentsObject::obj_delProperty(JS
   if (JSID_IS_INT(id)) {
     unsigned arg = unsigned(JSID_TO_INT(id));
     if (arg < argsobj.initialLength() && !argsobj.isElementDeleted(arg)) {
-      if (!argsobj.markElementDeleted(cx, arg)) {
+      if (!argsobj.markElementDeleted(cx, arg)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -555,7 +555,7 @@ bool js::MappedArgSetter(JSContext* cx, 
   Handle<MappedArgumentsObject*> argsobj = obj.as<MappedArgumentsObject>();
 
   Rooted<mozilla::Maybe<PropertyDescriptor>> desc(cx);
-  if (!GetOwnPropertyDescriptor(cx, argsobj, id, &desc)) {
+  if (!GetOwnPropertyDescriptor(cx, argsobj, id, &desc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(desc.isSome());
@@ -621,7 +621,7 @@ bool ArgumentsObject::reifyIterator(JSCo
 
   RootedId iteratorId(cx, SYMBOL_TO_JSID(cx->wellKnownSymbols().iterator));
   RootedValue val(cx);
-  if (!ArgumentsObject::getArgumentsIterator(cx, &val)) {
+  if (!ArgumentsObject::getArgumentsIterator(cx, &val)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!NativeDefineDataProperty(cx, obj, iteratorId, val, JSPROP_RESOLVING)) {
@@ -661,7 +661,7 @@ bool MappedArgumentsObject::obj_resolve(
       return true;
     }
 
-    if (!reifyIterator(cx, argsobj)) {
+    if (!reifyIterator(cx, argsobj)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     *resolvedp = true;
@@ -702,17 +702,17 @@ bool MappedArgumentsObject::obj_enumerat
 
   // Trigger reflection.
   id = NameToId(cx->names().length);
-  if (!HasOwnProperty(cx, argsobj, id, &found)) {
+  if (!HasOwnProperty(cx, argsobj, id, &found)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   id = NameToId(cx->names().callee);
-  if (!HasOwnProperty(cx, argsobj, id, &found)) {
+  if (!HasOwnProperty(cx, argsobj, id, &found)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   id = SYMBOL_TO_JSID(cx->wellKnownSymbols().iterator);
-  if (!HasOwnProperty(cx, argsobj, id, &found)) {
+  if (!HasOwnProperty(cx, argsobj, id, &found)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -751,7 +751,7 @@ static bool DefineMappedIndex(JSContext*
 
   // First, resolve the property to simplify the code below.
   Rooted<PropertyResult> prop(cx);
-  if (!NativeLookupOwnProperty<CanGC>(cx, obj, id, &prop)) {
+  if (!NativeLookupOwnProperty<CanGC>(cx, obj, id, &prop)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -837,12 +837,12 @@ bool MappedArgumentsObject::obj_definePr
 
   // Step 6. NativeDefineProperty will lookup [[Value]] for us.
   if (defineMapped) {
-    if (!DefineMappedIndex(cx, argsobj, id, &newArgDesc, result)) {
+    if (!DefineMappedIndex(cx, argsobj, id, &newArgDesc, result)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
     if (!NativeDefineProperty(cx, obj.as<NativeObject>(), id, newArgDesc,
-                              result)) {
+                              result)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -855,7 +855,7 @@ bool MappedArgumentsObject::obj_definePr
   if (isMapped) {
     unsigned arg = unsigned(JSID_TO_INT(id));
     if (desc.isAccessorDescriptor()) {
-      if (!argsobj->markElementDeleted(cx, arg)) {
+      if (!argsobj->markElementDeleted(cx, arg)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -901,7 +901,7 @@ bool js::UnmappedArgSetter(JSContext* cx
   Handle<UnmappedArgumentsObject*> argsobj = obj.as<UnmappedArgumentsObject>();
 
   Rooted<mozilla::Maybe<PropertyDescriptor>> desc(cx);
-  if (!GetOwnPropertyDescriptor(cx, argsobj, id, &desc)) {
+  if (!GetOwnPropertyDescriptor(cx, argsobj, id, &desc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(desc.isSome());
@@ -941,7 +941,7 @@ bool UnmappedArgumentsObject::obj_resolv
       return true;
     }
 
-    if (!reifyIterator(cx, argsobj)) {
+    if (!reifyIterator(cx, argsobj)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     *resolvedp = true;
@@ -951,14 +951,14 @@ bool UnmappedArgumentsObject::obj_resolv
   if (JSID_IS_ATOM(id, cx->names().callee)) {
     RootedObject throwTypeError(
         cx, GlobalObject::getOrCreateThrowTypeError(cx, cx->global()));
-    if (!throwTypeError) {
+    if (!throwTypeError) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     unsigned attrs =
         JSPROP_RESOLVING | JSPROP_PERMANENT | JSPROP_GETTER | JSPROP_SETTER;
     if (!NativeDefineAccessorProperty(cx, argsobj, id, throwTypeError,
-                                      throwTypeError, attrs)) {
+                                      throwTypeError, attrs)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -995,17 +995,17 @@ bool UnmappedArgumentsObject::obj_enumer
 
   // Trigger reflection.
   id = NameToId(cx->names().length);
-  if (!HasOwnProperty(cx, argsobj, id, &found)) {
+  if (!HasOwnProperty(cx, argsobj, id, &found)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   id = NameToId(cx->names().callee);
-  if (!HasOwnProperty(cx, argsobj, id, &found)) {
+  if (!HasOwnProperty(cx, argsobj, id, &found)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   id = SYMBOL_TO_JSID(cx->wellKnownSymbols().iterator);
-  if (!HasOwnProperty(cx, argsobj, id, &found)) {
+  if (!HasOwnProperty(cx, argsobj, id, &found)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1059,7 +1059,7 @@ size_t ArgumentsObject::objectMoved(JSOb
   } else {
     AutoEnterOOMUnsafeRegion oomUnsafe;
     uint8_t* data = nsrc->zone()->pod_malloc<uint8_t>(nDataBytes);
-    if (!data) {
+    if (!data) {MOZ_RELEASE_ASSERT(0);
       oomUnsafe.crash(
           "Failed to allocate ArgumentsObject data while tenuring.");
     }
@@ -1074,7 +1074,7 @@ size_t ArgumentsObject::objectMoved(JSOb
 
   if (RareArgumentsData* srcRareData = nsrc->maybeRareData()) {
     uint32_t nbytes = RareArgumentsData::bytesRequired(nsrc->initialLength());
-    if (!nursery.isInside(srcRareData)) {
+    if (!nursery.isInside(srcRareData)) {MOZ_RELEASE_ASSERT(0);
       nursery.removeMallocedBufferDuringMinorGC(srcRareData);
     } else {
       AutoEnterOOMUnsafeRegion oomUnsafe;
diff --git a/js/src/vm/ArrayBufferObject.cpp b/js/src/vm/ArrayBufferObject.cpp
--- a/js/src/vm/ArrayBufferObject.cpp
+++ b/js/src/vm/ArrayBufferObject.cpp
@@ -162,17 +162,17 @@ void* js::MapBufferMemory(size_t mappedS
   // Test >= to guard against the case where multiple extant runtimes
   // race to allocate.
   if (liveBufferCount >= MaximumLiveMappedBuffers) {
-    if (OnLargeAllocationFailure) {
+    if (OnLargeAllocationFailure) {MOZ_RELEASE_ASSERT(0);
       OnLargeAllocationFailure();
     }
-    if (liveBufferCount >= MaximumLiveMappedBuffers) {
+    if (liveBufferCount >= MaximumLiveMappedBuffers) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
 #ifdef XP_WIN
   void* data = VirtualAlloc(nullptr, mappedSize, MEM_RESERVE, PAGE_NOACCESS);
-  if (!data) {
+  if (!data) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -184,7 +184,7 @@ void* js::MapBufferMemory(size_t mappedS
   void* data =
       MozTaggedAnonymousMmap(nullptr, mappedSize, PROT_NONE,
                              MAP_PRIVATE | MAP_ANON, -1, 0, "wasm-reserved");
-  if (data == MAP_FAILED) {
+  if (data == MAP_FAILED) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -211,7 +211,7 @@ bool js::CommitBufferMemory(void* dataEn
   MOZ_ASSERT(delta % gc::SystemPageSize() == 0);
 
 #ifdef XP_WIN
-  if (!VirtualAlloc(dataEnd, delta, MEM_COMMIT, PAGE_READWRITE)) {
+  if (!VirtualAlloc(dataEnd, delta, MEM_COMMIT, PAGE_READWRITE)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 #else   // XP_WIN
@@ -239,7 +239,7 @@ bool js::ExtendBufferMapping(void* dataP
   uint32_t delta = newMappedSize - mappedSize;
   if (!VirtualAlloc(mappedEnd, delta, MEM_RESERVE, PAGE_NOACCESS)) {
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   return true;
 #elif defined(XP_LINUX)
   // Note this will not move memory (no MREMAP_MAYMOVE specified)
@@ -414,7 +414,7 @@ static ArrayBufferContents AllocateUnini
   // First attempt a normal allocation.
   uint8_t* p = cx->maybe_pod_arena_malloc<uint8_t>(js::ArrayBufferContentsArena,
                                                    nbytes.get());
-  if (MOZ_UNLIKELY(!p)) {
+  if (MOZ_UNLIKELY(!p)) {MOZ_RELEASE_ASSERT(0);
     // Otherwise attempt a large allocation, calling the
     // large-allocation-failure callback if necessary.
     p = static_cast<uint8_t*>(cx->runtime()->onOutOfMemoryCanGC(
@@ -432,7 +432,7 @@ static ArrayBufferContents AllocateArray
   // First attempt a normal allocation.
   uint8_t* p = cx->maybe_pod_arena_calloc<uint8_t>(js::ArrayBufferContentsArena,
                                                    nbytes.get());
-  if (MOZ_UNLIKELY(!p)) {
+  if (MOZ_UNLIKELY(!p)) {MOZ_RELEASE_ASSERT(0);
     // Otherwise attempt a large allocation, calling the
     // large-allocation-failure callback if necessary.
     p = static_cast<uint8_t*>(cx->runtime()->onOutOfMemoryCanGC(
@@ -585,7 +585,7 @@ void ArrayBufferObject::detach(JSContext
 bool WasmArrayRawBuffer::extendMappedSize(uint64_t maxSize) {
   size_t newMappedSize = wasm::ComputeMappedSize(maxSize);
   MOZ_ASSERT(mappedSize_ <= newMappedSize);
-  if (mappedSize_ == newMappedSize) {
+  if (mappedSize_ == newMappedSize) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -597,7 +597,7 @@ bool WasmArrayRawBuffer::extendMappedSiz
   return true;
 }
 
-void WasmArrayRawBuffer::tryGrowMaxSizeInPlace(uint64_t deltaMaxSize) {
+void WasmArrayRawBuffer::tryGrowMaxSizeInPlace(uint64_t deltaMaxSize) {MOZ_RELEASE_ASSERT(0);
   CheckedInt<uint64_t> newMaxSize = maxSize_.value();
   newMaxSize += deltaMaxSize;
   MOZ_ASSERT(newMaxSize.isValid());
@@ -720,7 +720,7 @@ static bool CreateSpecificWasmBuffer32(
   if (!buffer) {
     if (useHugeMemory) {
       WarnNumberASCII(cx, JSMSG_WASM_HUGE_MEMORY_FAILED);
-      if (cx->isExceptionPending()) {
+      if (cx->isExceptionPending()) {MOZ_RELEASE_ASSERT(0);
         cx->clearPendingException();
       }
 
@@ -730,25 +730,25 @@ static bool CreateSpecificWasmBuffer32(
 
     // If we fail, and have a clampedMaxSize, try to reserve the biggest chunk
     // in the range [initialSize, clampedMaxSize) using log backoff.
-    if (!clampedMaxSize) {
+    if (!clampedMaxSize) {MOZ_RELEASE_ASSERT(0);
       wasm::Log(cx, "new Memory({initial=%" PRIu64 " bytes}) failed",
                 initialSize);
       ReportOutOfMemory(cx);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     uint64_t cur = clampedMaxSize.value() / 2;
 
-    for (; cur > initialSize; cur /= 2) {
+    for (; cur > initialSize; cur /= 2) {MOZ_RELEASE_ASSERT(0);
       uint64_t clampedMaxSize = RoundUp(cur, wasm::PageSize);
       buffer = RawbufT::Allocate(BufferSize(size_t(initialSize)),
                                  Some(clampedMaxSize), mappedSize);
-      if (buffer) {
+      if (buffer) {MOZ_RELEASE_ASSERT(0);
         break;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
-    if (!buffer) {
+    if (!buffer) {MOZ_RELEASE_ASSERT(0);
       wasm::Log(cx, "new Memory({initial=%" PRIu64 " bytes}) failed",
                 initialSize);
       ReportOutOfMemory(cx);
@@ -756,9 +756,9 @@ static bool CreateSpecificWasmBuffer32(
     }
 
     // Try to grow our chunk as much as possible.
-    for (size_t d = cur / 2; d >= wasm::PageSize; d /= 2) {
+    for (size_t d = cur / 2; d >= wasm::PageSize; d /= 2) {MOZ_RELEASE_ASSERT(0);
       buffer->tryGrowMaxSizeInPlace(RoundUp(d, wasm::PageSize));
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   // ObjT::createFromNewRawBuffer assumes ownership of |buffer| even in case
@@ -766,14 +766,14 @@ static bool CreateSpecificWasmBuffer32(
   RootedArrayBufferObjectMaybeShared object(
       cx, ObjT::createFromNewRawBuffer(cx, buffer,
                                        BufferSize(size_t(initialSize))));
-  if (!object) {
+  if (!object) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   maybeSharedObject.set(object);
 
   // See MaximumLiveMappedBuffers comment above.
-  if (liveBufferCount > StartSyncFullGCAtLiveBufferCount) {
+  if (liveBufferCount > StartSyncFullGCAtLiveBufferCount) {MOZ_RELEASE_ASSERT(0);
     JS::PrepareForFullGC(cx);
     JS::NonIncrementalGC(cx, GC_NORMAL, JS::GCReason::TOO_MUCH_WASM_MEMORY);
     allocatedSinceLastTrigger = 0;
@@ -1023,12 +1023,12 @@ bool ArrayBufferObject::wasmGrowToSizeIn
   // last fallible operation.
 
   // Note, caller must guard on limit appropriate for the memory type
-  if (newSize.get() > ArrayBufferObject::maxBufferByteLength()) {
+  if (newSize.get() > ArrayBufferObject::maxBufferByteLength()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   newBuf.set(ArrayBufferObject::createEmpty(cx));
-  if (!newBuf) {
+  if (!newBuf) {MOZ_RELEASE_ASSERT(0);
     cx->clearPendingException();
     return false;
   }
@@ -1066,7 +1066,7 @@ bool ArrayBufferObject::wasmMovingGrowTo
   // unmodified and valid.
 
   // Note, caller must guard on the limit appropriate to the memory type
-  if (newSize.get() > ArrayBufferObject::maxBufferByteLength()) {
+  if (newSize.get() > ArrayBufferObject::maxBufferByteLength()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1076,7 +1076,7 @@ bool ArrayBufferObject::wasmMovingGrowTo
   }
 
   newBuf.set(ArrayBufferObject::createEmpty(cx));
-  if (!newBuf) {
+  if (!newBuf) {MOZ_RELEASE_ASSERT(0);
     cx->clearPendingException();
     return false;
   }
@@ -1128,7 +1128,7 @@ ArrayBufferObject* ArrayBufferObject::cr
   MOZ_ASSERT(contents.kind() != WASM);
 
   // 24.1.1.1, step 3 (Inlined 6.2.6.1 CreateByteDataBlock, step 2).
-  if (!CheckArrayBufferTooLarge(cx, nbytes.get())) {
+  if (!CheckArrayBufferTooLarge(cx, nbytes.get())) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1166,7 +1166,7 @@ ArrayBufferObject* ArrayBufferObject::cr
   Rooted<ArrayBufferObject*> buffer(
       cx, NewObjectWithClassProto<ArrayBufferObject>(cx, nullptr, allocKind,
                                                      TenuredObject));
-  if (!buffer) {
+  if (!buffer) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1201,11 +1201,11 @@ ArrayBufferObject::createBufferAndData(
     MOZ_ASSERT(int(nbytes.get()) <= newSlots * int(sizeof(Value)));
 
     nslots += newSlots;
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     data = FillType == FillContents::Uninitialized
                ? AllocateUninitializedArrayBufferContents(cx, nbytes)
                : AllocateArrayBufferContents(cx, nbytes);
-    if (!data) {
+    if (!data) {MOZ_RELEASE_ASSERT(0);
       return {nullptr, nullptr};
     }
   }
@@ -1215,7 +1215,7 @@ ArrayBufferObject::createBufferAndData(
 
   ArrayBufferObject* buffer = NewObjectWithClassProto<ArrayBufferObject>(
       cx, proto, allocKind, GenericObject);
-  if (!buffer) {
+  if (!buffer) {MOZ_RELEASE_ASSERT(0);
     return {nullptr, nullptr};
   }
 
@@ -1241,7 +1241,7 @@ ArrayBufferObject::createBufferAndData(
 
 /* static */ ArrayBufferObject* ArrayBufferObject::copy(
     JSContext* cx, JS::Handle<ArrayBufferObject*> unwrappedArrayBuffer) {
-  if (unwrappedArrayBuffer->isDetached()) {
+  if (unwrappedArrayBuffer->isDetached()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_TYPED_ARRAY_DETACHED);
     return nullptr;
@@ -1548,12 +1548,12 @@ bool InnerViewTable::addView(JSContext* 
       }
     }
 
-    if (!views.append(view)) {
+    if (!views.append(view)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
   } else {
-    if (!map.add(p, buffer, ViewVector(cx->zone()))) {
+    if (!map.add(p, buffer, ViewVector(cx->zone()))) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
@@ -1668,7 +1668,7 @@ JS_FRIEND_API uint8_t* JS::GetArrayBuffe
 static ArrayBufferObject* UnwrapArrayBuffer(
     JSContext* cx, JS::Handle<JSObject*> maybeArrayBuffer) {
   JSObject* obj = CheckedUnwrapStatic(maybeArrayBuffer);
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     ReportAccessDenied(cx);
     return nullptr;
   }
@@ -1688,7 +1688,7 @@ JS_FRIEND_API bool JS::DetachArrayBuffer
   cx->check(obj);
 
   Rooted<ArrayBufferObject*> unwrappedBuffer(cx, UnwrapArrayBuffer(cx, obj));
-  if (!unwrappedBuffer) {
+  if (!unwrappedBuffer) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1806,11 +1806,11 @@ JS_PUBLIC_API void* JS::StealArrayBuffer
   cx->check(obj);
 
   Rooted<ArrayBufferObject*> unwrappedBuffer(cx, UnwrapArrayBuffer(cx, obj));
-  if (!unwrappedBuffer) {
+  if (!unwrappedBuffer) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (unwrappedBuffer->isDetached()) {
+  if (unwrappedBuffer->isDetached()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_TYPED_ARRAY_DETACHED);
     return nullptr;
diff --git a/js/src/vm/ArrayBufferObjectMaybeShared.cpp b/js/src/vm/ArrayBufferObjectMaybeShared.cpp
--- a/js/src/vm/ArrayBufferObjectMaybeShared.cpp
+++ b/js/src/vm/ArrayBufferObjectMaybeShared.cpp
@@ -30,7 +30,7 @@ JS_PUBLIC_API void JS::GetArrayBufferMay
     JSObject* obj, size_t* length, bool* isSharedMemory, uint8_t** data) {
   MOZ_ASSERT(obj->is<ArrayBufferObjectMaybeShared>());
 
-  if (obj->is<SharedArrayBufferObject>()) {
+  if (obj->is<SharedArrayBufferObject>()) {MOZ_RELEASE_ASSERT(0);
     auto* buffer = &obj->as<SharedArrayBufferObject>();
     *length = buffer->byteLength().get();
     *data = buffer->dataPointerShared().unwrap();
@@ -47,7 +47,7 @@ JS_PUBLIC_API uint8_t* JS::GetArrayBuffe
     JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&) {
   MOZ_ASSERT(obj->maybeUnwrapIf<ArrayBufferObjectMaybeShared>());
 
-  if (ArrayBufferObject* aobj = obj->maybeUnwrapIf<ArrayBufferObject>()) {
+  if (ArrayBufferObject* aobj = obj->maybeUnwrapIf<ArrayBufferObject>()) {MOZ_RELEASE_ASSERT(0);
     *isSharedMemory = false;
     return aobj->dataPointer();
   } else if (SharedArrayBufferObject* saobj =
diff --git a/js/src/vm/ArrayBufferViewObject.cpp b/js/src/vm/ArrayBufferViewObject.cpp
--- a/js/src/vm/ArrayBufferViewObject.cpp
+++ b/js/src/vm/ArrayBufferViewObject.cpp
@@ -179,12 +179,12 @@ JS_FRIEND_API uint8_t* JS_GetArrayBuffer
                                                       uint8_t* buffer,
                                                       size_t bufSize) {
   ArrayBufferViewObject* view = obj->maybeUnwrapAs<ArrayBufferViewObject>();
-  if (!view) {
+  if (!view) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   // Disallow shared memory until it is needed.
-  if (view->isSharedMemory()) {
+  if (view->isSharedMemory()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -214,7 +214,7 @@ JS_FRIEND_API JSObject* JS_GetArrayBuffe
 
   Rooted<ArrayBufferViewObject*> unwrappedView(
       cx, obj->maybeUnwrapAs<ArrayBufferViewObject>());
-  if (!unwrappedView) {
+  if (!unwrappedView) {MOZ_RELEASE_ASSERT(0);
     ReportAccessDenied(cx);
     return nullptr;
   }
@@ -223,7 +223,7 @@ JS_FRIEND_API JSObject* JS_GetArrayBuffe
   {
     AutoRealm ar(cx, unwrappedView);
     unwrappedBuffer = ArrayBufferViewObject::bufferObject(cx, unwrappedView);
-    if (!unwrappedBuffer) {
+    if (!unwrappedBuffer) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
diff --git a/js/src/vm/AsyncFunction.cpp b/js/src/vm/AsyncFunction.cpp
--- a/js/src/vm/AsyncFunction.cpp
+++ b/js/src/vm/AsyncFunction.cpp
@@ -134,7 +134,7 @@ static bool AsyncFunctionResume(JSContex
 
     // Handle the OOM case mentioned above.
     if (resultPromise->state() == JS::PromiseState::Pending &&
-        cx->isExceptionPending()) {
+        cx->isExceptionPending()) {MOZ_RELEASE_ASSERT(0);
       RootedValue exn(cx);
       if (!GetAndClearException(cx, &exn)) {
         return false;
@@ -173,7 +173,7 @@ JSObject* js::AsyncFunctionResolve(
     HandleValue valueOrReason, AsyncFunctionResolveKind resolveKind) {
   Rooted<PromiseObject*> promise(cx, generator->promise());
   if (resolveKind == AsyncFunctionResolveKind::Fulfill) {
-    if (!AsyncFunctionReturned(cx, promise, valueOrReason)) {
+    if (!AsyncFunctionReturned(cx, promise, valueOrReason)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
@@ -209,7 +209,7 @@ AsyncFunctionGeneratorObject* AsyncFunct
   MOZ_ASSERT(fun->isAsync() && !fun->isGenerator());
 
   Rooted<PromiseObject*> resultPromise(cx, CreatePromiseObjectForAsync(cx));
-  if (!resultPromise) {
+  if (!resultPromise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -252,26 +252,26 @@ AsyncFunctionGeneratorObject* AsyncFunct
   MOZ_ASSERT(module->script()->isAsync());
 
   Rooted<PromiseObject*> resultPromise(cx, CreatePromiseObjectForAsync(cx));
-  if (!resultPromise) {
+  if (!resultPromise) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   Rooted<AsyncFunctionGeneratorObject*> obj(
       cx, NewBuiltinClassInstance<AsyncFunctionGeneratorObject>(cx));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   obj->initFixedSlot(PROMISE_SLOT, ObjectValue(*resultPromise));
 
   RootedObject onFulfilled(
       cx, NewHandler(cx, AsyncModuleExecutionFulfilledHandler, module));
-  if (!onFulfilled) {
+  if (!onFulfilled) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedObject onRejected(
       cx, NewHandler(cx, AsyncModuleExecutionRejectedHandler, module));
-  if (!onRejected) {
+  if (!onRejected) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/vm/AsyncIteration.cpp b/js/src/vm/AsyncIteration.cpp
--- a/js/src/vm/AsyncIteration.cpp
+++ b/js/src/vm/AsyncIteration.cpp
@@ -80,7 +80,7 @@ JSObject* AsyncFromSyncIteratorObject::c
   RootedObject proto(cx,
                      GlobalObject::getOrCreateAsyncFromSyncIteratorPrototype(
                          cx, cx->global()));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -182,7 +182,7 @@ static AsyncGeneratorObject* OrdinaryCre
 
   // Step 2.
   RootedValue protoVal(cx);
-  if (!GetProperty(cx, fun, fun, cx->names().prototype, &protoVal)) {
+  if (!GetProperty(cx, fun, fun, cx->names().prototype, &protoVal)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -248,12 +248,12 @@ AsyncGeneratorRequest* AsyncGeneratorObj
     }
 
     Rooted<ListObject*> queue(cx, ListObject::create(cx));
-    if (!queue) {
+    if (!queue) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     RootedValue requestVal(cx, ObjectValue(*asyncGenObj->singleQueueRequest()));
-    if (!queue->append(cx, requestVal)) {
+    if (!queue->append(cx, requestVal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     requestVal = ObjectValue(*request);
@@ -446,14 +446,14 @@ static const JSFunctionSpec async_genera
 
 bool GlobalObject::initAsyncIteratorProto(JSContext* cx,
                                           Handle<GlobalObject*> global) {
-  if (global->getReservedSlot(ASYNC_ITERATOR_PROTO).isObject()) {
+  if (global->getReservedSlot(ASYNC_ITERATOR_PROTO).isObject()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   // 25.1.3 The %AsyncIteratorPrototype% Object
   RootedObject asyncIterProto(
       cx, GlobalObject::createBlankPrototype<PlainObject>(cx, global));
-  if (!asyncIterProto) {
+  if (!asyncIterProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!DefinePropertiesAndFunctions(cx, asyncIterProto, nullptr,
@@ -467,13 +467,13 @@ bool GlobalObject::initAsyncIteratorProt
 
 bool GlobalObject::initAsyncFromSyncIteratorProto(
     JSContext* cx, Handle<GlobalObject*> global) {
-  if (global->getReservedSlot(ASYNC_FROM_SYNC_ITERATOR_PROTO).isObject()) {
+  if (global->getReservedSlot(ASYNC_FROM_SYNC_ITERATOR_PROTO).isObject()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   RootedObject asyncIterProto(
       cx, GlobalObject::getOrCreateAsyncIteratorPrototype(cx, global));
-  if (!asyncIterProto) {
+  if (!asyncIterProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -481,7 +481,7 @@ bool GlobalObject::initAsyncFromSyncIter
   RootedObject asyncFromSyncIterProto(
       cx, GlobalObject::createBlankPrototypeInheriting(cx, &PlainObject::class_,
                                                        asyncIterProto));
-  if (!asyncFromSyncIterProto) {
+  if (!asyncFromSyncIterProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!DefinePropertiesAndFunctions(cx, asyncFromSyncIterProto, nullptr,
@@ -531,26 +531,26 @@ static bool AsyncGeneratorFunctionClassF
 
   RootedValue asyncGenFunctionVal(cx, ObjectValue(*asyncGenFunction));
   if (!DefineDataProperty(cx, asyncGenerator, cx->names().constructor,
-                          asyncGenFunctionVal, JSPROP_READONLY)) {
+                          asyncGenFunctionVal, JSPROP_READONLY)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(!asyncGenerator->as<NativeObject>().inDictionaryMode());
 
   RootedObject asyncIterProto(
       cx, GlobalObject::getOrCreateAsyncIteratorPrototype(cx, global));
-  if (!asyncIterProto) {
+  if (!asyncIterProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // 25.5 AsyncGenerator Objects
   RootedObject asyncGenProto(cx, GlobalObject::createBlankPrototypeInheriting(
                                      cx, &PlainObject::class_, asyncIterProto));
-  if (!asyncGenProto) {
+  if (!asyncGenProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!DefinePropertiesAndFunctions(cx, asyncGenProto, nullptr,
                                     async_generator_methods) ||
-      !DefineToStringTag(cx, asyncGenProto, cx->names().AsyncGenerator)) {
+      !DefineToStringTag(cx, asyncGenProto, cx->names().AsyncGenerator)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -601,7 +601,7 @@ static bool AsyncIteratorConstructor(JSC
   // Step 2.
   RootedObject proto(cx);
   if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_AsyncIterator,
-                                          &proto)) {
+                                          &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -665,20 +665,20 @@ NativeObject* GlobalObject::getOrCreateA
 /* static */
 bool GlobalObject::initAsyncIteratorHelperProto(JSContext* cx,
                                                 Handle<GlobalObject*> global) {
-  if (global->getReservedSlot(ASYNC_ITERATOR_HELPER_PROTO).isObject()) {
+  if (global->getReservedSlot(ASYNC_ITERATOR_HELPER_PROTO).isObject()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   RootedObject asyncIterProto(
       cx, GlobalObject::getOrCreateAsyncIteratorPrototype(cx, global));
-  if (!asyncIterProto) {
+  if (!asyncIterProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject asyncIteratorHelperProto(
       cx, GlobalObject::createBlankPrototypeInheriting(
               cx, &AsyncIteratorHelperPrototypeClass, asyncIterProto));
-  if (!asyncIteratorHelperProto) {
+  if (!asyncIteratorHelperProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!DefinePropertiesAndFunctions(cx, asyncIteratorHelperProto, nullptr,
diff --git a/js/src/vm/BigIntType.cpp b/js/src/vm/BigIntType.cpp
--- a/js/src/vm/BigIntType.cpp
+++ b/js/src/vm/BigIntType.cpp
@@ -150,7 +150,7 @@ BigInt* BigInt::createUninitialized(JSCo
   }
 
   BigInt* x = AllocateBigInt(cx, heap);
-  if (!x) {
+  if (!x) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -244,7 +244,7 @@ BigInt* BigInt::createFromNonZeroRawUint
   }
 
   BigInt* result = createUninitialized(cx, resultLength, isNegative);
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   result->setDigit(0, n);
@@ -436,7 +436,7 @@ void BigInt::internalMultiplyAdd(BigInt*
     result->setDigit(n++, carry + high);
 
     // Current callers don't pass in such large results, but let's be robust.
-    while (n < result->digitLength()) {
+    while (n < result->digitLength()) {MOZ_RELEASE_ASSERT(0);
       result->setDigit(n++, 0);
     }
   } else {
@@ -561,7 +561,7 @@ BigInt* BigInt::absoluteAdd(JSContext* c
       }
     }
     BigInt* result = createUninitialized(cx, resultLength, resultNegative);
-    if (!result) {
+    if (!result) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     result->setDigit(0, res);
@@ -629,7 +629,7 @@ BigInt* BigInt::absoluteSub(JSContext* c
   }
 
   BigInt* result = createUninitialized(cx, x->digitLength(), resultNegative);
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   Digit borrow = 0;
@@ -674,18 +674,18 @@ bool BigInt::absoluteDivWithDigitDivisor
   MOZ_ASSERT(!x->isZero());
   *remainder = 0;
   if (divisor == 1) {
-    if (quotient) {
+    if (quotient) {MOZ_RELEASE_ASSERT(0);
       BigInt* q;
-      if (x->isNegative() == quotientNegative) {
+      if (x->isNegative() == quotientNegative) {MOZ_RELEASE_ASSERT(0);
         q = x;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         q = neg(cx, x);
-        if (!q) {
+        if (!q) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
-      }
+      }MOZ_RELEASE_ASSERT(0);
       quotient.value().set(q);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -693,7 +693,7 @@ bool BigInt::absoluteDivWithDigitDivisor
   if (quotient) {
     if (!quotient.value()) {
       BigInt* q = createUninitialized(cx, length, quotientNegative);
-      if (!q) {
+      if (!q) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       quotient.value().set(q);
@@ -714,7 +714,7 @@ bool BigInt::absoluteDivWithDigitDivisor
 
 // Adds `summand` onto `this`, starting with `summand`'s 0th digit
 // at `this`'s `startIndex`'th digit. Returns the "carry" (0 or 1).
-BigInt::Digit BigInt::absoluteInplaceAdd(BigInt* summand, unsigned startIndex) {
+BigInt::Digit BigInt::absoluteInplaceAdd(BigInt* summand, unsigned startIndex) {MOZ_RELEASE_ASSERT(0);
   Digit carry = 0;
   unsigned n = summand->digitLength();
   MOZ_ASSERT(digitLength() > startIndex,
@@ -769,7 +769,7 @@ void BigInt::inplaceRightShiftLowZeroBit
   MOZ_ASSERT(!(digit(0) & ((static_cast<Digit>(1) << shift) - 1)),
              "should only be shifting away zeroes");
 
-  if (!shift) {
+  if (!shift) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -793,17 +793,17 @@ BigInt* BigInt::absoluteLeftShiftAlwaysC
   unsigned n = x->digitLength();
   unsigned resultLength = mode == LeftShiftMode::AlwaysAddOneDigit ? n + 1 : n;
   BigInt* result = createUninitialized(cx, resultLength, x->isNegative());
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   if (!shift) {
-    for (unsigned i = 0; i < n; i++) {
+    for (unsigned i = 0; i < n; i++) {MOZ_RELEASE_ASSERT(0);
       result->setDigit(i, x->digit(i));
     }
-    if (mode == LeftShiftMode::AlwaysAddOneDigit) {
+    if (mode == LeftShiftMode::AlwaysAddOneDigit) {MOZ_RELEASE_ASSERT(0);
       result->setDigit(n, 0);
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     return result;
   }
@@ -857,7 +857,7 @@ bool BigInt::absoluteDivWithBigIntDiviso
   RootedBigInt q(cx);
   if (quotient) {
     q = createUninitialized(cx, m + 1, isNegative);
-    if (!q) {
+    if (!q) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -865,7 +865,7 @@ bool BigInt::absoluteDivWithBigIntDiviso
   // In each iteration, `qhatv` holds `divisor` * `current quotient digit`.
   // "v" is the book's name for `divisor`, `qhat` the current quotient digit.
   RootedBigInt qhatv(cx, createUninitialized(cx, n + 1, isNegative));
-  if (!qhatv) {
+  if (!qhatv) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -881,10 +881,10 @@ bool BigInt::absoluteDivWithBigIntDiviso
   if (shift > 0) {
     shiftedDivisor = absoluteLeftShiftAlwaysCopy(cx, divisor, shift,
                                                  LeftShiftMode::SameSizeResult);
-    if (!shiftedDivisor) {
+    if (!shiftedDivisor) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     shiftedDivisor = divisor;
   }
 
@@ -893,7 +893,7 @@ bool BigInt::absoluteDivWithBigIntDiviso
   RootedBigInt u(cx,
                  absoluteLeftShiftAlwaysCopy(cx, dividend, shift,
                                              LeftShiftMode::AlwaysAddOneDigit));
-  if (!u) {
+  if (!u) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -922,14 +922,14 @@ bool BigInt::absoluteDivWithBigIntDiviso
       // qhat * v_{n-2} > (rhat << DigitBits) + u_{j+n-2}.
       Digit vn2 = shiftedDivisor->digit(n - 2);
       Digit ujn2 = u->digit(j + n - 2);
-      while (productGreaterThan(qhat, vn2, rhat, ujn2)) {
+      while (productGreaterThan(qhat, vn2, rhat, ujn2)) {MOZ_RELEASE_ASSERT(0);
         qhat--;
         Digit prevRhat = rhat;
         rhat += vn1;
         // v[n-1] >= 0, so this tests for overflow.
-        if (rhat < prevRhat) {
+        if (rhat < prevRhat) {MOZ_RELEASE_ASSERT(0);
           break;
-        }
+        }MOZ_RELEASE_ASSERT(0);
       }
     }
 
@@ -940,7 +940,7 @@ bool BigInt::absoluteDivWithBigIntDiviso
     // the (shifted) divisor.
     internalMultiplyAdd(shiftedDivisor, qhat, 0, n, qhatv);
     Digit c = u->absoluteInplaceSub(qhatv, j);
-    if (c) {
+    if (c) {MOZ_RELEASE_ASSERT(0);
       c = u->absoluteInplaceAdd(shiftedDivisor, j);
       u->setDigit(j + n, u->digit(j + n) + c);
       qhat--;
@@ -953,7 +953,7 @@ bool BigInt::absoluteDivWithBigIntDiviso
 
   if (quotient) {
     BigInt* bi = destructivelyTrimHighZeroDigits(cx, q);
-    if (!bi) {
+    if (!bi) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     quotient.value().set(q);
@@ -997,7 +997,7 @@ inline BigInt* BigInt::absoluteBitwiseOp
   bool resultNegative = false;
 
   BigInt* result = createUninitialized(cx, resultLength, resultNegative);
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1092,7 +1092,7 @@ BigInt* BigInt::absoluteSubOne(JSContext
   }
 
   BigInt* result = createUninitialized(cx, length, resultNegative);
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1219,13 +1219,13 @@ JSLinearString* BigInt::toStringBasePowe
   const size_t bitLength = length * DigitBits - DigitLeadingZeroes(msd);
   const size_t charsRequired = CeilDiv(bitLength, bitsPerChar) + sign;
 
-  if (charsRequired > JSString::MAX_LENGTH) {
+  if (charsRequired > JSString::MAX_LENGTH) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
 
   auto resultChars = cx->make_pod_array<char>(charsRequired);
-  if (!resultChars) {
+  if (!resultChars) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1363,13 +1363,13 @@ JSLinearString* BigInt::toStringGeneric(
 
   size_t maximumCharactersRequired =
       calculateMaximumCharactersRequired(x, radix);
-  if (maximumCharactersRequired > JSString::MAX_LENGTH) {
+  if (maximumCharactersRequired > JSString::MAX_LENGTH) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
 
   UniqueChars resultString(js_pod_malloc<char>(maximumCharactersRequired));
-  if (!resultString) {
+  if (!resultString) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -1401,7 +1401,7 @@ JSLinearString* BigInt::toStringGeneric(
     do {
       Digit chunk;
       if (!absoluteDivWithDigitDivisor(cx, dividend, chunkDivisor, Some(&rest),
-                                       &chunk, dividend->isNegative())) {
+                                       &chunk, dividend->isNegative())) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -1436,7 +1436,7 @@ JSLinearString* BigInt::toStringGeneric(
 
   // Remove leading zeroes.
   while (writePos + 1 < maximumCharactersRequired &&
-         resultString[writePos] == '0') {
+         resultString[writePos] == '0') {MOZ_RELEASE_ASSERT(0);
     writePos++;
   }
 
@@ -1453,7 +1453,7 @@ JSLinearString* BigInt::toStringGeneric(
 
 static void FreeDigits(JSContext* cx, BigInt* bi, BigInt::Digit* digits,
                        size_t nbytes) {
-  if (cx->isHelperThreadContext()) {
+  if (cx->isHelperThreadContext()) {MOZ_RELEASE_ASSERT(0);
     js_free(digits);
   } else if (bi->isTenured()) {
     MOZ_ASSERT(!cx->nursery().isInside(digits));
@@ -1491,7 +1491,7 @@ BigInt* BigInt::destructivelyTrimHighZer
     size_t oldLength = x->digitLength();
     Digit* newdigits =
         js::ReallocateBigIntDigits(cx, x, x->heapDigits_, oldLength, newLength);
-    if (!newdigits) {
+    if (!newdigits) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     x->heapDigits_ = newdigits;
@@ -1582,11 +1582,11 @@ BigInt* BigInt::parseLiteralDigits(JSCon
   unsigned limitA = 'A' + (radix - 10);
 
   size_t length;
-  if (!calculateMaximumDigitsRequired(cx, radix, end - start, &length)) {
+  if (!calculateMaximumDigitsRequired(cx, radix, end - start, &length)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   BigInt* result = createUninitialized(cx, length, isNegative, heap);
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1700,7 +1700,7 @@ BigInt* BigInt::createFromDouble(JSConte
   MOZ_ASSERT(exponent >= 0);
   int length = exponent / DigitBits + 1;
   BigInt* result = createUninitialized(cx, length, d < 0);
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1794,7 +1794,7 @@ BigInt* BigInt::createFromUint64(JSConte
 
 BigInt* BigInt::createFromInt64(JSContext* cx, int64_t n) {
   BigInt* res = createFromUint64(cx, Abs(n));
-  if (!res) {
+  if (!res) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1830,7 +1830,7 @@ BigInt* BigInt::copy(JSContext* cx, Hand
 
   BigInt* result =
       createUninitialized(cx, x->digitLength(), x->isNegative(), heap);
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   for (size_t i = 0; i < x->digitLength(); i++) {
@@ -1953,7 +1953,7 @@ BigInt* BigInt::div(JSContext* cx, Handl
 
     Digit remainder;
     if (!absoluteDivWithDigitDivisor(cx, x, divisor, Some(&quotient),
-                                     &remainder, resultNegative)) {
+                                     &remainder, resultNegative)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
@@ -1997,7 +1997,7 @@ BigInt* BigInt::mod(JSContext* cx, Handl
     Digit remainderDigit;
     bool unusedQuotientNegative = false;
     if (!absoluteDivWithDigitDivisor(cx, x, divisor, Nothing(), &remainderDigit,
-                                     unusedQuotientNegative)) {
+                                     unusedQuotientNegative)) {MOZ_RELEASE_ASSERT(0);
       MOZ_CRASH("BigInt div by digit failed unexpectedly");
     }
 
@@ -2050,7 +2050,7 @@ BigInt* BigInt::pow(JSContext* cx, Handl
   // results.
   static_assert(MaxBitLength < std::numeric_limits<Digit>::max(),
                 "unexpectedly large MaxBitLength");
-  if (y->digitLength() > 1) {
+  if (y->digitLength() > 1) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_BIGINT_TOO_LARGE);
     return nullptr;
@@ -2059,7 +2059,7 @@ BigInt* BigInt::pow(JSContext* cx, Handl
   if (exponent == 1) {
     return x;
   }
-  if (exponent >= MaxBitLength) {
+  if (exponent >= MaxBitLength) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_BIGINT_TOO_LARGE);
     return nullptr;
@@ -2085,7 +2085,7 @@ BigInt* BigInt::pow(JSContext* cx, Handl
 
     int length = 1 + (n / DigitBits);
     BigInt* result = createUninitialized(cx, length, resultNegative);
-    if (!result) {
+    if (!result) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     result->initializeDigitsToZero();
@@ -2127,12 +2127,12 @@ BigInt* BigInt::pow(JSContext* cx, Handl
     }
 
     runningSquare = createFromNonZeroRawUint64(cx, runningSquareInt, false);
-    if (!runningSquare) {
+    if (!runningSquare) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     result = createFromNonZeroRawUint64(cx, resultInt, resultNegative);
-    if (!result) {
+    if (!result) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -2140,7 +2140,7 @@ BigInt* BigInt::pow(JSContext* cx, Handl
   // This implicitly sets the result's sign correctly.
   while (true) {
     runningSquare = mul(cx, runningSquare, runningSquare);
-    if (!runningSquare) {
+    if (!runningSquare) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -2149,7 +2149,7 @@ BigInt* BigInt::pow(JSContext* cx, Handl
         result = runningSquare;
       } else {
         result = mul(cx, result, runningSquare);
-        if (!result) {
+        if (!result) {MOZ_RELEASE_ASSERT(0);
           return nullptr;
         }
       }
@@ -2167,7 +2167,7 @@ BigInt* BigInt::lshByAbsolute(JSContext*
     return x;
   }
 
-  if (y->digitLength() > 1 || y->digit(0) > MaxBitLength) {
+  if (y->digitLength() > 1 || y->digit(0) > MaxBitLength) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_BIGINT_TOO_LARGE);
     return nullptr;
@@ -2259,7 +2259,7 @@ BigInt* BigInt::rshByAbsolute(JSContext*
   MOZ_ASSERT(resultLength <= length);
   RootedBigInt result(cx,
                       createUninitialized(cx, resultLength, x->isNegative()));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (!bitsShift) {
@@ -2323,15 +2323,15 @@ BigInt* BigInt::bitAnd(JSContext* cx, Ha
     // (-x) & (-y) == ~(x-1) & ~(y-1) == ~((x-1) | (y-1))
     // == -(((x-1) | (y-1)) + 1)
     RootedBigInt x1(cx, absoluteSubOne(cx, x));
-    if (!x1) {
+    if (!x1) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     RootedBigInt y1(cx, absoluteSubOne(cx, y));
-    if (!y1) {
+    if (!y1) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     RootedBigInt result(cx, absoluteOr(cx, x1, y1));
-    if (!result) {
+    if (!result) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     bool resultNegative = true;
@@ -2368,11 +2368,11 @@ BigInt* BigInt::bitXor(JSContext* cx, Ha
   if (x->isNegative() && y->isNegative()) {
     // (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1)
     RootedBigInt x1(cx, absoluteSubOne(cx, x));
-    if (!x1) {
+    if (!x1) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     RootedBigInt y1(cx, absoluteSubOne(cx, y));
-    if (!y1) {
+    if (!y1) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     return absoluteXor(cx, x1, y1);
@@ -2384,7 +2384,7 @@ BigInt* BigInt::bitXor(JSContext* cx, Ha
 
   // x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1)
   RootedBigInt result(cx, absoluteSubOne(cx, neg));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   result = absoluteXor(cx, result, pos);
@@ -2415,15 +2415,15 @@ BigInt* BigInt::bitOr(JSContext* cx, Han
     // (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) & (y-1))
     // == -(((x-1) & (y-1)) + 1)
     RootedBigInt result(cx, absoluteSubOne(cx, x));
-    if (!result) {
+    if (!result) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     RootedBigInt y1(cx, absoluteSubOne(cx, y));
-    if (!y1) {
+    if (!y1) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     result = absoluteAnd(cx, result, y1);
-    if (!result) {
+    if (!result) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     return absoluteAddOne(cx, result, resultNegative);
@@ -2435,7 +2435,7 @@ BigInt* BigInt::bitOr(JSContext* cx, Han
 
   // x | (-y) == x | ~(y-1) == ~((y-1) &~ x) == -(((y-1) &~ x) + 1)
   RootedBigInt result(cx, absoluteSubOne(cx, neg));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   result = absoluteAndNot(cx, result, pos);
@@ -2523,7 +2523,7 @@ BigInt* BigInt::truncateAndSubFromPowerO
 
   size_t resultLength = CeilDiv(bits, DigitBits);
   BigInt* result = createUninitialized(cx, resultLength, resultNegative);
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2626,7 +2626,7 @@ BigInt* BigInt::asUintN(JSContext* cx, H
 
   const bool isNegative = false;
   BigInt* res = createUninitialized(cx, length, isNegative);
-  if (res == nullptr) {
+  if (res == nullptr) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2669,7 +2669,7 @@ BigInt* BigInt::asIntN(JSContext* cx, Ha
   }
 
   Digit signBit = Digit(1) << ((bits - 1) % DigitBits);
-  if (bits == bitLength && msd < signBit) {
+  if (bits == bitLength && msd < signBit) {MOZ_RELEASE_ASSERT(0);
     return x;
   }
 
@@ -2680,7 +2680,7 @@ BigInt* BigInt::asIntN(JSContext* cx, Ha
 
   // BigInt.asIntN step 3:  Let `mod` be `x` modulo `2**bits`.
   RootedBigInt mod(cx, asUintN(cx, x, bits));
-  if (!mod) {
+  if (!mod) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3584,12 +3584,12 @@ static inline BigInt* ParseStringBigIntL
 JS::Result<BigInt*, JS::OOM> js::StringToBigInt(JSContext* cx,
                                                 HandleString str) {
   JSLinearString* linear = str->ensureLinear(cx);
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return cx->alreadyReportedOOM();
   }
 
   AutoStableStringChars chars(cx);
-  if (!chars.init(cx, str)) {
+  if (!chars.init(cx, str)) {MOZ_RELEASE_ASSERT(0);
     return cx->alreadyReportedOOM();
   }
 
@@ -3597,7 +3597,7 @@ JS::Result<BigInt*, JS::OOM> js::StringT
   bool parseError = false;
   if (chars.isLatin1()) {
     res = ParseStringBigIntLiteral(cx, chars.latin1Range(), &parseError);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     res = ParseStringBigIntLiteral(cx, chars.twoByteRange(), &parseError);
   }
 
@@ -3711,7 +3711,7 @@ XDRResult js::XDRBigInt(XDRState<mode>* 
   MOZ_RELEASE_ASSERT(length % sizeof(BigInt::Digit) == 0);
   uint32_t digitLength = length / sizeof(BigInt::Digit);
   auto buf = cx->make_pod_array<BigInt::Digit>(digitLength);
-  if (!buf) {
+  if (!buf) {MOZ_RELEASE_ASSERT(0);
     return xdr->fail(JS::TranscodeResult::Throw);
   }
 
diff --git a/js/src/vm/BuiltinObjectKind.cpp b/js/src/vm/BuiltinObjectKind.cpp
--- a/js/src/vm/BuiltinObjectKind.cpp
+++ b/js/src/vm/BuiltinObjectKind.cpp
@@ -99,7 +99,7 @@ BuiltinObjectKind js::BuiltinConstructor
 
 BuiltinObjectKind js::BuiltinPrototypeForName(
     frontend::TaggedParserAtomIndex name) {
-  if (name == frontend::TaggedParserAtomIndex::WellKnown::Function()) {
+  if (name == frontend::TaggedParserAtomIndex::WellKnown::Function()) {MOZ_RELEASE_ASSERT(0);
     return BuiltinObjectKind::FunctionPrototype;
   }
   if (name == frontend::TaggedParserAtomIndex::WellKnown::Object()) {
@@ -137,7 +137,7 @@ JSObject* js::GetOrCreateBuiltinObject(J
   return GlobalObject::getOrCreateConstructor(cx, key);
 }
 
-const char* js::BuiltinObjectName(BuiltinObjectKind kind) {
+const char* js::BuiltinObjectName(BuiltinObjectKind kind) {MOZ_RELEASE_ASSERT(0);
   switch (kind) {
     case BuiltinObjectKind::Array:
       return "Array";
diff --git a/js/src/vm/BytecodeUtil.cpp b/js/src/vm/BytecodeUtil.cpp
--- a/js/src/vm/BytecodeUtil.cpp
+++ b/js/src/vm/BytecodeUtil.cpp
@@ -112,7 +112,7 @@ static bool DecompileArgumentFromStack(J
 
 [[nodiscard]] static bool DumpIonScriptCounts(Sprinter* sp, HandleScript script,
                                               jit::IonScriptCounts* ionCounts) {
-  if (!sp->jsprintf("IonScript [%zu blocks]:\n", ionCounts->numBlocks())) {
+  if (!sp->jsprintf("IonScript [%zu blocks]:\n", ionCounts->numBlocks())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -122,20 +122,20 @@ static bool DecompileArgumentFromStack(J
     lineNumber = PCToLineNumber(script, script->offsetToPC(block.offset()),
                                 &columnNumber);
     if (!sp->jsprintf("BB #%" PRIu32 " [%05u,%u,%u]", block.id(),
-                      block.offset(), lineNumber, columnNumber)) {
+                      block.offset(), lineNumber, columnNumber)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (block.description()) {
-      if (!sp->jsprintf(" [inlined %s]", block.description())) {
+      if (!sp->jsprintf(" [inlined %s]", block.description())) {MOZ_RELEASE_ASSERT(0);
+        return false;
+      }MOZ_RELEASE_ASSERT(0);
+    }
+    for (size_t j = 0; j < block.numSuccessors(); j++) {
+      if (!sp->jsprintf(" -> #%" PRIu32, block.successor(j))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
-    for (size_t j = 0; j < block.numSuccessors(); j++) {
-      if (!sp->jsprintf(" -> #%" PRIu32, block.successor(j))) {
-        return false;
-      }
-    }
-    if (!sp->jsprintf(" :: %" PRIu64 " hits\n", block.hitCount())) {
+    if (!sp->jsprintf(" :: %" PRIu64 " hits\n", block.hitCount())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!sp->jsprintf("%s\n", block.code())) {
@@ -196,12 +196,12 @@ bool js::DumpRealmPCCounts(JSContext* cx
   Rooted<GCVector<JSScript*>> scripts(cx, GCVector<JSScript*>(cx));
   for (auto base = cx->zone()->cellIter<BaseScript>(); !base.done();
        base.next()) {
-    if (base->realm() != cx->realm()) {
+    if (base->realm() != cx->realm()) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
     MOZ_ASSERT_IF(base->hasScriptCounts(), base->hasBytecode());
     if (base->hasScriptCounts()) {
-      if (!scripts.append(base->asJSScript())) {
+      if (!scripts.append(base->asJSScript())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -210,7 +210,7 @@ bool js::DumpRealmPCCounts(JSContext* cx
   for (uint32_t i = 0; i < scripts.length(); i++) {
     HandleScript script = scripts[i];
     Sprinter sprinter(cx);
-    if (!sprinter.init()) {
+    if (!sprinter.init()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -360,7 +360,7 @@ class BytecodeParser {
       stackDepth = depth;
       if (stackDepth) {
         offsetStack = alloc.newArray<OffsetAndDefIndex>(stackDepth);
-        if (!offsetStack) {
+        if (!offsetStack) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         for (uint32_t n = 0; n < stackDepth; n++) {
@@ -773,7 +773,7 @@ bool BytecodeParser::recordBytecode(uint
   Bytecode*& code = codeArray_[offset];
   if (!code) {
     code = alloc().new_<Bytecode>(alloc());
-    if (!code || !code->captureOffsetStack(alloc(), offsetStack, stackDepth)) {
+    if (!code || !code->captureOffsetStack(alloc(), offsetStack, stackDepth)) {MOZ_RELEASE_ASSERT(0);
       reportOOM();
       return false;
     }
@@ -787,7 +787,7 @@ bool BytecodeParser::recordBytecode(uint
 bool BytecodeParser::addJump(uint32_t offset, uint32_t stackDepth,
                              const OffsetAndDefIndex* offsetStack,
                              jsbytecode* pc, JumpKind kind) {
-  if (!recordBytecode(offset, offsetStack, stackDepth)) {
+  if (!recordBytecode(offset, offsetStack, stackDepth)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -813,7 +813,7 @@ bool BytecodeParser::parse() {
   uint32_t length = script_->length();
   codeArray_ = alloc().newArray<Bytecode*>(length);
 
-  if (!codeArray_) {
+  if (!codeArray_) {MOZ_RELEASE_ASSERT(0);
     reportOOM();
     return false;
   }
@@ -822,7 +822,7 @@ bool BytecodeParser::parse() {
 
   // Fill in stack depth and definitions at initial bytecode.
   Bytecode* startcode = alloc().new_<Bytecode>(alloc());
-  if (!startcode) {
+  if (!startcode) {MOZ_RELEASE_ASSERT(0);
     reportOOM();
     return false;
   }
@@ -830,7 +830,7 @@ bool BytecodeParser::parse() {
   // Fill in stack depth and definitions at initial bytecode.
   OffsetAndDefIndex* offsetStack =
       alloc().newArray<OffsetAndDefIndex>(maximumStackDepth());
-  if (maximumStackDepth() && !offsetStack) {
+  if (maximumStackDepth() && !offsetStack) {MOZ_RELEASE_ASSERT(0);
     reportOOM();
     return false;
   }
@@ -863,7 +863,7 @@ bool BytecodeParser::parse() {
       }
     }
 
-    if (code->parsed) {
+    if (code->parsed) {MOZ_RELEASE_ASSERT(0);
       // No need to reparse.
       continue;
     }
@@ -948,7 +948,7 @@ bool BytecodeParser::parse() {
 
       uint32_t targetOffset = offset + GET_JUMP_OFFSET(pc);
       if (!addJump(targetOffset, newStackDepth, offsetStack, pc,
-                   JumpKind::Simple)) {
+                   JumpKind::Simple)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2301,7 +2301,7 @@ static bool FindStartPC(JSContext* cx, c
     // bytecode (e.g. JSOp::MoreIter), so restore *valuepc.
     if (index < size_t(parser.stackDepthAtPC(current))) {
       *valuepc = parser.pcForStackOperand(current, index, defIndex);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       *valuepc = current;
       *defIndex = index - size_t(parser.stackDepthAtPC(current));
     }
@@ -2324,7 +2324,7 @@ static bool DecompileExpressionFromStack
    * IonMonkey doesn't use InterpreterFrames and this ensures we get the same
    * error messages.
    */
-  if (js::SupportDifferentialTesting()) {
+  if (js::SupportDifferentialTesting()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -2353,19 +2353,19 @@ static bool DecompileExpressionFromStack
   MOZ_ASSERT(script->containsPC(valuepc));
 
   // Give up if in prologue.
-  if (valuepc < script->main()) {
+  if (valuepc < script->main()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   LifoAllocScope allocScope(&cx->tempLifoAlloc());
   BytecodeParser parser(cx, allocScope.alloc(), frameIter.script());
-  if (!parser.parse()) {
+  if (!parser.parse()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   uint8_t defIndex;
   if (!FindStartPC(cx, frameIter, parser, spindex, skipStackHits, v, &valuepc,
-                   &defIndex)) {
+                   &defIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!valuepc) {
@@ -2373,7 +2373,7 @@ static bool DecompileExpressionFromStack
   }
 
   ExpressionDecompiler ed(cx, script, parser);
-  if (!ed.init()) {
+  if (!ed.init()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!ed.decompilePC(valuepc, defIndex)) {
@@ -2390,7 +2390,7 @@ UniqueChars js::DecompileValueGenerator(
   RootedString fallback(cx, fallbackArg);
   {
     UniqueChars result;
-    if (!DecompileExpressionFromStack(cx, spindex, skipStackHits, v, &result)) {
+    if (!DecompileExpressionFromStack(cx, spindex, skipStackHits, v, &result)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (result && strcmp(result.get(), "(intermediate value)")) {
@@ -2418,7 +2418,7 @@ static bool DecompileArgumentFromStack(J
   *res = nullptr;
 
   /* See note in DecompileExpressionFromStack. */
-  if (js::SupportDifferentialTesting()) {
+  if (js::SupportDifferentialTesting()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -2445,7 +2445,7 @@ static bool DecompileArgumentFromStack(J
 
   MOZ_ASSERT(script->containsPC(current));
 
-  if (current < script->main()) {
+  if (current < script->main()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -2461,7 +2461,7 @@ static bool DecompileArgumentFromStack(J
 
   LifoAllocScope allocScope(&cx->tempLifoAlloc());
   BytecodeParser parser(cx, allocScope.alloc(), script);
-  if (!parser.parse()) {
+  if (!parser.parse()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2469,12 +2469,12 @@ static bool DecompileArgumentFromStack(J
   int formalStackIndex = parser.stackDepthAtPC(current) - GET_ARGC(current) -
                          pushedNewTarget + formalIndex;
   MOZ_ASSERT(formalStackIndex >= 0);
-  if (uint32_t(formalStackIndex) >= parser.stackDepthAtPC(current)) {
+  if (uint32_t(formalStackIndex) >= parser.stackDepthAtPC(current)) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   ExpressionDecompiler ed(cx, script, parser);
-  if (!ed.init()) {
+  if (!ed.init()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!ed.decompilePCForStackOperand(current, formalStackIndex)) {
@@ -2488,7 +2488,7 @@ static bool DecompileArgumentFromStack(J
 JSString* js::DecompileArgument(JSContext* cx, int formalIndex, HandleValue v) {
   {
     UniqueChars result;
-    if (!DecompileArgumentFromStack(cx, formalIndex, &result)) {
+    if (!DecompileArgumentFromStack(cx, formalIndex, &result)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (result && strcmp(result.get(), "(intermediate value)")) {
@@ -2550,7 +2550,7 @@ static void ReleaseScriptCounts(JSRuntim
 JS_FRIEND_API void js::StartPCCountProfiling(JSContext* cx) {
   JSRuntime* rt = cx->runtime();
 
-  if (rt->profilingScripts) {
+  if (rt->profilingScripts) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -2566,7 +2566,7 @@ JS_FRIEND_API void js::StartPCCountProfi
 JS_FRIEND_API void js::StopPCCountProfiling(JSContext* cx) {
   JSRuntime* rt = cx->runtime();
 
-  if (!rt->profilingScripts) {
+  if (!rt->profilingScripts) {MOZ_RELEASE_ASSERT(0);
     return;
   }
   MOZ_ASSERT(!rt->scriptAndCountsVector);
@@ -2575,7 +2575,7 @@ JS_FRIEND_API void js::StopPCCountProfil
 
   auto* vec = cx->new_<PersistentRooted<ScriptAndCountsVector>>(
       cx, ScriptAndCountsVector());
-  if (!vec) {
+  if (!vec) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -2629,7 +2629,7 @@ JS_FRIEND_API JSString* js::GetPCCountSc
   JSRuntime* rt = cx->runtime();
 
   if (!rt->scriptAndCountsVector ||
-      index >= rt->scriptAndCountsVector->length()) {
+      index >= rt->scriptAndCountsVector->length()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_BUFFER_TOO_SMALL);
     return nullptr;
@@ -2639,7 +2639,7 @@ JS_FRIEND_API JSString* js::GetPCCountSc
   RootedScript script(cx, sac.script);
 
   Sprinter sp(cx);
-  if (!sp.init()) {
+  if (!sp.init()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2648,17 +2648,17 @@ JS_FRIEND_API JSString* js::GetPCCountSc
   json.beginObject();
 
   RootedString filename(cx, NewStringCopyZ<CanGC>(cx, script->filename()));
-  if (!filename) {
+  if (!filename) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
-  if (!JSONStringProperty(sp, json, "file", filename)) {
+  if (!JSONStringProperty(sp, json, "file", filename)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   json.property("line", script->lineno());
 
   if (JSFunction* fun = script->function()) {
     if (JSAtom* atom = fun->displayAtom()) {
-      if (!JSONStringProperty(sp, json, "name", atom)) {
+      if (!JSONStringProperty(sp, json, "name", atom)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -2708,18 +2708,18 @@ static bool GetPCCountJSON(JSContext* cx
 
   LifoAllocScope allocScope(&cx->tempLifoAlloc());
   BytecodeParser parser(cx, allocScope.alloc(), script);
-  if (!parser.parse()) {
+  if (!parser.parse()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   json.beginObject();
 
   JSString* str = JS_DecompileScript(cx, script);
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!JSONStringProperty(sp, json, "text", str)) {
+  if (!JSONStringProperty(sp, json, "text", str)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2748,25 +2748,25 @@ static bool GetPCCountJSON(JSContext* cx
 
     {
       ExpressionDecompiler ed(cx, script, parser);
-      if (!ed.init()) {
+      if (!ed.init()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       // defIndex passed here is not used.
-      if (!ed.decompilePC(pc, /* defIndex = */ 0)) {
+      if (!ed.decompilePC(pc, /* defIndex = */ 0)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       UniqueChars text = ed.getOutput();
-      if (!text) {
+      if (!text) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       JS::ConstUTF8CharsZ utf8chars(text.get(), strlen(text.get()));
       JSString* str = NewStringCopyUTF8Z<CanGC>(cx, utf8chars);
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
-      if (!JSONStringProperty(sp, json, "text", str)) {
+      if (!JSONStringProperty(sp, json, "text", str)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2781,7 +2781,7 @@ static bool GetPCCountJSON(JSContext* cx
 
     // If the current instruction has thrown,
     // then decrement the hit counts with the number of throws.
-    if (const PCCounts* counts = sac.maybeGetThrowCounts(pc)) {
+    if (const PCCounts* counts = sac.maybeGetThrowCounts(pc)) {MOZ_RELEASE_ASSERT(0);
       hits -= counts->numExec();
     }
   }
@@ -2809,7 +2809,7 @@ static bool GetPCCountJSON(JSContext* cx
         json.property("hits", block.hitCount());
 
         JSString* str = NewStringCopyZ<CanGC>(cx, block.code());
-        if (!str) {
+        if (!str) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -2837,7 +2837,7 @@ JS_FRIEND_API JSString* js::GetPCCountSc
   JSRuntime* rt = cx->runtime();
 
   if (!rt->scriptAndCountsVector ||
-      index >= rt->scriptAndCountsVector->length()) {
+      index >= rt->scriptAndCountsVector->length()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_BUFFER_TOO_SMALL);
     return nullptr;
@@ -2847,13 +2847,13 @@ JS_FRIEND_API JSString* js::GetPCCountSc
   JSScript* script = sac.script;
 
   Sprinter sp(cx);
-  if (!sp.init()) {
+  if (!sp.init()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   {
     AutoRealm ar(cx, &script->global());
-    if (!GetPCCountJSON(cx, sac, sp)) {
+    if (!GetPCCountJSON(cx, sac, sp)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -2904,7 +2904,7 @@ static bool GenerateLcovInfo(JSContext* 
   {
     CollectedScripts result(&queue);
     IterateScripts(cx, realm, &result, &CollectedScripts::consider);
-    if (!result.ok) {
+    if (!result.ok) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2915,7 +2915,7 @@ static bool GenerateLcovInfo(JSContext* 
 
   // Ensure the LCovRealm exists to collect info into.
   coverage::LCovRealm* lcovRealm = realm->lcovRealm();
-  if (!lcovRealm) {
+  if (!lcovRealm) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2929,13 +2929,13 @@ static bool GenerateLcovInfo(JSContext* 
       continue;
     }
 
-    if (!coverage::CollectScriptCoverage(script, false)) {
+    if (!coverage::CollectScriptCoverage(script, false)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     script->resetScriptCounts();
 
-    if (!scriptsDone.add(entry, script)) {
+    if (!scriptsDone.add(entry, script)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2960,14 +2960,14 @@ static bool GenerateLcovInfo(JSContext* 
       fun = &obj->as<JSFunction>();
 
       // Ignore asm.js functions
-      if (!fun->isInterpreted()) {
+      if (!fun->isInterpreted()) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
 
       // Queue the script in the list of script associated to the
       // current source.
       JSScript* childScript = JSFunction::getOrCreateScript(cx, fun);
-      if (!childScript || !queue.append(childScript)) {
+      if (!childScript || !queue.append(childScript)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2985,7 +2985,7 @@ static bool GenerateLcovInfo(JSContext* 
 JS_FRIEND_API UniqueChars js::GetCodeCoverageSummaryAll(JSContext* cx,
                                                         size_t* length) {
   Sprinter out(cx);
-  if (!out.init()) {
+  if (!out.init()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3003,7 +3003,7 @@ JS_FRIEND_API UniqueChars js::GetCodeCov
 JS_FRIEND_API UniqueChars js::GetCodeCoverageSummary(JSContext* cx,
                                                      size_t* length) {
   Sprinter out(cx);
-  if (!out.init()) {
+  if (!out.init()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/vm/CharacterEncoding.cpp b/js/src/vm/CharacterEncoding.cpp
--- a/js/src/vm/CharacterEncoding.cpp
+++ b/js/src/vm/CharacterEncoding.cpp
@@ -177,7 +177,7 @@ static uint32_t Utf8ToOneUcs4CharImpl(co
                                       int utf8Length) {
   MOZ_ASSERT(1 <= utf8Length && utf8Length <= 4);
 
-  if (utf8Length == 1) {
+  if (utf8Length == 1) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(!(*utf8Buffer & 0x80));
     return *utf8Buffer;
   }
@@ -252,7 +252,7 @@ static bool InflateUTF8ToUTF16(JSContext
     uint32_t v = uint32_t(src[i]);
     if (!(v & 0x80)) {
       // ASCII code unit.  Simple copy.
-      if (dst(uint16_t(v)) == LoopDisposition::Break) {
+      if (dst(uint16_t(v)) == LoopDisposition::Break) {MOZ_RELEASE_ASSERT(0);
         break;
       }
     } else {
@@ -286,12 +286,12 @@ static bool InflateUTF8ToUTF16(JSContext
   } while (0)
 
       // Check the leading byte.
-      if (n < 2 || n > 4) {
+      if (n < 2 || n > 4) {MOZ_RELEASE_ASSERT(0);
         INVALID(ReportInvalidCharacter, i, 1);
       }
 
       // Check that |src| is large enough to hold an n-byte code unit.
-      if (i + n > srclen) {
+      if (i + n > srclen) {MOZ_RELEASE_ASSERT(0);
         INVALID(ReportBufferTooSmall, /* dummy = */ 0, 1);
       }
 
@@ -301,13 +301,13 @@ static bool InflateUTF8ToUTF16(JSContext
           (v == 0xED && ((uint8_t)src[i + 1] & 0xE0) != 0x80) ||  // ED 80~9F
           (v == 0xF0 && ((uint8_t)src[i + 1] & 0xF0) == 0x80) ||  // F0 90~BF
           (v == 0xF4 && ((uint8_t)src[i + 1] & 0xF0) != 0x80))    // F4 80~8F
-      {
+      {MOZ_RELEASE_ASSERT(0);
         INVALID(ReportInvalidCharacter, i, 1);
       }
 
       // Check the continuation bytes.
       for (uint32_t m = 1; m < n; m++) {
-        if ((src[i + m] & 0xC0) != 0x80) {
+        if ((src[i + m] & 0xC0) != 0x80) {MOZ_RELEASE_ASSERT(0);
           INVALID(ReportInvalidCharacter, i, m);
         }
       }
@@ -316,15 +316,15 @@ static bool InflateUTF8ToUTF16(JSContext
       v = Utf8ToOneUcs4CharImpl((uint8_t*)&src[i], n);
       if (v < NonBMPMin) {
         // The n-byte UTF8 code unit will fit in a single CharT.
-        if (dst(char16_t(v)) == LoopDisposition::Break) {
+        if (dst(char16_t(v)) == LoopDisposition::Break) {MOZ_RELEASE_ASSERT(0);
           break;
         }
       } else if (v <= NonBMPMax) {
         // The n-byte UTF8 code unit will fit in two CharT units.
-        if (dst(LeadSurrogate(v)) == LoopDisposition::Break) {
+        if (dst(LeadSurrogate(v)) == LoopDisposition::Break) {MOZ_RELEASE_ASSERT(0);
           break;
         }
-        if (dst(TrailSurrogate(v)) == LoopDisposition::Break) {
+        if (dst(TrailSurrogate(v)) == LoopDisposition::Break) {MOZ_RELEASE_ASSERT(0);
           break;
         }
       } else {
@@ -382,7 +382,7 @@ static CharsT InflateUTF8StringHelper(JS
     allASCII &= (c < 0x80);
     return LoopDisposition::Continue;
   };
-  if (!InflateUTF8ToUTF16<ErrorAction>(cx, src, count)) {
+  if (!InflateUTF8ToUTF16<ErrorAction>(cx, src, count)) {MOZ_RELEASE_ASSERT(0);
     return CharsT();
   }
   *outlen = len;
@@ -587,11 +587,11 @@ bool StringBuffer::append(const Utf8Unit
     Latin1CharBuffer& latin1 = latin1Chars();
 
     while (len > 0) {
-      if (!IsAscii(*units)) {
+      if (!IsAscii(*units)) {MOZ_RELEASE_ASSERT(0);
         break;
       }
 
-      if (!latin1.append(units->toUnsignedChar())) {
+      if (!latin1.append(units->toUnsignedChar())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -607,7 +607,7 @@ bool StringBuffer::append(const Utf8Unit
     // and handling the full complexity of UTF-8 only for that very small
     // additional range isn't worth it.  Inflate to two-byte storage before
     // appending the remaining code points.
-    if (!inflateChars()) {
+    if (!inflateChars()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -622,14 +622,14 @@ bool StringBuffer::append(const Utf8Unit
     return LoopDisposition::Continue;
   };
   if (!InflateUTF8ToUTF16<OnUTF8Error::Throw>(cx_, remainingUtf8,
-                                              countInflated)) {
+                                              countInflated)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   TwoByteCharBuffer& buf = twoByteChars();
 
   size_t i = buf.length();
-  if (!buf.growByUninitialized(utf16Len)) {
+  if (!buf.growByUninitialized(utf16Len)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(i + utf16Len == buf.length(),
diff --git a/js/src/vm/CodeCoverage.cpp b/js/src/vm/CodeCoverage.cpp
--- a/js/src/vm/CodeCoverage.cpp
+++ b/js/src/vm/CodeCoverage.cpp
@@ -76,7 +76,7 @@ LCovSource::LCovSource(LifoAlloc* alloc,
       hadOOM_(false) {}
 
 void LCovSource::exportInto(GenericPrinter& out) {
-  if (hadOutOfMemory()) {
+  if (hadOutOfMemory()) {MOZ_RELEASE_ASSERT(0);
     out.reportOutOfMemory();
   } else {
     out.printf("SF:%s\n", name_.get());
@@ -118,7 +118,7 @@ void LCovSource::exportInto(GenericPrint
 }
 
 void LCovSource::writeScript(JSScript* script, const char* scriptName) {
-  if (hadOutOfMemory()) {
+  if (hadOutOfMemory()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -186,7 +186,7 @@ void LCovSource::writeScript(JSScript* s
           pc >= script->main() && fallsthrough) {
         auto p = linesHit_.lookupForAdd(lineno);
         if (!p) {
-          if (!linesHit_.add(p, lineno, hits)) {
+          if (!linesHit_.add(p, lineno, hits)) {MOZ_RELEASE_ASSERT(0);
             hadOOM_ = true;
             return;
           }
@@ -363,7 +363,7 @@ void LCovSource::writeScript(JSScript* s
   }
 
   if (outFN_.hadOutOfMemory() || outFNDA_.hadOutOfMemory() ||
-      outBRDA_.hadOutOfMemory()) {
+      outBRDA_.hadOutOfMemory()) {MOZ_RELEASE_ASSERT(0);
     hadOOM_ = true;
     return;
   }
@@ -401,14 +401,14 @@ LCovSource* LCovRealm::lookupOrAdd(const
   }
 
   UniqueChars source_name = DuplicateString(name);
-  if (!source_name) {
+  if (!source_name) {MOZ_RELEASE_ASSERT(0);
     outTN_.reportOutOfMemory();
     return nullptr;
   }
 
   // Allocate a new LCovSource for the current top-level.
   LCovSource* source = alloc_.new_<LCovSource>(&alloc_, std::move(source_name));
-  if (!source) {
+  if (!source) {MOZ_RELEASE_ASSERT(0);
     outTN_.reportOutOfMemory();
     return nullptr;
   }
@@ -422,7 +422,7 @@ LCovSource* LCovRealm::lookupOrAdd(const
 }
 
 void LCovRealm::exportInto(GenericPrinter& out, bool* isEmpty) const {
-  if (outTN_.hadOutOfMemory()) {
+  if (outTN_.hadOutOfMemory()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -519,7 +519,7 @@ LCovRuntime::~LCovRuntime() {
 
 bool LCovRuntime::fillWithFilename(char* name, size_t length) {
   const char* outDir = getenv("JS_CODE_COVERAGE_OUTPUT_DIR");
-  if (!outDir || *outDir == 0) {
+  if (!outDir || *outDir == 0) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -540,7 +540,7 @@ bool LCovRuntime::fillWithFilename(char*
 
 void LCovRuntime::init() {
   char name[1024];
-  if (!fillWithFilename(name, sizeof(name))) {
+  if (!fillWithFilename(name, sizeof(name))) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -568,13 +568,13 @@ void LCovRuntime::finishFile() {
 void LCovRuntime::writeLCovResult(LCovRealm& realm) {
   if (!out_.isInitialized()) {
     init();
-    if (!out_.isInitialized()) {
+    if (!out_.isInitialized()) {MOZ_RELEASE_ASSERT(0);
       return;
     }
   }
 
   uint32_t p = getpid();
-  if (pid_ != p) {
+  if (pid_ != p) {MOZ_RELEASE_ASSERT(0);
     pid_ = p;
     finishFile();
     init();
@@ -607,21 +607,21 @@ bool InitScriptCoverage(JSContext* cx, J
 
   // Create LCovRealm if necessary.
   LCovRealm* lcovRealm = script->realm()->lcovRealm();
-  if (!lcovRealm) {
+  if (!lcovRealm) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
 
   // Create LCovSource if necessary.
   LCovSource* source = lcovRealm->lookupOrAdd(filename);
-  if (!source) {
+  if (!source) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
 
   // Computed the formated script name.
   const char* scriptName = lcovRealm->getScriptName(script);
-  if (!scriptName) {
+  if (!scriptName) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -631,7 +631,7 @@ bool InitScriptCoverage(JSContext* cx, J
   if (!zone->scriptLCovMap) {
     zone->scriptLCovMap = cx->make_unique<ScriptLCovMap>();
   }
-  if (!zone->scriptLCovMap) {
+  if (!zone->scriptLCovMap) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/vm/Compartment.cpp b/js/src/vm/Compartment.cpp
--- a/js/src/vm/Compartment.cpp
+++ b/js/src/vm/Compartment.cpp
@@ -123,7 +123,7 @@ static JSString* CopyStringPure(JSContex
     }
 
     AutoStableStringChars chars(cx);
-    if (!chars.init(cx, str)) {
+    if (!chars.init(cx, str)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -136,7 +136,7 @@ static JSString* CopyStringPure(JSContex
   if (str->hasLatin1Chars()) {
     UniquePtr<Latin1Char[], JS::FreePolicy> copiedChars =
         str->asRope().copyLatin1Chars(cx, js::StringBufferArena);
-    if (!copiedChars) {
+    if (!copiedChars) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -178,7 +178,7 @@ bool Compartment::wrap(JSContext* cx, Mu
 
   /* No dice. Make a copy, and cache it. */
   JSString* copy = CopyStringPure(cx, str);
-  if (!copy) {
+  if (!copy) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!putWrapper(cx, strp, copy)) {
@@ -309,7 +309,7 @@ bool Compartment::getOrCreateWrapper(JSC
   // Create a new wrapper for the object.
   auto wrap = cx->runtime()->wrapObjectCallbacks->wrap;
   RootedObject wrapper(cx, wrap(cx, existing, obj));
-  if (!wrapper) {
+  if (!wrapper) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -391,7 +391,7 @@ bool Compartment::rewrap(JSContext* cx, 
   // |existingArg| instead of |existing|, because the purpose is to get the
   // address of the object we are transplanting onto, not to find a wrapper
   // to reuse.
-  if (!getNonWrapperObjectForCurrentCompartment(cx, existingArg, obj)) {
+  if (!getNonWrapperObjectForCurrentCompartment(cx, existingArg, obj)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -406,12 +406,12 @@ bool Compartment::rewrap(JSContext* cx, 
 
 bool Compartment::wrap(JSContext* cx,
                        MutableHandle<JS::PropertyDescriptor> desc) {
-  if (!wrap(cx, desc.object())) {
+  if (!wrap(cx, desc.object())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (desc.hasGetterObject()) {
-    if (!wrap(cx, desc.getterObject())) {
+    if (!wrap(cx, desc.getterObject())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
diff --git a/js/src/vm/CompilationAndEvaluation.cpp b/js/src/vm/CompilationAndEvaluation.cpp
--- a/js/src/vm/CompilationAndEvaluation.cpp
+++ b/js/src/vm/CompilationAndEvaluation.cpp
@@ -105,12 +105,12 @@ static JSScript* CompileSourceBufferAndS
 
     Rooted<frontend::CompilationGCOutput> gcOutput(cx);
     if (!frontend::InstantiateStencils(cx, input.get(), borrowingStencil,
-                                       gcOutput.get())) {
+                                       gcOutput.get())) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     script = gcOutput.get().script;
-    if (!script) {
+    if (!script) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -140,7 +140,7 @@ JSScript* JS::CompileUtf8File(JSContext*
                               const ReadOnlyCompileOptions& options,
                               FILE* file) {
   FileContents buffer(cx);
-  if (!ReadCompleteFile(cx, file, buffer)) {
+  if (!ReadCompleteFile(cx, file, buffer)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -169,7 +169,7 @@ JSScript* JS::CompileUtf8Path(JSContext*
 JS_PUBLIC_API bool JS_Utf8BufferIsCompilableUnit(JSContext* cx,
                                                  HandleObject obj,
                                                  const char* utf8,
-                                                 size_t length) {
+                                                 size_t length) {MOZ_RELEASE_ASSERT(0);
   AssertHeapIsIdle();
   CHECK_THREAD(cx);
   cx->check(obj);
@@ -180,9 +180,9 @@ JS_PUBLIC_API bool JS_Utf8BufferIsCompil
       UTF8CharsToNewTwoByteCharsZ(cx, UTF8Chars(utf8, length), &length,
                                   js::MallocArena)
           .get()};
-  if (!chars) {
+  if (!chars) {MOZ_RELEASE_ASSERT(0);
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Return true on any out-of-memory error or non-EOF-related syntax error, so
   // our caller doesn't try to collect more buffered source.
@@ -195,22 +195,22 @@ JS_PUBLIC_API bool JS_Utf8BufferIsCompil
   CompileOptions options(cx);
   Rooted<frontend::CompilationInput> input(cx,
                                            frontend::CompilationInput(options));
-  if (!input.get().initForGlobal(cx)) {
+  if (!input.get().initForGlobal(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   LifoAllocScope allocScope(&cx->tempLifoAlloc());
   frontend::CompilationState compilationState(cx, allocScope, input.get());
-  if (!compilationState.init(cx)) {
+  if (!compilationState.init(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   JS::AutoSuppressWarningReporter suppressWarnings(cx);
   Parser<FullParseHandler, char16_t> parser(cx, options, chars.get(), length,
                                             /* foldConstants = */ true,
                                             compilationState,
                                             /* syntaxParser = */ nullptr);
-  if (!parser.checkOptions() || !parser.parse()) {
+  if (!parser.checkOptions() || !parser.parse()) {MOZ_RELEASE_ASSERT(0);
     // We ran into an error. If it was because we ran out of source, we
     // return false so our caller knows to try to collect more buffered
     // source.
@@ -243,10 +243,10 @@ class FunctionCompiler {
 
   [[nodiscard]] bool init(const char* name, unsigned nargs,
                           const char* const* argnames) {
-    if (!funStr_.ensureTwoByteChars()) {
+    if (!funStr_.ensureTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!funStr_.append("function ")) {
+    if (!funStr_.append("function ")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -254,7 +254,7 @@ class FunctionCompiler {
       size_t nameLen = strlen(name);
 
       nameAtom_ = Atomize(cx_, name, nameLen);
-      if (!nameAtom_) {
+      if (!nameAtom_) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -263,19 +263,19 @@ class FunctionCompiler {
       nameIsIdentifier_ = js::frontend::IsIdentifier(
           reinterpret_cast<const Latin1Char*>(name), nameLen);
       if (nameIsIdentifier_) {
-        if (!funStr_.append(nameAtom_)) {
+        if (!funStr_.append(nameAtom_)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
     }
 
-    if (!funStr_.append("(")) {
+    if (!funStr_.append("(")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     for (unsigned i = 0; i < nargs; i++) {
       if (i != 0) {
-        if (!funStr_.append(", ")) {
+        if (!funStr_.append(", ")) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -300,18 +300,18 @@ class FunctionCompiler {
                      const ReadOnlyCompileOptions& optionsArg) {
     using js::frontend::FunctionSyntaxKind;
 
-    if (!funStr_.append(FunctionConstructorFinalBrace)) {
+    if (!funStr_.append(FunctionConstructorFinalBrace)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     size_t newLen = funStr_.length();
     UniqueTwoByteChars stolen(funStr_.stealChars());
-    if (!stolen) {
+    if (!stolen) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     SourceText<char16_t> newSrcBuf;
-    if (!newSrcBuf.init(cx_, std::move(stolen), newLen)) {
+    if (!newSrcBuf.init(cx_, std::move(stolen), newLen)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -324,7 +324,7 @@ class FunctionCompiler {
       enclosingEnv.set(&cx_->global()->lexicalEnvironment());
       kind = ScopeKind::Global;
     } else {
-      if (!CreateNonSyntacticEnvironmentChain(cx_, envChain, &enclosingEnv)) {
+      if (!CreateNonSyntacticEnvironmentChain(cx_, envChain, &enclosingEnv)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       kind = ScopeKind::NonSyntactic;
@@ -345,7 +345,7 @@ class FunctionCompiler {
     if (kind == ScopeKind::NonSyntactic) {
       RootedScope enclosingScope(
           cx_, GlobalScope::createEmpty(cx_, ScopeKind::NonSyntactic));
-      if (!enclosingScope) {
+      if (!enclosingScope) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -363,7 +363,7 @@ class FunctionCompiler {
 
     // When the function name isn't a valid identifier, the generated function
     // source in srcBuf won't include the name, so name the function manually.
-    if (!nameIsIdentifier_) {
+    if (!nameIsIdentifier_) {MOZ_RELEASE_ASSERT(0);
       fun->setAtom(nameAtom_);
     }
 
@@ -404,7 +404,7 @@ JS_PUBLIC_API JSFunction* JS::CompileFun
 JS_PUBLIC_API JSFunction* JS::CompileFunctionUtf8(
     JSContext* cx, HandleObjectVector envChain,
     const ReadOnlyCompileOptions& options, const char* name, unsigned nargs,
-    const char* const* argnames, const char* bytes, size_t length) {
+    const char* const* argnames, const char* bytes, size_t length) {MOZ_RELEASE_ASSERT(0);
   SourceText<Utf8Unit> srcBuf;
   if (!srcBuf.init(cx, bytes, length, SourceOwnership::Borrowed)) {
     return nullptr;
diff --git a/js/src/vm/Compression.cpp b/js/src/vm/Compression.cpp
--- a/js/src/vm/Compression.cpp
+++ b/js/src/vm/Compression.cpp
@@ -67,7 +67,7 @@ Compressor::~Compressor() {
 static const int WindowBits = -15;
 
 bool Compressor::init() {
-  if (inplen >= UINT32_MAX) {
+  if (inplen >= UINT32_MAX) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   // zlib is slow and we'd rather be done compression sooner
@@ -119,7 +119,7 @@ Compressor::Status Compressor::compressM
   currentChunkSize += zs.next_in - oldin;
   MOZ_ASSERT(currentChunkSize <= CHUNK_SIZE);
 
-  if (ret == Z_MEM_ERROR) {
+  if (ret == Z_MEM_ERROR) {MOZ_RELEASE_ASSERT(0);
     zs.avail_out = 0;
     return OOM;
   }
@@ -234,7 +234,7 @@ bool js::DecompressStringChunk(const uns
   zs.avail_out = outlen;
 
   int ret = inflateInit2(&zs, WindowBits);
-  if (ret != Z_OK) {
+  if (ret != Z_OK) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(ret == Z_MEM_ERROR);
     return false;
   }
diff --git a/js/src/vm/DateTime.cpp b/js/src/vm/DateTime.cpp
--- a/js/src/vm/DateTime.cpp
+++ b/js/src/vm/DateTime.cpp
@@ -86,14 +86,14 @@ static int32_t UTCToLocalStandardOffsetS
 
   // Get the current time.
   time_t currentMaybeWithDST = time(nullptr);
-  if (currentMaybeWithDST == time_t(-1)) {
+  if (currentMaybeWithDST == time_t(-1)) {MOZ_RELEASE_ASSERT(0);
     return 0;
   }
 
   // Break down the current time into its (locally-valued, maybe with DST)
   // components.
   struct tm local;
-  if (!ComputeLocalTime(currentMaybeWithDST, &local)) {
+  if (!ComputeLocalTime(currentMaybeWithDST, &local)) {MOZ_RELEASE_ASSERT(0);
     return 0;
   }
 
@@ -117,7 +117,7 @@ static int32_t UTCToLocalStandardOffsetS
     // time zone; and 3) in the absence of an API that provides the time
     // zone offset directly, this may be the best we can do.
     currentNoDST = mktime(&localNoDST);
-    if (currentNoDST == time_t(-1)) {
+    if (currentNoDST == time_t(-1)) {MOZ_RELEASE_ASSERT(0);
       return 0;
     }
   }
@@ -125,7 +125,7 @@ static int32_t UTCToLocalStandardOffsetS
   // Break down the time corresponding to the no-DST |local| into UTC-based
   // components.
   struct tm utc;
-  if (!ComputeUTCTime(currentNoDST, &utc)) {
+  if (!ComputeUTCTime(currentNoDST, &utc)) {MOZ_RELEASE_ASSERT(0);
     return 0;
   }
 
@@ -247,7 +247,7 @@ int32_t js::DateTimeInfo::computeDSTOffs
   UErrorCode status = U_ZERO_ERROR;
 
   timeZone()->getOffset(date, dateIsLocalTime, rawOffset, dstOffset, status);
-  if (U_FAILURE(status)) {
+  if (U_FAILURE(status)) {MOZ_RELEASE_ASSERT(0);
     return 0;
   }
 
@@ -453,7 +453,7 @@ bool js::DateTimeInfo::internalTimeZoneD
   // Clear any previously cached names when the default locale changed.
   if (!locale_ || std::strcmp(locale_.get(), locale) != 0) {
     locale_ = DuplicateString(locale);
-    if (!locale_) {
+    if (!locale_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -473,7 +473,7 @@ bool js::DateTimeInfo::internalTimeZoneD
 
     size_t capacity = displayName.length() + 1;  // Null-terminate.
     JS::UniqueTwoByteChars displayNameChars(js_pod_malloc<char16_t>(capacity));
-    if (!displayNameChars) {
+    if (!displayNameChars) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -662,7 +662,7 @@ static icu::UnicodeString ReadTimeZoneLi
       std::size(linkName) - 1;  // -1 to null-terminate.
 
   // Return if the TZ value is too large.
-  if (std::strlen(tz) > linkNameLen) {
+  if (std::strlen(tz) > linkNameLen) {MOZ_RELEASE_ASSERT(0);
     return icu::UnicodeString();
   }
 
@@ -678,13 +678,13 @@ static icu::UnicodeString ReadTimeZoneLi
   const char* timeZoneWithZoneInfo;
   while (!(timeZoneWithZoneInfo = std::strstr(linkName, ZoneInfoPath))) {
     // Return if the symlink nesting is too deep.
-    if (++depth > FollowDepthLimit) {
+    if (++depth > FollowDepthLimit) {MOZ_RELEASE_ASSERT(0);
       return icu::UnicodeString();
     }
 
     // Return on error or if the result was truncated.
     ssize_t slen = readlink(linkName, linkTarget, linkTargetLen);
-    if (slen < 0 || size_t(slen) >= linkTargetLen) {
+    if (slen < 0 || size_t(slen) >= linkTargetLen) {MOZ_RELEASE_ASSERT(0);
       return icu::UnicodeString();
     }
 
@@ -697,7 +697,7 @@ static icu::UnicodeString ReadTimeZoneLi
     if (linkTarget[0] == '/') {
       std::strcpy(linkName, linkTarget);
       continue;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // If the target is relative, it must be resolved against either the
     // directory the link was in, or against the current working directory.
@@ -705,10 +705,10 @@ static icu::UnicodeString ReadTimeZoneLi
 
     // If the link name is just something like "foo", resolve linkTarget
     // against the current working directory.
-    if (!separator) {
+    if (!separator) {MOZ_RELEASE_ASSERT(0);
       std::strcpy(linkName, linkTarget);
       continue;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Remove everything after the final path separator in linkName.
     separator[1] = '\0';
diff --git a/js/src/vm/EnvironmentObject.cpp b/js/src/vm/EnvironmentObject.cpp
--- a/js/src/vm/EnvironmentObject.cpp
+++ b/js/src/vm/EnvironmentObject.cpp
@@ -202,7 +202,7 @@ CallObject* CallObject::find(JSObject* e
   for (;;) {
     if (env->is<CallObject>()) {
       break;
-    } else if (env->is<EnvironmentObject>()) {
+    } else if (env->is<EnvironmentObject>()) {MOZ_RELEASE_ASSERT(0);
       env = &env->as<EnvironmentObject>().enclosingEnvironment();
     } else if (env->is<DebugEnvironmentProxy>()) {
       EnvironmentObject& unwrapped =
@@ -227,11 +227,11 @@ CallObject* CallObject::createHollowForD
   RootedScript script(cx, callee->nonLazyScript());
   Rooted<FunctionScope*> scope(cx, &script->bodyScope()->as<FunctionScope>());
   RootedShape shape(cx, EmptyEnvironmentShape<CallObject>(cx));
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   Rooted<CallObject*> callobj(cx, create(cx, shape));
-  if (!callobj) {
+  if (!callobj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -315,7 +315,7 @@ VarEnvironmentObject* VarEnvironmentObje
   MOZ_ASSERT(!scope->hasEnvironment());
 
   RootedShape shape(cx, EmptyEnvironmentShape<VarEnvironmentObject>(cx));
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -326,7 +326,7 @@ VarEnvironmentObject* VarEnvironmentObje
   RootedObject enclosingEnv(cx, &cx->global()->lexicalEnvironment());
   Rooted<VarEnvironmentObject*> env(
       cx, create(cx, shape, enclosingEnv, gc::TenuredHeap));
-  if (!env) {
+  if (!env) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -394,7 +394,7 @@ ModuleEnvironmentObject* ModuleEnvironme
   RootedModuleEnvironmentObject env(
       cx, CreateEnvironmentObject<ModuleEnvironmentObject>(cx, shape,
                                                            TenuredObject));
-  if (!env) {
+  if (!env) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -476,7 +476,7 @@ bool ModuleEnvironmentObject::lookupProp
     objp.set(env);
     propp.setNativeProperty(shape);
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedNativeObject target(cx, &obj->as<NativeObject>());
   if (!NativeLookupOwnProperty<CanGC>(cx, target, id, propp)) {
@@ -532,7 +532,7 @@ bool ModuleEnvironmentObject::setPropert
 /* static */
 bool ModuleEnvironmentObject::getOwnPropertyDescriptor(
     JSContext* cx, HandleObject obj, HandleId id,
-    MutableHandle<PropertyDescriptor> desc) {
+    MutableHandle<PropertyDescriptor> desc) {MOZ_RELEASE_ASSERT(0);
   const IndirectBindingMap& bindings =
       obj->as<ModuleEnvironmentObject>().importBindings();
   Shape* shape;
@@ -566,7 +566,7 @@ bool ModuleEnvironmentObject::newEnumera
 
   MOZ_ASSERT(properties.length() == 0);
   size_t count = bs.count() + self->slotSpan() - RESERVED_SLOTS;
-  if (!properties.reserve(count)) {
+  if (!properties.reserve(count)) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -593,7 +593,7 @@ WasmInstanceEnvironmentObject::createHol
     JSContext* cx, Handle<WasmInstanceScope*> scope) {
   RootedShape shape(cx,
                     EmptyEnvironmentShape<WasmInstanceEnvironmentObject>(cx));
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -618,7 +618,7 @@ const JSClass WasmFunctionCallObject::cl
 WasmFunctionCallObject* WasmFunctionCallObject::createHollowForDebug(
     JSContext* cx, HandleObject enclosing, Handle<WasmFunctionScope*> scope) {
   RootedShape shape(cx, EmptyEnvironmentShape<WasmFunctionCallObject>(cx));
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -640,12 +640,12 @@ WithEnvironmentObject* WithEnvironmentOb
                                                      HandleObject enclosing,
                                                      Handle<WithScope*> scope) {
   RootedShape shape(cx, EmptyEnvironmentShape<WithEnvironmentObject>(cx));
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   auto* obj = CreateEnvironmentObject<WithEnvironmentObject>(cx, shape);
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -752,7 +752,7 @@ static bool with_HasProperty(JSContext* 
   RootedObject actual(cx, &obj->as<WithEnvironmentObject>().object());
 
   // ES 8.1.1.2.1 step 3-5.
-  if (!HasProperty(cx, actual, id, foundp)) {
+  if (!HasProperty(cx, actual, id, foundp)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!*foundp) {
@@ -826,14 +826,14 @@ const JSClass WithEnvironmentObject::cla
 NonSyntacticVariablesObject* NonSyntacticVariablesObject::create(
     JSContext* cx) {
   RootedShape shape(cx, EmptyEnvironmentShape<NonSyntacticVariablesObject>(cx));
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   Rooted<NonSyntacticVariablesObject*> obj(
       cx, CreateEnvironmentObject<NonSyntacticVariablesObject>(cx, shape,
                                                                TenuredObject));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -858,7 +858,7 @@ bool js::CreateNonSyntacticEnvironmentCh
   MOZ_RELEASE_ASSERT(!envChain.empty());
 
   RootedObject globalLexical(cx, &cx->global()->lexicalEnvironment());
-  if (!CreateObjectsForEnvironmentChain(cx, envChain, globalLexical, env)) {
+  if (!CreateObjectsForEnvironmentChain(cx, envChain, globalLexical, env)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -907,7 +907,7 @@ LexicalEnvironmentObject* LexicalEnviron
 
   auto* env =
       CreateEnvironmentObject<LexicalEnvironmentObject>(cx, shape, heap);
-  if (!env) {
+  if (!env) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -934,7 +934,7 @@ BlockLexicalEnvironmentObject* BlockLexi
   RootedShape shape(cx, scope->environmentShape());
   auto* env = static_cast<BlockLexicalEnvironmentObject*>(
       createTemplateObject(cx, shape, enclosing, heap));
-  if (!env) {
+  if (!env) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -963,7 +963,7 @@ BlockLexicalEnvironmentObject::createHol
   MOZ_ASSERT(!scope->hasEnvironment());
 
   RootedShape shape(cx, LexicalScope::getEmptyExtensibleEnvironmentShape(cx));
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -974,7 +974,7 @@ BlockLexicalEnvironmentObject::createHol
   RootedObject enclosingEnv(cx, &cx->global()->lexicalEnvironment());
   Rooted<LexicalEnvironmentObject*> env(
       cx, createTemplateObject(cx, shape, enclosingEnv, gc::TenuredHeap));
-  if (!env) {
+  if (!env) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -982,7 +982,7 @@ BlockLexicalEnvironmentObject::createHol
   RootedId id(cx);
   for (Rooted<BindingIter> bi(cx, BindingIter(scope)); bi; bi++) {
     id = NameToId(bi.name()->asPropertyName());
-    if (!SetProperty(cx, env, id, optimizedOut)) {
+    if (!SetProperty(cx, env, id, optimizedOut)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -1004,7 +1004,7 @@ BlockLexicalEnvironmentObject* BlockLexi
   RootedObject enclosing(cx, &env->enclosingEnvironment());
   Rooted<BlockLexicalEnvironmentObject*> copy(
       cx, create(cx, scope, enclosing, gc::DefaultHeap));
-  if (!copy) {
+  if (!copy) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1108,7 +1108,7 @@ GlobalLexicalEnvironmentObject* GlobalLe
   MOZ_ASSERT(global);
 
   RootedShape shape(cx, LexicalScope::getEmptyExtensibleEnvironmentShape(cx));
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1136,7 +1136,7 @@ NonSyntacticLexicalEnvironmentObject::cr
   MOZ_ASSERT(!IsSyntacticEnvironment(enclosing));
 
   RootedShape shape(cx, LexicalScope::getEmptyExtensibleEnvironmentShape(cx));
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1156,7 +1156,7 @@ RuntimeLexicalErrorObject* RuntimeLexica
     JSContext* cx, HandleObject enclosing, unsigned errorNumber) {
   RootedShape shape(cx, EmptyEnvironmentShape(cx, &class_, JSSLOT_FREE(&class_),
                                               ObjectFlags()));
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1297,7 +1297,7 @@ void EnvironmentIter::settle() {
     // Skip until we're at the enclosing scope of the script.
     while (si_.scope() != frame_.script()->enclosingScope()) {
       if (env_->is<BlockLexicalEnvironmentObject>() &&
-          &env_->as<BlockLexicalEnvironmentObject>().scope() == si_.scope()) {
+          &env_->as<BlockLexicalEnvironmentObject>().scope() == si_.scope()) {MOZ_RELEASE_ASSERT(0);
         MOZ_ASSERT(si_.kind() == ScopeKind::NamedLambda ||
                    si_.kind() == ScopeKind::StrictNamedLambda);
         env_ =
@@ -1480,7 +1480,7 @@ class DebugEnvironmentProxyHandler : pub
         CallObject& callobj = env->as<CallObject>();
         RootedFunction fun(cx, &callobj.callee());
         script = JSFunction::getOrCreateScript(cx, fun);
-        if (!script->ensureHasAnalyzedArgsUsage(cx)) {
+        if (!script->ensureHasAnalyzedArgsUsage(cx)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
@@ -1525,9 +1525,9 @@ class DebugEnvironmentProxyHandler : pub
             genObj->setUnaliasedLocal(i, vp);
           }
         } else if (NativeObject* snapshot = debugEnv->maybeSnapshot()) {
-          if (action == GET) {
+          if (action == GET) {MOZ_RELEASE_ASSERT(0);
             vp.set(snapshot->getDenseElement(script->numArgs() + i));
-          } else {
+          } else {MOZ_RELEASE_ASSERT(0);
             snapshot->setDenseElement(script->numArgs() + i, vp);
           }
         } else {
@@ -1559,9 +1559,9 @@ class DebugEnvironmentProxyHandler : pub
             }
           }
         } else if (NativeObject* snapshot = debugEnv->maybeSnapshot()) {
-          if (action == GET) {
+          if (action == GET) {MOZ_RELEASE_ASSERT(0);
             vp.set(snapshot->getDenseElement(i));
-          } else {
+          } else {MOZ_RELEASE_ASSERT(0);
             snapshot->setDenseElement(i, vp);
           }
         } else {
@@ -1603,7 +1603,7 @@ class DebugEnvironmentProxyHandler : pub
 
       // Currently all vars inside non-strict eval var environments are aliased.
       if (env->is<VarEnvironmentObject>() &&
-          env->as<VarEnvironmentObject>().isForNonStrictEval()) {
+          env->as<VarEnvironmentObject>().isForNonStrictEval()) {MOZ_RELEASE_ASSERT(0);
         return true;
       }
 
@@ -1621,7 +1621,7 @@ class DebugEnvironmentProxyHandler : pub
       while (bi && NameToId(bi.name()->asPropertyName()) != id) {
         bi++;
       }
-      if (!bi) {
+      if (!bi) {MOZ_RELEASE_ASSERT(0);
         return true;
       }
 
@@ -1654,7 +1654,7 @@ class DebugEnvironmentProxyHandler : pub
                  genObj && genObj->isSuspended() && genObj->hasStackStorage()) {
         if (action == GET) {
           vp.set(genObj->getUnaliasedLocal(loc.slot()));
-        } else {
+        } else {MOZ_RELEASE_ASSERT(0);
           genObj->setUnaliasedLocal(loc.slot(), vp);
         }
       } else if (NativeObject* snapshot = debugEnv->maybeSnapshot()) {
@@ -1678,11 +1678,11 @@ class DebugEnvironmentProxyHandler : pub
             return true;
           }
 
-          if (!GetProperty(cx, env, env, id, vp)) {
+          if (!GetProperty(cx, env, env, id, vp)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         } else {
-          if (!SetProperty(cx, env, id, vp)) {
+          if (!SetProperty(cx, env, id, vp)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -1714,7 +1714,7 @@ class DebugEnvironmentProxyHandler : pub
         MOZ_ASSERT(frame.isWasmDebugFrame());
         wasm::DebugFrame* wasmFrame = frame.asWasmDebugFrame();
         if (action == GET) {
-          if (!wasmFrame->getLocal(index, vp)) {
+          if (!wasmFrame->getLocal(index, vp)) {MOZ_RELEASE_ASSERT(0);
             ReportOutOfMemory(cx);
             return false;
           }
@@ -1722,7 +1722,7 @@ class DebugEnvironmentProxyHandler : pub
         } else {  // if (action == SET)
                   // TODO
         }
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         *accessResult = ACCESS_LOST;
       }
       return true;
@@ -1753,7 +1753,7 @@ class DebugEnvironmentProxyHandler : pub
         if (instanceScope->globalsStart() <= index) {
           MOZ_ASSERT(index < instanceScope->namesCount());
           if (!instance.debug().getGlobal(
-                  instance, index - instanceScope->globalsStart(), vp)) {
+                  instance, index - instanceScope->globalsStart(), vp)) {MOZ_RELEASE_ASSERT(0);
             ReportOutOfMemory(cx);
             return false;
           }
@@ -2006,9 +2006,9 @@ class DebugEnvironmentProxyHandler : pub
 
   bool getMissingArgumentsPropertyDescriptor(
       JSContext* cx, Handle<DebugEnvironmentProxy*> debugEnv,
-      EnvironmentObject& env, MutableHandle<PropertyDescriptor> desc) const {
+      EnvironmentObject& env, MutableHandle<PropertyDescriptor> desc) const {MOZ_RELEASE_ASSERT(0);
     RootedArgumentsObject argsObj(cx);
-    if (!createMissingArguments(cx, env, &argsObj)) {
+    if (!createMissingArguments(cx, env, &argsObj)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2027,10 +2027,10 @@ class DebugEnvironmentProxyHandler : pub
   }
   bool getMissingThisPropertyDescriptor(
       JSContext* cx, Handle<DebugEnvironmentProxy*> debugEnv,
-      EnvironmentObject& env, MutableHandle<PropertyDescriptor> desc) const {
+      EnvironmentObject& env, MutableHandle<PropertyDescriptor> desc) const {MOZ_RELEASE_ASSERT(0);
     RootedValue thisv(cx);
     bool success;
-    if (!createMissingThis(cx, env, &thisv, &success)) {
+    if (!createMissingThis(cx, env, &thisv, &success)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2050,22 +2050,22 @@ class DebugEnvironmentProxyHandler : pub
 
   bool getOwnPropertyDescriptor(
       JSContext* cx, HandleObject proxy, HandleId id,
-      MutableHandle<PropertyDescriptor> desc) const override {
+      MutableHandle<PropertyDescriptor> desc) const override {MOZ_RELEASE_ASSERT(0);
     Rooted<DebugEnvironmentProxy*> debugEnv(
         cx, &proxy->as<DebugEnvironmentProxy>());
     Rooted<EnvironmentObject*> env(cx, &debugEnv->environment());
 
-    if (isMissingArguments(cx, id, *env)) {
+    if (isMissingArguments(cx, id, *env)) {MOZ_RELEASE_ASSERT(0);
       return getMissingArgumentsPropertyDescriptor(cx, debugEnv, *env, desc);
     }
 
-    if (isMissingThis(cx, id, *env)) {
+    if (isMissingThis(cx, id, *env)) {MOZ_RELEASE_ASSERT(0);
       return getMissingThisPropertyDescriptor(cx, debugEnv, *env, desc);
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     RootedValue v(cx);
     AccessResult access;
-    if (!handleUnaliasedAccess(cx, debugEnv, env, id, GET, &v, &access)) {
+    if (!handleUnaliasedAccess(cx, debugEnv, env, id, GET, &v, &access)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2095,7 +2095,7 @@ class DebugEnvironmentProxyHandler : pub
   bool getMissingArguments(JSContext* cx, EnvironmentObject& env,
                            MutableHandleValue vp) const {
     RootedArgumentsObject argsObj(cx);
-    if (!createMissingArguments(cx, env, &argsObj)) {
+    if (!createMissingArguments(cx, env, &argsObj)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2113,7 +2113,7 @@ class DebugEnvironmentProxyHandler : pub
                       MutableHandleValue vp) const {
     RootedValue thisv(cx);
     bool success;
-    if (!createMissingThis(cx, env, &thisv, &success)) {
+    if (!createMissingThis(cx, env, &thisv, &success)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2143,7 +2143,7 @@ class DebugEnvironmentProxyHandler : pub
     }
 
     AccessResult access;
-    if (!handleUnaliasedAccess(cx, debugEnv, env, id, GET, vp, &access)) {
+    if (!handleUnaliasedAccess(cx, debugEnv, env, id, GET, vp, &access)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2185,7 +2185,7 @@ class DebugEnvironmentProxyHandler : pub
   }
 
   bool getMissingThisMaybeSentinelValue(JSContext* cx, EnvironmentObject& env,
-                                        MutableHandleValue vp) const {
+                                        MutableHandleValue vp) const {MOZ_RELEASE_ASSERT(0);
     RootedValue thisv(cx);
     bool success;
     if (!createMissingThis(cx, env, &thisv, &success)) {
@@ -2207,12 +2207,12 @@ class DebugEnvironmentProxyHandler : pub
     if (isMissingArguments(cx, id, *env)) {
       return getMissingArgumentsMaybeSentinelValue(cx, *env, vp);
     }
-    if (isMissingThis(cx, id, *env)) {
+    if (isMissingThis(cx, id, *env)) {MOZ_RELEASE_ASSERT(0);
       return getMissingThisMaybeSentinelValue(cx, *env, vp);
     }
 
     AccessResult access;
-    if (!handleUnaliasedAccess(cx, debugEnv, env, id, GET, vp, &access)) {
+    if (!handleUnaliasedAccess(cx, debugEnv, env, id, GET, vp, &access)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2254,7 +2254,7 @@ class DebugEnvironmentProxyHandler : pub
 
     AccessResult access;
     RootedValue valCopy(cx, v);
-    if (!handleUnaliasedAccess(cx, debugEnv, env, id, SET, &valCopy, &access)) {
+    if (!handleUnaliasedAccess(cx, debugEnv, env, id, SET, &valCopy, &access)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2277,7 +2277,7 @@ class DebugEnvironmentProxyHandler : pub
         cx, &proxy->as<DebugEnvironmentProxy>().environment());
 
     bool found;
-    if (!has(cx, proxy, id, &found)) {
+    if (!has(cx, proxy, id, &found)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (found) {
@@ -2293,12 +2293,12 @@ class DebugEnvironmentProxyHandler : pub
         cx, &proxy->as<DebugEnvironmentProxy>().environment());
 
     if (isMissingArgumentsBinding(*env)) {
-      if (!props.append(NameToId(cx->names().arguments))) {
+      if (!props.append(NameToId(cx->names().arguments))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
     if (isMissingThisBinding(*env)) {
-      if (!props.append(NameToId(cx->names().dotThis))) {
+      if (!props.append(NameToId(cx->names().dotThis))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2317,7 +2317,7 @@ class DebugEnvironmentProxyHandler : pub
     } else {
       target = env;
     }
-    if (!GetPropertyKeys(cx, target, JSITER_OWNONLY, props)) {
+    if (!GetPropertyKeys(cx, target, JSITER_OWNONLY, props)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2325,14 +2325,14 @@ class DebugEnvironmentProxyHandler : pub
       size_t j = 0;
       for (size_t i = 0; i < props.length(); i++) {
         bool inScope;
-        if (!CheckUnscopables(cx, env, props[i], &inScope)) {
+        if (!CheckUnscopables(cx, env, props[i], &inScope)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         if (inScope) {
           props[j++].set(props[i]);
         }
       }
-      if (!props.resize(j)) {
+      if (!props.resize(j)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2373,7 +2373,7 @@ class DebugEnvironmentProxyHandler : pub
 
     bool found;
     RootedObject env(cx, &envObj);
-    if (!JS_HasPropertyById(cx, env, id, &found)) {
+    if (!JS_HasPropertyById(cx, env, id, &found)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2621,7 +2621,7 @@ bool DebugEnvironments::addDebugEnvironm
   MOZ_ASSERT(cx->realm() == env->realm());
   MOZ_ASSERT(cx->realm() == debugEnv->nonCCWRealm());
 
-  if (!CanUseDebugEnvironmentMaps(cx)) {
+  if (!CanUseDebugEnvironmentMaps(cx)) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -2658,19 +2658,19 @@ bool DebugEnvironments::addDebugEnvironm
   MOZ_ASSERT(!ei.hasSyntacticEnvironment());
   MOZ_ASSERT(cx->realm() == debugEnv->nonCCWRealm());
 
-  if (!CanUseDebugEnvironmentMaps(cx)) {
+  if (!CanUseDebugEnvironmentMaps(cx)) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   DebugEnvironments* envs = ensureRealmData(cx);
-  if (!envs) {
+  if (!envs) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MissingEnvironmentKey key(ei);
   MOZ_ASSERT(!envs->missingEnvs.has(key));
   if (!envs->missingEnvs.put(key,
-                             WeakHeapPtr<DebugEnvironmentProxy*>(debugEnv))) {
+                             WeakHeapPtr<DebugEnvironmentProxy*>(debugEnv))) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -2717,7 +2717,7 @@ void DebugEnvironments::takeFrameSnapsho
     // even if we don't need all of them (like in the case of a defaults
     // parameter scope having frame slots).
     uint32_t numFormals = frame.numFormalArgs();
-    if (!vec.resize(numFormals + frameSlotCount)) {
+    if (!vec.resize(numFormals + frameSlotCount)) {MOZ_RELEASE_ASSERT(0);
       cx->recoverFromOutOfMemory();
       return;
     }
@@ -2747,14 +2747,14 @@ void DebugEnvironments::takeFrameSnapsho
           &debugEnv->environment().as<BlockLexicalEnvironmentObject>().scope();
       frameSlotStart = scope->firstFrameSlot();
       frameSlotEnd = scope->nextFrameSlot();
-    } else if (debugEnv->environment().is<VarEnvironmentObject>()) {
+    } else if (debugEnv->environment().is<VarEnvironmentObject>()) {MOZ_RELEASE_ASSERT(0);
       VarEnvironmentObject* env =
           &debugEnv->environment().as<VarEnvironmentObject>();
-      if (frame.isFunctionFrame()) {
+      if (frame.isFunctionFrame()) {MOZ_RELEASE_ASSERT(0);
         VarScope* scope = &env->scope().as<VarScope>();
         frameSlotStart = scope->firstFrameSlot();
         frameSlotEnd = scope->nextFrameSlot();
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         EvalScope* scope = &env->scope().as<EvalScope>();
         MOZ_ASSERT(scope == script->bodyScope());
         frameSlotStart = 0;
@@ -2771,7 +2771,7 @@ void DebugEnvironments::takeFrameSnapsho
     uint32_t frameSlotCount = frameSlotEnd - frameSlotStart;
     MOZ_ASSERT(frameSlotCount <= script->nfixed());
 
-    if (!vec.resize(frameSlotCount)) {
+    if (!vec.resize(frameSlotCount)) {MOZ_RELEASE_ASSERT(0);
       cx->recoverFromOutOfMemory();
       return;
     }
@@ -2818,7 +2818,7 @@ void DebugEnvironments::onPopCall(JSCont
      * The frame may be observed before the prologue has created the
      * CallObject. See EnvironmentIter::settle.
      */
-    if (!frame.environmentChain()->is<CallObject>()) {
+    if (!frame.environmentChain()->is<CallObject>()) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
@@ -2917,7 +2917,7 @@ void DebugEnvironments::onRealmUnsetIsDe
 }
 
 bool DebugEnvironments::updateLiveEnvironments(JSContext* cx) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2949,7 +2949,7 @@ bool DebugEnvironments::updateLiveEnviro
 
     RootedObject env(cx);
     RootedScope scope(cx);
-    if (!GetFrameEnvironmentAndScope(cx, frame, i.pc(), &env, &scope)) {
+    if (!GetFrameEnvironmentAndScope(cx, frame, i.pc(), &env, &scope)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2958,10 +2958,10 @@ bool DebugEnvironments::updateLiveEnviro
       if (ei.hasSyntacticEnvironment() && !ei.scope().is<GlobalScope>()) {
         MOZ_ASSERT(ei.environment().realm() == cx->realm());
         DebugEnvironments* envs = ensureRealmData(cx);
-        if (!envs) {
+        if (!envs) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
-        if (!envs->liveEnvs.put(&ei.environment(), LiveEnvironmentVal(ei))) {
+        if (!envs->liveEnvs.put(&ei.environment(), LiveEnvironmentVal(ei))) {MOZ_RELEASE_ASSERT(0);
           ReportOutOfMemory(cx);
           return false;
         }
@@ -2981,7 +2981,7 @@ bool DebugEnvironments::updateLiveEnviro
 LiveEnvironmentVal* DebugEnvironments::hasLiveEnvironment(
     EnvironmentObject& env) {
   DebugEnvironments* envs = env.realm()->debugEnvs();
-  if (!envs) {
+  if (!envs) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3069,13 +3069,13 @@ static DebugEnvironmentProxy* GetDebugEn
 
   EnvironmentIter copy(cx, ei);
   RootedObject enclosingDebug(cx, GetDebugEnvironment(cx, ++copy));
-  if (!enclosingDebug) {
+  if (!enclosingDebug) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   Rooted<DebugEnvironmentProxy*> debugEnv(
       cx, DebugEnvironmentProxy::create(cx, *env, enclosingDebug));
-  if (!debugEnv) {
+  if (!debugEnv) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3101,7 +3101,7 @@ static DebugEnvironmentProxy* GetDebugEn
 
   EnvironmentIter copy(cx, ei);
   RootedObject enclosingDebug(cx, GetDebugEnvironment(cx, ++copy));
-  if (!enclosingDebug) {
+  if (!enclosingDebug) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3125,7 +3125,7 @@ static DebugEnvironmentProxy* GetDebugEn
     JS::ExposeObjectToActiveJS(callee);
     Rooted<CallObject*> callobj(cx,
                                 CallObject::createHollowForDebug(cx, callee));
-    if (!callobj) {
+    if (!callobj) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -3135,7 +3135,7 @@ static DebugEnvironmentProxy* GetDebugEn
     Rooted<BlockLexicalEnvironmentObject*> env(
         cx,
         BlockLexicalEnvironmentObject::createHollowForDebug(cx, lexicalScope));
-    if (!env) {
+    if (!env) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -3146,7 +3146,7 @@ static DebugEnvironmentProxy* GetDebugEn
     Rooted<WasmInstanceEnvironmentObject*> env(
         cx, WasmInstanceEnvironmentObject::createHollowForDebug(
                 cx, wasmInstanceScope));
-    if (!env) {
+    if (!env) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -3159,7 +3159,7 @@ static DebugEnvironmentProxy* GetDebugEn
     Rooted<WasmFunctionCallObject*> callobj(
         cx, WasmFunctionCallObject::createHollowForDebug(cx, enclosing,
                                                          wasmFunctionScope));
-    if (!callobj) {
+    if (!callobj) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -3170,14 +3170,14 @@ static DebugEnvironmentProxy* GetDebugEn
 
     Rooted<VarEnvironmentObject*> env(
         cx, VarEnvironmentObject::createHollowForDebug(cx, scope));
-    if (!env) {
+    if (!env) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     debugEnv = DebugEnvironmentProxy::create(cx, *env, enclosingDebug);
   }
 
-  if (!debugEnv) {
+  if (!debugEnv) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3201,7 +3201,7 @@ static JSObject* GetDebugEnvironmentForN
 }
 
 static JSObject* GetDebugEnvironment(JSContext* cx, const EnvironmentIter& ei) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3228,7 +3228,7 @@ JSObject* js::GetDebugEnvironmentForFunc
                                              HandleFunction fun) {
   cx->check(fun);
   MOZ_ASSERT(CanUseDebugEnvironmentMaps(cx));
-  if (!DebugEnvironments::updateLiveEnvironments(cx)) {
+  if (!DebugEnvironments::updateLiveEnvironments(cx)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   JSScript* script = JSFunction::getOrCreateScript(cx, fun);
@@ -3253,7 +3253,7 @@ JSObject* js::GetDebugEnvironmentForFram
                                           jsbytecode* pc) {
   cx->check(frame);
   if (CanUseDebugEnvironmentMaps(cx) &&
-      !DebugEnvironments::updateLiveEnvironments(cx)) {
+      !DebugEnvironments::updateLiveEnvironments(cx)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3387,7 +3387,7 @@ static bool GetThisValueForDebuggerEnvir
         // correct |this| value for this frame (box primitives if not
         // in strict mode), and assign it to the this-argument slot so
         // JSOp::FunctionThis will use it and not box a second time.
-        if (!GetFunctionThis(cx, initialFrame, res)) {
+        if (!GetFunctionThis(cx, initialFrame, res)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         initialFrame.thisArgument() = res;
@@ -3484,13 +3484,13 @@ bool js::CheckLexicalNameConflict(
              (shape = varObj->as<NativeObject>().lookup(cx, name))) {
     // Faster path for ES 15.1.11 step 5.c-d when the shape can be found
     // without going through a resolve hook.
-    if (!shape->configurable()) {
+    if (!shape->configurable()) {MOZ_RELEASE_ASSERT(0);
       redeclKind = "non-configurable global property";
     }
   } else {
     // ES 15.1.11 step 5.c-d
     Rooted<mozilla::Maybe<PropertyDescriptor>> desc(cx);
-    if (!GetOwnPropertyDescriptor(cx, varObj, id, &desc)) {
+    if (!GetOwnPropertyDescriptor(cx, varObj, id, &desc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (desc.isSome() && !desc->configurable()) {
@@ -3532,7 +3532,7 @@ bool js::CheckCanDeclareGlobalBinding(JS
                                       bool isFunction) {
   RootedId id(cx, NameToId(name));
   Rooted<mozilla::Maybe<PropertyDescriptor>> desc(cx);
-  if (!GetOwnPropertyDescriptor(cx, global, id, &desc)) {
+  if (!GetOwnPropertyDescriptor(cx, global, id, &desc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3662,14 +3662,14 @@ static bool InitHoistedFunctionDeclarati
 
     // Clone the function before exposing to script as a binding.
     JSObject* clone = Lambda(cx, fun, envChain);
-    if (!clone) {
+    if (!clone) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     RootedValue rval(cx, ObjectValue(*clone));
 
     Rooted<PropertyResult> prop(cx);
     RootedObject pobj(cx);
-    if (!LookupProperty(cx, varObj, name, &pobj, &prop)) {
+    if (!LookupProperty(cx, varObj, name, &pobj, &prop)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3679,12 +3679,12 @@ static bool InitHoistedFunctionDeclarati
                                          : JSPROP_ENUMERATE | JSPROP_PERMANENT;
 
     if (prop.isNotFound() || pobj != varObj) {
-      if (!DefineDataProperty(cx, varObj, name, rval, attrs)) {
+      if (!DefineDataProperty(cx, varObj, name, rval, attrs)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       if (varObj->is<GlobalObject>()) {
-        if (!varObj->as<GlobalObject>().realm()->addToVarNames(cx, name)) {
+        if (!varObj->as<GlobalObject>().realm()->addToVarNames(cx, name)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -3705,7 +3705,7 @@ static bool InitHoistedFunctionDeclarati
     if (varObj->is<GlobalObject>()) {
       Shape* shape = prop.shape();
       if (shape->configurable()) {
-        if (!DefineDataProperty(cx, varObj, name, rval, attrs)) {
+        if (!DefineDataProperty(cx, varObj, name, rval, attrs)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
@@ -3716,7 +3716,7 @@ static bool InitHoistedFunctionDeclarati
 
       // Careful: the presence of a shape, even one appearing to derive from
       // a variable declaration, doesn't mean it's in [[VarNames]].
-      if (!varObj->as<GlobalObject>().realm()->addToVarNames(cx, name)) {
+      if (!varObj->as<GlobalObject>().realm()->addToVarNames(cx, name)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -3943,7 +3943,7 @@ bool js::InitFunctionEnvironmentObjects(
   // Named lambdas may have an environment that holds itself for recursion.
   if (callee->needsNamedLambdaEnvironment()) {
     NamedLambdaObject* declEnv = NamedLambdaObject::create(cx, frame);
-    if (!declEnv) {
+    if (!declEnv) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     frame.pushOnEnvironmentChain(*declEnv);
@@ -3981,7 +3981,7 @@ bool js::GetFrameEnvironmentAndScope(JSC
     RootedWasmInstanceObject instance(cx, frame.wasmInstance()->object());
     uint32_t funcIndex = frame.asWasmDebugFrame()->funcIndex();
     scope.set(WasmInstanceObject::getFunctionScope(cx, instance, funcIndex));
-    if (!scope) {
+    if (!scope) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
diff --git a/js/src/vm/EqualityOperations.cpp b/js/src/vm/EqualityOperations.cpp
--- a/js/src/vm/EqualityOperations.cpp
+++ b/js/src/vm/EqualityOperations.cpp
@@ -111,7 +111,7 @@ bool js::LooselyEqual(JSContext* cx, JS:
   // Step 6.
   if (lval.isNumber() && rval.isString()) {
     double num;
-    if (!StringToNumber(cx, rval.toString(), &num)) {
+    if (!StringToNumber(cx, rval.toString(), &num)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     *result = (lval.toNumber() == num);
@@ -121,7 +121,7 @@ bool js::LooselyEqual(JSContext* cx, JS:
   // Step 7.
   if (lval.isString() && rval.isNumber()) {
     double num;
-    if (!StringToNumber(cx, lval.toString(), &num)) {
+    if (!StringToNumber(cx, lval.toString(), &num)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     *result = (num == rval.toNumber());
diff --git a/js/src/vm/ErrorObject.cpp b/js/src/vm/ErrorObject.cpp
--- a/js/src/vm/ErrorObject.cpp
+++ b/js/src/vm/ErrorObject.cpp
@@ -238,13 +238,13 @@ static ErrorObject* CreateErrorObject(JS
       }
     }
   }
-  if (!fileName) {
+  if (!fileName) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   uint32_t lineNumber, columnNumber = 0;
   if (args.length() > messageArg + 2) {
-    if (!ToUint32(cx, args[messageArg + 2], &lineNumber)) {
+    if (!ToUint32(cx, args[messageArg + 2], &lineNumber)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
@@ -299,7 +299,7 @@ static ArrayObject* IterableToArray(JSCo
   }
 
   RootedArrayObject array(cx, NewDenseEmptyArray(cx));
-  if (!array) {
+  if (!array) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -331,7 +331,7 @@ static bool AggregateError(JSContext* cx
   // Steps 1-2. (9.1.13 OrdinaryCreateFromConstructor, steps 1-2).
   RootedObject proto(cx);
   if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_AggregateError,
-                                          &proto)) {
+                                          &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -396,7 +396,7 @@ JSObject* ErrorObject::createConstructor
   } else {
     RootedFunction proto(
         cx, GlobalObject::getOrCreateErrorConstructor(cx, cx->global()));
-    if (!proto) {
+    if (!proto) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -430,7 +430,7 @@ Shape* js::ErrorObject::assignInitialSha
   MOZ_ASSERT(obj->empty());
 
   if (!NativeObject::addProperty(cx, obj, cx->names().fileName, FILENAME_SLOT,
-                                 0)) {
+                                 0)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (!NativeObject::addProperty(cx, obj, cx->names().lineNumber,
@@ -453,7 +453,7 @@ bool js::ErrorObject::init(JSContext* cx
   // Null out early in case of error, for exn_finalize's sake.
   obj->initReservedSlot(ERROR_REPORT_SLOT, PrivateValue(nullptr));
 
-  if (!EmptyShape::ensureInitialCustomShape<ErrorObject>(cx, obj)) {
+  if (!EmptyShape::ensureInitialCustomShape<ErrorObject>(cx, obj)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -464,7 +464,7 @@ bool js::ErrorObject::init(JSContext* cx
   if (message) {
     Shape* messageShape = NativeObject::addProperty(
         cx, obj, cx->names().message, MESSAGE_SLOT, 0);
-    if (!messageShape) {
+    if (!messageShape) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     MOZ_ASSERT(messageShape->slot() == MESSAGE_SLOT);
@@ -515,7 +515,7 @@ ErrorObject* js::ErrorObject::create(JSC
   if (!proto) {
     proto = GlobalObject::getOrCreateCustomErrorPrototype(cx, cx->global(),
                                                           errorType);
-    if (!proto) {
+    if (!proto) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -524,7 +524,7 @@ ErrorObject* js::ErrorObject::create(JSC
   {
     const JSClass* clasp = ErrorObject::classForType(errorType);
     JSObject* obj = NewObjectWithGivenProto(cx, clasp, proto);
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     errObject = &obj->as<ErrorObject>();
@@ -553,7 +553,7 @@ JSErrorReport* js::ErrorObject::getOrCre
 
   // Filename.
   UniqueChars filenameStr = JS_EncodeStringToLatin1(cx, fileName(cx));
-  if (!filenameStr) {
+  if (!filenameStr) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   report.filename = filenameStr.get();
@@ -571,7 +571,7 @@ JSErrorReport* js::ErrorObject::getOrCre
   }
 
   UniqueChars utf8 = StringToNewUTF8CharsZ(cx, *message);
-  if (!utf8) {
+  if (!utf8) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   report.initOwnedMessage(utf8.release());
@@ -597,14 +597,14 @@ static bool FindErrorInstanceOrPrototype
   // to continue returning stacks that are useless, but at least don't throw.
 
   RootedObject target(cx, CheckedUnwrapStatic(obj));
-  if (!target) {
+  if (!target) {MOZ_RELEASE_ASSERT(0);
     ReportAccessDenied(cx);
     return false;
   }
 
   RootedObject proto(cx);
   while (!IsErrorProtoKey(StandardProtoKeyOrNull(target))) {
-    if (!GetPrototype(cx, target, &proto)) {
+    if (!GetPrototype(cx, target, &proto)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -657,7 +657,7 @@ bool js::ErrorObject::getStack_impl(JSCo
 
   RootedObject savedFrameObj(cx, obj->as<ErrorObject>().stack());
   RootedString stackString(cx);
-  if (!BuildStackString(cx, principals, savedFrameObj, &stackString)) {
+  if (!BuildStackString(cx, principals, savedFrameObj, &stackString)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -667,7 +667,7 @@ bool js::ErrorObject::getStack_impl(JSCo
     HandlePropertyName name = cx->names().ErrorToStringWithTrailingNewline;
     FixedInvokeArgs<0> args2(cx);
     RootedValue rval(cx);
-    if (!CallSelfHostedFunction(cx, name, args.thisv(), args2, &rval)) {
+    if (!CallSelfHostedFunction(cx, name, args.thisv(), args2, &rval)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -713,7 +713,7 @@ JSString* js::ErrorToSource(JSContext* c
   RootedValue nameVal(cx);
   RootedString name(cx);
   if (!GetProperty(cx, obj, obj, cx->names().name, &nameVal) ||
-      !(name = ToString<CanGC>(cx, nameVal))) {
+      !(name = ToString<CanGC>(cx, nameVal))) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -734,35 +734,35 @@ JSString* js::ErrorToSource(JSContext* c
   RootedValue linenoVal(cx);
   uint32_t lineno;
   if (!GetProperty(cx, obj, obj, cx->names().lineNumber, &linenoVal) ||
-      !ToUint32(cx, linenoVal, &lineno)) {
+      !ToUint32(cx, linenoVal, &lineno)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   JSStringBuilder sb(cx);
-  if (!sb.append("(new ") || !sb.append(name) || !sb.append("(")) {
+  if (!sb.append("(new ") || !sb.append(name) || !sb.append("(")) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!sb.append(message)) {
+  if (!sb.append(message)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   if (!filename->empty()) {
-    if (!sb.append(", ") || !sb.append(filename)) {
+    if (!sb.append(", ") || !sb.append(filename)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
   if (lineno != 0) {
     /* We have a line, but no filename, add empty string */
-    if (filename->empty() && !sb.append(", \"\"")) {
+    if (filename->empty() && !sb.append(", \"\"")) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     JSString* linenumber = ToString<CanGC>(cx, linenoVal);
-    if (!linenumber) {
+    if (!linenumber) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (!sb.append(", ") || !sb.append(linenumber)) {
+    if (!sb.append(", ") || !sb.append(linenumber)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -784,7 +784,7 @@ static bool exn_toSource(JSContext* cx, 
   CallArgs args = CallArgsFromVp(argc, vp);
 
   RootedObject obj(cx, ToObject(cx, args.thisv()));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/vm/ErrorReporting.cpp b/js/src/vm/ErrorReporting.cpp
--- a/js/src/vm/ErrorReporting.cpp
+++ b/js/src/vm/ErrorReporting.cpp
@@ -59,7 +59,7 @@ bool js::ReportCompileWarning(JSContext*
   // it later.
   CompileError tempErr;
   CompileError* err = &tempErr;
-  if (cx->isHelperThreadContext() && !cx->addPendingCompileError(&err)) {
+  if (cx->isHelperThreadContext() && !cx->addPendingCompileError(&err)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -78,7 +78,7 @@ bool js::ReportCompileWarning(JSContext*
   }
 
   if (!ExpandErrorArgumentsVA(cx, GetErrorMessage, nullptr, errorNumber,
-                              ArgumentsAreLatin1, err, *args)) {
+                              ArgumentsAreLatin1, err, *args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -98,7 +98,7 @@ static void ReportCompileErrorImpl(JSCon
   // it later.
   js::CompileError tempErr;
   js::CompileError* err = &tempErr;
-  if (cx->isHelperThreadContext() && !cx->addPendingCompileError(&err)) {
+  if (cx->isHelperThreadContext() && !cx->addPendingCompileError(&err)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -117,7 +117,7 @@ static void ReportCompileErrorImpl(JSCon
   }
 
   if (!js::ExpandErrorArgumentsVA(cx, js::GetErrorMessage, nullptr, errorNumber,
-                                  argumentsType, err, *args)) {
+                                  argumentsType, err, *args)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -171,7 +171,7 @@ static void ReportError(JSContext* cx, J
  */
 static void PopulateReportBlame(JSContext* cx, JSErrorReport* report) {
   JS::Realm* realm = cx->realm();
-  if (!realm) {
+  if (!realm) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -322,7 +322,7 @@ static bool ExpandErrorArgumentsHelper(J
                                        T* reportp, va_list ap) {
   const JSErrorFormatString* efs;
 
-  if (!callback) {
+  if (!callback) {MOZ_RELEASE_ASSERT(0);
     callback = GetErrorMessage;
   }
 
@@ -359,7 +359,7 @@ static bool ExpandErrorArgumentsHelper(J
         size_t len = strlen(efs->format);
 
         AutoMessageArgs args;
-        if (!args.init(cx, messageArgs, argCount, argumentsType, ap)) {
+        if (!args.init(cx, messageArgs, argCount, argumentsType, ap)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -371,7 +371,7 @@ static bool ExpandErrorArgumentsHelper(J
          * is used once and only once in the expansion !!!
          */
         char* utf8 = out = cx->pod_malloc<char>(expandedLength + 1);
-        if (!out) {
+        if (!out) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -409,7 +409,7 @@ static bool ExpandErrorArgumentsHelper(J
       }
     }
   }
-  if (!reportp->message()) {
+  if (!reportp->message()) {MOZ_RELEASE_ASSERT(0);
     /* where's the right place for this ??? */
     const char* defaultErrorMessage =
         "No error message available for error number %d";
@@ -541,7 +541,7 @@ bool js::ReportErrorVA(JSContext* cx, Is
   JSErrorReport report;
 
   UniqueChars message(JS_vsmprintf(format, ap));
-  if (!message) {
+  if (!message) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -553,7 +553,7 @@ bool js::ReportErrorVA(JSContext* cx, Is
   report.errorNumber = JSMSG_USER_DEFINED_ERROR;
   if (argumentsType == ArgumentsAreASCII || argumentsType == ArgumentsAreUTF8) {
     report.initOwnedMessage(message.release());
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(argumentsType == ArgumentsAreLatin1);
     JS::Latin1Chars latin1(message.get(), strlen(message.get()));
     JS::UTF8CharsZ utf8(JS::CharsToNewUTF8CharsZ(cx, latin1));
@@ -572,15 +572,15 @@ bool js::ReportErrorVA(JSContext* cx, Is
 void js::MaybePrintAndClearPendingException(JSContext* cx) {
   if (!cx->isExceptionPending()) {
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   AutoClearPendingException acpe(cx);
 
   JS::ExceptionStack exnStack(cx);
-  if (!JS::StealPendingExceptionStack(cx, &exnStack)) {
+  if (!JS::StealPendingExceptionStack(cx, &exnStack)) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "error getting pending exception\n");
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   JS::ErrorReportBuilder report(cx);
   if (!report.init(cx, exnStack, JS::ErrorReportBuilder::WithSideEffects)) {
diff --git a/js/src/vm/ForOfIterator.cpp b/js/src/vm/ForOfIterator.cpp
--- a/js/src/vm/ForOfIterator.cpp
+++ b/js/src/vm/ForOfIterator.cpp
@@ -30,13 +30,13 @@ bool ForOfIterator::init(HandleValue ite
   // Check the PIC first for a match.
   if (iterableObj->is<ArrayObject>()) {
     ForOfPIC::Chain* stubChain = ForOfPIC::getOrCreate(cx);
-    if (!stubChain) {
+    if (!stubChain) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     bool optimized;
     if (!stubChain->tryOptimizeArray(cx, iterableObj.as<ArrayObject>(),
-                                     &optimized)) {
+                                     &optimized)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -71,7 +71,7 @@ bool ForOfIterator::init(HandleValue ite
   if (!callee.isObject() || !callee.toObject().isCallable()) {
     UniqueChars bytes =
         DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, iterable, nullptr);
-    if (!bytes) {
+    if (!bytes) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     JS_ReportErrorNumberUTF8(cx, GetErrorMessage, nullptr, JSMSG_NOT_ITERABLE,
@@ -165,7 +165,7 @@ void ForOfIterator::closeThrow() {
   RootedSavedFrame completionExceptionStack(cx_);
   if (cx_->isExceptionPending()) {
     if (!GetAndClearExceptionAndStack(cx_, &completionException,
-                                      &completionExceptionStack)) {
+                                      &completionExceptionStack)) {MOZ_RELEASE_ASSERT(0);
       completionException.setUndefined();
       completionExceptionStack = nullptr;
     }
@@ -175,7 +175,7 @@ void ForOfIterator::closeThrow() {
 
   // Step 3 (partial).
   RootedValue returnVal(cx_);
-  if (!GetProperty(cx_, iterator, iterator, cx_->names().return_, &returnVal)) {
+  if (!GetProperty(cx_, iterator, iterator, cx_->names().return_, &returnVal)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -186,13 +186,13 @@ void ForOfIterator::closeThrow() {
   }
 
   // Step 3 (remaining part)
-  if (!returnVal.isObject()) {
+  if (!returnVal.isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx_, GetErrorMessage, nullptr,
                               JSMSG_RETURN_NOT_CALLABLE);
     return;
   }
   RootedObject returnObj(cx_, &returnVal.toObject());
-  if (!returnObj->isCallable()) {
+  if (!returnObj->isCallable()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx_, GetErrorMessage, nullptr,
                               JSMSG_RETURN_NOT_CALLABLE);
     return;
diff --git a/js/src/vm/FrameIter.cpp b/js/src/vm/FrameIter.cpp
--- a/js/src/vm/FrameIter.cpp
+++ b/js/src/vm/FrameIter.cpp
@@ -134,7 +134,7 @@ uint8_t* JitFrameIter::resumePCinCurrent
 }
 
 bool JitFrameIter::done() const {
-  if (!isSome()) {
+  if (!isSome()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
   if (isJSJit()) {
@@ -298,7 +298,7 @@ void FrameIter::settleOnActivation() {
     if (activation->isJit()) {
       data_.jitFrames_ = JitFrameIter(activation->asJit());
       data_.jitFrames_.skipNonScriptedJSFrames();
-      if (data_.jitFrames_.done()) {
+      if (data_.jitFrames_.done()) {MOZ_RELEASE_ASSERT(0);
         // It's possible to have an JitActivation with no scripted
         // frames, for instance if we hit an over-recursion during
         // bailout.
@@ -462,7 +462,7 @@ FrameIter& FrameIter::operator++() {
 
 FrameIter::Data* FrameIter::copyData() const {
   Data* data = data_.cx_->new_<Data>(data_);
-  if (!data) {
+  if (!data) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -929,7 +929,7 @@ ArgumentsObject& FrameIter::argsObj() co
   return abstractFramePtr().argsObj();
 }
 
-Value FrameIter::thisArgument(JSContext* cx) const {
+Value FrameIter::thisArgument(JSContext* cx) const {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(isFunctionFrame());
 
   switch (data_.state_) {
@@ -948,7 +948,7 @@ Value FrameIter::thisArgument(JSContext*
   MOZ_CRASH("Unexpected state");
 }
 
-Value FrameIter::newTarget() const {
+Value FrameIter::newTarget() const {MOZ_RELEASE_ASSERT(0);
   switch (data_.state_) {
     case DONE:
       break;
@@ -961,7 +961,7 @@ Value FrameIter::newTarget() const {
   MOZ_CRASH("Unexpected state");
 }
 
-Value FrameIter::returnValue() const {
+Value FrameIter::returnValue() const {MOZ_RELEASE_ASSERT(0);
   switch (data_.state_) {
     case DONE:
       break;
@@ -976,7 +976,7 @@ Value FrameIter::returnValue() const {
   MOZ_CRASH("Unexpected state");
 }
 
-void FrameIter::setReturnValue(const Value& v) {
+void FrameIter::setReturnValue(const Value& v) {MOZ_RELEASE_ASSERT(0);
   switch (data_.state_) {
     case DONE:
       break;
diff --git a/js/src/vm/GeckoProfiler.cpp b/js/src/vm/GeckoProfiler.cpp
--- a/js/src/vm/GeckoProfiler.cpp
+++ b/js/src/vm/GeckoProfiler.cpp
@@ -60,7 +60,7 @@ static void* GetTopProfilingJitFrame(Act
   jit::JitActivation* jitActivation = act->asJit();
 
   // If there is no exit frame set, just return.
-  if (!jitActivation->hasExitFP()) {
+  if (!jitActivation->hasExitFP()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -167,7 +167,7 @@ const char* GeckoProfilerRuntime::profil
 
   if (!s) {
     UniqueChars str = allocProfileString(cx, script);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     MOZ_ASSERT(script->hasBytecode());
@@ -204,7 +204,7 @@ void GeckoProfilerRuntime::markEvent(con
 bool GeckoProfilerThread::enter(JSContext* cx, JSScript* script) {
   const char* dynamicString =
       cx->runtime()->geckoProfiler().profileString(cx, script);
-  if (dynamicString == nullptr) {
+  if (dynamicString == nullptr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -283,7 +283,7 @@ UniqueChars GeckoProfilerRuntime::allocP
   JSFunction* func = script->function();
   if (func && func->displayAtom()) {
     nameStr = StringToNewUTF8CharsZ(cx, *func->displayAtom());
-    if (!nameStr) {
+    if (!nameStr) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -327,7 +327,7 @@ UniqueChars GeckoProfilerRuntime::allocP
 
   // Allocate string.
   UniqueChars str(cx->pod_malloc<char>(fullLength + 1));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -410,7 +410,7 @@ GeckoProfilerBaselineOSRMarker::GeckoPro
   }
 
   uint32_t sp = profiler->profilingStack_->stackPointer;
-  if (sp >= profiler->profilingStack_->stackCapacity()) {
+  if (sp >= profiler->profilingStack_->stackCapacity()) {MOZ_RELEASE_ASSERT(0);
     profiler = nullptr;
     return;
   }
@@ -444,7 +444,7 @@ GeckoProfilerBaselineOSRMarker::~GeckoPr
 JS_PUBLIC_API JSScript* ProfilingStackFrame::script() const {
   MOZ_ASSERT(isJsFrame());
   auto script = reinterpret_cast<JSScript*>(spOrScript.operator void*());
-  if (!script) {
+  if (!script) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/vm/GeneratorObject.cpp b/js/src/vm/GeneratorObject.cpp
--- a/js/src/vm/GeneratorObject.cpp
+++ b/js/src/vm/GeneratorObject.cpp
@@ -38,7 +38,7 @@ AbstractGeneratorObject* AbstractGenerat
   } else {
     genObj = AsyncFunctionGeneratorObject::create(cx, callee);
   }
-  if (!genObj) {
+  if (!genObj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -78,7 +78,7 @@ JSObject* AbstractGeneratorObject::creat
   Rooted<AbstractGeneratorObject*> genObj(
       cx, AbstractGeneratorObject::create(cx, fun, script, environmentChain,
                                           maybeArgs));
-  if (!genObj) {
+  if (!genObj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -94,7 +94,7 @@ JSObject* AbstractGeneratorObject::creat
   Rooted<ModuleObject*> module(cx, frame.script()->module());
   Rooted<AbstractGeneratorObject*> genObj(cx);
   genObj = AsyncFunctionGeneratorObject::create(cx, module);
-  if (!genObj) {
+  if (!genObj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -106,7 +106,7 @@ JSObject* AbstractGeneratorObject::creat
                                FunctionFlags::INTERPRETED_GENERATOR_OR_ASYNC,
                                nullptr, funName, nullptr,
                                gc::AllocKind::FUNCTION, GenericObject));
-  if (!handlerFun) {
+  if (!handlerFun) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   handlerFun->initScript(module->script());
@@ -116,7 +116,7 @@ JSObject* AbstractGeneratorObject::creat
 
   ArrayObject* stack =
       NewDenseFullyAllocatedArray(cx, module->script()->nslots());
-  if (!stack) {
+  if (!stack) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -275,7 +275,7 @@ bool AbstractGeneratorObject::resume(JSC
 
   RootedFunction callee(cx, &genObj->callee());
   RootedObject envChain(cx, &genObj->environmentChain());
-  if (!activation.resumeGeneratorFrame(callee, envChain)) {
+  if (!activation.resumeGeneratorFrame(callee, envChain)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   activation.regs().fp()->setResumedGenerator();
@@ -314,7 +314,7 @@ GeneratorObject* GeneratorObject::create
   // FIXME: This would be faster if we could avoid doing a lookup to get
   // the prototype for the instance.  Bug 906600.
   RootedValue pval(cx);
-  if (!GetProperty(cx, fun, fun, cx->names().prototype, &pval)) {
+  if (!GetProperty(cx, fun, fun, cx->names().prototype, &pval)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   RootedObject proto(cx, pval.isObject() ? &pval.toObject() : nullptr);
@@ -396,25 +396,25 @@ static bool GeneratorFunctionClassFinish
 
   RootedValue genFunctionVal(cx, ObjectValue(*genFunction));
   if (!DefineDataProperty(cx, genFunctionProto, cx->names().constructor,
-                          genFunctionVal, JSPROP_READONLY)) {
+                          genFunctionVal, JSPROP_READONLY)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(!genFunctionProto->as<NativeObject>().inDictionaryMode());
 
   RootedObject iteratorProto(
       cx, GlobalObject::getOrCreateIteratorPrototype(cx, global));
-  if (!iteratorProto) {
+  if (!iteratorProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject genObjectProto(cx, GlobalObject::createBlankPrototypeInheriting(
                                       cx, &PlainObject::class_, iteratorProto));
-  if (!genObjectProto) {
+  if (!genObjectProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!DefinePropertiesAndFunctions(cx, genObjectProto, nullptr,
                                     generator_methods) ||
-      !DefineToStringTag(cx, genObjectProto, cx->names().Generator)) {
+      !DefineToStringTag(cx, genObjectProto, cx->names().Generator)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/vm/GlobalObject.cpp b/js/src/vm/GlobalObject.cpp
--- a/js/src/vm/GlobalObject.cpp
+++ b/js/src/vm/GlobalObject.cpp
@@ -242,7 +242,7 @@ bool GlobalObject::resolveConstructor(JS
   // if a feature is compile-time disabled, clasp is null.
   const JSClass* clasp = ProtoKeyToClass(key);
   if (!clasp || skipDeselectedConstructor(cx, key)) {
-    if (mode == IfClassIsDisabled::Throw) {
+    if (mode == IfClassIsDisabled::Throw) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                 JSMSG_CONSTRUCTOR_DISABLED,
                                 clasp ? clasp->name : "constructor");
@@ -252,7 +252,7 @@ bool GlobalObject::resolveConstructor(JS
   }
 
   // Class spec must have a constructor defined.
-  if (!clasp->specDefined()) {
+  if (!clasp->specDefined()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -282,13 +282,13 @@ bool GlobalObject::resolveConstructor(JS
   // setting these up. Ensure the workaround is triggered already:
   if (key == JSProto_GeneratorFunction &&
       !global->getSlotRef(ITERATOR_PROTO).isObject()) {
-    if (!getOrCreateIteratorPrototype(cx, global)) {
+    if (!getOrCreateIteratorPrototype(cx, global)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // If iterator helpers are enabled, populating %IteratorPrototype% will
     // have recursively gone through here.
-    if (global->isStandardClassResolved(key)) {
+    if (global->isStandardClassResolved(key)) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
   }
@@ -300,7 +300,7 @@ bool GlobalObject::resolveConstructor(JS
   if (ClassObjectCreationOp createPrototype =
           clasp->specCreatePrototypeHook()) {
     proto = createPrototype(cx, key);
-    if (!proto) {
+    if (!proto) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -318,7 +318,7 @@ bool GlobalObject::resolveConstructor(JS
 
   // Create the constructor.
   RootedObject ctor(cx, clasp->specCreateConstructorHook()(cx, key));
-  if (!ctor) {
+  if (!ctor) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -326,7 +326,7 @@ bool GlobalObject::resolveConstructor(JS
   if (isObjectOrFunction) {
     if (clasp->specShouldDefineConstructor()) {
       RootedValue ctorValue(cx, ObjectValue(*ctor));
-      if (!DefineDataProperty(cx, global, id, ctorValue, JSPROP_RESOLVING)) {
+      if (!DefineDataProperty(cx, global, id, ctorValue, JSPROP_RESOLVING)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -338,7 +338,7 @@ bool GlobalObject::resolveConstructor(JS
   // functions and properties on the builtins and their prototypes.
   if (!cx->runtime()->isSelfHostingGlobal(global)) {
     if (const JSFunctionSpec* funs = clasp->specPrototypeFunctions()) {
-      if (!JS_DefineFunctions(cx, proto, funs)) {
+      if (!JS_DefineFunctions(cx, proto, funs)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -348,25 +348,25 @@ bool GlobalObject::resolveConstructor(JS
       }
     }
     if (const JSFunctionSpec* funs = clasp->specConstructorFunctions()) {
-      if (!JS_DefineFunctions(cx, ctor, funs)) {
+      if (!JS_DefineFunctions(cx, ctor, funs)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
     if (const JSPropertySpec* props = clasp->specConstructorProperties()) {
-      if (!JS_DefineProperties(cx, ctor, props)) {
+      if (!JS_DefineProperties(cx, ctor, props)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
   }
 
   // If the prototype exists, link it with the constructor.
-  if (proto && !LinkConstructorAndPrototype(cx, ctor, proto)) {
+  if (proto && !LinkConstructorAndPrototype(cx, ctor, proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Call the post-initialization hook, if provided.
   if (FinishClassInitOp finishInit = clasp->specFinishInitHook()) {
-    if (!finishInit(cx, ctor, proto)) {
+    if (!finishInit(cx, ctor, proto)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -396,7 +396,7 @@ bool GlobalObject::resolveConstructor(JS
 
       if (shouldReallyDefine) {
         RootedValue ctorValue(cx, ObjectValue(*ctor));
-        if (!DefineDataProperty(cx, global, id, ctorValue, JSPROP_RESOLVING)) {
+        if (!DefineDataProperty(cx, global, id, ctorValue, JSPROP_RESOLVING)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -460,7 +460,7 @@ JSObject* GlobalObject::createObject(JSC
                                      Handle<GlobalObject*> global,
                                      unsigned slot, HandleAtom tag,
                                      ObjectInitWithTagOp init) {
-  if (global->zone()->createdForHelperThread()) {
+  if (global->zone()->createdForHelperThread()) {MOZ_RELEASE_ASSERT(0);
     return createOffThreadObject(cx, global, slot);
   }
 
@@ -509,7 +509,7 @@ bool GlobalObject::resolveOffThreadConst
 
   Rooted<OffThreadPlaceholderObject*> placeholder(cx);
   placeholder = OffThreadPlaceholderObject::New(cx, prototypeSlot(key));
-  if (!placeholder) {
+  if (!placeholder) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -595,7 +595,7 @@ JSObject* GlobalObject::getOrCreateThrow
 
   RootedFunction throwTypeError(
       cx, NewNativeFunction(cx, ThrowTypeError, 0, nullptr));
-  if (!throwTypeError || !PreventExtensions(cx, throwTypeError)) {
+  if (!throwTypeError || !PreventExtensions(cx, throwTypeError)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -609,7 +609,7 @@ JSObject* GlobalObject::getOrCreateThrow
   RootedId lengthId(cx, NameToId(cx->names().length));
   ObjectOpResult lengthResult;
   if (!NativeDefineProperty(cx, throwTypeError, lengthId, nonConfigurableDesc,
-                            lengthResult)) {
+                            lengthResult)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   MOZ_ASSERT(lengthResult);
@@ -649,13 +649,13 @@ GlobalObject* GlobalObject::createIntern
 
   Rooted<GlobalLexicalEnvironmentObject*> lexical(
       cx, GlobalLexicalEnvironmentObject::create(cx, global));
-  if (!lexical) {
+  if (!lexical) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   Rooted<GlobalScope*> emptyGlobalScope(
       cx, GlobalScope::createEmpty(cx, ScopeKind::Global));
-  if (!emptyGlobalScope) {
+  if (!emptyGlobalScope) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   global->setReservedSlot(EMPTY_GLOBAL_SCOPE,
@@ -690,7 +690,7 @@ GlobalObject* GlobalObject::new_(JSConte
   }
 
   Realm* realm = NewRealm(cx, principals, options);
-  if (!realm) {
+  if (!realm) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -743,13 +743,13 @@ bool GlobalObject::initStandardClasses(J
   /* Define a top-level property 'undefined' with the undefined value. */
   if (!DefineDataProperty(
           cx, global, cx->names().undefined, UndefinedHandleValue,
-          JSPROP_PERMANENT | JSPROP_READONLY | JSPROP_RESOLVING)) {
+          JSPROP_PERMANENT | JSPROP_READONLY | JSPROP_RESOLVING)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Resolve a "globalThis" self-referential property if necessary.
   bool resolved;
-  if (!GlobalObject::maybeResolveGlobalThis(cx, global, &resolved)) {
+  if (!GlobalObject::maybeResolveGlobalThis(cx, global, &resolved)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -778,7 +778,7 @@ static bool InitBareBuiltinCtor(JSContex
   const JSClass* clasp = ProtoKeyToClass(protoKey);
   RootedObject proto(cx);
   proto = clasp->specCreatePrototypeHook()(cx, protoKey);
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -803,7 +803,7 @@ bool GlobalObject::initSelfHostingBuilti
   // Define a top-level property 'undefined' with the undefined value.
   if (!DefineDataProperty(cx, global, cx->names().undefined,
                           UndefinedHandleValue,
-                          JSPROP_PERMANENT | JSPROP_READONLY)) {
+                          JSPROP_PERMANENT | JSPROP_READONLY)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -871,7 +871,7 @@ JSFunction* GlobalObject::createConstruc
                                             const JSJitInfo* jitInfo) {
   RootedAtom name(cx, nameArg);
   JSFunction* fun = NewNativeConstructor(cx, ctor, length, name, kind);
-  if (!fun) {
+  if (!fun) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -930,7 +930,7 @@ bool js::LinkConstructorAndPrototype(JSC
 bool js::DefinePropertiesAndFunctions(JSContext* cx, HandleObject obj,
                                       const JSPropertySpec* ps,
                                       const JSFunctionSpec* fs) {
-  if (ps && !JS_DefineProperties(cx, obj, ps)) {
+  if (ps && !JS_DefineProperties(cx, obj, ps)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (fs && !JS_DefineFunctions(cx, obj, fs)) {
@@ -951,7 +951,7 @@ NativeObject* GlobalObject::getOrCreateF
     JSContext* cx, Handle<GlobalObject*> global) {
   cx->check(global);
   NativeObject* forOfPIC = global->getForOfPICObject();
-  if (forOfPIC) {
+  if (forOfPIC) {MOZ_RELEASE_ASSERT(0);
     return forOfPIC;
   }
 
@@ -999,7 +999,7 @@ NativeObject* GlobalObject::getIntrinsic
     intrinsicsHolder = global;
   } else {
     intrinsicsHolder = NewTenuredObjectWithGivenProto<PlainObject>(cx, nullptr);
-    if (!intrinsicsHolder) {
+    if (!intrinsicsHolder) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -1024,7 +1024,7 @@ bool GlobalObject::getSelfHostedFunction
                                          MutableHandleValue funVal) {
   bool exists = false;
   if (!GlobalObject::maybeGetIntrinsicValue(cx, global, selfHostedName, funVal,
-                                            &exists)) {
+                                            &exists)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (exists) {
@@ -1071,7 +1071,7 @@ bool GlobalObject::addIntrinsicValue(JSC
                                      HandlePropertyName name,
                                      HandleValue value) {
   RootedNativeObject holder(cx, GlobalObject::getIntrinsicsHolder(cx, global));
-  if (!holder) {
+  if (!holder) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1083,7 +1083,7 @@ bool GlobalObject::addIntrinsicValue(JSC
   Rooted<StackShape> child(cx,
                            StackShape(base, last->objectFlags(), id, slot, 0));
   Shape* shape = cx->zone()->propertyTree().getChild(cx, last, child);
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1112,17 +1112,17 @@ bool GlobalObject::ensureModulePrototype
 
   RootedObject proto(cx);
   proto = getOrCreateModulePrototype(cx, global);
-  if (!proto || !maybeSetUsedAsPrototype(proto)) {
+  if (!proto || !maybeSetUsedAsPrototype(proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   proto = getOrCreateImportEntryPrototype(cx, global);
-  if (!proto || !maybeSetUsedAsPrototype(proto)) {
+  if (!proto || !maybeSetUsedAsPrototype(proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   proto = getOrCreateExportEntryPrototype(cx, global);
-  if (!proto || !maybeSetUsedAsPrototype(proto)) {
+  if (!proto || !maybeSetUsedAsPrototype(proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/vm/HelperThreads.cpp b/js/src/vm/HelperThreads.cpp
--- a/js/src/vm/HelperThreads.cpp
+++ b/js/src/vm/HelperThreads.cpp
@@ -77,7 +77,7 @@ bool js::CreateHelperThreadsState() {
   MOZ_ASSERT(!gHelperThreadState);
   UniquePtr<GlobalHelperThreadState> helperThreadState =
       MakeUnique<GlobalHelperThreadState>();
-  if (!helperThreadState) {
+  if (!helperThreadState) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   gHelperThreadState = helperThreadState.release();
@@ -191,7 +191,7 @@ static void CancelOffThreadWasmTier2Gene
   {
     wasm::Tier2GeneratorTaskPtrVector& worklist =
         HelperThreadState().wasmTier2GeneratorWorklist(lock);
-    for (size_t i = 0; i < worklist.length(); i++) {
+    for (size_t i = 0; i < worklist.length(); i++) {MOZ_RELEASE_ASSERT(0);
       wasm::Tier2GeneratorTask* task = worklist[i];
       HelperThreadState().remove(worklist, &i);
       js_delete(task);
@@ -701,7 +701,7 @@ void ScriptParseTask<Unit>::parse(JSCont
   if (extensibleStencil_) {
     frontend::BorrowingCompilationStencil borrowingStencil(*extensibleStencil_);
     if (!frontend::PrepareForInstantiate(cx, *stencilInput_, borrowingStencil,
-                                         gcOutput_)) {
+                                         gcOutput_)) {MOZ_RELEASE_ASSERT(0);
       extensibleStencil_ = nullptr;
     }
   }
@@ -712,7 +712,7 @@ void ScriptParseTask<Unit>::parse(JSCont
 }
 
 bool ParseTask::instantiateStencils(JSContext* cx) {
-  if (!stencil_ && !extensibleStencil_) {
+  if (!stencil_ && !extensibleStencil_) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -777,7 +777,7 @@ void ModuleParseTask<Unit>::parse(JSCont
   if (extensibleStencil_) {
     frontend::BorrowingCompilationStencil borrowingStencil(*extensibleStencil_);
     if (!frontend::PrepareForInstantiate(cx, *stencilInput_, borrowingStencil,
-                                         gcOutput_)) {
+                                         gcOutput_)) {MOZ_RELEASE_ASSERT(0);
       extensibleStencil_ = nullptr;
     }
   }
@@ -806,28 +806,28 @@ void ScriptDecodeTask::parse(JSContext* 
     // The buffer contains stencil.
 
     stencilInput_ = cx->make_unique<frontend::CompilationInput>(options);
-    if (!stencilInput_) {
+    if (!stencilInput_) {MOZ_RELEASE_ASSERT(0);
       return;
     }
-    if (!stencilInput_->initForGlobal(cx)) {
+    if (!stencilInput_->initForGlobal(cx)) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
     stencil_ =
         cx->make_unique<frontend::CompilationStencil>(stencilInput_->source);
-    if (!stencil_) {
+    if (!stencil_) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
     XDRStencilDecoder decoder(cx, range);
     XDRResult res = decoder.codeStencil(*stencilInput_, *stencil_);
-    if (!res.isOk()) {
+    if (!res.isOk()) {MOZ_RELEASE_ASSERT(0);
       stencil_.reset();
       return;
     }
 
     if (!frontend::PrepareForInstantiate(cx, *stencilInput_, *stencil_,
-                                         gcOutput_)) {
+                                         gcOutput_)) {MOZ_RELEASE_ASSERT(0);
       stencil_.reset();
     }
 
@@ -842,7 +842,7 @@ void ScriptDecodeTask::parse(JSContext* 
   auto decoder = js::MakeUnique<XDROffThreadDecoder>(
       cx, &options, XDROffThreadDecoder::Type::Single,
       /* sourceObjectOut = */ &sourceObject.get(), range);
-  if (!decoder) {
+  if (!decoder) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return;
   }
@@ -869,7 +869,7 @@ void MultiScriptsDecodeTask::parse(JSCon
   MOZ_ASSERT(cx->isHelperThreadContext());
 
   if (!scripts.reserve(sources->length()) ||
-      !sourceObjects.reserve(sources->length())) {
+      !sourceObjects.reserve(sources->length())) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);  // This sets |outOfMemory|.
     return;
   }
@@ -884,7 +884,7 @@ void MultiScriptsDecodeTask::parse(JSCon
     auto decoder = js::MakeUnique<XDROffThreadDecoder>(
         cx, &opts, XDROffThreadDecoder::Type::Multi, &sourceObject.get(),
         source.range);
-    if (!decoder) {
+    if (!decoder) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return;
     }
@@ -1020,27 +1020,27 @@ static bool EnsureConstructor(JSContext*
 static bool EnsureParserCreatedClasses(JSContext* cx, ParseTaskKind kind) {
   Handle<GlobalObject*> global = cx->global();
 
-  if (!EnsureConstructor(cx, global, JSProto_Function)) {
+  if (!EnsureConstructor(cx, global, JSProto_Function)) {MOZ_RELEASE_ASSERT(0);
     return false;  // needed by functions, also adds object literals' proto
   }
 
-  if (!EnsureConstructor(cx, global, JSProto_Array)) {
+  if (!EnsureConstructor(cx, global, JSProto_Array)) {MOZ_RELEASE_ASSERT(0);
     return false;  // needed by array literals
   }
 
-  if (!EnsureConstructor(cx, global, JSProto_RegExp)) {
+  if (!EnsureConstructor(cx, global, JSProto_RegExp)) {MOZ_RELEASE_ASSERT(0);
     return false;  // needed by regular expression literals
   }
 
-  if (!EnsureConstructor(cx, global, JSProto_GeneratorFunction)) {
+  if (!EnsureConstructor(cx, global, JSProto_GeneratorFunction)) {MOZ_RELEASE_ASSERT(0);
     return false;  // needed by function*() {}
   }
 
-  if (!EnsureConstructor(cx, global, JSProto_AsyncFunction)) {
+  if (!EnsureConstructor(cx, global, JSProto_AsyncFunction)) {MOZ_RELEASE_ASSERT(0);
     return false;  // needed by async function() {}
   }
 
-  if (!EnsureConstructor(cx, global, JSProto_AsyncGeneratorFunction)) {
+  if (!EnsureConstructor(cx, global, JSProto_AsyncGeneratorFunction)) {MOZ_RELEASE_ASSERT(0);
     return false;  // needed by async function*() {}
   }
 
@@ -1142,7 +1142,7 @@ static JS::OffThreadToken* StartOffThrea
   JSObject* global = nullptr;
   if (options.useOffThreadParseGlobal) {
     global = CreateGlobalForOffThreadParse(cx, nogc);
-    if (!global) {
+    if (!global) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -1153,7 +1153,7 @@ static JS::OffThreadToken* StartOffThrea
   // cleared automatically.
   AutoSetCreatedForHelperThread createdForHelper(global);
 
-  if (!task->init(cx, options, global)) {
+  if (!task->init(cx, options, global)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1274,7 +1274,7 @@ void js::EnqueuePendingParseTasksAfterGC
   GlobalHelperThreadState::ParseTaskVector& waiting =
       HelperThreadState().parseWaitingOnGC(lock);
   for (size_t i = 0; i < waiting.length(); i++) {
-    if (!waiting[i]->runtimeMatches(rt)) {
+    if (!waiting[i]->runtimeMatches(rt)) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
@@ -1303,7 +1303,7 @@ bool GlobalHelperThreadState::ensureInit
 }
 
 bool GlobalHelperThreadState::ensureThreadCount(size_t count) {
-  if (!ensureContextList(count)) {
+  if (!ensureContextList(count)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1313,11 +1313,11 @@ bool GlobalHelperThreadState::ensureThre
     return true;
   }
 
-  if (!threads(lock).reserve(count)) {
+  if (!threads(lock).reserve(count)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!helperTasks_.reserve(count)) {
+  if (!helperTasks_.reserve(count)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1527,7 +1527,7 @@ bool GlobalHelperThreadState::checkTaskT
   // It is possible for the number of idle threads to be zero here, because
   // checkTaskThreadLimit() can be called from non-helper threads.  Notably,
   // the compression task scheduler invokes it, and runs off a helper thread.
-  if (idle == 0) {
+  if (idle == 0) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1599,33 +1599,33 @@ void GlobalHelperThreadState::addSizeOfI
       helperTasks_.sizeOfExcludingThis(mallocSizeOf);
 
   // Report ParseTasks on wait lists
-  for (const auto& task : parseWorklist_) {
+  for (const auto& task : parseWorklist_) {MOZ_RELEASE_ASSERT(0);
     htStats.parseTask += task->sizeOfIncludingThis(mallocSizeOf);
   }
-  for (auto task : parseFinishedList_) {
+  for (auto task : parseFinishedList_) {MOZ_RELEASE_ASSERT(0);
     htStats.parseTask += task->sizeOfIncludingThis(mallocSizeOf);
   }
-  for (const auto& task : parseWaitingOnGC_) {
+  for (const auto& task : parseWaitingOnGC_) {MOZ_RELEASE_ASSERT(0);
     htStats.parseTask += task->sizeOfIncludingThis(mallocSizeOf);
   }
 
   // Report IonCompileTasks on wait lists
-  for (auto task : ionWorklist_) {
+  for (auto task : ionWorklist_) {MOZ_RELEASE_ASSERT(0);
     htStats.ionCompileTask += task->sizeOfExcludingThis(mallocSizeOf);
   }
-  for (auto task : ionFinishedList_) {
+  for (auto task : ionFinishedList_) {MOZ_RELEASE_ASSERT(0);
     htStats.ionCompileTask += task->sizeOfExcludingThis(mallocSizeOf);
   }
-  for (const auto& task : ionFreeList_) {
+  for (const auto& task : ionFreeList_) {MOZ_RELEASE_ASSERT(0);
     htStats.ionCompileTask +=
         task->compileTask()->sizeOfExcludingThis(mallocSizeOf);
   }
 
   // Report wasm::CompileTasks on wait lists
-  for (auto task : wasmWorklist_tier1_) {
+  for (auto task : wasmWorklist_tier1_) {MOZ_RELEASE_ASSERT(0);
     htStats.wasmCompile += task->sizeOfExcludingThis(mallocSizeOf);
   }
-  for (auto task : wasmWorklist_tier2_) {
+  for (auto task : wasmWorklist_tier2_) {MOZ_RELEASE_ASSERT(0);
     htStats.wasmCompile += task->sizeOfExcludingThis(mallocSizeOf);
   }
 
@@ -1738,13 +1738,13 @@ HelperThreadTask* GlobalHelperThreadStat
 
   size_t threads;
   if (mode == wasm::CompileMode::Tier2) {
-    if (tier2oversubscribed) {
+    if (tier2oversubscribed) {MOZ_RELEASE_ASSERT(0);
       threads = maxWasmCompilationThreads();
     } else {
       threads = physCoresAvailable;
     }
   } else {
-    if (tier2oversubscribed) {
+    if (tier2oversubscribed) {MOZ_RELEASE_ASSERT(0);
       threads = 0;
     } else {
       threads = maxWasmCompilationThreads();
@@ -1956,7 +1956,7 @@ UniquePtr<ParseTask> GlobalHelperThreadS
   if (parseTask->options.useOffThreadParseGlobal) {
     // Make sure we have all the constructors we need for the prototype
     // remapping below, since we can't GC while that's happening.
-    if (!EnsureParserCreatedClasses(cx, kind)) {
+    if (!EnsureParserCreatedClasses(cx, kind)) {MOZ_RELEASE_ASSERT(0);
       LeaveParseTaskZone(cx->runtime(), parseTask.get().get());
       return nullptr;
     }
@@ -1979,11 +1979,11 @@ UniquePtr<ParseTask> GlobalHelperThreadS
     for (auto& sourceObject : parseTask->sourceObjects) {
       RootedScriptSourceObject sso(cx, sourceObject);
 
-      if (!ScriptSourceObject::initFromOptions(cx, sso, parseTask->options)) {
+      if (!ScriptSourceObject::initFromOptions(cx, sso, parseTask->options)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
-      if (!sso->source()->tryCompressOffThread(cx)) {
+      if (!sso->source()->tryCompressOffThread(cx)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -1995,7 +1995,7 @@ UniquePtr<ParseTask> GlobalHelperThreadS
   }
 
   // Report out of memory errors eagerly, or errors could be malformed.
-  if (parseTask->outOfMemory) {
+  if (parseTask->outOfMemory) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -2004,7 +2004,7 @@ UniquePtr<ParseTask> GlobalHelperThreadS
   for (size_t i = 0; i < parseTask->errors.length(); i++) {
     parseTask->errors[i]->throwError(cx);
   }
-  if (parseTask->overRecursed) {
+  if (parseTask->overRecursed) {MOZ_RELEASE_ASSERT(0);
     ReportOverRecursed(cx);
   }
   if (cx->isExceptionPending()) {
@@ -2027,7 +2027,7 @@ bool GlobalHelperThreadState::generateLC
                                                   ParseTask* parseTask) {
   Rooted<GCVector<JSScript*>> workList(cx, GCVector<JSScript*>(cx));
 
-  if (!workList.appendAll(parseTask->scripts)) {
+  if (!workList.appendAll(parseTask->scripts)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2036,7 +2036,7 @@ bool GlobalHelperThreadState::generateLC
     elem = workList.popCopy();
 
     // Initialize LCov data for the script.
-    if (!coverage::InitScriptCoverage(cx, elem)) {
+    if (!coverage::InitScriptCoverage(cx, elem)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2053,7 +2053,7 @@ bool GlobalHelperThreadState::generateLC
       JSFunction* fun = &obj->as<JSFunction>();
 
       // Ignore asm.js functions
-      if (!fun->isInterpreted()) {
+      if (!fun->isInterpreted()) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
 
@@ -2085,7 +2085,7 @@ JSScript* GlobalHelperThreadState::finis
       script = parseTask->scripts[0];
     }
 
-    if (!script) {
+    if (!script) {MOZ_RELEASE_ASSERT(0);
       // No error was reported, but no script produced. Assume we hit out of
       // memory.
       MOZ_ASSERT(false, "Expected script");
@@ -2097,7 +2097,7 @@ JSScript* GlobalHelperThreadState::finis
       // See: InstantiateTopLevel in frontend/Stencil.cpp.
       MOZ_ASSERT(script->isModule());
       RootedModuleObject module(cx, script->module());
-      if (!ModuleObject::Freeze(cx, module)) {
+      if (!ModuleObject::Freeze(cx, module)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -2123,19 +2123,19 @@ JSScript* GlobalHelperThreadState::finis
   if (startEncoding == StartEncoding::Yes) {
     MOZ_DIAGNOSTIC_ASSERT(parseTask->options.useStencilXDR);
 
-    if (parseTask->stencil_) {
+    if (parseTask->stencil_) {MOZ_RELEASE_ASSERT(0);
       auto initial = js::MakeUnique<frontend::ExtensibleCompilationStencil>(
           cx, *parseTask->stencilInput_);
-      if (!initial) {
+      if (!initial) {MOZ_RELEASE_ASSERT(0);
         ReportOutOfMemory(cx);
         return nullptr;
       }
-      if (!initial->steal(cx, std::move(*parseTask->stencil_))) {
+      if (!initial->steal(cx, std::move(*parseTask->stencil_))) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       if (!script->scriptSource()->startIncrementalEncoding(
-              cx, parseTask->options, std::move(initial))) {
+              cx, parseTask->options, std::move(initial))) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     } else if (parseTask->extensibleStencil_) {
@@ -2155,7 +2155,7 @@ bool GlobalHelperThreadState::finishMult
     MutableHandle<ScriptVector> scripts) {
   Rooted<UniquePtr<ParseTask>> parseTask(
       cx, finishParseTaskCommon(cx, kind, token));
-  if (!parseTask) {
+  if (!parseTask) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2163,7 +2163,7 @@ bool GlobalHelperThreadState::finishMult
   auto task = static_cast<MultiScriptsDecodeTask*>(parseTask.get().get());
   size_t expectedLength = task->sources->length();
 
-  if (!scripts.reserve(parseTask->scripts.length())) {
+  if (!scripts.reserve(parseTask->scripts.length())) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -2172,7 +2172,7 @@ bool GlobalHelperThreadState::finishMult
     scripts.infallibleAppend(script);
   }
 
-  if (scripts.length() != expectedLength) {
+  if (scripts.length() != expectedLength) {MOZ_RELEASE_ASSERT(0);
     // No error was reported, but fewer scripts produced than expected.
     // Assume we hit out of memory.
     MOZ_ASSERT(false, "Expected more scripts");
@@ -2239,7 +2239,7 @@ frontend::CompilationStencil* GlobalHelp
 
   Rooted<UniquePtr<ParseTask>> parseTask(
       cx, finishParseTaskCommon(cx, task->kind, token));
-  if (!parseTask) {
+  if (!parseTask) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2249,7 +2249,7 @@ frontend::CompilationStencil* GlobalHelp
   UniquePtr<frontend::CompilationStencil> stencil =
       cx->make_unique<frontend::CompilationStencil>(
           parseTask->stencilInput_->source);
-  if (!stencil) {
+  if (!stencil) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2271,19 +2271,19 @@ void GlobalHelperThreadState::cancelPars
   GlobalHelperThreadState::ParseTaskVector& waitingOnGC =
       HelperThreadState().parseWaitingOnGC(lock);
   for (size_t i = 0; i < waitingOnGC.length(); i++) {
-    if (task == waitingOnGC[i]) {
+    if (task == waitingOnGC[i]) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(task->kind == kind);
       MOZ_ASSERT(task->runtimeMatches(rt));
       task->parseGlobal->zoneFromAnyThread()->clearUsedByHelperThread();
       HelperThreadState().remove(waitingOnGC, &i);
       return;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   GlobalHelperThreadState::ParseTaskVector& worklist =
       HelperThreadState().parseWorklist(lock);
   for (size_t i = 0; i < worklist.length(); i++) {
-    if (task == worklist[i]) {
+    if (task == worklist[i]) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(task->kind == kind);
       MOZ_ASSERT(task->runtimeMatches(rt));
       LeaveParseTaskZone(rt, task);
@@ -2360,7 +2360,7 @@ void HelperThread::setTerminate(const Au
 void HelperThread::join() { thread.join(); }
 
 void HelperThread::ensureRegisteredWithProfiler() {
-  if (profilingStack) {
+  if (profilingStack) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -2402,7 +2402,7 @@ void HelperThread::ThreadMain(void* arg)
 
 bool JSContext::addPendingCompileError(js::CompileError** error) {
   auto errorPtr = make_unique<js::CompileError>();
-  if (!errorPtr) {
+  if (!errorPtr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!parseTask_->errors.append(std::move(errorPtr))) {
@@ -2423,7 +2423,7 @@ void JSContext::addPendingOverRecursed()
   }
 }
 
-void JSContext::addPendingOutOfMemory() {
+void JSContext::addPendingOutOfMemory() {MOZ_RELEASE_ASSERT(0);
   // Keep in sync with recoverFromOutOfMemory.
   if (parseTask_) {
     parseTask_->outOfMemory = true;
@@ -2523,7 +2523,7 @@ void js::SweepPendingCompressions(AutoLo
 void js::RunPendingSourceCompressions(JSRuntime* runtime) {
   AutoLockHelperThreadState lock;
 
-  if (HelperThreadState().threads(lock).empty()) {
+  if (HelperThreadState().threads(lock).empty()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
diff --git a/js/src/vm/Id.cpp b/js/src/vm/Id.cpp
--- a/js/src/vm/Id.cpp
+++ b/js/src/vm/Id.cpp
@@ -38,7 +38,7 @@ bool JS::PropertyKey::isWellKnownSymbol(
   return js::AtomToId(&str->asAtom());
 }
 
-/* static */ bool JS::PropertyKey::isNonIntAtom(JSAtom* atom) {
+/* static */ bool JS::PropertyKey::isNonIntAtom(JSAtom* atom) {MOZ_RELEASE_ASSERT(0);
   uint32_t index;
   if (!atom->isIndex(&index)) {
     return true;
diff --git a/js/src/vm/Initialization.cpp b/js/src/vm/Initialization.cpp
--- a/js/src/vm/Initialization.cpp
+++ b/js/src/vm/Initialization.cpp
@@ -158,7 +158,7 @@ JS_PUBLIC_API const char* JS::detail::In
 #endif
 
 #if defined(JS_GC_ALLOW_EXTRA_POISONING)
-  if (getenv("JSGC_EXTRA_POISONING")) {
+  if (getenv("JSGC_EXTRA_POISONING")) {MOZ_RELEASE_ASSERT(0);
     js::gExtraPoisoningEnabled = true;
   }
 #endif
diff --git a/js/src/vm/Instrumentation.cpp b/js/src/vm/Instrumentation.cpp
--- a/js/src/vm/Instrumentation.cpp
+++ b/js/src/vm/Instrumentation.cpp
@@ -46,7 +46,7 @@ void RealmInstrumentation::holderFinaliz
 }
 
 /* static */
-void RealmInstrumentation::holderTrace(JSTracer* trc, JSObject* obj) {
+void RealmInstrumentation::holderTrace(JSTracer* trc, JSObject* obj) {MOZ_RELEASE_ASSERT(0);
   RealmInstrumentation* instrumentation = GetInstrumentation(obj);
   if (instrumentation) {
     instrumentation->trace(trc);
@@ -82,7 +82,7 @@ static bool StringToInstrumentationKind(
                                         InstrumentationKind* result) {
   for (size_t i = 0; i < std::size(instrumentationNames); i++) {
     bool match;
-    if (!JS_StringEqualsAscii(cx, str, instrumentationNames[i], &match)) {
+    if (!JS_StringEqualsAscii(cx, str, instrumentationNames[i], &match)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (match) {
@@ -116,18 +116,18 @@ bool RealmInstrumentation::install(JSCon
                                    Handle<StringVector> kindStrings) {
   MOZ_ASSERT(global == cx->global());
 
-  if (global->getInstrumentationHolder()) {
+  if (global->getInstrumentationHolder()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Global already has instrumentation specified");
     return false;
   }
 
   RootedObject callback(cx, callbackArg);
-  if (!cx->compartment()->wrap(cx, &callback)) {
+  if (!cx->compartment()->wrap(cx, &callback)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject dbgObject(cx, dbgObjectArg);
-  if (!cx->compartment()->wrap(cx, &dbgObject)) {
+  if (!cx->compartment()->wrap(cx, &dbgObject)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -144,7 +144,7 @@ bool RealmInstrumentation::install(JSCon
   Rooted<UniquePtr<RealmInstrumentation>> instrumentation(
       cx,
       MakeUnique<RealmInstrumentation>(cx->zone(), callback, dbgObject, kinds));
-  if (!instrumentation) {
+  if (!instrumentation) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -168,7 +168,7 @@ bool RealmInstrumentation::setActive(JSC
   MOZ_ASSERT(global == cx->global());
 
   RootedObject holder(cx, global->getInstrumentationHolder());
-  if (!holder) {
+  if (!holder) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Global does not have instrumentation specified");
     return false;
   }
@@ -250,7 +250,7 @@ bool RealmInstrumentation::getScriptId(J
   AutoRealm ar(cx, dbgObject);
 
   RootedValue idValue(cx);
-  if (!DebugAPI::getScriptInstrumentationId(cx, dbgObject, script, &idValue)) {
+  if (!DebugAPI::getScriptInstrumentationId(cx, dbgObject, script, &idValue)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/vm/Interpreter.cpp b/js/src/vm/Interpreter.cpp
--- a/js/src/vm/Interpreter.cpp
+++ b/js/src/vm/Interpreter.cpp
@@ -143,7 +143,7 @@ bool js::GetFunctionThis(JSContext* cx, 
         res.setObject(*GetThisObjectOfLexical(env));
         return true;
       }
-      if (!env->enclosingEnvironment()) {
+      if (!env->enclosingEnvironment()) {MOZ_RELEASE_ASSERT(0);
         // This can only happen in Debugger eval frames: in that case we
         // don't always have a global lexical env, see EvaluateInEnv.
         MOZ_ASSERT(env->is<GlobalObject>());
@@ -201,7 +201,7 @@ static inline bool GetPropertyOperation(
   RootedPropertyName name(cx, script->getName(pc));
 
   if (name == cx->names().length) {
-    if (IsOptimizedArguments(fp, lval)) {
+    if (IsOptimizedArguments(fp, lval)) {MOZ_RELEASE_ASSERT(0);
       vp.setInt32(fp->numActualArgs());
       return true;
     }
@@ -528,7 +528,7 @@ bool js::InternalCallOrConstruct(JSConte
     }
   }
 
-  if (!JSFunction::getOrCreateScript(cx, fun)) {
+  if (!JSFunction::getOrCreateScript(cx, fun)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -752,7 +752,7 @@ bool js::ExecuteKernel(JSContext* cx, Ha
 #endif
 
   if (script->treatAsRunOnce()) {
-    if (script->hasRunOnce()) {
+    if (script->hasRunOnce()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx,
                           "Trying to execute a run-once script multiple times");
       return false;
@@ -1009,7 +1009,7 @@ static void PopEnvironment(JSContext* cx
 // Unwind environment chain and iterator to match the env corresponding to
 // the given bytecode position.
 void js::UnwindEnvironment(JSContext* cx, EnvironmentIter& ei, jsbytecode* pc) {
-  if (!ei.withinInitialFrame()) {
+  if (!ei.withinInitialFrame()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -1641,7 +1641,7 @@ static MOZ_ALWAYS_INLINE bool LessThanIm
     JSString* l = lhs.toString();
     JSString* r = rhs.toString();
     int32_t result;
-    if (!CompareStrings(cx, l, r, &result)) {
+    if (!CompareStrings(cx, l, r, &result)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     res = mozilla::Some(result < 0);
@@ -1889,7 +1889,7 @@ void js::ReportInNotObjectError(JSContex
 
   if (lref.isString() && rref.isString()) {
     UniqueChars lbytes = uniqueCharsFromString(cx, lref);
-    if (!lbytes) {
+    if (!lbytes) {MOZ_RELEASE_ASSERT(0);
       return;
     }
     UniqueChars rbytes = uniqueCharsFromString(cx, rref);
@@ -2074,7 +2074,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
   bool interpReturnOK;
   bool frameHalfInitialized;
 
-  if (!activation.entryFrame()->prologue(cx)) {
+  if (!activation.entryFrame()->prologue(cx)) {MOZ_RELEASE_ASSERT(0);
     goto prologue_error;
   }
 
@@ -2089,16 +2089,16 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
   // Enter the interpreter loop starting at the current pc.
   ADVANCE_AND_DISPATCH(0);
 
-  INTERPRETER_LOOP() {
+  INTERPRETER_LOOP() {MOZ_RELEASE_ASSERT(0);
     CASE(EnableInterruptsPseudoOpcode) {
       bool moreInterrupts = false;
       jsbytecode op = *REGS.pc;
 
       if (!script->hasScriptCounts() &&
-          cx->realm()->collectCoverageForDebug()) {
-        if (!script->initScriptCounts(cx)) {
+          cx->realm()->collectCoverageForDebug()) {MOZ_RELEASE_ASSERT(0);
+        if (!script->initScriptCounts(cx)) {MOZ_RELEASE_ASSERT(0);
           goto error;
-        }
+        }MOZ_RELEASE_ASSERT(0);
       }
 
       if (script->isDebuggee()) {
@@ -2134,7 +2134,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
     CASE(Nop)
     CASE(Try)
     CASE(NopDestructuring)
-    CASE(TryDestructuring) {
+    CASE(TryDestructuring) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(GetBytecodeLength(REGS.pc) == 1);
       ADVANCE_AND_DISPATCH(1);
     }
@@ -2152,7 +2152,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
 
         jit::MethodStatus status =
             jit::CanEnterBaselineInterpreterAtBranch(cx, REGS.fp());
-        if (status == jit::Method_Error) {
+        if (status == jit::Method_Error) {MOZ_RELEASE_ASSERT(0);
           goto error;
         }
         if (status == jit::Method_Compiled) {
@@ -2166,7 +2166,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
           }
 
           // We failed to call into baseline at all, so treat as an error.
-          if (maybeOsr == jit::JitExec_Aborted) {
+          if (maybeOsr == jit::JitExec_Aborted) {MOZ_RELEASE_ASSERT(0);
             goto error;
           }
 
@@ -2292,9 +2292,9 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
 
         /* Resume execution in the calling frame. */
         if (MOZ_LIKELY(interpReturnOK)) {
-          if (JSOp(*REGS.pc) == JSOp::Resume) {
+          if (JSOp(*REGS.pc) == JSOp::Resume) {MOZ_RELEASE_ASSERT(0);
             ADVANCE_AND_DISPATCH(JSOpLength_Resume);
-          }
+          }MOZ_RELEASE_ASSERT(0);
 
           MOZ_ASSERT(GetBytecodeLength(REGS.pc) == JSOpLength_Call);
           ADVANCE_AND_DISPATCH(JSOpLength_Call);
@@ -2320,7 +2320,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
     CASE(JumpIfFalse) {
       bool cond = ToBoolean(REGS.stackHandleAt(-1));
       REGS.sp--;
-      if (!cond) {
+      if (!cond) {MOZ_RELEASE_ASSERT(0);
         BRANCH(GET_JUMP_OFFSET(REGS.pc));
       }
     }
@@ -2329,7 +2329,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
     CASE(JumpIfTrue) {
       bool cond = ToBoolean(REGS.stackHandleAt(-1));
       REGS.sp--;
-      if (cond) {
+      if (cond) {MOZ_RELEASE_ASSERT(0);
         BRANCH(GET_JUMP_OFFSET(REGS.pc));
       }
     }
@@ -2337,7 +2337,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
 
     CASE(Or) {
       bool cond = ToBoolean(REGS.stackHandleAt(-1));
-      if (cond) {
+      if (cond) {MOZ_RELEASE_ASSERT(0);
         ADVANCE_AND_DISPATCH(GET_JUMP_OFFSET(REGS.pc));
       }
     }
@@ -2346,7 +2346,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
     CASE(Coalesce) {
       MutableHandleValue res = REGS.stackHandleAt(-1);
       bool cond = !res.isNullOrUndefined();
-      if (cond) {
+      if (cond) {MOZ_RELEASE_ASSERT(0);
         ADVANCE_AND_DISPATCH(GET_JUMP_OFFSET(REGS.pc));
       }
     }
@@ -2354,7 +2354,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
 
     CASE(And) {
       bool cond = ToBoolean(REGS.stackHandleAt(-1));
-      if (!cond) {
+      if (!cond) {MOZ_RELEASE_ASSERT(0);
         ADVANCE_AND_DISPATCH(GET_JUMP_OFFSET(REGS.pc));
       }
     }
@@ -2523,7 +2523,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
 
       // Assigning to an undeclared name adds a property to the global object.
       ReservedRooted<JSObject*> env(&rootObject1);
-      if (!LookupNameUnqualified(cx, name, envChain, &env)) {
+      if (!LookupNameUnqualified(cx, name, envChain, &env)) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
 
@@ -2618,7 +2618,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
     CASE(Case) {
       bool cond = REGS.sp[-1].toBoolean();
       REGS.sp--;
-      if (cond) {
+      if (cond) {MOZ_RELEASE_ASSERT(0);
         REGS.sp--;
         BRANCH(GET_JUMP_OFFSET(REGS.pc));
       }
@@ -2813,7 +2813,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
 
       PUSH_BOOLEAN(true);
       MutableHandleValue res = REGS.stackHandleAt(-1);
-      if (!DeleteNameOperation(cx, name, envObj, res)) {
+      if (!DeleteNameOperation(cx, name, envObj, res)) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
     }
@@ -2880,7 +2880,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
 
     CASE(FunctionThis) {
       PUSH_NULL();
-      if (!GetFunctionThis(cx, REGS.fp(), REGS.stackHandleAt(-1))) {
+      if (!GetFunctionThis(cx, REGS.fp(), REGS.stackHandleAt(-1))) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
     }
@@ -2944,7 +2944,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
       ReservedRooted<JSObject*> obj(&rootObject1, &REGS.sp[-1].toObject());
       MutableHandleValue rref = REGS.stackHandleAt(-2);
 
-      if (!GetProperty(cx, obj, receiver, script->getName(REGS.pc), rref)) {
+      if (!GetProperty(cx, obj, receiver, script->getName(REGS.pc), rref)) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
 
@@ -2968,7 +2968,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
     CASE(SetIntrinsic) {
       HandleValue value = REGS.stackHandleAt(-1);
 
-      if (!SetIntrinsicOperation(cx, script, REGS.pc, value)) {
+      if (!SetIntrinsicOperation(cx, script, REGS.pc, value)) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
     }
@@ -3244,7 +3244,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
           if (!CallFromStack(cx, args)) {
             goto error;
           }
-        }
+        }MOZ_RELEASE_ASSERT(0);
         Value* newsp = args.spAfterCall();
         REGS.sp = newsp;
         ADVANCE_AND_DISPATCH(JSOpLength_Call);
@@ -3255,7 +3255,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
         ReservedRooted<JSFunction*> fun(&rootFunction0, maybeFun);
         ReservedRooted<JSScript*> funScript(
             &rootScript0, JSFunction::getOrCreateScript(cx, fun));
-        if (!funScript) {
+        if (!funScript) {MOZ_RELEASE_ASSERT(0);
           goto error;
         }
 
@@ -3317,7 +3317,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
 
       if (!DebugAPI::onEnterFrame(cx, REGS.fp())) {
         goto error;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       // Increment the coverage for the main entry point.
       INIT_COVERAGE();
@@ -3331,7 +3331,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
       ReservedRooted<Value> val(&rootValue0, REGS.sp[-1]);
 
       bool optimized = false;
-      if (!OptimizeSpreadCall(cx, val, &optimized)) {
+      if (!OptimizeSpreadCall(cx, val, &optimized)) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
 
@@ -3354,7 +3354,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
         ReservedRooted<JSObject*> envObj(&rootObject0,
                                          REGS.fp()->environmentChain());
         ReservedRooted<JSObject*> env(&rootObject1);
-        if (!LookupNameWithGlobalDefault(cx, name, envObj, &env)) {
+        if (!LookupNameWithGlobalDefault(cx, name, envObj, &env)) {MOZ_RELEASE_ASSERT(0);
           goto error;
         }
 
@@ -3394,7 +3394,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
 
     CASE(GetIntrinsic) {
       ReservedRooted<Value> rval(&rootValue0);
-      if (!GetIntrinsicOperation(cx, script, REGS.pc, &rval)) {
+      if (!GetIntrinsicOperation(cx, script, REGS.pc, &rval)) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
 
@@ -3447,7 +3447,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
 
     CASE(CallSiteObj) {
       JSObject* cso = ProcessCallSiteObjOperation(cx, script, REGS.pc);
-      if (!cso) {
+      if (!cso) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
       PUSH_OBJECT(*cso);
@@ -3498,7 +3498,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
         i = rref.toInt32();
       } else {
         /* Use mozilla::NumberEqualsInt32 to treat -0 (double) as 0. */
-        if (!rref.isDouble() || !NumberEqualsInt32(rref.toDouble(), &i)) {
+        if (!rref.isDouble() || !NumberEqualsInt32(rref.toDouble(), &i)) {MOZ_RELEASE_ASSERT(0);
           ADVANCE_AND_DISPATCH(len);
         }
       }
@@ -3512,12 +3512,12 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
       if (uint32_t(i) < uint32_t(high - low + 1)) {
         len = script->tableSwitchCaseOffset(REGS.pc, uint32_t(i)) -
               script->pcToOffset(REGS.pc);
-      }
+      }MOZ_RELEASE_ASSERT(0);
       ADVANCE_AND_DISPATCH(len);
     }
 
     CASE(Arguments) {
-      if (!script->ensureHasAnalyzedArgsUsage(cx)) {
+      if (!script->ensureHasAnalyzedArgsUsage(cx)) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
       if (script->needsArgsObj()) {
@@ -3526,7 +3526,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
           goto error;
         }
         PUSH_COPY(ObjectValue(*obj));
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         PUSH_COPY(MagicValue(JS_OPTIMIZED_ARGUMENTS));
       }
     }
@@ -3535,7 +3535,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
     CASE(Rest) {
       ReservedRooted<JSObject*> rest(&rootObject0,
                                      REGS.fp()->createRestParameter(cx));
-      if (!rest) {
+      if (!rest) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
       PUSH_COPY(ObjectValue(*rest));
@@ -3578,7 +3578,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
                                   REGS.pc);
         goto error;
       }
-    }
+    }MOZ_RELEASE_ASSERT(0);
     END_CASE(CheckLexical)
 
     CASE(CheckAliasedLexical) {
@@ -3686,7 +3686,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
       ReservedRooted<JSFunction*> fun(&rootFunction0,
                                       script->getFunction(REGS.pc));
       JSObject* obj = Lambda(cx, fun, REGS.fp()->environmentChain());
-      if (!obj) {
+      if (!obj) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
 
@@ -3702,7 +3702,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
       ReservedRooted<Value> newTarget(&rootValue1, REGS.sp[-1]);
       JSObject* obj =
           LambdaArrow(cx, fun, REGS.fp()->environmentChain(), newTarget);
-      if (!obj) {
+      if (!obj) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
 
@@ -3715,7 +3715,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
       ReservedRooted<Value> nextMethod(&rootValue0, REGS.sp[-1]);
       ReservedRooted<JSObject*> iter(&rootObject1, &REGS.sp[-2].toObject());
       JSObject* asyncIter = CreateAsyncFromSyncIterator(cx, iter, nextMethod);
-      if (!asyncIter) {
+      if (!asyncIter) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
 
@@ -3727,7 +3727,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
     CASE(CanSkipAwait) {
       ReservedRooted<Value> val(&rootValue0, REGS.sp[-1]);
       bool canSkip;
-      if (!CanSkipAwait(cx, val, &canSkip)) {
+      if (!CanSkipAwait(cx, val, &canSkip)) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
 
@@ -3740,7 +3740,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
       ReservedRooted<Value> canSkip(&rootValue0, REGS.sp[-1]);
 
       if (canSkip.toBoolean()) {
-        if (!ExtractAwaitValue(cx, val, val)) {
+        if (!ExtractAwaitValue(cx, val, val)) {MOZ_RELEASE_ASSERT(0);
           goto error;
         }
       }
@@ -3770,7 +3770,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
       JSObject* promise =
           AsyncFunctionResolve(cx, gen.as<AsyncFunctionGeneratorObject>(),
                                valueOrReason, resolveKind);
-      if (!promise) {
+      if (!promise) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
 
@@ -3785,7 +3785,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
       ReservedRooted<Value> name(&rootValue0, REGS.sp[-1]);
       ReservedRooted<JSFunction*> fun(&rootFunction0,
                                       &REGS.sp[-2].toObject().as<JSFunction>());
-      if (!SetFunctionName(cx, fun, name, prefixKind)) {
+      if (!SetFunctionName(cx, fun, name, prefixKind)) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
 
@@ -3809,7 +3809,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
       ReservedRooted<PropertyName*> name(&rootName0, script->getName(REGS.pc));
       ReservedRooted<JSObject*> val(&rootObject1, &REGS.sp[-1].toObject());
 
-      if (!InitPropGetterSetterOperation(cx, REGS.pc, obj, name, val)) {
+      if (!InitPropGetterSetterOperation(cx, REGS.pc, obj, name, val)) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
 
@@ -3841,7 +3841,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
     CASE(NewInit) {
       JSObject* obj = NewObjectOperation(cx, script, REGS.pc);
 
-      if (!obj) {
+      if (!obj) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
       PUSH_OBJECT(*obj);
@@ -3860,7 +3860,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
 
     CASE(NewObject) {
       JSObject* obj = NewObjectOperation(cx, script, REGS.pc);
-      if (!obj) {
+      if (!obj) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
       PUSH_OBJECT(*obj);
@@ -3876,7 +3876,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
         ReservedRooted<JSObject*> obj(&rootObject0, &REGS.sp[-2].toObject());
         MOZ_ASSERT(obj->is<PlainObject>());
 
-        if (!SetPrototype(cx, obj, newProto)) {
+        if (!SetPrototype(cx, obj, newProto)) {MOZ_RELEASE_ASSERT(0);
           goto error;
         }
       }
@@ -3943,7 +3943,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
       ReservedRooted<JSObject*> obj(&rootObject0, &REGS.sp[-3].toObject());
 
       uint32_t index = REGS.sp[-2].toInt32();
-      if (!InitElemIncOperation(cx, obj.as<ArrayObject>(), index, val)) {
+      if (!InitElemIncOperation(cx, obj.as<ArrayObject>(), index, val)) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
 
@@ -3952,7 +3952,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
     }
     END_CASE(InitElemInc)
 
-    CASE(Gosub) {
+    CASE(Gosub) {MOZ_RELEASE_ASSERT(0);
       int32_t len = GET_JUMP_OFFSET(REGS.pc);
       ADVANCE_AND_DISPATCH(len);
     }
@@ -3973,7 +3973,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
         ReservedRooted<Value> v(&rootValue0, rval);
         cx->setPendingExceptionAndCaptureStack(v);
         goto error;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       MOZ_ASSERT(rval.toInt32() >= 0);
 
@@ -4030,7 +4030,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
       ReservedRooted<Scope*> scope(&rootScope0, script->getScope(REGS.pc));
 
       // Create block environment and push on scope chain.
-      if (!REGS.fp()->pushLexicalEnvironment(cx, scope.as<LexicalScope>())) {
+      if (!REGS.fp()->pushLexicalEnvironment(cx, scope.as<LexicalScope>())) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
     }
@@ -4074,7 +4074,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
         DebugEnvironments::onPopLexical(cx, REGS.fp(), REGS.pc);
       }
 
-      if (!REGS.fp()->freshenLexicalEnvironment(cx)) {
+      if (!REGS.fp()->freshenLexicalEnvironment(cx)) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
     }
@@ -4085,7 +4085,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
         DebugEnvironments::onPopLexical(cx, REGS.fp(), REGS.pc);
       }
 
-      if (!REGS.fp()->recreateLexicalEnvironment(cx)) {
+      if (!REGS.fp()->recreateLexicalEnvironment(cx)) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
     }
@@ -4094,7 +4094,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
     CASE(PushVarEnv) {
       ReservedRooted<Scope*> scope(&rootScope0, script->getScope(REGS.pc));
 
-      if (!REGS.fp()->pushVarEnvironment(cx, scope)) {
+      if (!REGS.fp()->pushVarEnvironment(cx, scope)) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
     }
@@ -4104,7 +4104,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
       MOZ_ASSERT(!cx->isExceptionPending());
       MOZ_ASSERT(REGS.stackDepth() == 0);
       JSObject* obj = AbstractGeneratorObject::createFromFrame(cx, REGS.fp());
-      if (!obj) {
+      if (!obj) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
       PUSH_OBJECT(*obj);
@@ -4121,7 +4121,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
       POP_RETURN_VALUE();
       MOZ_ASSERT(REGS.stackDepth() == 0);
       if (!AbstractGeneratorObject::suspend(cx, obj, REGS.fp(), REGS.pc,
-                                            script->nfixed())) {
+                                            script->nfixed())) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
       goto successful_return_continuation;
@@ -4137,7 +4137,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
       ReservedRooted<JSObject*> obj(&rootObject0, &REGS.sp[-1].toObject());
       if (!AbstractGeneratorObject::suspend(
               cx, obj, REGS.fp(), REGS.pc,
-              script->nfixed() + REGS.stackDepth() - 2)) {
+              script->nfixed() + REGS.stackDepth() - 2)) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
 
@@ -4180,7 +4180,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
         REGS.sp -= 1;
 
         if (!AbstractGeneratorObject::resume(cx, activation, gen, val,
-                                             resumeKindVal)) {
+                                             resumeKindVal)) {MOZ_RELEASE_ASSERT(0);
           goto error;
         }
 
@@ -4205,7 +4205,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
           }
           goto error;
         }
-      }
+      }MOZ_RELEASE_ASSERT(0);
       ADVANCE_AND_DISPATCH(0);
     }
 
@@ -4236,7 +4236,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
     CASE(BuiltinObject) {
       auto kind = BuiltinObjectKind(GET_UINT8(REGS.pc));
       JSObject* builtin = BuiltinObjectOperation(cx, kind);
-      if (!builtin) {
+      if (!builtin) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
       PUSH_OBJECT(*builtin);
@@ -4252,7 +4252,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
 
       JSObject* obj =
           FunWithProtoOperation(cx, fun, REGS.fp()->environmentChain(), proto);
-      if (!obj) {
+      if (!obj) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
 
@@ -4312,7 +4312,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
 
     CASE(ImportMeta) {
       JSObject* metaObject = ImportMetaOperation(cx, script);
-      if (!metaObject) {
+      if (!metaObject) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
 
@@ -4364,7 +4364,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
         goto error;
       }
 #endif
-    }
+    }MOZ_RELEASE_ASSERT(0);
     END_CASE(DebugCheckSelfHosted)
 
     CASE(IsConstructing) { PUSH_MAGIC(JS_IS_CONSTRUCTING); }
@@ -4398,7 +4398,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
 
     CASE(InstrumentationActive) {
       ReservedRooted<Value> rval(&rootValue0);
-      if (!InstrumentationActiveOperation(cx, &rval)) {
+      if (!InstrumentationActiveOperation(cx, &rval)) {MOZ_RELEASE_ASSERT(0);
         goto error;
       }
       PUSH_COPY(rval);
@@ -4421,7 +4421,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
     }
     END_CASE(InstrumentationScriptId)
 
-    DEFAULT() {
+    DEFAULT() {MOZ_RELEASE_ASSERT(0);
       char numBuf[12];
       SprintfLiteral(numBuf, "%d", *REGS.pc);
       JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
@@ -4429,7 +4429,7 @@ static MOZ_NEVER_INLINE JS_HAZ_JSNATIVE_
       goto error;
     }
 
-  } /* interpreter loop */
+  }MOZ_RELEASE_ASSERT(0); /* interpreter loop */
 
   MOZ_CRASH("Interpreter loop exited via fallthrough");
 
@@ -4540,7 +4540,7 @@ bool js::GetProperty(JSContext* cx, Hand
         MOZ_CRASH("unexpected type");
     }
 
-    if (!proto) {
+    if (!proto) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -4675,7 +4675,7 @@ bool js::DelElemOperation(JSContext* cx,
   }
 
   RootedId id(cx);
-  if (!ToPropertyKey(cx, index, &id)) {
+  if (!ToPropertyKey(cx, index, &id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   ObjectOpResult result;
@@ -4803,7 +4803,7 @@ bool js::GreaterThanOrEqual(JSContext* c
   return GreaterThanOrEqualOperation(cx, lhs, rhs, res);
 }
 
-bool js::AtomicIsLockFree(JSContext* cx, HandleValue in, int* out) {
+bool js::AtomicIsLockFree(JSContext* cx, HandleValue in, int* out) {MOZ_RELEASE_ASSERT(0);
   int i;
   if (!ToInt32(cx, in, &i)) {
     return false;
@@ -4816,7 +4816,7 @@ bool js::DeleteNameOperation(JSContext* 
                              HandleObject scopeObj, MutableHandleValue res) {
   RootedObject scope(cx), pobj(cx);
   Rooted<PropertyResult> prop(cx);
-  if (!LookupName(cx, name, scopeObj, &scope, &pobj, &prop)) {
+  if (!LookupName(cx, name, scopeObj, &scope, &pobj, &prop)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4828,7 +4828,7 @@ bool js::DeleteNameOperation(JSContext* 
 
   ObjectOpResult result;
   RootedId id(cx, NameToId(name));
-  if (!DeleteProperty(cx, scope, id, result)) {
+  if (!DeleteProperty(cx, scope, id, result)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4960,11 +4960,11 @@ bool js::SpreadCallOperation(JSContext* 
     }
 
     ConstructArgs cargs(cx);
-    if (!cargs.init(cx, length)) {
+    if (!cargs.init(cx, length)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!GetElements(cx, aobj, length, cargs.array())) {
+    if (!GetElements(cx, aobj, length, cargs.array())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -4975,11 +4975,11 @@ bool js::SpreadCallOperation(JSContext* 
     res.setObject(*obj);
   } else {
     InvokeArgs args(cx);
-    if (!args.init(cx, length)) {
+    if (!args.init(cx, length)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!GetElements(cx, aobj, length, args.array())) {
+    if (!GetElements(cx, aobj, length, args.array())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
diff --git a/js/src/vm/Iteration.cpp b/js/src/vm/Iteration.cpp
--- a/js/src/vm/Iteration.cpp
+++ b/js/src/vm/Iteration.cpp
@@ -116,7 +116,7 @@ static inline bool Enumerate(JSContext* 
     // duplicated properties, so always add in such cases.
     if (pobj->is<ProxyObject>() || pobj->staticPrototype() ||
         pobj->getClass()->getNewEnumerate()) {
-      if (!visited.add(p, id)) {
+      if (!visited.add(p, id)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -134,7 +134,7 @@ static inline bool Enumerate(JSContext* 
     if (!(flags & JSITER_SYMBOLS)) {
       return true;
     }
-    if (!(flags & JSITER_PRIVATE) && id.isPrivateName()) {
+    if (!(flags & JSITER_PRIVATE) && id.isPrivateName()) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
   } else {
@@ -155,7 +155,7 @@ static bool EnumerateExtraProperties(JSC
   RootedIdVector properties(cx);
   bool enumerableOnly = !(flags & JSITER_HIDDEN);
   if (!obj->getClass()->getNewEnumerate()(cx, obj, &properties,
-                                          enumerableOnly)) {
+                                          enumerableOnly)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -206,7 +206,7 @@ static bool EnumerateNativeProperties(JS
         // integer id.
         if (!Enumerate<CheckForDuplicates>(cx, pobj, INT_TO_JSID(i),
                                            /* enumerable = */ true, flags,
-                                           visited, props)) {
+                                           visited, props)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -229,7 +229,7 @@ static bool EnumerateNativeProperties(JS
       for (size_t i = 0; i < len; i++) {
         if (!Enumerate<CheckForDuplicates>(cx, pobj, INT_TO_JSID(i),
                                            /* enumerable = */ true, flags,
-                                           visited, props)) {
+                                           visited, props)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -251,7 +251,7 @@ static bool EnumerateNativeProperties(JS
         uint32_t dummy;
         if (IdIsIndex(id, &dummy)) {
           if (!Enumerate<CheckForDuplicates>(cx, pobj, id, shape.enumerable(),
-                                             flags, visited, props)) {
+                                             flags, visited, props)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -263,12 +263,12 @@ static bool EnumerateNativeProperties(JS
       size_t n = props.length() - firstElemIndex;
 
       RootedIdVector tmp(cx);
-      if (!tmp.resize(n)) {
+      if (!tmp.resize(n)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       PodCopy(tmp.begin(), ids, n);
 
-      if (!MergeSort(ids, n, tmp.begin(), SortComparatorIntegerIds)) {
+      if (!MergeSort(ids, n, tmp.begin(), SortComparatorIntegerIds)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -293,7 +293,7 @@ static bool EnumerateNativeProperties(JS
       }
 
       if (!Enumerate<CheckForDuplicates>(cx, pobj, id, shape.enumerable(),
-                                         flags, visited, props)) {
+                                         flags, visited, props)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -357,14 +357,14 @@ static bool EnumerateProxyProperties(JSC
 
       // We need to filter, if the caller just wants enumerable symbols.
       if (!(flags & JSITER_HIDDEN)) {
-        if (!Proxy::getOwnPropertyDescriptor(cx, pobj, proxyProps[n], &desc)) {
+        if (!Proxy::getOwnPropertyDescriptor(cx, pobj, proxyProps[n], &desc)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         enumerable = desc.enumerable();
       }
 
       if (!Enumerate<CheckForDuplicates>(cx, pobj, proxyProps[n], enumerable,
-                                         flags, visited, props)) {
+                                         flags, visited, props)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -478,13 +478,13 @@ static bool Snapshot(JSContext* cx, Hand
 
   do {
     if (pobj->getClass()->getNewEnumerate()) {
-      if (!EnumerateExtraProperties(cx, pobj, flags, &visited, props)) {
+      if (!EnumerateExtraProperties(cx, pobj, flags, &visited, props)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       if (pobj->is<NativeObject>()) {
         if (!EnumerateNativeProperties(cx, pobj.as<NativeObject>(), flags,
-                                       &visited, props, true)) {
+                                       &visited, props, true)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -511,7 +511,7 @@ static bool Snapshot(JSContext* cx, Hand
           return false;
         }
       }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       MOZ_CRASH("non-native objects must have an enumerate op");
     }
 
@@ -621,19 +621,19 @@ static inline size_t AllocationSize(size
 static PropertyIteratorObject* CreatePropertyIterator(
     JSContext* cx, Handle<JSObject*> objBeingIterated, HandleIdVector props,
     uint32_t numShapes, HashNumber shapesHash) {
-  if (props.length() > NativeIterator::PropCountLimit) {
+  if (props.length() > NativeIterator::PropCountLimit) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return nullptr;
   }
 
   Rooted<PropertyIteratorObject*> propIter(cx, NewPropertyIteratorObject(cx));
-  if (!propIter) {
+  if (!propIter) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   void* mem = cx->pod_malloc_with_extra<NativeIterator, uintptr_t>(
       NumTrailingWords(props.length(), numShapes));
-  if (!mem) {
+  if (!mem) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -814,7 +814,7 @@ static MOZ_ALWAYS_INLINE PropertyIterato
     Shape* shape = pobj->as<NativeObject>().lastProperty();
     shapesHash = mozilla::AddToHash(shapesHash, HashIteratorShape(shape));
 
-    if (MOZ_UNLIKELY(!shapes.append(shape))) {
+    if (MOZ_UNLIKELY(!shapes.append(shape))) {MOZ_RELEASE_ASSERT(0);
       cx->recoverFromOutOfMemory();
       return nullptr;
     }
@@ -960,7 +960,7 @@ static JSObject* GetIterator(JSContext* 
 
   PropertyIteratorObject* iterobj =
       CreatePropertyIterator(cx, obj, keys, numShapes, 0);
-  if (!iterobj) {
+  if (!iterobj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1051,13 +1051,13 @@ PlainObject* Realm::createIterResultTemp
       cx, withProto == WithObjectPrototype::Yes
               ? NewTenuredBuiltinClassInstance<PlainObject>(cx)
               : NewObjectWithGivenProto<PlainObject>(cx, nullptr));
-  if (!templateObject) {
+  if (!templateObject) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   // Set dummy `value` property
   if (!NativeDefineDataProperty(cx, templateObject, cx->names().value,
-                                UndefinedHandleValue, JSPROP_ENUMERATE)) {
+                                UndefinedHandleValue, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1315,7 +1315,7 @@ bool js::IteratorCloseForException(JSCon
   //
   // Get the "return" method.
   RootedValue returnMethod(cx);
-  if (!GetProperty(cx, obj, obj, cx->names().return_, &returnMethod)) {
+  if (!GetProperty(cx, obj, obj, cx->names().return_, &returnMethod)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1355,7 +1355,7 @@ bool js::IteratorCloseForException(JSCon
   return true;
 }
 
-void js::UnwindIteratorForUncatchableException(JSObject* obj) {
+void js::UnwindIteratorForUncatchableException(JSObject* obj) {MOZ_RELEASE_ASSERT(0);
   if (obj->is<PropertyIteratorObject>()) {
     NativeIterator* ni = obj->as<PropertyIteratorObject>().getNativeIterator();
     ni->unlink();
@@ -1394,7 +1394,7 @@ static bool SuppressDeletedProperty(JSCo
           continue;
         }
       } else {
-        if (!EqualStrings(*idp, str)) {
+        if (!EqualStrings(*idp, str)) {MOZ_RELEASE_ASSERT(0);
           continue;
         }
       }
@@ -1402,18 +1402,18 @@ static bool SuppressDeletedProperty(JSCo
       // Check whether another property along the prototype chain became
       // visible as a result of this deletion.
       RootedObject proto(cx);
-      if (!GetPrototype(cx, obj, &proto)) {
+      if (!GetPrototype(cx, obj, &proto)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (proto) {
         RootedId id(cx);
         RootedValue idv(cx, StringValue(*idp));
-        if (!PrimitiveValueToId<CanGC>(cx, idv, &id)) {
+        if (!PrimitiveValueToId<CanGC>(cx, idv, &id)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         Rooted<PropertyDescriptor> desc(cx);
-        if (!GetPropertyDescriptor(cx, proto, id, &desc)) {
+        if (!GetPropertyDescriptor(cx, proto, id, &desc)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -1424,7 +1424,7 @@ static bool SuppressDeletedProperty(JSCo
 
       // If GetPropertyDescriptor above removed a property from ni, start
       // over.
-      if (end != ni->propertiesEnd() || cursor != ni->nextProperty()) {
+      if (end != ni->propertiesEnd() || cursor != ni->nextProperty()) {MOZ_RELEASE_ASSERT(0);
         restart = true;
         break;
       }
@@ -1484,7 +1484,7 @@ bool js::SuppressDeletedProperty(JSConte
     return true;
   }
 
-  if (JSID_IS_SYMBOL(id)) {
+  if (JSID_IS_SYMBOL(id)) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -1502,7 +1502,7 @@ bool js::SuppressDeletedElement(JSContex
   }
 
   RootedId id(cx);
-  if (!IndexToId(cx, index, &id)) {
+  if (!IndexToId(cx, index, &id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1576,13 +1576,13 @@ static const JSFunctionSpec iterator_met
 /* static */
 bool GlobalObject::initIteratorProto(JSContext* cx,
                                      Handle<GlobalObject*> global) {
-  if (global->getReservedSlot(ITERATOR_PROTO).isObject()) {
+  if (global->getReservedSlot(ITERATOR_PROTO).isObject()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   RootedObject proto(
       cx, GlobalObject::createBlankPrototype<PlainObject>(cx, global));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1607,13 +1607,13 @@ template <unsigned Slot, const JSClass* 
 bool GlobalObject::initObjectIteratorProto(JSContext* cx,
                                            Handle<GlobalObject*> global,
                                            HandleAtom tag) {
-  if (global->getReservedSlot(Slot).isObject()) {
+  if (global->getReservedSlot(Slot).isObject()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   RootedObject iteratorProto(
       cx, GlobalObject::getOrCreateIteratorPrototype(cx, global));
-  if (!iteratorProto) {
+  if (!iteratorProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1679,7 +1679,7 @@ static bool IteratorConstructor(JSContex
 
   // Step 2.
   RootedObject proto(cx);
-  if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_Iterator, &proto)) {
+  if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_Iterator, &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/vm/JSAtom.cpp b/js/src/vm/JSAtom.cpp
--- a/js/src/vm/JSAtom.cpp
+++ b/js/src/vm/JSAtom.cpp
@@ -229,7 +229,7 @@ bool JSRuntime::initializeAtoms(JSContex
     wellKnownSymbols = parentRuntime->wellKnownSymbols;
 
     atoms_ = js_new<AtomsTable>();
-    if (!atoms_) {
+    if (!atoms_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -237,7 +237,7 @@ bool JSRuntime::initializeAtoms(JSContex
   }
 
   permanentAtomsDuringInit_ = js_new<AtomSet>(JS_PERMANENT_ATOM_SIZE);
-  if (!permanentAtomsDuringInit_) {
+  if (!permanentAtomsDuringInit_) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -483,16 +483,16 @@ void js::TraceWellKnownSymbols(JSTracer*
   }
 }
 
-void AtomsTable::traceWeak(JSTracer* trc) {
+void AtomsTable::traceWeak(JSTracer* trc) {MOZ_RELEASE_ASSERT(0);
   JSRuntime* rt = trc->runtime();
-  for (size_t i = 0; i < PartitionCount; i++) {
+  for (size_t i = 0; i < PartitionCount; i++) {MOZ_RELEASE_ASSERT(0);
     AutoLock lock(rt, partitions[i]->lock);
     AtomSet& atoms = partitions[i]->atoms;
-    for (AtomSet::Enum e(atoms); !e.empty(); e.popFront()) {
+    for (AtomSet::Enum e(atoms); !e.empty(); e.popFront()) {MOZ_RELEASE_ASSERT(0);
       JSAtom* atom = e.front().asPtrUnbarriered();
       MOZ_DIAGNOSTIC_ASSERT(atom);
       if (!TraceManuallyBarrieredWeakEdge(trc, &atom,
-                                          "AtomsTable::partitions::atoms")) {
+                                          "AtomsTable::partitions::atoms")) {MOZ_RELEASE_ASSERT(0);
         e.removeFront();
       } else {
         MOZ_ASSERT(atom == e.front().asPtrUnbarriered());
@@ -558,7 +558,7 @@ bool AtomsTable::startIncrementalSweep()
     auto& part = *partitions[i];
 
     auto newAtoms = js_new<AtomSet>();
-    if (!newAtoms) {
+    if (!newAtoms) {MOZ_RELEASE_ASSERT(0);
       ok = false;
       break;
     }
@@ -711,7 +711,7 @@ static MOZ_ALWAYS_INLINE JSAtom* Atomize
   if (pp) {
     JSAtom* atom = pp->asPtr(cx);
     if (zonePtr && MOZ_UNLIKELY(!zone->atomCache().add(
-                       *zonePtr, AtomStateEntry(atom, false)))) {
+                       *zonePtr, AtomStateEntry(atom, false)))) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return nullptr;
     }
@@ -721,7 +721,7 @@ static MOZ_ALWAYS_INLINE JSAtom* Atomize
 
   // Validate the length before taking an atoms partition lock, as throwing an
   // exception here may reenter this code.
-  if (MOZ_UNLIKELY(!JSString::validateLength(cx, length))) {
+  if (MOZ_UNLIKELY(!JSString::validateLength(cx, length))) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -731,7 +731,7 @@ static MOZ_ALWAYS_INLINE JSAtom* Atomize
     return nullptr;
   }
 
-  if (MOZ_UNLIKELY(!cx->atomMarking().inlinedMarkAtomFallible(cx, atom))) {
+  if (MOZ_UNLIKELY(!cx->atomMarking().inlinedMarkAtomFallible(cx, atom))) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -843,7 +843,7 @@ static MOZ_NEVER_INLINE JSAtom* Permanen
   }
 
   JSAtom* atom = AllocateNewAtom(cx, chars, length, indexValue, lookup);
-  if (!atom) {
+  if (!atom) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -852,7 +852,7 @@ static MOZ_NEVER_INLINE JSAtom* Permanen
   // We are single threaded at this point, and the operations we've done since
   // then can't GC; therefore the atoms table has not been modified and p is
   // still valid.
-  if (!atoms.add(p, AtomStateEntry(atom, true))) {
+  if (!atoms.add(p, AtomStateEntry(atom, true))) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx); /* SystemAllocPolicy does not report OOM. */
     return nullptr;
   }
@@ -897,7 +897,7 @@ static MOZ_ALWAYS_INLINE JSLinearString*
     CharT* storage;
     JSInlineString* str =
         AllocateInlineString<NoGC>(cx, length, &storage, gc::TenuredHeap);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -926,7 +926,7 @@ static MOZ_ALWAYS_INLINE JSLinearString*
 // Another 2 variants of MakeLinearStringForAtomization.
 static MOZ_ALWAYS_INLINE JSLinearString* MakeLinearStringForAtomization(
     JSContext* cx, const AtomizeUTF8CharsWrapper* chars, size_t length) {
-  if (length == 0) {
+  if (length == 0) {MOZ_RELEASE_ASSERT(0);
     return cx->emptyString();
   }
 
@@ -980,7 +980,7 @@ JSAtom* js::AtomizeString(JSContext* cx,
   }
 
   JSLinearString* linear = str->ensureLinear(cx);
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1001,7 +1001,7 @@ JSAtom* js::AtomizeString(JSContext* cx,
                                            linear->length(), pin, indexValue)
                      : AtomizeAndCopyChars(cx, linear->twoByteChars(nogc),
                                            linear->length(), pin, indexValue);
-  if (!atom) {
+  if (!atom) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1184,7 +1184,7 @@ static JSAtom* ToAtomSlow(
   Value v = arg;
   if (!v.isPrimitive()) {
     MOZ_ASSERT(!cx->isHelperThreadContext());
-    if (!allowGC) {
+    if (!allowGC) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     RootedValue v2(cx, v);
@@ -1196,21 +1196,21 @@ static JSAtom* ToAtomSlow(
 
   if (v.isString()) {
     JSAtom* atom = AtomizeString(cx, v.toString());
-    if (!allowGC && !atom) {
+    if (!allowGC && !atom) {MOZ_RELEASE_ASSERT(0);
       cx->recoverFromOutOfMemory();
     }
     return atom;
   }
   if (v.isInt32()) {
     JSAtom* atom = Int32ToAtom(cx, v.toInt32());
-    if (!allowGC && !atom) {
+    if (!allowGC && !atom) {MOZ_RELEASE_ASSERT(0);
       cx->recoverFromOutOfMemory();
     }
     return atom;
   }
   if (v.isDouble()) {
     JSAtom* atom = NumberToAtom(cx, v.toDouble());
-    if (!allowGC && !atom) {
+    if (!allowGC && !atom) {MOZ_RELEASE_ASSERT(0);
       cx->recoverFromOutOfMemory();
     }
     return atom;
diff --git a/js/src/vm/JSContext.cpp b/js/src/vm/JSContext.cpp
--- a/js/src/vm/JSContext.cpp
+++ b/js/src/vm/JSContext.cpp
@@ -125,7 +125,7 @@ bool JSContext::init(ContextKind kind) {
     currentThread_ = ThreadId::ThisThreadId();
     nativeStackBase_.emplace(GetNativeStackBase());
 
-    if (!fx.initInstance()) {
+    if (!fx.initInstance()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -138,7 +138,7 @@ bool JSContext::init(ContextKind kind) {
 
   } else {
     atomsZoneFreeLists_ = js_new<gc::FreeLists>();
-    if (!atomsZoneFreeLists_) {
+    if (!atomsZoneFreeLists_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -166,17 +166,17 @@ JSContext* js::NewContext(uint32_t maxBy
 #endif
 
   JSRuntime* runtime = js_new<JSRuntime>(parentRuntime);
-  if (!runtime) {
+  if (!runtime) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   JSContext* cx = js_new<JSContext>(runtime, JS::ContextOptions());
-  if (!cx) {
+  if (!cx) {MOZ_RELEASE_ASSERT(0);
     js_delete(runtime);
     return nullptr;
   }
 
-  if (!cx->init(ContextKind::MainThread)) {
+  if (!cx->init(ContextKind::MainThread)) {MOZ_RELEASE_ASSERT(0);
     js_delete(cx);
     js_delete(runtime);
     return nullptr;
@@ -254,11 +254,11 @@ JS_FRIEND_API void js::ReportOutOfMemory
    * (e.g. interpreter vs JIT). When doing differential testing, print to stderr
    * so that the fuzzers can detect this.
    */
-  if (js::SupportDifferentialTesting()) {
+  if (js::SupportDifferentialTesting()) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "ReportOutOfMemory called\n");
   }
 
-  if (cx->isHelperThreadContext()) {
+  if (cx->isHelperThreadContext()) {MOZ_RELEASE_ASSERT(0);
     return cx->addPendingOutOfMemory();
   }
 
@@ -294,7 +294,7 @@ void js::ReportOverRecursed(JSContext* m
    * stack depth which is useful for external testing programs
    * like fuzzers.
    */
-  if (js::SupportDifferentialTesting()) {
+  if (js::SupportDifferentialTesting()) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "ReportOverRecursed called\n");
   }
 
@@ -316,7 +316,7 @@ JS_FRIEND_API void js::ReportOverRecurse
 }
 
 void js::ReportAllocationOverflow(JSContext* cx) {
-  if (!cx) {
+  if (!cx) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -332,11 +332,11 @@ void js::ReportAllocationOverflow(JSCont
 void js::ReportUsageErrorASCII(JSContext* cx, HandleObject callee,
                                const char* msg) {
   RootedValue usage(cx);
-  if (!JS_GetProperty(cx, callee, "usage", &usage)) {
+  if (!JS_GetProperty(cx, callee, "usage", &usage)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
-  if (!usage.isString()) {
+  if (!usage.isString()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "%s", msg);
   } else {
     RootedString usageStr(cx, usage.toString());
@@ -375,7 +375,7 @@ static void PrintErrorLine(FILE* file, c
     const char* utf8buf;
     if (line) {
       utf8buf = line.get();
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       static const char unavailableStr[] = "<context unavailable>";
       utf8buf = unavailableStr;
       n = js_strlen(unavailableStr);
@@ -539,7 +539,7 @@ void js::ReportIsNullOrUndefinedForPrope
   }
 
   UniqueChars bytes = DecompileValueGenerator(cx, vIndex, v, nullptr);
-  if (!bytes) {
+  if (!bytes) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -570,18 +570,18 @@ void js::ReportIsNullOrUndefinedForPrope
   }
 
   UniqueChars keyStr = StringToNewUTF8CharsZ(cx, *idStr);
-  if (!keyStr) {
+  if (!keyStr) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
-  if (vIndex == JSDVG_IGNORE_STACK) {
+  if (vIndex == JSDVG_IGNORE_STACK) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberUTF8(cx, GetErrorMessage, nullptr, JSMSG_PROPERTY_FAIL,
                              keyStr.get(), NullOrUndefinedToCharZ(v));
     return;
   }
 
   UniqueChars bytes = DecompileValueGenerator(cx, vIndex, v, nullptr);
-  if (!bytes) {
+  if (!bytes) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -614,7 +614,7 @@ bool js::ReportValueError(JSContext* cx,
 
 JSObject* js::CreateErrorNotesArray(JSContext* cx, JSErrorReport* report) {
   RootedArrayObject notesArray(cx, NewDenseEmptyArray(cx));
-  if (!notesArray) {
+  if (!notesArray) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -624,37 +624,37 @@ JSObject* js::CreateErrorNotesArray(JSCo
 
   for (auto&& note : *report->notes) {
     RootedPlainObject noteObj(cx, NewBuiltinClassInstance<PlainObject>(cx));
-    if (!noteObj) {
+    if (!noteObj) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     RootedString messageStr(cx, note->newMessageString(cx));
-    if (!messageStr) {
+    if (!messageStr) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     RootedValue messageVal(cx, StringValue(messageStr));
-    if (!DefineDataProperty(cx, noteObj, cx->names().message, messageVal)) {
+    if (!DefineDataProperty(cx, noteObj, cx->names().message, messageVal)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     RootedValue filenameVal(cx);
     if (note->filename) {
       RootedString filenameStr(cx, NewStringCopyZ<CanGC>(cx, note->filename));
-      if (!filenameStr) {
+      if (!filenameStr) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       filenameVal = StringValue(filenameStr);
     }
-    if (!DefineDataProperty(cx, noteObj, cx->names().fileName, filenameVal)) {
+    if (!DefineDataProperty(cx, noteObj, cx->names().fileName, filenameVal)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     RootedValue linenoVal(cx, Int32Value(note->lineno));
-    if (!DefineDataProperty(cx, noteObj, cx->names().lineNumber, linenoVal)) {
+    if (!DefineDataProperty(cx, noteObj, cx->names().lineNumber, linenoVal)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     RootedValue columnVal(cx, Int32Value(note->column));
-    if (!DefineDataProperty(cx, noteObj, cx->names().columnNumber, columnVal)) {
+    if (!DefineDataProperty(cx, noteObj, cx->names().columnNumber, columnVal)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -669,7 +669,7 @@ JSObject* js::CreateErrorNotesArray(JSCo
 void JSContext::recoverFromOutOfMemory() {
   if (isHelperThreadContext()) {
     // Keep in sync with addPendingOutOfMemory.
-    if (ParseTask* task = parseTask()) {
+    if (ParseTask* task = parseTask()) {MOZ_RELEASE_ASSERT(0);
       task->outOfMemory = false;
     }
   } else {
@@ -780,9 +780,9 @@ void InternalJobQueue::runJobs(JSContext
           // Nothing we can do about uncatchable exceptions.
           if (!cx->isExceptionPending()) {
             continue;
-          }
+          }MOZ_RELEASE_ASSERT(0);
           RootedValue exn(cx);
-          if (cx->getPendingException(&exn)) {
+          if (cx->getPendingException(&exn)) {MOZ_RELEASE_ASSERT(0);
             /*
              * Clear the exception, because
              * PrepareScriptEnvironmentAndInvoke will assert that we don't
@@ -791,7 +791,7 @@ void InternalJobQueue::runJobs(JSContext
             cx->clearPendingException();
             js::ReportExceptionClosure reportExn(exn);
             PrepareScriptEnvironmentAndInvoke(cx, cx->global(), reportExn);
-          }
+          }MOZ_RELEASE_ASSERT(0);
         }
       }
     }
@@ -982,7 +982,7 @@ JSContext::~JSContext() {
 #endif
 
 #ifdef JS_TRACE_LOGGING
-  if (traceLogger) {
+  if (traceLogger) {MOZ_RELEASE_ASSERT(0);
     DestroyTraceLogger(traceLogger);
   }
 #endif
@@ -1037,7 +1037,7 @@ void JSContext::setPendingException(Hand
     // Do not intercept exceptions if we are already
     // in the exception interceptor. That would lead
     // to infinite recursion.
-    if (this->runtime()->errorInterception.isExecuting) {
+    if (this->runtime()->errorInterception.isExecuting) {MOZ_RELEASE_ASSERT(0);
       break;
     }
 
@@ -1076,7 +1076,7 @@ void JSContext::setPendingException(Hand
 
 void JSContext::setPendingExceptionAndCaptureStack(HandleValue value) {
   RootedObject stack(this);
-  if (!CaptureStack(this, &stack)) {
+  if (!CaptureStack(this, &stack)) {MOZ_RELEASE_ASSERT(0);
     clearPendingException();
   }
 
@@ -1090,7 +1090,7 @@ void JSContext::setPendingExceptionAndCa
 bool JSContext::getPendingException(MutableHandleValue rval) {
   MOZ_ASSERT(throwing);
   rval.set(unwrappedException());
-  if (zone()->isAtomsZone()) {
+  if (zone()->isAtomsZone()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
   RootedSavedFrame stack(this, unwrappedExceptionStack());
@@ -1197,8 +1197,8 @@ mozilla::Atomic<AutoEnterOOMUnsafeRegion
                 mozilla::Relaxed>
     AutoEnterOOMUnsafeRegion::annotateOOMSizeCallback(nullptr);
 
-void AutoEnterOOMUnsafeRegion::crash(size_t size, const char* reason) {
-  {
+void AutoEnterOOMUnsafeRegion::crash(size_t size, const char* reason) {MOZ_RELEASE_ASSERT(0);
+  {MOZ_RELEASE_ASSERT(0);
     JS::AutoSuppressGCAnalysis suppress;
     if (annotateOOMSizeCallback) {
       annotateOOMSizeCallback(size);
diff --git a/js/src/vm/JSFunction.cpp b/js/src/vm/JSFunction.cpp
--- a/js/src/vm/JSFunction.cpp
+++ b/js/src/vm/JSFunction.cpp
@@ -94,14 +94,14 @@ static bool fun_enumerate(JSContext* cx,
 
   if (!obj->isBoundFunction() && !obj->as<JSFunction>().isArrow()) {
     id = NameToId(cx->names().prototype);
-    if (!HasOwnProperty(cx, obj, id, &found)) {
+    if (!HasOwnProperty(cx, obj, id, &found)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   if (!obj->as<JSFunction>().hasResolvedLength()) {
     id = NameToId(cx->names().length);
-    if (!HasOwnProperty(cx, obj, id, &found)) {
+    if (!HasOwnProperty(cx, obj, id, &found)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -286,7 +286,7 @@ bool CallerGetterImpl(JSContext* cx, con
   }
 
   RootedObject caller(cx, iter.callee(cx));
-  if (!cx->compartment()->wrap(cx, &caller)) {
+  if (!cx->compartment()->wrap(cx, &caller)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -375,13 +375,13 @@ static bool ResolveInterpretedFunctionPr
   } else {
     objProto = GlobalObject::getOrCreateObjectPrototype(cx, global);
   }
-  if (!objProto) {
+  if (!objProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedPlainObject proto(
       cx, NewTenuredObjectWithGivenProto<PlainObject>(cx, objProto));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -481,7 +481,7 @@ static bool fun_resolve(JSContext* cx, H
       return true;
     }
 
-    if (!ResolveInterpretedFunctionPrototype(cx, fun, id)) {
+    if (!ResolveInterpretedFunctionPrototype(cx, fun, id)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -514,7 +514,7 @@ static bool fun_resolve(JSContext* cx, H
         return true;
       }
 
-      if (!JSFunction::getUnresolvedLength(cx, fun, &v)) {
+      if (!JSFunction::getUnresolvedLength(cx, fun, &v)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -528,7 +528,7 @@ static bool fun_resolve(JSContext* cx, H
     }
 
     if (!NativeDefineDataProperty(cx, fun, id, v,
-                                  JSPROP_READONLY | JSPROP_RESOLVING)) {
+                                  JSPROP_READONLY | JSPROP_RESOLVING)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -573,7 +573,7 @@ XDRResult js::XDRInterpretedFunction(XDR
 
   if (mode == XDR_ENCODE) {
     fun = objp;
-    if (!fun->isInterpreted() || fun->isBoundFunction()) {
+    if (!fun->isInterpreted() || fun->isBoundFunction()) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Failure_NotInterpretedFun);
     }
 
@@ -587,7 +587,7 @@ XDRResult js::XDRInterpretedFunction(XDR
     if (fun->hasBytecode()) {
       // Encode the script.
       script = fun->nonLazyScript();
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       // Encode a lazy script.
       xdrFlags |= IsLazy;
       lazy = fun->baseScript();
@@ -621,7 +621,7 @@ XDRResult js::XDRInterpretedFunction(XDR
                                       : FunctionAsyncKind::SyncFunction;
 
     RootedObject proto(cx);
-    if (!GetFunctionPrototype(cx, generatorKind, asyncKind, &proto)) {
+    if (!GetFunctionPrototype(cx, generatorKind, asyncKind, &proto)) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Throw);
     }
 
@@ -635,19 +635,19 @@ XDRResult js::XDRInterpretedFunction(XDR
     constexpr uint16_t UnsupportedFlags =
         FunctionFlags::MUTABLE_FLAGS | FunctionFlags::SELFHOSTLAZY |
         FunctionFlags::BOUND_FUN | FunctionFlags::WASM_JIT_ENTRY;
-    if ((flags & UnsupportedFlags) != 0) {
+    if ((flags & UnsupportedFlags) != 0) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Failure_BadDecode);
     }
 
     fun = NewFunctionWithProto(cx, nullptr, nargs, FunctionFlags(flags),
                                nullptr, atom, proto, allocKind, TenuredObject);
-    if (!fun) {
+    if (!fun) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Throw);
     }
     objp.set(fun);
   }
 
-  if (xdrFlags & IsLazy) {
+  if (xdrFlags & IsLazy) {MOZ_RELEASE_ASSERT(0);
     MOZ_TRY(XDRLazyScript(xdr, enclosingScope, sourceObject, fun, &lazy));
   } else {
     MOZ_TRY(XDRScript(xdr, enclosingScope, sourceObject, fun, &script));
@@ -771,7 +771,7 @@ inline void JSFunction::trace(JSTracer* 
     // Functions can be be marked as interpreted despite having no script
     // yet at some points when parsing, and can be lazy with no lazy script
     // for self-hosted code.
-    if (isIncomplete()) {
+    if (isIncomplete()) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(u.scripted.s.script_ == nullptr);
     } else if (hasBaseScript()) {
       BaseScript* script = u.scripted.s.script_;
@@ -883,7 +883,7 @@ JSString* js::FunctionToString(JSContext
         (end - start <= ScriptSource::SourceDeflateLimit)
             ? script->scriptSource()->substring(cx, start, end)
             : script->scriptSource()->substringDontDeflate(cx, start, end);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -893,13 +893,13 @@ JSString* js::FunctionToString(JSContext
 
   JSStringBuilder out(cx);
   if (addParentheses) {
-    if (!out.append('(')) {
+    if (!out.append('(')) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
 
   if (haveSource) {
-    if (!fun->baseScript()->appendSourceDataForToString(cx, out)) {
+    if (!fun->baseScript()->appendSourceDataForToString(cx, out)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else if (!isToSource) {
@@ -928,7 +928,7 @@ JSString* js::FunctionToString(JSContext
                   : hasGetterOrSetterPrefix(name->twoByteChars(nogc)));
     };
 
-    if (!out.append("function")) {
+    if (!out.append("function")) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -938,7 +938,7 @@ JSString* js::FunctionToString(JSContext
     if (fun->explicitName() && !fun->isBoundFunction() &&
         (fun->kind() == FunctionFlags::NormalFunction ||
          fun->kind() == FunctionFlags::ClassConstructor)) {
-      if (!out.append(' ')) {
+      if (!out.append(' ')) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -946,51 +946,51 @@ JSString* js::FunctionToString(JSContext
       // functions, strip any leading "get " or "set " if present.
       JSAtom* name = fun->explicitName();
       size_t offset = hasGetterOrSetterPrefix(name) ? 4 : 0;
-      if (!out.appendSubstring(name, offset, name->length() - offset)) {
+      if (!out.appendSubstring(name, offset, name->length() - offset)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
 
-    if (!out.append("() {\n    [native code]\n}")) {
+    if (!out.append("() {\n    [native code]\n}")) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
     if (fun->isAsync()) {
-      if (!out.append("async ")) {
+      if (!out.append("async ")) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
     if (!fun->isArrow()) {
-      if (!out.append("function")) {
+      if (!out.append("function")) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
       if (fun->isGenerator()) {
-        if (!out.append('*')) {
+        if (!out.append('*')) {MOZ_RELEASE_ASSERT(0);
+          return nullptr;
+        }MOZ_RELEASE_ASSERT(0);
+      }
+    }
+
+    if (fun->explicitName()) {
+      if (!out.append(' ')) {MOZ_RELEASE_ASSERT(0);
+        return nullptr;
+      }
+
+      if (fun->isBoundFunction()) {MOZ_RELEASE_ASSERT(0);
+        JSLinearString* boundName = JSFunction::getBoundFunctionName(cx, fun);
+        if (!boundName || !out.append(boundName)) {MOZ_RELEASE_ASSERT(0);
+          return nullptr;
+        }
+      } else {
+        if (!out.append(fun->explicitName())) {MOZ_RELEASE_ASSERT(0);
           return nullptr;
         }
       }
     }
 
-    if (fun->explicitName()) {
-      if (!out.append(' ')) {
-        return nullptr;
-      }
-
-      if (fun->isBoundFunction()) {
-        JSLinearString* boundName = JSFunction::getBoundFunctionName(cx, fun);
-        if (!boundName || !out.append(boundName)) {
-          return nullptr;
-        }
-      } else {
-        if (!out.append(fun->explicitName())) {
-          return nullptr;
-        }
-      }
-    }
-
-    if (!out.append("() {\n    [native code]\n}")) {
+    if (!out.append("() {\n    [native code]\n}")) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -1042,7 +1042,7 @@ static bool fun_toSource(JSContext* cx, 
   MOZ_ASSERT(IsFunctionObject(args.calleev()));
 
   RootedObject obj(cx, ToObject(cx, args.thisv()));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1086,7 +1086,7 @@ bool js::fun_call(JSContext* cx, unsigne
   }
 
   InvokeArgs iargs(cx);
-  if (!iargs.init(cx, argCount)) {
+  if (!iargs.init(cx, argCount)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1123,13 +1123,13 @@ bool js::fun_apply(JSContext* cx, unsign
   // this apply call from a scripted caller and, as an optimization, we've
   // avoided creating it since apply can simply pull the argument values from
   // the calling frame (which we must do now).
-  if (args[1].isMagic(JS_OPTIMIZED_ARGUMENTS)) {
+  if (args[1].isMagic(JS_OPTIMIZED_ARGUMENTS)) {MOZ_RELEASE_ASSERT(0);
     // Step 3-6.
     ScriptFrameIter iter(cx);
     MOZ_ASSERT(iter.numActualArgs() <= ARGS_LENGTH_MAX);
-    if (!args2.init(cx, iter.numActualArgs())) {
+    if (!args2.init(cx, iter.numActualArgs())) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Steps 7-8.
     iter.unaliasedForEachActual(cx, CopyTo(args2.array()));
@@ -1321,18 +1321,18 @@ JSLinearString* JSFunction::getBoundFunc
       StringEqualsAscii(cx->names().boundWithSpace, boundWithSpaceChars));
 
   JSStringBuilder sb(cx);
-  if (name->hasTwoByteChars() && !sb.ensureTwoByteChars()) {
+  if (name->hasTwoByteChars() && !sb.ensureTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   CheckedInt<size_t> len(boundTargets);
   len *= boundWithSpaceCharsLength;
   len += name->length();
-  if (!len.isValid()) {
+  if (!len.isValid()) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return nullptr;
   }
-  if (!sb.reserve(len.value())) {
+  if (!sb.reserve(len.value())) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1406,13 +1406,13 @@ bool JSFunction::finishBoundFunctionInit
 
   // 9.4.1.3 BoundFunctionCreate, step 2.
   RootedObject proto(cx);
-  if (!GetPrototype(cx, targetObj, &proto)) {
+  if (!GetPrototype(cx, targetObj, &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // 9.4.1.3 BoundFunctionCreate, step 7.
   if (bound->staticPrototype() != proto) {
-    if (!SetPrototype(cx, bound, proto)) {
+    if (!SetPrototype(cx, bound, proto)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1424,7 +1424,7 @@ bool JSFunction::finishBoundFunctionInit
       !targetObj->as<JSFunction>().hasResolvedLength()) {
     RootedValue targetLength(cx);
     if (!JSFunction::getUnresolvedLength(cx, targetObj.as<JSFunction>(),
-                                         &targetLength)) {
+                                         &targetLength)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1440,7 +1440,7 @@ bool JSFunction::finishBoundFunctionInit
     // 19.2.3.2 Function.prototype.bind, step 6.
     if (hasLength) {
       RootedValue targetLength(cx);
-      if (!GetProperty(cx, targetObj, targetObj, idRoot, &targetLength)) {
+      if (!GetProperty(cx, targetObj, targetObj, idRoot, &targetLength)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -1469,7 +1469,7 @@ bool JSFunction::finishBoundFunctionInit
     // we need to append the bound function name prefix here.
     if (targetFn->isBoundFunction() && targetFn->hasBoundFunctionNamePrefix()) {
       JSAtom* name = AppendBoundFunctionPrefix(cx, targetFn->explicitName());
-      if (!name) {
+      if (!name) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       bound->setPrefixedBoundFunctionName(name);
@@ -1498,7 +1498,7 @@ bool JSFunction::finishBoundFunctionInit
     if (targetObj->is<JSFunction>() &&
         targetObj->as<JSFunction>().isBoundFunction()) {
       JSAtom* name = AppendBoundFunctionPrefix(cx, targetName.toString());
-      if (!name) {
+      if (!name) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       bound->setPrefixedBoundFunctionName(name);
@@ -1533,7 +1533,7 @@ bool JSFunction::delazifyLazilyInterpret
   // always non-lazy if any of the clones are non-lazy.
   if (fun != canonicalFun) {
     JSScript* script = JSFunction::getOrCreateScript(cx, canonicalFun);
-    if (!script) {
+    if (!script) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1600,23 +1600,23 @@ void JSFunction::maybeRelazify(JSRuntime
   // information.
   if (coverage::IsLCovEnabled()) {
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Check the script's eligibility.
   JSScript* script = nonLazyScript();
-  if (!script->allowRelazify()) {
+  if (!script->allowRelazify()) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(script->isRelazifiable());
 
   // There must not be any JIT code attached since the relazification process
   // does not know how to discard it. In general, the GC should discard most JIT
   // code before attempting relazification.
-  if (script->hasJitScript()) {
+  if (script->hasJitScript()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
-  if (isSelfHostedBuiltin()) {
+  if (isSelfHostedBuiltin()) {MOZ_RELEASE_ASSERT(0);
     gc::PreWriteBarrier(script);
     initSelfHostedLazyScript(&rt->selfHostedLazyScript.ref());
   } else {
@@ -1681,20 +1681,20 @@ static bool CreateDynamicFunction(JSCont
   JSStringBuilder sb(cx);
 
   if (isAsync) {
-    if (!sb.append("async ")) {
+    if (!sb.append("async ")) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
-  if (!sb.append("function")) {
+  if (!sb.append("function")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (isGenerator) {
-    if (!sb.append('*')) {
+    if (!sb.append('*')) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!sb.append(" anonymous(")) {
+  if (!sb.append(" anonymous(")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1712,20 +1712,20 @@ static bool CreateDynamicFunction(JSCont
       }
 
       // Steps 14.b, 14.d.iii.
-      if (!sb.append(str)) {
+      if (!sb.append(str)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       if (i < args.length() - 2) {
         // Step 14.d.iii.
-        if (!sb.append(',')) {
+        if (!sb.append(',')) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
     }
   }
 
-  if (!sb.append('\n')) {
+  if (!sb.append('\n')) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1733,7 +1733,7 @@ static bool CreateDynamicFunction(JSCont
   Maybe<uint32_t> parameterListEnd = Some(uint32_t(sb.length()));
   MOZ_ASSERT(FunctionConstructorMedialSigils[0] == ')');
 
-  if (!sb.append(FunctionConstructorMedialSigils)) {
+  if (!sb.append(FunctionConstructorMedialSigils)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1745,17 +1745,17 @@ static bool CreateDynamicFunction(JSCont
     }
   }
 
-  if (!sb.append(FunctionConstructorFinalBrace)) {
+  if (!sb.append(FunctionConstructorFinalBrace)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // The parser only accepts two byte strings.
-  if (!sb.ensureTwoByteChars()) {
+  if (!sb.ensureTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedString functionText(cx, sb.finishString());
-  if (!functionText) {
+  if (!functionText) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1769,7 +1769,7 @@ static bool CreateDynamicFunction(JSCont
 
   // Steps 7.a-b, 8.a-b, 9.a-b, 16-28.
   AutoStableStringChars stableChars(cx);
-  if (!stableChars.initTwoByte(cx, functionText)) {
+  if (!stableChars.initTwoByte(cx, functionText)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1778,7 +1778,7 @@ static bool CreateDynamicFunction(JSCont
                                   ? SourceOwnership::TakeOwnership
                                   : SourceOwnership::Borrowed;
   SourceText<char16_t> srcBuf;
-  if (!srcBuf.init(cx, chars.begin().get(), chars.length(), ownership)) {
+  if (!srcBuf.init(cx, chars.begin().get(), chars.length(), ownership)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1861,7 +1861,7 @@ bool JSFunction::isBuiltinFunctionConstr
 }
 
 bool JSFunction::needsExtraBodyVarEnvironment() const {
-  if (isNativeFun()) {
+  if (isNativeFun()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1952,7 +1952,7 @@ JSFunction* js::NewFunctionWithProto(
 
   JSFunction* fun =
       NewObjectWithClassProto<JSFunction>(cx, proto, allocKind, newKind);
-  if (!fun) {
+  if (!fun) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2014,14 +2014,14 @@ bool js::GetFunctionPrototype(JSContext*
 }
 
 bool js::CanReuseScriptForClone(JS::Realm* realm, HandleFunction fun,
-                                HandleObject newEnclosingEnv) {
+                                HandleObject newEnclosingEnv) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(fun->isInterpreted());
 
-  if (realm != fun->realm()) {
+  if (realm != fun->realm()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (newEnclosingEnv->is<GlobalObject>()) {
+  if (newEnclosingEnv->is<GlobalObject>()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -2049,7 +2049,7 @@ static inline JSFunction* NewFunctionClo
   RootedObject cloneProto(cx, proto);
   if (!proto) {
     if (!GetFunctionPrototype(cx, fun->generatorKind(), fun->asyncKind(),
-                              &cloneProto)) {
+                              &cloneProto)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -2057,7 +2057,7 @@ static inline JSFunction* NewFunctionClo
   RootedFunction clone(cx);
   clone =
       NewObjectWithClassProto<JSFunction>(cx, cloneProto, allocKind, newKind);
-  if (!clone) {
+  if (!clone) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2107,7 +2107,7 @@ JSFunction* js::CloneFunctionReuseScript
   NewObjectKind newKind = GenericObject;
   RootedFunction clone(cx,
                        NewFunctionClone(cx, fun, newKind, allocKind, proto));
-  if (!clone) {
+  if (!clone) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2136,13 +2136,13 @@ JSFunction* js::CloneFunctionAndScript(J
   MOZ_ASSERT(!fun->isBoundFunction());
 
   JSScript::AutoDelazify funScript(cx, fun);
-  if (!funScript) {
+  if (!funScript) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedFunction clone(
       cx, NewFunctionClone(cx, fun, TenuredObject, allocKind, proto));
-  if (!clone) {
+  if (!clone) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2215,11 +2215,11 @@ static JSAtom* SymbolToFunctionName(JSCo
   // Step 5 (reordered).
   StringBuffer sb(cx);
   if (prefixKind == FunctionPrefixKind::Get) {
-    if (!sb.append("get ")) {
+    if (!sb.append("get ")) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else if (prefixKind == FunctionPrefixKind::Set) {
-    if (!sb.append("set ")) {
+    if (!sb.append("set ")) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -2231,7 +2231,7 @@ static JSAtom* SymbolToFunctionName(JSCo
     // i.e. obj.#f desugars to obj.[PrivateNameSymbol("#f")], however
     // they don't use the symbol naming, but rather property naming.
     if (symbol->isPrivateName()) {
-      if (!sb.append(desc)) {
+      if (!sb.append(desc)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     } else {
@@ -2253,17 +2253,17 @@ static JSAtom* NameToFunctionName(JSCont
   }
 
   JSString* nameStr = ToString(cx, name);
-  if (!nameStr) {
+  if (!nameStr) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   StringBuffer sb(cx);
   if (prefixKind == FunctionPrefixKind::Get) {
-    if (!sb.append("get ")) {
+    if (!sb.append("get ")) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
-    if (!sb.append("set ")) {
+    if (!sb.append("set ")) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -2334,7 +2334,7 @@ JSFunction* js::DefineFunction(
     JSContext* cx, HandleObject obj, HandleId id, Native native, unsigned nargs,
     unsigned flags, gc::AllocKind allocKind /* = AllocKind::FUNCTION */) {
   RootedAtom atom(cx, IdToFunctionName(cx, id));
-  if (!atom) {
+  if (!atom) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2347,7 +2347,7 @@ JSFunction* js::DefineFunction(
     fun = NewNativeFunction(cx, native, nargs, atom, allocKind);
   }
 
-  if (!fun) {
+  if (!fun) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/vm/JSONParser.cpp b/js/src/vm/JSONParser.cpp
--- a/js/src/vm/JSONParser.cpp
+++ b/js/src/vm/JSONParser.cpp
@@ -128,7 +128,7 @@ JSONParserBase::Token JSONParser<CharT>:
           (ST == JSONParser::PropertyName)
               ? AtomizeChars(cx, start.get(), length)
               : NewStringCopyN<CanGC>(cx, start.get(), length);
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         return token(OOM);
       }
       return stringToken(str);
@@ -151,7 +151,7 @@ JSONParserBase::Token JSONParser<CharT>:
    */
   JSStringBuilder buffer(cx);
   do {
-    if (start < current && !buffer.append(start.get(), current.get())) {
+    if (start < current && !buffer.append(start.get(), current.get())) {MOZ_RELEASE_ASSERT(0);
       return token(OOM);
     }
 
@@ -164,7 +164,7 @@ JSONParserBase::Token JSONParser<CharT>:
       JSLinearString* str = (ST == JSONParser::PropertyName)
                                 ? buffer.finishAtom()
                                 : buffer.finishString();
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         return token(OOM);
       }
       return stringToken(str);
@@ -239,7 +239,7 @@ JSONParserBase::Token JSONParser<CharT>:
         error("bad escaped character");
         return token(Error);
     }
-    if (!buffer.append(c)) {
+    if (!buffer.append(c)) {MOZ_RELEASE_ASSERT(0);
       return token(OOM);
     }
 
@@ -303,7 +303,7 @@ JSONParserBase::Token JSONParser<CharT>:
 
     double d;
     if (!GetFullInteger(cx, digitStart.get(), current.get(), 10,
-                        IntegerSeparatorHandling::None, &d)) {
+                        IntegerSeparatorHandling::None, &d)) {MOZ_RELEASE_ASSERT(0);
       return token(OOM);
     }
     return numberToken(negative ? -d : d);
@@ -583,7 +583,7 @@ inline bool JSONParserBase::finishObject
 
   JSObject* obj = NewPlainObjectWithProperties(
       cx, properties.begin(), properties.length(), GenericObject);
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -601,7 +601,7 @@ inline bool JSONParserBase::finishArray(
 
   ArrayObject* obj =
       NewDenseCopiedArray(cx, elements.length(), elements.begin());
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/vm/JSONPrinter.cpp b/js/src/vm/JSONPrinter.cpp
--- a/js/src/vm/JSONPrinter.cpp
+++ b/js/src/vm/JSONPrinter.cpp
@@ -83,7 +83,7 @@ void JSONPrinter::endStringProperty() {
   first_ = false;
 }
 
-GenericPrinter& JSONPrinter::beginString() {
+GenericPrinter& JSONPrinter::beginString() {MOZ_RELEASE_ASSERT(0);
   if (!first_) {
     out_.putChar(',');
   }
@@ -123,7 +123,7 @@ void JSONPrinter::formatProperty(const c
   endStringProperty();
 }
 
-void JSONPrinter::value(const char* format, ...) {
+void JSONPrinter::value(const char* format, ...) {MOZ_RELEASE_ASSERT(0);
   va_list ap;
   va_start(ap, format);
 
@@ -218,7 +218,7 @@ void JSONPrinter::nullProperty(const cha
   out_.put("null");
 }
 
-void JSONPrinter::nullValue() {
+void JSONPrinter::nullValue() {MOZ_RELEASE_ASSERT(0);
   if (!first_) {
     out_.putChar(',');
   }
diff --git a/js/src/vm/JSObject.cpp b/js/src/vm/JSObject.cpp
--- a/js/src/vm/JSObject.cpp
+++ b/js/src/vm/JSObject.cpp
@@ -164,7 +164,7 @@ bool js::FromPropertyDescriptorToObject(
                                         MutableHandleValue vp) {
   // Step 2-3.
   RootedObject obj(cx, NewBuiltinClassInstance<PlainObject>(cx));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -172,7 +172,7 @@ bool js::FromPropertyDescriptorToObject(
 
   // Step 4.
   if (desc.hasValue()) {
-    if (!DefineDataProperty(cx, obj, names.value, desc.value())) {
+    if (!DefineDataProperty(cx, obj, names.value, desc.value())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -181,7 +181,7 @@ bool js::FromPropertyDescriptorToObject(
   RootedValue v(cx);
   if (desc.hasWritable()) {
     v.setBoolean(desc.writable());
-    if (!DefineDataProperty(cx, obj, names.writable, v)) {
+    if (!DefineDataProperty(cx, obj, names.writable, v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -193,7 +193,7 @@ bool js::FromPropertyDescriptorToObject(
     } else {
       v.setUndefined();
     }
-    if (!DefineDataProperty(cx, obj, names.get, v)) {
+    if (!DefineDataProperty(cx, obj, names.get, v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -205,7 +205,7 @@ bool js::FromPropertyDescriptorToObject(
     } else {
       v.setUndefined();
     }
-    if (!DefineDataProperty(cx, obj, names.set, v)) {
+    if (!DefineDataProperty(cx, obj, names.set, v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -213,7 +213,7 @@ bool js::FromPropertyDescriptorToObject(
   // Step 8.
   if (desc.hasEnumerable()) {
     v.setBoolean(desc.enumerable());
-    if (!DefineDataProperty(cx, obj, names.enumerable, v)) {
+    if (!DefineDataProperty(cx, obj, names.enumerable, v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -256,7 +256,7 @@ bool js::GetFirstArgumentAsObject(JSCont
 
 static bool GetPropertyIfPresent(JSContext* cx, HandleObject obj, HandleId id,
                                  MutableHandleValue vp, bool* foundp) {
-  if (!HasProperty(cx, obj, id, foundp)) {
+  if (!HasProperty(cx, obj, id, foundp)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!*foundp) {
@@ -274,7 +274,7 @@ bool js::Throw(JSContext* cx, HandleId i
 
   UniqueChars bytes =
       IdToPrintableUTF8(cx, id, IdToPrintableBehavior::IdIsPropertyKey);
-  if (!bytes) {
+  if (!bytes) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -324,7 +324,7 @@ bool js::ToPropertyDescriptor(JSContext*
 
   // step 4
   id = NameToId(cx->names().enumerable);
-  if (!GetPropertyIfPresent(cx, obj, id, &v, &found)) {
+  if (!GetPropertyIfPresent(cx, obj, id, &v, &found)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (found) {
@@ -337,7 +337,7 @@ bool js::ToPropertyDescriptor(JSContext*
 
   // step 5
   id = NameToId(cx->names().configurable);
-  if (!GetPropertyIfPresent(cx, obj, id, &v, &found)) {
+  if (!GetPropertyIfPresent(cx, obj, id, &v, &found)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (found) {
@@ -350,7 +350,7 @@ bool js::ToPropertyDescriptor(JSContext*
 
   // step 6
   id = NameToId(cx->names().value);
-  if (!GetPropertyIfPresent(cx, obj, id, &v, &found)) {
+  if (!GetPropertyIfPresent(cx, obj, id, &v, &found)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (found) {
@@ -361,7 +361,7 @@ bool js::ToPropertyDescriptor(JSContext*
 
   // step 7
   id = NameToId(cx->names().writable);
-  if (!GetPropertyIfPresent(cx, obj, id, &v, &found)) {
+  if (!GetPropertyIfPresent(cx, obj, id, &v, &found)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (found) {
@@ -375,7 +375,7 @@ bool js::ToPropertyDescriptor(JSContext*
   // step 8
   bool hasGetOrSet;
   id = NameToId(cx->names().get);
-  if (!GetPropertyIfPresent(cx, obj, id, &v, &found)) {
+  if (!GetPropertyIfPresent(cx, obj, id, &v, &found)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   hasGetOrSet = found;
@@ -396,7 +396,7 @@ bool js::ToPropertyDescriptor(JSContext*
 
   // step 9
   id = NameToId(cx->names().set);
-  if (!GetPropertyIfPresent(cx, obj, id, &v, &found)) {
+  if (!GetPropertyIfPresent(cx, obj, id, &v, &found)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   hasGetOrSet |= found;
@@ -474,7 +474,7 @@ void js::CompletePropertyDescriptor(Muta
 bool js::ReadPropertyDescriptors(
     JSContext* cx, HandleObject props, bool checkAccessors,
     MutableHandleIdVector ids, MutableHandle<PropertyDescriptorVector> descs) {
-  if (!GetPropertyKeys(cx, props, JSITER_OWNONLY | JSITER_SYMBOLS, ids)) {
+  if (!GetPropertyKeys(cx, props, JSITER_OWNONLY | JSITER_SYMBOLS, ids)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -529,7 +529,7 @@ bool js::SetIntegrityLevel(JSContext* cx
         cx, EmptyShape::getInitialShape(
                 cx, nobj->getClass(), nobj->realm(), nobj->taggedProto(),
                 nobj->numFixedSlots(), nobj->lastProperty()->objectFlags()));
-    if (!last) {
+    if (!last) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -537,7 +537,7 @@ bool js::SetIntegrityLevel(JSContext* cx
     using ShapeVec = GCVector<Shape*, 8>;
     Rooted<ShapeVec> shapes(cx, ShapeVec(cx));
     for (Shape::Range<NoGC> r(nobj->lastProperty()); !r.empty(); r.popFront()) {
-      if (!shapes.append(&r.front())) {
+      if (!shapes.append(&r.front())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -559,7 +559,7 @@ bool js::SetIntegrityLevel(JSContext* cx
       child.setObjectFlags(flags);
 
       last = cx->zone()->propertyTree().getChild(cx, last, child);
-      if (!last) {
+      if (!last) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -576,7 +576,7 @@ bool js::SetIntegrityLevel(JSContext* cx
     // Steps 6-7.
     RootedIdVector keys(cx);
     if (!GetPropertyKeys(
-            cx, obj, JSITER_HIDDEN | JSITER_OWNONLY | JSITER_SYMBOLS, &keys)) {
+            cx, obj, JSITER_HIDDEN | JSITER_OWNONLY | JSITER_SYMBOLS, &keys)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -598,12 +598,12 @@ bool js::SetIntegrityLevel(JSContext* cx
       } else {
         // 9.a.i-ii.
         Rooted<Maybe<PropertyDescriptor>> currentDesc(cx);
-        if (!GetOwnPropertyDescriptor(cx, obj, id, &currentDesc)) {
+        if (!GetOwnPropertyDescriptor(cx, obj, id, &currentDesc)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         // 9.a.iii.
-        if (currentDesc.isNothing()) {
+        if (currentDesc.isNothing()) {MOZ_RELEASE_ASSERT(0);
           continue;
         }
 
@@ -636,14 +636,14 @@ bool js::SetIntegrityLevel(JSContext* cx
 static bool ResolveLazyProperties(JSContext* cx, HandleNativeObject obj) {
   const JSClass* clasp = obj->getClass();
   if (JSEnumerateOp enumerate = clasp->getEnumerate()) {
-    if (!enumerate(cx, obj)) {
+    if (!enumerate(cx, obj)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
   if (clasp->getNewEnumerate() && clasp->getResolve()) {
     RootedIdVector properties(cx);
     if (!clasp->getNewEnumerate()(cx, obj, &properties,
-                                  /* enumerableOnly = */ false)) {
+                                  /* enumerableOnly = */ false)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -677,7 +677,7 @@ bool js::TestIntegrityLevel(JSContext* c
     HandleNativeObject nobj = obj.as<NativeObject>();
 
     // Force lazy properties to be resolved.
-    if (!ResolveLazyProperties(cx, nobj)) {
+    if (!ResolveLazyProperties(cx, nobj)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -727,7 +727,7 @@ bool js::TestIntegrityLevel(JSContext* c
     // Steps 7-8.
     RootedIdVector props(cx);
     if (!GetPropertyKeys(
-            cx, obj, JSITER_HIDDEN | JSITER_OWNONLY | JSITER_SYMBOLS, &props)) {
+            cx, obj, JSITER_HIDDEN | JSITER_OWNONLY | JSITER_SYMBOLS, &props)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -738,12 +738,12 @@ bool js::TestIntegrityLevel(JSContext* c
       id = props[i];
 
       // Steps 9.a-b.
-      if (!GetOwnPropertyDescriptor(cx, obj, id, &desc)) {
+      if (!GetOwnPropertyDescriptor(cx, obj, id, &desc)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       // Step 9.c.
-      if (desc.isNothing()) {
+      if (desc.isNothing()) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
 
@@ -904,7 +904,7 @@ JSObject* js::NewObjectWithClassProto(JS
   }
 
   JSObject* proto = GlobalObject::getOrCreatePrototype(cx, protoKey);
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -962,7 +962,7 @@ bool js::GetPrototypeFromConstructor(JSC
     // Steps 4.a-b fetch the builtin prototype of the current realm, which we
     // represent as nullptr.
     proto.set(nullptr);
-  } else if (intrinsicDefaultProto == JSProto_Null) {
+  } else if (intrinsicDefaultProto == JSProto_Null) {MOZ_RELEASE_ASSERT(0);
     // Bug 1317416. The caller did not pass a reasonable JSProtoKey, so let the
     // caller select a prototype object. Most likely they will choose one from
     // the wrong realm.
@@ -983,7 +983,7 @@ bool js::GetPrototypeFromConstructor(JSC
       }
       proto.set(GlobalObject::getOrCreatePrototype(cx, intrinsicDefaultProto));
     }
-    if (!proto) {
+    if (!proto) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!cx->compartment()->wrap(cx, proto)) {
@@ -1005,7 +1005,7 @@ bool JSObject::nonNativeSetProperty(JSCo
 bool JSObject::nonNativeSetElement(JSContext* cx, HandleObject obj,
                                    uint32_t index, HandleValue v,
                                    HandleValue receiver,
-                                   ObjectOpResult& result) {
+                                   ObjectOpResult& result) {MOZ_RELEASE_ASSERT(0);
   RootedId id(cx);
   if (!IndexToId(cx, index, &id)) {
     return false;
@@ -1023,7 +1023,7 @@ static bool CopyPropertyFrom(JSContext* 
   cx->check(obj, id);
   Rooted<PropertyDescriptor> desc(cx);
 
-  if (!GetOwnPropertyDescriptor(cx, obj, id, &desc)) {
+  if (!GetOwnPropertyDescriptor(cx, obj, id, &desc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(desc.object());
@@ -1052,7 +1052,7 @@ JS_FRIEND_API bool JS_CopyOwnPropertiesA
   if (!GetPropertyKeys(
           cx, obj,
           JSITER_PRIVATE | JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS,
-          &props)) {
+          &props)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1070,7 +1070,7 @@ static bool GetScriptArrayObjectElements
   MOZ_ASSERT(!arr->isIndexed());
 
   size_t length = arr->length();
-  if (!values.appendN(MagicValue(JS_ELEMENTS_HOLE), length)) {
+  if (!values.appendN(MagicValue(JS_ELEMENTS_HOLE), length)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1087,7 +1087,7 @@ static bool GetScriptPlainObjectProperti
   MOZ_ASSERT(obj->is<PlainObject>());
   PlainObject* nobj = &obj->as<PlainObject>();
 
-  if (!properties.appendN(IdValuePair(), nobj->slotSpan())) {
+  if (!properties.appendN(IdValuePair(), nobj->slotSpan())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1111,12 +1111,12 @@ static bool GetScriptPlainObjectProperti
 }
 
 static bool DeepCloneValue(JSContext* cx, Value* vp) {
-  if (vp->isObject()) {
+  if (vp->isObject()) {MOZ_RELEASE_ASSERT(0);
     RootedObject obj(cx, &vp->toObject());
     obj = DeepCloneObjectLiteral(cx, obj);
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     vp->setObject(*obj);
   } else {
     cx->markAtomValue(*vp);
@@ -1130,13 +1130,13 @@ JSObject* js::DeepCloneObjectLiteral(JSC
 
   if (obj->is<ArrayObject>()) {
     Rooted<GCVector<Value>> values(cx, GCVector<Value>(cx));
-    if (!GetScriptArrayObjectElements(obj.as<ArrayObject>(), &values)) {
+    if (!GetScriptArrayObjectElements(obj.as<ArrayObject>(), &values)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     // Deep clone any elements.
     for (uint32_t i = 0; i < values.length(); ++i) {
-      if (!DeepCloneValue(cx, values[i].address())) {
+      if (!DeepCloneValue(cx, values[i].address())) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -1146,7 +1146,7 @@ JSObject* js::DeepCloneObjectLiteral(JSC
   }
 
   Rooted<IdValueVector> properties(cx, IdValueVector(cx));
-  if (!GetScriptPlainObjectProperties(obj, &properties)) {
+  if (!GetScriptPlainObjectProperties(obj, &properties)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1168,12 +1168,12 @@ static bool InitializePropertiesFromComp
   MOZ_ASSERT(dst->lastProperty()->objectFlags().isEmpty());
   MOZ_ASSERT(src->numFixedSlots() == dst->numFixedSlots());
 
-  if (!dst->ensureElements(cx, src->getDenseInitializedLength())) {
+  if (!dst->ensureElements(cx, src->getDenseInitializedLength())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   uint32_t initialized = src->getDenseInitializedLength();
-  for (uint32_t i = 0; i < initialized; ++i) {
+  for (uint32_t i = 0; i < initialized; ++i) {MOZ_RELEASE_ASSERT(0);
     dst->setDenseInitializedLength(i + 1);
     dst->initDenseElement(i, src->getDenseElement(i));
   }
@@ -1189,7 +1189,7 @@ static bool InitializePropertiesFromComp
     shape = EmptyShape::getInitialShape(cx, dst->getClass(), dst->realm(),
                                         dst->taggedProto(),
                                         dst->numFixedSlots(), ObjectFlags());
-    if (!shape) {
+    if (!shape) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1198,7 +1198,7 @@ static bool InitializePropertiesFromComp
     // Get an in-order list of the shapes in the src object.
     Rooted<ShapeVector> shapes(cx, ShapeVector(cx));
     for (Shape::Range<NoGC> r(src->lastProperty()); !r.empty(); r.popFront()) {
-      if (!shapes.append(&r.front())) {
+      if (!shapes.append(&r.front())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1213,13 +1213,13 @@ static bool InitializePropertiesFromComp
       child.setObjectFlags(flags);
 
       shape = cx->zone()->propertyTree().getChild(cx, shape, child);
-      if (!shape) {
+      if (!shape) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
   }
   size_t span = shape->slotSpan();
-  if (!dst->setLastProperty(cx, shape)) {
+  if (!dst->setLastProperty(cx, shape)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (size_t i = JSCLASS_RESERVED_SLOTS(src->getClass()); i < span; i++) {
@@ -1260,7 +1260,7 @@ XDRResult js::XDRObjectLiteral(XDRState<
     Rooted<GCVector<Value>> values(cx, GCVector<Value>(cx));
     if (mode == XDR_ENCODE) {
       RootedArrayObject arr(cx, &obj->as<ArrayObject>());
-      if (!GetScriptArrayObjectElements(arr, &values)) {
+      if (!GetScriptArrayObjectElements(arr, &values)) {MOZ_RELEASE_ASSERT(0);
         return xdr->fail(JS::TranscodeResult::Throw);
       }
     }
@@ -1271,7 +1271,7 @@ XDRResult js::XDRObjectLiteral(XDRState<
     }
     MOZ_TRY(xdr->codeUint32(&initialized));
     if (mode == XDR_DECODE &&
-        !values.appendN(MagicValue(JS_ELEMENTS_HOLE), initialized)) {
+        !values.appendN(MagicValue(JS_ELEMENTS_HOLE), initialized)) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Throw);
     }
 
@@ -1283,7 +1283,7 @@ XDRResult js::XDRObjectLiteral(XDRState<
     if (mode == XDR_DECODE) {
       obj.set(NewDenseCopiedArray(cx, values.length(), values.begin(),
                                   /* proto = */ nullptr, TenuredObject));
-      if (!obj) {
+      if (!obj) {MOZ_RELEASE_ASSERT(0);
         return xdr->fail(JS::TranscodeResult::Throw);
       }
     }
@@ -1293,14 +1293,14 @@ XDRResult js::XDRObjectLiteral(XDRState<
 
   // Code the properties in the object.
   Rooted<IdValueVector> properties(cx, IdValueVector(cx));
-  if (mode == XDR_ENCODE && !GetScriptPlainObjectProperties(obj, &properties)) {
+  if (mode == XDR_ENCODE && !GetScriptPlainObjectProperties(obj, &properties)) {MOZ_RELEASE_ASSERT(0);
     return xdr->fail(JS::TranscodeResult::Throw);
   }
 
   uint32_t nproperties = properties.length();
   MOZ_TRY(xdr->codeUint32(&nproperties));
 
-  if (mode == XDR_DECODE && !properties.appendN(IdValuePair(), nproperties)) {
+  if (mode == XDR_DECODE && !properties.appendN(IdValuePair(), nproperties)) {MOZ_RELEASE_ASSERT(0);
     return xdr->fail(JS::TranscodeResult::Throw);
   }
 
@@ -1314,7 +1314,7 @@ XDRResult js::XDRObjectLiteral(XDRState<
     MOZ_TRY(XDRScriptConst(xdr, &tmpValue));
 
     if (mode == XDR_DECODE) {
-      if (!PrimitiveValueToId<CanGC>(cx, tmpIdValue, &tmpId)) {
+      if (!PrimitiveValueToId<CanGC>(cx, tmpIdValue, &tmpId)) {MOZ_RELEASE_ASSERT(0);
         return xdr->fail(JS::TranscodeResult::Throw);
       }
       properties[i].get().id = tmpId;
@@ -1353,13 +1353,13 @@ bool NativeObject::fillInAfterSwap(JSCon
   size_t nfixed =
       gc::GetGCKindSlots(obj->asTenured().getAllocKind(), obj->getClass());
   if (nfixed != obj->shape()->numFixedSlots()) {
-    if (!NativeObject::generateOwnShape(cx, obj)) {
+    if (!NativeObject::generateOwnShape(cx, obj)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     obj->shape()->setNumFixedSlots(nfixed);
   }
 
-  if (obj->hasPrivate()) {
+  if (obj->hasPrivate()) {MOZ_RELEASE_ASSERT(0);
     obj->setPrivate(priv);
   } else {
     MOZ_ASSERT(!priv);
@@ -1382,7 +1382,7 @@ bool NativeObject::fillInAfterSwap(JSCon
   size_t currentSlots = obj->getSlotsHeader()->capacity();
   MOZ_ASSERT(ndynamic >= currentSlots);
   if (ndynamic > currentSlots) {
-    if (!obj->growSlots(cx, currentSlots, ndynamic)) {
+    if (!obj->growSlots(cx, currentSlots, ndynamic)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1429,7 +1429,7 @@ bool js::ObjectMayBeSwapped(const JSObje
   gc::StoreBuffer& sb = cx->runtime()->gc.storeBuffer();
 
   // Reserve space for the expando, private slot and the reserved slots.
-  if (!values.reserve(2 + proxy->numReservedSlots())) {
+  if (!values.reserve(2 + proxy->numReservedSlots())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1461,7 +1461,7 @@ bool ProxyObject::initExternalValueArray
 
   auto* valArray = reinterpret_cast<js::detail::ProxyValueArray*>(
       cx->zone()->pod_malloc<uint8_t>(nbytes));
-  if (!valArray) {
+  if (!valArray) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1586,7 +1586,7 @@ void JSObject::swap(JSContext* cx, Handl
     if (na) {
       apriv = na->hasPrivate() ? na->getPrivate() : nullptr;
       for (size_t i = 0; i < na->slotSpan(); i++) {
-        if (!avals.append(na->getSlot(i))) {
+        if (!avals.append(na->getSlot(i))) {MOZ_RELEASE_ASSERT(0);
           oomUnsafe.crash("JSObject::swap");
         }
       }
@@ -1596,7 +1596,7 @@ void JSObject::swap(JSContext* cx, Handl
     if (nb) {
       bpriv = nb->hasPrivate() ? nb->getPrivate() : nullptr;
       for (size_t i = 0; i < nb->slotSpan(); i++) {
-        if (!bvals.append(nb->getSlot(i))) {
+        if (!bvals.append(nb->getSlot(i))) {MOZ_RELEASE_ASSERT(0);
           oomUnsafe.crash("JSObject::swap");
         }
       }
@@ -1609,12 +1609,12 @@ void JSObject::swap(JSContext* cx, Handl
         b->is<ProxyObject>() ? &b->as<ProxyObject>() : nullptr;
 
     if (aIsProxyWithInlineValues) {
-      if (!CopyProxyValuesBeforeSwap(cx, proxyA, &avals)) {
+      if (!CopyProxyValuesBeforeSwap(cx, proxyA, &avals)) {MOZ_RELEASE_ASSERT(0);
         oomUnsafe.crash("CopyProxyValuesBeforeSwap");
       }
     }
     if (bIsProxyWithInlineValues) {
-      if (!CopyProxyValuesBeforeSwap(cx, proxyB, &bvals)) {
+      if (!CopyProxyValuesBeforeSwap(cx, proxyB, &bvals)) {MOZ_RELEASE_ASSERT(0);
         oomUnsafe.crash("CopyProxyValuesBeforeSwap");
       }
     }
@@ -1631,23 +1631,23 @@ void JSObject::swap(JSContext* cx, Handl
 
     if (na) {
       if (!NativeObject::fillInAfterSwap(cx, b.as<NativeObject>(), na, avals,
-                                         apriv)) {
+                                         apriv)) {MOZ_RELEASE_ASSERT(0);
         oomUnsafe.crash("fillInAfterSwap");
       }
     }
     if (nb) {
       if (!NativeObject::fillInAfterSwap(cx, a.as<NativeObject>(), nb, bvals,
-                                         bpriv)) {
+                                         bpriv)) {MOZ_RELEASE_ASSERT(0);
         oomUnsafe.crash("fillInAfterSwap");
       }
     }
     if (aIsProxyWithInlineValues) {
-      if (!b->as<ProxyObject>().initExternalValueArrayAfterSwap(cx, avals)) {
+      if (!b->as<ProxyObject>().initExternalValueArrayAfterSwap(cx, avals)) {MOZ_RELEASE_ASSERT(0);
         oomUnsafe.crash("initExternalValueArray");
       }
     }
     if (bIsProxyWithInlineValues) {
-      if (!a->as<ProxyObject>().initExternalValueArrayAfterSwap(cx, bvals)) {
+      if (!a->as<ProxyObject>().initExternalValueArrayAfterSwap(cx, bvals)) {MOZ_RELEASE_ASSERT(0);
         oomUnsafe.crash("initExternalValueArray");
       }
     }
@@ -1680,7 +1680,7 @@ static NativeObject* DefineConstructorAn
   // Create the prototype object.
   RootedNativeObject proto(
       cx, GlobalObject::createBlankPrototypeInheriting(cx, clasp, protoProto));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1689,24 +1689,24 @@ static NativeObject* DefineConstructorAn
     ctor = proto;
   } else {
     ctor = NewNativeConstructor(cx, constructor, nargs, atom);
-    if (!ctor) {
+    if (!ctor) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (!LinkConstructorAndPrototype(cx, ctor, proto)) {
+    if (!LinkConstructorAndPrototype(cx, ctor, proto)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
 
   if (!DefinePropertiesAndFunctions(cx, proto, ps, fs) ||
       (ctor != proto &&
-       !DefinePropertiesAndFunctions(cx, ctor, static_ps, static_fs))) {
+       !DefinePropertiesAndFunctions(cx, ctor, static_ps, static_fs))) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedId id(cx, AtomToId(atom));
   RootedValue value(cx, ObjectValue(*ctor));
-  if (!DefineDataProperty(cx, obj, id, value, 0)) {
+  if (!DefineDataProperty(cx, obj, id, value, 0)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1724,7 +1724,7 @@ NativeObject* js::InitClass(JSContext* c
                             const JSFunctionSpec* static_fs,
                             NativeObject** ctorp) {
   RootedAtom atom(cx, Atomize(cx, clasp->name, strlen(clasp->name)));
-  if (!atom) {
+  if (!atom) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1799,7 +1799,7 @@ static bool SetProto(JSContext* cx, Hand
                      Handle<js::TaggedProto> proto) {
   // Update prototype shapes if needed to invalidate JIT code that is affected
   // by a prototype mutation.
-  if (!ReshapeForProtoMutation(cx, obj)) {
+  if (!ReshapeForProtoMutation(cx, obj)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1840,7 +1840,7 @@ bool js::GetObjectFromIncumbentGlobal(JS
   {
     AutoRealm ar(cx, globalObj);
     obj.set(GlobalObject::getOrCreateObjectPrototype(cx, globalObj));
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1970,7 +1970,7 @@ bool js::LookupNameWithGlobalDefault(JSC
 
   RootedObject env(cx, envChain);
   for (; !env->is<GlobalObject>(); env = env->enclosingEnvironment()) {
-    if (!LookupProperty(cx, env, id, &pobj, &prop)) {
+    if (!LookupProperty(cx, env, id, &pobj, &prop)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (prop.isFound()) {
@@ -1992,7 +1992,7 @@ bool js::LookupNameUnqualified(JSContext
 
   RootedObject env(cx, envChain);
   for (; !env->isUnqualifiedVarObj(); env = env->enclosingEnvironment()) {
-    if (!LookupProperty(cx, env, id, &pobj, &prop)) {
+    if (!LookupProperty(cx, env, id, &pobj, &prop)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (prop.isFound()) {
@@ -2012,7 +2012,7 @@ bool js::LookupNameUnqualified(JSContext
         Rooted<DebugEnvironmentProxy*> envProxy(
             cx, &env->as<DebugEnvironmentProxy>());
         if (!DebugEnvironmentProxy::getMaybeSentinelValue(cx, envProxy, id,
-                                                          &v)) {
+                                                          &v)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         isTDZ = IsUninitializedLexical(v);
@@ -2024,7 +2024,7 @@ bool js::LookupNameUnqualified(JSContext
     if (isTDZ) {
       env = RuntimeLexicalErrorObject::create(cx, env,
                                               JSMSG_UNINITIALIZED_LEXICAL);
-      if (!env) {
+      if (!env) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (env->is<LexicalEnvironmentObject>() &&
@@ -2053,11 +2053,11 @@ bool js::HasOwnProperty(JSContext* cx, H
     return Proxy::hasOwn(cx, obj, id, result);
   }
 
-  if (GetOwnPropertyOp op = obj->getOpsGetOwnPropertyDescriptor()) {
+  if (GetOwnPropertyOp op = obj->getOpsGetOwnPropertyDescriptor()) {MOZ_RELEASE_ASSERT(0);
     Rooted<PropertyDescriptor> desc(cx);
-    if (!op(cx, obj, id, &desc)) {
+    if (!op(cx, obj, id, &desc)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     *result = !!desc.object();
     return true;
   }
@@ -2096,7 +2096,7 @@ static inline bool NativeGetPureInline(N
     *vp = pobj->getDenseElement(prop.denseElementIndex());
     return true;
   }
-  if (prop.isTypedArrayElement()) {
+  if (prop.isTypedArrayElement()) {MOZ_RELEASE_ASSERT(0);
     size_t idx = prop.typedArrayElementIndex();
     return pobj->as<TypedArrayObject>().getElement<NoGC>(cx, idx, vp);
   }
@@ -2167,7 +2167,7 @@ bool js::GetGetterPure(JSContext* cx, JS
    * it. */
   NativeObject* pobj;
   PropertyResult prop;
-  if (!LookupPropertyPure(cx, obj, id, &pobj, &prop)) {
+  if (!LookupPropertyPure(cx, obj, id, &pobj, &prop)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2183,7 +2183,7 @@ bool js::GetOwnGetterPure(JSContext* cx,
                           JSFunction** fp) {
   JS::AutoCheckCannotGC nogc;
   PropertyResult prop;
-  if (!LookupOwnPropertyPure(cx, obj, id, &prop)) {
+  if (!LookupOwnPropertyPure(cx, obj, id, &prop)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2201,21 +2201,21 @@ bool js::GetOwnNativeGetterPure(JSContex
   JS::AutoCheckCannotGC nogc;
   *native = nullptr;
   PropertyResult prop;
-  if (!LookupOwnPropertyPure(cx, obj, id, &prop)) {
+  if (!LookupOwnPropertyPure(cx, obj, id, &prop)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!prop.isNativeProperty()) {
+  if (!prop.isNativeProperty()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   NativeObject* nobj = &obj->as<NativeObject>();
-  if (!nobj->hasGetter(prop.shape())) {
+  if (!nobj->hasGetter(prop.shape())) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   JSObject* getterObj = nobj->getGetter(prop.shape());
-  if (!getterObj->is<JSFunction>()) {
+  if (!getterObj->is<JSFunction>()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -2278,7 +2278,7 @@ bool js::SetPrototype(JSContext* cx, Han
   /*
    * Disallow mutating the [[Prototype]] on Typed Objects, per the spec.
    */
-  if (obj->is<TypedObject>()) {
+  if (obj->is<TypedObject>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_CANT_SET_PROTO_OF,
                               "incompatible TypedObject");
@@ -2287,7 +2287,7 @@ bool js::SetPrototype(JSContext* cx, Han
 
   /* ES6 9.1.2 step 5 forbids changing [[Prototype]] if not [[Extensible]]. */
   bool extensible;
-  if (!IsExtensible(cx, obj, &extensible)) {
+  if (!IsExtensible(cx, obj, &extensible)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!extensible) {
@@ -2308,7 +2308,7 @@ bool js::SetPrototype(JSContext* cx, Han
     }
 
     bool isOrdinary;
-    if (!GetPrototypeIfOrdinary(cx, obj2, &isOrdinary, &obj2)) {
+    if (!GetPrototypeIfOrdinary(cx, obj2, &isOrdinary, &obj2)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!isOrdinary) {
@@ -2349,7 +2349,7 @@ bool js::PreventExtensions(JSContext* cx
   if (obj->is<NativeObject>()) {
     // Force lazy properties to be resolved.
     HandleNativeObject nobj = obj.as<NativeObject>();
-    if (!ResolveLazyProperties(cx, nobj)) {
+    if (!ResolveLazyProperties(cx, nobj)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2360,7 +2360,7 @@ bool js::PreventExtensions(JSContext* cx
 
   // Finally, set the NotExtensible flag on the Shape and ObjectElements.
   if (!JSObject::setFlag(cx, obj, ObjectFlag::NotExtensible,
-                         JSObject::GENERATE_SHAPE)) {
+                         JSObject::GENERATE_SHAPE)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (obj->is<NativeObject>()) {
@@ -2509,7 +2509,7 @@ bool js::SetImmutablePrototype(JSContext
   // having an immutable prototype.
   if (obj->is<GlobalObject>()) {
     Handle<GlobalObject*> global = obj.as<GlobalObject>();
-    if (!GlobalObject::ensureConstructor(cx, global, JSProto_Object)) {
+    if (!GlobalObject::ensureConstructor(cx, global, JSProto_Object)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2574,7 +2574,7 @@ static bool DefineFunctionFromSpec(JSCon
                                    const JSFunctionSpec* fs, unsigned flags,
                                    DefineAsIntrinsic intrinsic) {
   RootedId id(cx);
-  if (!PropertySpecNameToId(cx, fs->name, &id)) {
+  if (!PropertySpecNameToId(cx, fs->name, &id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2583,7 +2583,7 @@ static bool DefineFunctionFromSpec(JSCon
   }
 
   JSFunction* fun = NewFunctionFromSpec(cx, fs, id);
-  if (!fun) {
+  if (!fun) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2637,7 +2637,7 @@ static bool ReportCantConvert(JSContext*
   RootedString str(cx);
   if (hint == JSTYPE_STRING) {
     str = JS_AtomizeAndPinString(cx, clasp->name);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -2929,7 +2929,7 @@ JSObject* js::ToObjectSlowForPropertyAcc
   if (val.isNullOrUndefined()) {
     RootedId key(cx);
     if (keyValue.isPrimitive()) {
-      if (!PrimitiveValueToId<CanGC>(cx, keyValue, &key)) {
+      if (!PrimitiveValueToId<CanGC>(cx, keyValue, &key)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       ReportIsNullOrUndefinedForPropertyAccess(cx, val, valIndex, key);
@@ -2988,7 +2988,7 @@ void GetObjectSlotNameFunctor::operator(
                      shape->slot() != slot)) {
       shape = shape->previous();
     }
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     shape = nullptr;
   }
 
@@ -3609,7 +3609,7 @@ void JSObject::addSizeOfExcludingThis(mo
         as<PropertyIteratorObject>().sizeOfMisc(mallocSizeOf);
   } else if (is<ArrayBufferObject>()) {
     ArrayBufferObject::addSizeOfExcludingThis(this, mallocSizeOf, info);
-  } else if (is<SharedArrayBufferObject>()) {
+  } else if (is<SharedArrayBufferObject>()) {MOZ_RELEASE_ASSERT(0);
     SharedArrayBufferObject::addSizeOfExcludingThis(this, mallocSizeOf, info);
   } else if (is<WeakCollectionObject>()) {
     info->objectsMallocHeapMisc +=
diff --git a/js/src/vm/JSScript.cpp b/js/src/vm/JSScript.cpp
--- a/js/src/vm/JSScript.cpp
+++ b/js/src/vm/JSScript.cpp
@@ -128,21 +128,21 @@ XDRResult js::XDRScriptConst(XDRState<mo
   if (mode == XDR_ENCODE) {
     if (vp.isInt32()) {
       tag = SCRIPT_INT;
-    } else if (vp.isDouble()) {
+    } else if (vp.isDouble()) {MOZ_RELEASE_ASSERT(0);
       tag = SCRIPT_DOUBLE;
     } else if (vp.isString()) {
       tag = SCRIPT_ATOM;
-    } else if (vp.isTrue()) {
+    } else if (vp.isTrue()) {MOZ_RELEASE_ASSERT(0);
       tag = SCRIPT_TRUE;
-    } else if (vp.isFalse()) {
+    } else if (vp.isFalse()) {MOZ_RELEASE_ASSERT(0);
       tag = SCRIPT_FALSE;
-    } else if (vp.isNull()) {
+    } else if (vp.isNull()) {MOZ_RELEASE_ASSERT(0);
       tag = SCRIPT_NULL;
-    } else if (vp.isObject()) {
+    } else if (vp.isObject()) {MOZ_RELEASE_ASSERT(0);
       tag = SCRIPT_OBJECT;
-    } else if (vp.isMagic(JS_ELEMENTS_HOLE)) {
+    } else if (vp.isMagic(JS_ELEMENTS_HOLE)) {MOZ_RELEASE_ASSERT(0);
       tag = SCRIPT_HOLE;
-    } else if (vp.isBigInt()) {
+    } else if (vp.isBigInt()) {MOZ_RELEASE_ASSERT(0);
       tag = SCRIPT_BIGINT;
     } else {
       MOZ_ASSERT(vp.isUndefined());
@@ -256,29 +256,29 @@ template <XDRMode mode>
 /* static */
 XDRResult BaseScript::XDRLazyScriptData(XDRState<mode>* xdr,
                                         HandleScriptSourceObject sourceObject,
-                                        Handle<BaseScript*> lazy) {
+                                        Handle<BaseScript*> lazy) {MOZ_RELEASE_ASSERT(0);
   JSContext* cx = xdr->cx();
 
   RootedAtom atom(cx);
   RootedFunction func(cx);
 
-  if (lazy->useMemberInitializers()) {
+  if (lazy->useMemberInitializers()) {MOZ_RELEASE_ASSERT(0);
     uint32_t numMemberInitializers;
-    if (mode == XDR_ENCODE) {
+    if (mode == XDR_ENCODE) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(lazy->getMemberInitializers().valid);
       numMemberInitializers =
           lazy->getMemberInitializers().numMemberInitializers;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     MOZ_TRY(xdr->codeUint32(&numMemberInitializers));
-    if (mode == XDR_DECODE) {
+    if (mode == XDR_DECODE) {MOZ_RELEASE_ASSERT(0);
       lazy->setMemberInitializers(MemberInitializers(numMemberInitializers));
-    }
-  }
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
 
   mozilla::Span<JS::GCCellPtr> gcThings =
       lazy->data_ ? lazy->data_->gcthings() : mozilla::Span<JS::GCCellPtr>();
 
-  for (JS::GCCellPtr& elem : gcThings) {
+  for (JS::GCCellPtr& elem : gcThings) {MOZ_RELEASE_ASSERT(0);
     JS::TraceKind kind = elem.kind();
 
     MOZ_TRY(xdr->codeEnum32(&kind));
@@ -358,7 +358,7 @@ static XDRResult XDRInnerObject(XDRState
       classk = ClassKind::JSObject;
     } else if (inner->is<ArrayObject>()) {
       classk = ClassKind::ArrayObject;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       MOZ_CRASH("Cannot encode this class of object.");
     }
   }
@@ -639,7 +639,7 @@ void js::BaseScript::finalize(JSFreeOp* 
   fop->runtime()->geckoProfiler().onScriptFinalized(this);
 
 #ifdef MOZ_VTUNE
-  if (zone()->scriptVTuneIdMap) {
+  if (zone()->scriptVTuneIdMap) {MOZ_RELEASE_ASSERT(0);
     // Note: we should only get here if the VTune JIT profiler is running.
     zone()->scriptVTuneIdMap->remove(this);
   }
@@ -727,7 +727,7 @@ size_t JSScript::numAlwaysLiveFixedSlots
   return 0;
 }
 
-unsigned JSScript::numArgs() const {
+unsigned JSScript::numArgs() const {MOZ_RELEASE_ASSERT(0);
   if (bodyScope()->is<js::FunctionScope>()) {
     return bodyScope()->as<js::FunctionScope>().numPositionalFormalParameters();
   }
@@ -808,7 +808,7 @@ XDRResult js::PrivateScriptData::XDR(XDR
   MOZ_TRY(xdr->codeUint32(&ngcthings));
 
   if (mode == XDR_DECODE) {
-    if (!JSScript::createPrivateScriptData(cx, script, ngcthings)) {
+    if (!JSScript::createPrivateScriptData(cx, script, ngcthings)) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Throw);
     }
 
@@ -971,7 +971,7 @@ XDRResult js::XDRImmutableScriptData(XDR
                "Decode below relies on the data placement");
   } else {
     isd = ImmutableScriptData::new_(xdr->cx(), size);
-    if (!isd) {
+    if (!isd) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Throw);
     }
     data = reinterpret_cast<uint8_t*>(isd.get());
@@ -1090,7 +1090,7 @@ XDRResult js::XDRScript(XDRState<mode>* 
   // compile scripts via the bytecode emitter, which will insert these
   // instructions.
   if (xdr->hasOptions() ? !!xdr->options().instrumentationKinds
-                        : !!cx->global()->getInstrumentationHolder()) {
+                        : !!cx->global()->getInstrumentationHolder()) {MOZ_RELEASE_ASSERT(0);
     return xdr->fail(JS::TranscodeResult::Failure);
   }
 
@@ -1103,7 +1103,7 @@ XDRResult js::XDRScript(XDRState<mode>* 
       xdrFlags |= OwnSource;
     }
     // Preserve the MutableFlags::AllowRelazify flag.
-    if (script->allowRelazify()) {
+    if (script->allowRelazify()) {MOZ_RELEASE_ASSERT(0);
       xdrFlags |= HasLazyScript;
     }
   }
@@ -1137,7 +1137,7 @@ XDRResult js::XDRScript(XDRState<mode>* 
       options.emplace(xdr->cx(), xdr->options());
       if (!js::CheckCompileOptionsMatch(*options,
                                         ImmutableScriptFlags(immutableFlags),
-                                        xdr->isMultiDecode())) {
+                                        xdr->isMultiDecode())) {MOZ_RELEASE_ASSERT(0);
         return xdr->fail(JS::TranscodeResult::Failure_WrongCompileOption);
       }
     }
@@ -1159,7 +1159,7 @@ XDRResult js::XDRScript(XDRState<mode>* 
 
     if (mode == XDR_DECODE) {
       sourceObject = ScriptSourceObject::create(cx, source);
-      if (!sourceObject) {
+      if (!sourceObject) {MOZ_RELEASE_ASSERT(0);
         return xdr->fail(JS::TranscodeResult::Throw);
       }
 
@@ -1186,7 +1186,7 @@ XDRResult js::XDRScript(XDRState<mode>* 
 
     script = JSScript::Create(cx, functionOrGlobal, sourceObject, extent,
                               ImmutableScriptFlags(immutableFlags));
-    if (!script) {
+    if (!script) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Throw);
     }
     scriptp.set(script);
@@ -1213,20 +1213,20 @@ XDRResult js::XDRScript(XDRState<mode>* 
   MOZ_TRY(frontend::StencilXDR::codeSharedData<mode>(xdr, script->sharedData_));
 
   if (mode == XDR_DECODE) {
-    if (!SharedImmutableScriptData::shareScriptData(cx, script->sharedData_)) {
+    if (!SharedImmutableScriptData::shareScriptData(cx, script->sharedData_)) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Throw);
     }
   }
 
   if (xdrFlags & HasLazyScript) {
-    if (mode == XDR_DECODE) {
+    if (mode == XDR_DECODE) {MOZ_RELEASE_ASSERT(0);
       script->setAllowRelazify();
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   if (mode == XDR_DECODE) {
     if (coverage::IsLCovEnabled()) {
-      if (!coverage::InitScriptCoverage(cx, script)) {
+      if (!coverage::InitScriptCoverage(cx, script)) {MOZ_RELEASE_ASSERT(0);
         return xdr->fail(JS::TranscodeResult::Throw);
       }
     }
@@ -1254,32 +1254,32 @@ template <XDRMode mode>
 XDRResult js::XDRLazyScript(XDRState<mode>* xdr, HandleScope enclosingScope,
                             HandleScriptSourceObject sourceObject,
                             HandleFunction fun,
-                            MutableHandle<BaseScript*> lazy) {
+                            MutableHandle<BaseScript*> lazy) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT_IF(mode == XDR_DECODE, sourceObject);
 
   JSContext* cx = xdr->cx();
 
-  {
+  {MOZ_RELEASE_ASSERT(0);
     SourceExtent extent;
     uint32_t immutableFlags;
     uint32_t ngcthings;
 
-    if (mode == XDR_ENCODE) {
+    if (mode == XDR_ENCODE) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(fun == lazy->function());
 
       extent = lazy->extent();
       immutableFlags = lazy->immutableFlags();
       ngcthings = lazy->gcthings().size();
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     MOZ_TRY(XDRSourceExtent(xdr, &extent));
     MOZ_TRY(xdr->codeUint32(&immutableFlags));
     MOZ_TRY(xdr->codeUint32(&ngcthings));
 
-    if (mode == XDR_DECODE) {
+    if (mode == XDR_DECODE) {MOZ_RELEASE_ASSERT(0);
       lazy.set(BaseScript::CreateRawLazy(cx, ngcthings, fun, sourceObject,
                                          extent, immutableFlags));
-      if (!lazy) {
+      if (!lazy) {MOZ_RELEASE_ASSERT(0);
         return xdr->fail(JS::TranscodeResult::Throw);
       }
 
@@ -1319,7 +1319,7 @@ bool JSScript::initScriptCounts(JSContex
   AllBytecodesIterable iterable(this);
   for (auto& loc : iterable) {
     if (loc.isJumpTarget() || loc == main) {
-      if (!jumpTargets.append(loc.toRawBytecode())) {
+      if (!jumpTargets.append(loc.toRawBytecode())) {MOZ_RELEASE_ASSERT(0);
         ReportOutOfMemory(cx);
         return false;
       }
@@ -1328,7 +1328,7 @@ bool JSScript::initScriptCounts(JSContex
 
   // Initialize all PCCounts counters to 0.
   ScriptCounts::PCCountsVector base;
-  if (!base.reserve(jumpTargets.length())) {
+  if (!base.reserve(jumpTargets.length())) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -1340,7 +1340,7 @@ bool JSScript::initScriptCounts(JSContex
   // Create zone's scriptCountsMap if necessary.
   if (!zone()->scriptCountsMap) {
     auto map = cx->make_unique<ScriptCountsMap>();
-    if (!map) {
+    if (!map) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1349,7 +1349,7 @@ bool JSScript::initScriptCounts(JSContex
 
   // Allocate the ScriptCounts.
   UniqueScriptCounts sc = cx->make_unique<ScriptCounts>(std::move(base));
-  if (!sc) {
+  if (!sc) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -1357,7 +1357,7 @@ bool JSScript::initScriptCounts(JSContex
   MOZ_ASSERT(this->hasBytecode());
 
   // Register the current ScriptCounts in the zone's map.
-  if (!zone()->scriptCountsMap->putNew(this, std::move(sc))) {
+  if (!zone()->scriptCountsMap->putNew(this, std::move(sc))) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -1412,10 +1412,10 @@ js::PCCounts* ScriptCounts::getImmediate
   PCCounts searched = PCCounts(offset);
   PCCounts* elem =
       std::lower_bound(pcCounts_.begin(), pcCounts_.end(), searched);
-  if (elem == pcCounts_.end()) {
+  if (elem == pcCounts_.end()) {MOZ_RELEASE_ASSERT(0);
     return &pcCounts_.back();
   }
-  if (elem->pcOffset() == offset) {
+  if (elem->pcOffset() == offset) {MOZ_RELEASE_ASSERT(0);
     return elem;
   }
   if (elem != pcCounts_.begin()) {
@@ -1445,7 +1445,7 @@ const js::PCCounts* ScriptCounts::getImm
     }
     return &throwCounts_.back();
   }
-  if (elem->pcOffset() == offset) {
+  if (elem->pcOffset() == offset) {MOZ_RELEASE_ASSERT(0);
     return elem;
   }
   if (elem != throwCounts_.begin()) {
@@ -1491,7 +1491,7 @@ js::PCCounts* JSScript::getThrowCounts(j
 
 uint64_t JSScript::getHitCount(jsbytecode* pc) {
   MOZ_ASSERT(containsPC(pc));
-  if (pc < main()) {
+  if (pc < main()) {MOZ_RELEASE_ASSERT(0);
     pc = main();
   }
 
@@ -1499,10 +1499,10 @@ uint64_t JSScript::getHitCount(jsbytecod
   size_t targetOffset = pcToOffset(pc);
   const js::PCCounts* baseCount =
       sc.getImmediatePrecedingPCCounts(targetOffset);
-  if (!baseCount) {
+  if (!baseCount) {MOZ_RELEASE_ASSERT(0);
     return 0;
   }
-  if (baseCount->pcOffset() == targetOffset) {
+  if (baseCount->pcOffset() == targetOffset) {MOZ_RELEASE_ASSERT(0);
     return baseCount->numExec();
   }
   MOZ_ASSERT(baseCount->pcOffset() < targetOffset);
@@ -1599,7 +1599,7 @@ ScriptSourceObject* ScriptSourceObject::
                                                        HandleObject canonical) {
   ScriptSourceObject* obj =
       NewObjectWithGivenProto<ScriptSourceObject>(cx, nullptr);
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1693,7 +1693,7 @@ bool ScriptSourceObject::initFromOptions
   }
 
   RootedString elementAttributeName(cx, options.elementAttributeName());
-  if (!initElementProperties(cx, source, elementAttributeName)) {
+  if (!initElementProperties(cx, source, elementAttributeName)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1793,7 +1793,7 @@ class ScriptSource::LoadSourceMatcher {
 
   template <typename Unit>
   bool operator()(const Retrievable<Unit>&) {
-    if (!cx_->runtime()->sourceHook.ref()) {
+    if (!cx_->runtime()->sourceHook.ref()) {MOZ_RELEASE_ASSERT(0);
       *loaded_ = false;
       return true;
     }
@@ -1817,11 +1817,11 @@ class ScriptSource::LoadSourceMatcher {
   bool tryLoadAndSetSource(const Utf8Unit&, size_t* length) const {
     char* utf8Source;
     if (!cx_->runtime()->sourceHook->load(cx_, ss_->filename(), nullptr,
-                                          &utf8Source, length)) {
+                                          &utf8Source, length)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!utf8Source) {
+    if (!utf8Source) {MOZ_RELEASE_ASSERT(0);
       *loaded_ = false;
       return true;
     }
@@ -1843,7 +1843,7 @@ class ScriptSource::LoadSourceMatcher {
       return false;
     }
 
-    if (!utf16Source) {
+    if (!utf16Source) {MOZ_RELEASE_ASSERT(0);
       *loaded_ = false;
       return true;
     }
@@ -1912,7 +1912,7 @@ bool UncompressedSourceCache::put(const 
 
   if (!map_) {
     map_ = MakeUnique<Map>();
-    if (!map_) {
+    if (!map_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1943,7 +1943,7 @@ void UncompressedSourceCache::purge() {
 size_t UncompressedSourceCache::sizeOfExcludingThis(
     mozilla::MallocSizeOf mallocSizeOf) {
   size_t n = 0;
-  if (map_ && !map_->empty()) {
+  if (map_ && !map_->empty()) {MOZ_RELEASE_ASSERT(0);
     n += map_->shallowSizeOfIncludingThis(mallocSizeOf);
     for (Map::Range r = map_->all(); !r.empty(); r.popFront()) {
       n += mallocSizeOf(r.front().value().get());
@@ -1970,7 +1970,7 @@ const Unit* ScriptSource::chunkUnits(
   MOZ_ASSERT((chunkBytes % sizeof(Unit)) == 0);
   const size_t chunkLength = chunkBytes / sizeof(Unit);
   EntryUnits<Unit> decompressed(js_pod_malloc<Unit>(chunkLength));
-  if (!decompressed) {
+  if (!decompressed) {MOZ_RELEASE_ASSERT(0);
     JS_ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -1979,7 +1979,7 @@ const Unit* ScriptSource::chunkUnits(
   // reinterpret_cast<>s accord exactly with that.
   if (!DecompressStringChunk(
           reinterpret_cast<const unsigned char*>(c.raw.chars()), chunk,
-          reinterpret_cast<unsigned char*>(decompressed.get()), chunkBytes)) {
+          reinterpret_cast<unsigned char*>(decompressed.get()), chunkBytes)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -1999,7 +1999,7 @@ void ScriptSource::convertToCompressedSo
   MOZ_ASSERT(isUncompressed<Unit>());
   MOZ_ASSERT(uncompressedData<Unit>()->length() == uncompressedLength);
 
-  if (data.is<Uncompressed<Unit, SourceRetrievable::Yes>>()) {
+  if (data.is<Uncompressed<Unit, SourceRetrievable::Yes>>()) {MOZ_RELEASE_ASSERT(0);
     data = SourceType(Compressed<Unit, SourceRetrievable::Yes>(
         std::move(compressed), uncompressedLength));
   } else {
@@ -2044,17 +2044,17 @@ const Unit* ScriptSource::units(JSContex
 
   if (isUncompressed<Unit>()) {
     const Unit* units = uncompressedData<Unit>()->units();
-    if (!units) {
+    if (!units) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     return units + begin;
   }
 
-  if (data.is<Missing>()) {
+  if (data.is<Missing>()) {MOZ_RELEASE_ASSERT(0);
     MOZ_CRASH("ScriptSource::units() on ScriptSource with missing source");
   }
 
-  if (data.is<Retrievable<Unit>>()) {
+  if (data.is<Retrievable<Unit>>()) {MOZ_RELEASE_ASSERT(0);
     MOZ_CRASH("ScriptSource::units() on ScriptSource with retrievable source");
   }
 
@@ -2080,7 +2080,7 @@ const Unit* ScriptSource::units(JSContex
   // and |holder| will hold the units alive past function return.
   if (firstChunk == lastChunk) {
     const Unit* units = chunkUnits<Unit>(cx, holder, firstChunk);
-    if (!units) {
+    if (!units) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -2090,7 +2090,7 @@ const Unit* ScriptSource::units(JSContex
   // Otherwise the units span multiple chunks.  Copy successive chunks'
   // decompressed units into freshly-allocated memory to return.
   EntryUnits<Unit> decompressed(js_pod_malloc<Unit>(len));
-  if (!decompressed) {
+  if (!decompressed) {MOZ_RELEASE_ASSERT(0);
     JS_ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -2105,7 +2105,7 @@ const Unit* ScriptSource::units(JSContex
     // holders for each chunk.
     UncompressedSourceCache::AutoHoldEntry firstHolder;
     const Unit* units = chunkUnits<Unit>(cx, firstHolder, firstChunk);
-    if (!units) {
+    if (!units) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -2116,7 +2116,7 @@ const Unit* ScriptSource::units(JSContex
   for (size_t i = firstChunk + 1; i < lastChunk; i++) {
     UncompressedSourceCache::AutoHoldEntry chunkHolder;
     const Unit* units = chunkUnits<Unit>(cx, chunkHolder, i);
-    if (!units) {
+    if (!units) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -2172,7 +2172,7 @@ JSLinearString* ScriptSource::substring(
   // UTF-8 source text.
   if (hasSourceType<Utf8Unit>()) {
     PinnedUnits<Utf8Unit> units(cx, this, holder, start, len);
-    if (!units.asChars()) {
+    if (!units.asChars()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -2194,7 +2194,7 @@ JSLinearString* ScriptSource::substringD
   MOZ_ASSERT(start <= stop);
 
   size_t len = stop - start;
-  if (!len) {
+  if (!len) {MOZ_RELEASE_ASSERT(0);
     return cx->emptyString();
   }
   UncompressedSourceCache::AutoHoldEntry holder;
@@ -2202,7 +2202,7 @@ JSLinearString* ScriptSource::substringD
   // UTF-8 source text.
   if (hasSourceType<Utf8Unit>()) {
     PinnedUnits<Utf8Unit> units(cx, this, holder, start, len);
-    if (!units.asChars()) {
+    if (!units.asChars()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -2232,10 +2232,10 @@ bool ScriptSource::appendSubstring(JSCon
 
   if (hasSourceType<Utf8Unit>()) {
     PinnedUnits<Utf8Unit> pinned(cx, this, holder, start, len);
-    if (!pinned.get()) {
+    if (!pinned.get()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (len > SourceDeflateLimit && !buf.ensureTwoByteChars()) {
+    if (len > SourceDeflateLimit && !buf.ensureTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2243,7 +2243,7 @@ bool ScriptSource::appendSubstring(JSCon
     return buf.append(units, len);
   } else {
     PinnedUnits<char16_t> pinned(cx, this, holder, start, len);
-    if (!pinned.get()) {
+    if (!pinned.get()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (len > SourceDeflateLimit && !buf.ensureTwoByteChars()) {
@@ -2272,7 +2272,7 @@ template <typename Unit>
 
   auto uniqueChars = SourceTypeTraits<Unit>::toCacheable(std::move(source));
   auto deduped = cache.getOrCreate(std::move(uniqueChars), length);
-  if (!deduped) {
+  if (!deduped) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -2486,13 +2486,13 @@ void SourceCompressionTask::workEncoding
   size_t inputBytes = source_->length() * sizeof(Unit);
   size_t firstSize = inputBytes / 2;
   UniqueChars compressed(js_pod_malloc<char>(firstSize));
-  if (!compressed) {
+  if (!compressed) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
   const Unit* chars = source_->uncompressedData<Unit>()->units();
   Compressor comp(reinterpret_cast<const unsigned char*>(chars), inputBytes);
-  if (!comp.init()) {
+  if (!comp.init()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -2535,7 +2535,7 @@ void SourceCompressionTask::workEncoding
   size_t totalBytes = comp.totalBytesNeeded();
 
   // Shrink the buffer to the size of the compressed data.
-  if (!reallocUniquePtr(compressed, totalBytes)) {
+  if (!reallocUniquePtr(compressed, totalBytes)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -2637,13 +2637,13 @@ bool js::SynchronouslyCompressSource(JSC
   // have already completed.  If that happens, there's nothing more to do.
   if (ss->hasCompressedSource()) {
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MOZ_ASSERT(ss->hasUncompressedSource(),
              "shouldn't be compressing uncompressible source");
 
   // Use an explicit scope to delineate the lifetime of |task|, for simplicity.
-  {
+  {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
     uint32_t sourceRefs = ss->refs;
 #endif
@@ -2695,7 +2695,7 @@ bool ScriptSource::startIncrementalEncod
   initial->source = nullptr;
 
   xdrEncoder_ = js::MakeUnique<XDRIncrementalStencilEncoder>();
-  if (!xdrEncoder_) {
+  if (!xdrEncoder_) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -2718,7 +2718,7 @@ bool ScriptSource::startIncrementalEncod
 }
 
 bool ScriptSource::addDelazificationToIncrementalEncoding(
-    JSContext* cx, const frontend::CompilationStencil& stencil) {
+    JSContext* cx, const frontend::CompilationStencil& stencil) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(hasEncoder());
   AutoIncrementalTimer timer(cx->realm()->timers.xdrEncodingTime);
   auto failureCase =
@@ -2905,14 +2905,14 @@ XDRResult ScriptSource::codeCompressedDa
   if (mode == XDR_DECODE) {
     // Compressed data is always single-byte chars.
     auto bytes = xdr->cx()->template make_pod_array<char>(compressedLength);
-    if (!bytes) {
+    if (!bytes) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Throw);
     }
     MOZ_TRY(xdr->codeBytes(bytes.get(), compressedLength));
 
     if (!ss->initializeWithUnretrievableCompressedSource<Unit>(
             xdr->cx(), std::move(bytes), compressedLength,
-            uncompressedLength)) {
+            uncompressedLength)) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Throw);
     }
   } else {
@@ -2982,7 +2982,7 @@ XDRResult ScriptSource::xdrData(XDRState
     // it, then switch on it (and ignore the |Variant::match| API).
     class XDRDataTag {
      public:
-      DataType operator()(const Compressed<Utf8Unit, SourceRetrievable::Yes>&) {
+      DataType operator()(const Compressed<Utf8Unit, SourceRetrievable::Yes>&) {MOZ_RELEASE_ASSERT(0);
         return DataType::CompressedUtf8Retrievable;
       }
       DataType operator()(
@@ -2996,14 +2996,14 @@ XDRResult ScriptSource::xdrData(XDRState
           const Uncompressed<Utf8Unit, SourceRetrievable::No>&) {
         return DataType::UncompressedUtf8NotRetrievable;
       }
-      DataType operator()(const Compressed<char16_t, SourceRetrievable::Yes>&) {
+      DataType operator()(const Compressed<char16_t, SourceRetrievable::Yes>&) {MOZ_RELEASE_ASSERT(0);
         return DataType::CompressedUtf16Retrievable;
       }
       DataType operator()(
           const Uncompressed<char16_t, SourceRetrievable::Yes>&) {
         return DataType::UncompressedUtf16Retrievable;
       }
-      DataType operator()(const Compressed<char16_t, SourceRetrievable::No>&) {
+      DataType operator()(const Compressed<char16_t, SourceRetrievable::No>&) {MOZ_RELEASE_ASSERT(0);
         return DataType::CompressedUtf16NotRetrievable;
       }
       DataType operator()(
@@ -3025,7 +3025,7 @@ XDRResult ScriptSource::xdrData(XDRState
     }
     MOZ_TRY(xdr->codeUint8(&type));
 
-    if (type > static_cast<uint8_t>(DataType::Missing)) {
+    if (type > static_cast<uint8_t>(DataType::Missing)) {MOZ_RELEASE_ASSERT(0);
       // Fail in debug, but only soft-fail in release, if the type is invalid.
       MOZ_ASSERT_UNREACHABLE("bad tag");
       return xdr->fail(JS::TranscodeResult::Failure_BadDecode);
@@ -3099,7 +3099,7 @@ XDRResult ScriptSource::XDR(XDRState<mod
   if (mode == XDR_DECODE) {
     // Allocate a new ScriptSource and root it with the holder.
     source = do_AddRef(cx->new_<ScriptSource>());
-    if (!source) {
+    if (!source) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Throw);
     }
 
@@ -3107,7 +3107,7 @@ XDRResult ScriptSource::XDR(XDRState<mod
     // Most CompileOptions fields aren't used by ScriptSourceObject, and those
     // that are (element; elementAttributeName) aren't preserved by XDR. So
     // this can be simple.
-    if (!source->initFromOptions(cx, *maybeOptions)) {
+    if (!source->initFromOptions(cx, *maybeOptions)) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Throw);
     }
   }
@@ -3126,7 +3126,7 @@ XDRResult ScriptSource::XDR(XDRState<mod
     MOZ_TRY(xdr->codeCharsZ(chars));
     if (mode == XDR_DECODE) {
       if (!source->setSourceMapURL(
-              cx, std::move(chars.ref<UniqueTwoByteChars>()))) {
+              cx, std::move(chars.ref<UniqueTwoByteChars>()))) {MOZ_RELEASE_ASSERT(0);
         return xdr->fail(JS::TranscodeResult::Throw);
       }
     }
@@ -3135,19 +3135,19 @@ XDRResult ScriptSource::XDR(XDRState<mod
   uint8_t haveDisplayURL = source->hasDisplayURL();
   MOZ_TRY(xdr->codeUint8(&haveDisplayURL));
 
-  if (haveDisplayURL) {
+  if (haveDisplayURL) {MOZ_RELEASE_ASSERT(0);
     XDRTranscodeString<char16_t> chars;
 
-    if (mode == XDR_ENCODE) {
+    if (mode == XDR_ENCODE) {MOZ_RELEASE_ASSERT(0);
       chars.construct<const char16_t*>(source->displayURL());
-    }
+    }MOZ_RELEASE_ASSERT(0);
     MOZ_TRY(xdr->codeCharsZ(chars));
-    if (mode == XDR_DECODE) {
+    if (mode == XDR_DECODE) {MOZ_RELEASE_ASSERT(0);
       if (!source->setDisplayURL(cx,
-                                 std::move(chars.ref<UniqueTwoByteChars>()))) {
+                                 std::move(chars.ref<UniqueTwoByteChars>()))) {MOZ_RELEASE_ASSERT(0);
         return xdr->fail(JS::TranscodeResult::Throw);
       }
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   uint8_t haveFilename = !!source->filename_;
@@ -3235,14 +3235,14 @@ bool ScriptSource::initFromOptions(JSCon
         options.filename() ? options.filename() : "<unknown>";
     UniqueChars formatted = FormatIntroducedFilename(
         cx, filename, options.introductionLineno, options.introductionType);
-    if (!formatted) {
+    if (!formatted) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!setFilename(cx, std::move(formatted))) {
+    if (!setFilename(cx, std::move(formatted))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else if (options.filename()) {
-    if (!setFilename(cx, options.filename())) {
+    if (!setFilename(cx, options.filename())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -3319,13 +3319,13 @@ bool ScriptSource::setDisplayURL(JSConte
 }
 
 bool ScriptSource::setDisplayURL(JSContext* cx, UniqueTwoByteChars&& url) {
-  if (hasDisplayURL()) {
+  if (hasDisplayURL()) {MOZ_RELEASE_ASSERT(0);
     // FIXME: filename() should be UTF-8 (bug 987069).
     if (!cx->isHelperThreadContext() &&
         !WarnNumberLatin1(cx, JSMSG_ALREADY_HAS_PRAGMA, filename(),
-                          "//# sourceURL")) {
+                          "//# sourceURL")) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   MOZ_ASSERT(url);
@@ -3399,7 +3399,7 @@ js::UniquePtr<ImmutableScriptData> js::I
     uint32_t numResumeOffsets, uint32_t numScopeNotes, uint32_t numTryNotes) {
   auto size = sizeFor(codeLength, noteLength, numResumeOffsets, numScopeNotes,
                       numTryNotes);
-  if (!size.isValid()) {
+  if (!size.isValid()) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return nullptr;
   }
@@ -3407,7 +3407,7 @@ js::UniquePtr<ImmutableScriptData> js::I
   // Allocate contiguous raw buffer.
   void* raw = cx->pod_malloc<uint8_t>(size.value());
   MOZ_ASSERT(uintptr_t(raw) % alignof(ImmutableScriptData) == 0);
-  if (!raw) {
+  if (!raw) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3579,7 +3579,7 @@ PrivateScriptData* PrivateScriptData::ne
   // Compute size including trailing arrays.
   CheckedInt<Offset> size = sizeof(PrivateScriptData);
   size += CheckedInt<Offset>(ngcthings) * sizeof(JS::GCCellPtr);
-  if (!size.isValid()) {
+  if (!size.isValid()) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return nullptr;
   }
@@ -3587,7 +3587,7 @@ PrivateScriptData* PrivateScriptData::ne
   // Allocate contiguous raw buffer for the trailing arrays.
   void* raw = cx->pod_malloc<uint8_t>(size.value());
   MOZ_ASSERT(uintptr_t(raw) % alignof(PrivateScriptData) == 0);
-  if (!raw) {
+  if (!raw) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3617,7 +3617,7 @@ bool PrivateScriptData::InitFromStencil(
   MOZ_ASSERT(ngcthings <= INDEX_LIMIT);
 
   // Create and initialize PrivateScriptData
-  if (!JSScript::createPrivateScriptData(cx, script, ngcthings)) {
+  if (!JSScript::createPrivateScriptData(cx, script, ngcthings)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3657,20 +3657,20 @@ JSScript* JSScript::Create(JSContext* cx
 }
 
 #ifdef MOZ_VTUNE
-uint32_t JSScript::vtuneMethodID() {
-  if (!zone()->scriptVTuneIdMap) {
+uint32_t JSScript::vtuneMethodID() {MOZ_RELEASE_ASSERT(0);
+  if (!zone()->scriptVTuneIdMap) {MOZ_RELEASE_ASSERT(0);
     auto map = MakeUnique<ScriptVTuneIdMap>();
-    if (!map) {
+    if (!map) {MOZ_RELEASE_ASSERT(0);
       MOZ_CRASH("Failed to allocate ScriptVTuneIdMap");
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     zone()->scriptVTuneIdMap = std::move(map);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   ScriptVTuneIdMap::AddPtr p = zone()->scriptVTuneIdMap->lookupForAdd(this);
-  if (p) {
+  if (p) {MOZ_RELEASE_ASSERT(0);
     return p->value();
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MOZ_ASSERT(this->hasBytecode());
 
@@ -3757,7 +3757,7 @@ bool JSScript::fullyInitFromStencil(
 
   // Create and initialize PrivateScriptData
   if (!PrivateScriptData::InitFromStencil(cx, script, input, stencil, gcOutput,
-                                          scriptIndex)) {
+                                          scriptIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3769,7 +3769,7 @@ bool JSScript::fullyInitFromStencil(
       MemberInitializers initializers(
           stencil.scriptExtra[scriptIndex].memberInitializers());
       script->setMemberInitializers(initializers);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       script->setMemberInitializers(lazyData.get()->getMemberInitializers());
     }
   }
@@ -3833,7 +3833,7 @@ JSScript* JSScript::fromStencil(JSContex
   RootedScript script(
       cx, Create(cx, functionOrGlobal, sourceObject, scriptExtra.extent,
                  scriptExtra.immutableFlags));
-  if (!script) {
+  if (!script) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3935,7 +3935,7 @@ void GSNCache::purge() {
 const js::SrcNote* js::GetSrcNote(GSNCache& cache, JSScript* script,
                                   jsbytecode* pc) {
   size_t target = pc - script->code();
-  if (target >= script->length()) {
+  if (target >= script->length()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3963,7 +3963,7 @@ const js::SrcNote* js::GetSrcNote(GSNCac
     unsigned nsrcnotes = 0;
     for (SrcNoteIterator iter(script->notes()); !iter.atEnd(); ++iter) {
       auto sn = *iter;
-      if (sn->isGettable()) {
+      if (sn->isGettable()) {MOZ_RELEASE_ASSERT(0);
         ++nsrcnotes;
       }
     }
@@ -4044,34 +4044,34 @@ unsigned js::PCToLineNumber(JSScript* sc
                         script->code(), pc, columnp);
 }
 
-jsbytecode* js::LineNumberToPC(JSScript* script, unsigned target) {
+jsbytecode* js::LineNumberToPC(JSScript* script, unsigned target) {MOZ_RELEASE_ASSERT(0);
   ptrdiff_t offset = 0;
   ptrdiff_t best = -1;
   unsigned lineno = script->lineno();
   unsigned bestdiff = SrcNote::MaxOperand;
-  for (SrcNoteIterator iter(script->notes()); !iter.atEnd(); ++iter) {
+  for (SrcNoteIterator iter(script->notes()); !iter.atEnd(); ++iter) {MOZ_RELEASE_ASSERT(0);
     auto sn = *iter;
     /*
      * Exact-match only if offset is not in the prologue; otherwise use
      * nearest greater-or-equal line number match.
      */
-    if (lineno == target && offset >= ptrdiff_t(script->mainOffset())) {
+    if (lineno == target && offset >= ptrdiff_t(script->mainOffset())) {MOZ_RELEASE_ASSERT(0);
       goto out;
     }
-    if (lineno >= target) {
+    if (lineno >= target) {MOZ_RELEASE_ASSERT(0);
       unsigned diff = lineno - target;
-      if (diff < bestdiff) {
+      if (diff < bestdiff) {MOZ_RELEASE_ASSERT(0);
         bestdiff = diff;
         best = offset;
-      }
-    }
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
     offset += sn->delta();
     SrcNoteType type = sn->type();
-    if (type == SrcNoteType::SetLine) {
+    if (type == SrcNoteType::SetLine) {MOZ_RELEASE_ASSERT(0);
       lineno = SrcNote::SetLine::getLine(sn, script->lineno());
-    } else if (type == SrcNoteType::NewLine) {
+    } else if (type == SrcNoteType::NewLine) {MOZ_RELEASE_ASSERT(0);
       lineno++;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
   if (best >= 0) {
     offset = best;
@@ -4208,7 +4208,7 @@ static JSObject* CloneInnerInterpretedFu
   /* NB: Keep this in sync with XDRInterpretedFunction. */
   RootedObject cloneProto(cx);
   if (!GetFunctionPrototype(cx, srcFun->generatorKind(), srcFun->asyncKind(),
-                            &cloneProto)) {
+                            &cloneProto)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -4228,12 +4228,12 @@ static JSObject* CloneInnerInterpretedFu
   RootedFunction clone(
       cx, NewFunctionWithProto(cx, nullptr, srcFun->nargs(), flags, nullptr,
                                atom, cloneProto, allocKind, TenuredObject));
-  if (!clone) {
+  if (!clone) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   JSScript::AutoDelazify srcScript(cx, srcFun);
-  if (!srcScript) {
+  if (!srcScript) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   JSScript* cloneScript = CloneScriptIntoFunction(cx, enclosingScope, clone,
@@ -4262,11 +4262,11 @@ static JSObject* CloneScriptObject(JSCon
         MOZ_ASSERT(innerFun->isAsmJSNative());
         JS_ReportErrorASCII(cx, "AsmJS modules do not yet support cloning.");
         return nullptr;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       return innerFun;
     }
 
-    if (!innerFun->hasBytecode()) {
+    if (!innerFun->hasBytecode()) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(!innerFun->isSelfHostedOrIntrinsic(),
                  "Cannot enter realm of self-hosted functions");
       AutoRealm ar(cx, innerFun);
@@ -4312,7 +4312,7 @@ bool PrivateScriptData::Clone(JSContext*
       // cloned especially, depending on whether the script is a function or
       // global scope. Clone all other scopes.
       if (scopeIndex < scopes.length()) {
-        if (!gcThings.append(JS::GCCellPtr(scopes[scopeIndex].get()))) {
+        if (!gcThings.append(JS::GCCellPtr(scopes[scopeIndex].get()))) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
@@ -4321,7 +4321,7 @@ bool PrivateScriptData::Clone(JSContext*
             FindScopeIndex(srcData->gcthings(), *scope->enclosing());
         enclosingScope = &gcThings[enclosingScopeIndex].get().as<Scope>();
         Scope* clone = Scope::clone(cx, scope, enclosingScope);
-        if (!clone || !gcThings.append(JS::GCCellPtr(clone))) {
+        if (!clone || !gcThings.append(JS::GCCellPtr(clone))) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -4331,26 +4331,26 @@ bool PrivateScriptData::Clone(JSContext*
       if (cx->zone() != atom->zone()) {
         cx->markAtom(atom);
       }
-      if (!gcThings.append(JS::GCCellPtr(atom))) {
+      if (!gcThings.append(JS::GCCellPtr(atom))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       bigint = &gcThing.as<BigInt>();
       BigInt* clone = bigint;
-      if (cx->zone() != bigint->zone()) {
+      if (cx->zone() != bigint->zone()) {MOZ_RELEASE_ASSERT(0);
         clone = BigInt::copy(cx, bigint, gc::TenuredHeap);
-        if (!clone) {
+        if (!clone) {MOZ_RELEASE_ASSERT(0);
           return false;
-        }
+        }MOZ_RELEASE_ASSERT(0);
       }
-      if (!gcThings.append(JS::GCCellPtr(clone))) {
+      if (!gcThings.append(JS::GCCellPtr(clone))) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
   }
 
   // Create the new PrivateScriptData on |dst| and fill it in.
-  if (!JSScript::createPrivateScriptData(cx, dst, ngcthings)) {
+  if (!JSScript::createPrivateScriptData(cx, dst, ngcthings)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   PrivateScriptData* dstData = dst->data_;
@@ -4372,7 +4372,7 @@ static JSScript* CopyScriptImpl(JSContex
                                 HandleScriptSourceObject sourceObject,
                                 MutableHandle<GCVector<Scope*>> scopes,
                                 SourceExtent* maybeClassExtent = nullptr) {
-  if (src->treatAsRunOnce()) {
+  if (src->treatAsRunOnce()) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(!src->isFunction());
     JS_ReportErrorASCII(cx, "No cloning toplevel run-once scripts");
     return nullptr;
@@ -4397,7 +4397,7 @@ static JSScript* CopyScriptImpl(JSContex
   // Create a new JSScript to fill in.
   RootedScript dst(
       cx, JSScript::Create(cx, functionOrGlobal, sourceObject, extent, flags));
-  if (!dst) {
+  if (!dst) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -4425,7 +4425,7 @@ JSScript* js::CloneGlobalScript(JSContex
   Rooted<ScriptSourceObject*> sourceObject(cx, src->sourceObject());
   if (cx->compartment() != sourceObject->compartment()) {
     sourceObject = ScriptSourceObject::clone(cx, sourceObject);
-    if (!sourceObject) {
+    if (!sourceObject) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -4434,7 +4434,7 @@ JSScript* js::CloneGlobalScript(JSContex
   Rooted<GCVector<Scope*>> scopes(cx, GCVector<Scope*>(cx));
   Rooted<GlobalScope*> original(cx, &src->bodyScope()->as<GlobalScope>());
   GlobalScope* clone = GlobalScope::clone(cx, original);
-  if (!clone || !scopes.append(clone)) {
+  if (!clone || !scopes.append(clone)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -4549,7 +4549,7 @@ js::UniquePtr<ImmutableScriptData> Immut
   js::UniquePtr<ImmutableScriptData> data(ImmutableScriptData::new_(
       cx, code.Length(), noteLength + nullLength, resumeOffsets.Length(),
       scopeNotes.Length(), tryNotes.Length()));
-  if (!data) {
+  if (!data) {MOZ_RELEASE_ASSERT(0);
     return data;
   }
 
@@ -4614,9 +4614,9 @@ size_t JSScript::calculateLiveFixed(jsby
     }
 
     // Find the nearest LexicalScope in the same script.
-    while (scope && scope->is<WithScope>()) {
+    while (scope && scope->is<WithScope>()) {MOZ_RELEASE_ASSERT(0);
       scope = scope->enclosing();
-      if (scope) {
+      if (scope) {MOZ_RELEASE_ASSERT(0);
         scope = MaybeForwarded(scope);
       }
     }
@@ -4664,7 +4664,7 @@ Scope* JSScript::lookupScope(jsbytecode*
         if (offset < checkNote->start + checkNote->length) {
           // We found a matching block chain but there may be inner ones
           // at a higher block chain index than mid. Continue the binary search.
-          if (checkNote->index == ScopeNote::NoScopeIndex) {
+          if (checkNote->index == ScopeNote::NoScopeIndex) {MOZ_RELEASE_ASSERT(0);
             scope = nullptr;
           } else {
             scope = getScope(checkNote->index);
@@ -4709,7 +4709,7 @@ void js::SetFrameArgumentsObject(JSConte
   while (bi && bi.name() != cx->names().arguments) {
     bi++;
   }
-  if (!bi) {
+  if (!bi) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -4729,7 +4729,7 @@ void js::SetFrameArgumentsObject(JSConte
     // JS_OPTIMIZED_ARGUMENTS, as Ion could have optimized out the
     // arguments slot.
     EnvironmentObject& env = frame.callObj().as<EnvironmentObject>();
-    if (IsOptimizedPlaceholderMagicValue(env.aliasedBinding(bi))) {
+    if (IsOptimizedPlaceholderMagicValue(env.aliasedBinding(bi))) {MOZ_RELEASE_ASSERT(0);
       env.setAliasedBinding(cx, bi, ObjectValue(*argsobj));
     }
   } else {
@@ -4751,7 +4751,7 @@ void js::SetFrameArgumentsObject(JSConte
 }
 
 /* static */
-void JSScript::argumentsOptimizationFailed(JSContext* cx, HandleScript script) {
+void JSScript::argumentsOptimizationFailed(JSContext* cx, HandleScript script) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(script->isFunction());
   MOZ_ASSERT(!script->needsArgsAnalysis());
   MOZ_ASSERT(script->argumentsHasVarBinding());
@@ -4763,9 +4763,9 @@ void JSScript::argumentsOptimizationFail
    * is nothing to do; GuardFunApplySpeculation will patch in the real
    * argsobj.
    */
-  if (script->needsArgsObj()) {
+  if (script->needsArgsObj()) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MOZ_ASSERT(!script->isGenerator());
   MOZ_ASSERT(!script->isAsync());
@@ -4774,7 +4774,7 @@ void JSScript::argumentsOptimizationFail
 
   // Warp code depends on the NeedsArgsObj flag so invalidate the script
   // (including compilations inlining the script).
-  {
+  {MOZ_RELEASE_ASSERT(0);
     jit::RecompileInfoVector invalid;
     AddPendingInvalidation(invalid, script);
     Invalidate(cx, invalid);
@@ -4793,7 +4793,7 @@ void JSScript::argumentsOptimizationFail
    *    assumption of !script->needsArgsObj();
    *  - type inference data for the script assuming script->needsArgsObj
    */
-  for (AllScriptFramesIter i(cx); !i.done(); ++i) {
+  for (AllScriptFramesIter i(cx); !i.done(); ++i) {MOZ_RELEASE_ASSERT(0);
     /*
      * We cannot reliably create an arguments object for Ion activations of
      * this script.  To maintain the invariant that "script->needsArgsObj
@@ -4801,11 +4801,11 @@ void JSScript::argumentsOptimizationFail
      * arguments object right after restoring the BaselineFrame and before
      * entering Baseline code (in jit::FinishBailoutToBaseline).
      */
-    if (i.isIon()) {
+    if (i.isIon()) {MOZ_RELEASE_ASSERT(0);
       continue;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     AbstractFramePtr frame = i.abstractFramePtr();
-    if (frame.isFunctionFrame() && frame.script() == script) {
+    if (frame.isFunctionFrame() && frame.script() == script) {MOZ_RELEASE_ASSERT(0);
       /* We crash on OOM since cleaning up here would be complicated. */
       AutoEnterOOMUnsafeRegion oomUnsafe;
       ArgumentsObject* argsobj = ArgumentsObject::createExpected(cx, frame);
@@ -4818,7 +4818,7 @@ void JSScript::argumentsOptimizationFail
 }
 
 bool JSScript::formalIsAliased(unsigned argSlot) {
-  if (functionHasParameterExprs()) {
+  if (functionHasParameterExprs()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4878,7 +4878,7 @@ BaseScript* BaseScript::CreateRawLazy(JS
   cx->check(fun);
 
   BaseScript* lazy = New(cx, fun, sourceObject, extent, immutableFlags);
-  if (!lazy) {
+  if (!lazy) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -4915,8 +4915,8 @@ void JSScript::updateJitCodeRaw(JSRuntim
   MOZ_ASSERT(jitCodeRaw());
 }
 
-bool JSScript::hasLoops() {
-  for (const TryNote& tn : trynotes()) {
+bool JSScript::hasLoops() {MOZ_RELEASE_ASSERT(0);
+  for (const TryNote& tn : trynotes()) {MOZ_RELEASE_ASSERT(0);
     if (tn.isLoop()) {
       return true;
     }
@@ -4937,7 +4937,7 @@ void JSScript::resetWarmUpCounterToDelay
   if (getWarmUpCount() > jit::JitOptions.baselineJitWarmUpThreshold) {
     incWarmUpResetCounter();
     uint32_t newCount = jit::JitOptions.baselineJitWarmUpThreshold;
-    if (warmUpData_.isWarmUpCount()) {
+    if (warmUpData_.isWarmUpCount()) {MOZ_RELEASE_ASSERT(0);
       warmUpData_.resetWarmUpCount(newCount);
     } else {
       warmUpData_.toJitScript()->resetWarmUpCount(newCount);
diff --git a/js/src/vm/JitActivation.cpp b/js/src/vm/JitActivation.cpp
--- a/js/src/vm/JitActivation.cpp
+++ b/js/src/vm/JitActivation.cpp
@@ -102,7 +102,7 @@ js::jit::RematerializedFrame* js::jit::J
 
   if (!rematerializedFrames_) {
     rematerializedFrames_ = cx->make_unique<RematerializedFrameTable>(cx);
-    if (!rematerializedFrames_) {
+    if (!rematerializedFrames_) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -126,7 +126,7 @@ js::jit::RematerializedFrame* js::jit::J
     AutoRealmUnchecked ar(cx, iter.script()->realm());
 
     if (!RematerializedFrame::RematerializeInlineFrames(cx, top, inlineIter,
-                                                        recover, frames)) {
+                                                        recover, frames)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
diff --git a/js/src/vm/MemoryMetrics.cpp b/js/src/vm/MemoryMetrics.cpp
--- a/js/src/vm/MemoryMetrics.cpp
+++ b/js/src/vm/MemoryMetrics.cpp
@@ -75,7 +75,7 @@ static bool EqualStringsPure(JSString* s
   } else {
     ownedChars1 =
         s1->asRope().copyChars<Char1>(/* tcx */ nullptr, js::MallocArena);
-    if (!ownedChars1) {
+    if (!ownedChars1) {MOZ_RELEASE_ASSERT(0);
       MOZ_CRASH("oom");
     }
     c1 = ownedChars1.get();
@@ -122,7 +122,7 @@ static void StoreStringChars(char* buffe
   JS::AutoCheckCannotGC nogc;
   if (str->isLinear()) {
     chars = str->asLinear().chars<CharT>(nogc);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     ownedChars =
         str->asRope().copyChars<CharT>(/* tcx */ nullptr, js::MallocArena);
     if (!ownedChars) {
@@ -141,7 +141,7 @@ NotableStringInfo::NotableStringInfo(JSS
     : StringInfo(info), length(str->length()) {
   size_t bufferSize = std::min(str->length() + 1, size_t(MAX_SAVED_CHARS));
   buffer.reset(js_pod_malloc<char>(bufferSize));
-  if (!buffer) {
+  if (!buffer) {MOZ_RELEASE_ASSERT(0);
     MOZ_CRASH("oom");
   }
 
@@ -162,7 +162,7 @@ NotableClassInfo::NotableClassInfo(const
 
 NotableScriptSourceInfo::NotableScriptSourceInfo(const char* filename,
                                                  const ScriptSourceInfo& info)
-    : ScriptSourceInfo(info) {
+    : ScriptSourceInfo(info) {MOZ_RELEASE_ASSERT(0);
   filename_ = DuplicateString(filename);
   if (!filename_) {
     MOZ_CRASH("oom");
@@ -265,7 +265,7 @@ enum Granularity { FineGrained, CoarseGr
 static void AddClassInfo(Granularity granularity, RealmStats& realmStats,
                          const char* className, JS::ClassInfo& info) {
   if (granularity == FineGrained) {
-    if (!className) {
+    if (!className) {MOZ_RELEASE_ASSERT(0);
       className = "<no class name>";
     }
     RealmStats::ClassesHashMap::AddPtr p =
@@ -300,7 +300,7 @@ static void CollectScriptSourceStats(Sta
 
   if (granularity == FineGrained) {
     const char* filename = ss->filename();
-    if (!filename) {
+    if (!filename) {MOZ_RELEASE_ASSERT(0);
       filename = "<no filename>";
     }
 
@@ -625,12 +625,12 @@ static bool CollectRuntimeStatsHelper(JS
   // Wait for any background tasks to finish.
   WaitForAllHelperThreads();
 
-  if (!rtStats->realmStatsVector.reserve(rt->numRealms)) {
+  if (!rtStats->realmStatsVector.reserve(rt->numRealms)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   size_t totalZones = rt->gc.zones().length() + 1;  // + 1 for the atoms zone.
-  if (!rtStats->zoneStatsVector.reserve(totalZones)) {
+  if (!rtStats->zoneStatsVector.reserve(totalZones)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -653,7 +653,7 @@ static bool CollectRuntimeStatsHelper(JS
   // Take the "explicit/js/runtime/" measurements.
   rt->addSizeOfIncludingThis(rtStats->mallocSizeOf_, &rtStats->runtime);
 
-  if (!FindNotableScriptSources(rtStats->runtime)) {
+  if (!FindNotableScriptSources(rtStats->runtime)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -668,7 +668,7 @@ static bool CollectRuntimeStatsHelper(JS
   }
 
   for (size_t i = 0; i < zs.length(); i++) {
-    if (!FindNotableStrings(zs[i])) {
+    if (!FindNotableStrings(zs[i])) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -685,7 +685,7 @@ static bool CollectRuntimeStatsHelper(JS
   }
 
   for (size_t i = 0; i < realmStats.length(); i++) {
-    if (!FindNotableClasses(realmStats[i])) {
+    if (!FindNotableClasses(realmStats[i])) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -816,11 +816,11 @@ JS_PUBLIC_API bool AddSizeOfTab(JSContex
     numRealms += comp->realms().length();
   }
 
-  if (!rtStats.realmStatsVector.reserve(numRealms)) {
+  if (!rtStats.realmStatsVector.reserve(numRealms)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!rtStats.zoneStatsVector.reserve(1)) {
+  if (!rtStats.zoneStatsVector.reserve(1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/vm/NativeObject.cpp b/js/src/vm/NativeObject.cpp
--- a/js/src/vm/NativeObject.cpp
+++ b/js/src/vm/NativeObject.cpp
@@ -148,7 +148,7 @@ bool ObjectElements::FreezeOrSeal(JSCont
 
   if (level == IntegrityLevel::Frozen) {
     if (!JSObject::setFlag(cx, obj, ObjectFlag::FrozenElements,
-                           JSObject::GENERATE_SHAPE)) {
+                           JSObject::GENERATE_SHAPE)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -314,7 +314,7 @@ bool NativeObject::ensureSlotsForDiction
   MOZ_ASSERT(inDictionaryMode());
 
   size_t oldSpan = dictionaryModeSlotSpan();
-  if (oldSpan == span) {
+  if (oldSpan == span) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -441,7 +441,7 @@ bool NativeObject::addDenseElementPure(J
 
 static inline void FreeSlots(JSContext* cx, NativeObject* obj,
                              ObjectSlots* slots, size_t nbytes) {
-  if (cx->isHelperThreadContext()) {
+  if (cx->isHelperThreadContext()) {MOZ_RELEASE_ASSERT(0);
     js_free(slots);
   } else if (obj->isTenured()) {
     MOZ_ASSERT(!cx->nursery().isInside(slots));
@@ -585,7 +585,7 @@ DenseElementResult NativeObject::maybeDe
     return DenseElementResult::Incomplete;
   }
 
-  if (newInitializedLength > MAX_DENSE_ELEMENTS_COUNT) {
+  if (newInitializedLength > MAX_DENSE_ELEMENTS_COUNT) {MOZ_RELEASE_ASSERT(0);
     return DenseElementResult::Incomplete;
   }
 
@@ -595,7 +595,7 @@ DenseElementResult NativeObject::maybeDe
    */
 
   if (newInitializedLength > obj->getDenseCapacity()) {
-    if (!obj->growElements(cx, newInitializedLength)) {
+    if (!obj->growElements(cx, newInitializedLength)) {MOZ_RELEASE_ASSERT(0);
       return DenseElementResult::Failure;
     }
   }
@@ -624,13 +624,13 @@ DenseElementResult NativeObject::maybeDe
        * Compute the next shape in the traverse, watching for such
        * removals from the list.
        */
-      if (shape != obj->lastProperty()) {
+      if (shape != obj->lastProperty()) {MOZ_RELEASE_ASSERT(0);
         shape = shape->previous();
-        if (!NativeObject::removeProperty(cx, obj, id)) {
+        if (!NativeObject::removeProperty(cx, obj, id)) {MOZ_RELEASE_ASSERT(0);
           return DenseElementResult::Failure;
         }
       } else {
-        if (!NativeObject::removeProperty(cx, obj, id)) {
+        if (!NativeObject::removeProperty(cx, obj, id)) {MOZ_RELEASE_ASSERT(0);
           return DenseElementResult::Failure;
         }
         shape = obj->lastProperty();
@@ -903,7 +903,7 @@ bool NativeObject::growElements(JSContex
     // elements to avoid the problem.
     CheckedInt<uint32_t> checkedReqCapacity(reqCapacity);
     checkedReqCapacity += numShifted;
-    if (MOZ_UNLIKELY(!checkedReqCapacity.isValid())) {
+    if (MOZ_UNLIKELY(!checkedReqCapacity.isValid())) {MOZ_RELEASE_ASSERT(0);
       moveShiftedElements();
       numShifted = 0;
     }
@@ -948,12 +948,12 @@ bool NativeObject::growElements(JSContex
 
     newHeaderSlots = ReallocateObjectBuffer<HeapSlot>(
         cx, this, oldHeaderSlots, oldAllocated, newAllocated);
-    if (!newHeaderSlots) {
+    if (!newHeaderSlots) {MOZ_RELEASE_ASSERT(0);
       return false;  // Leave elements at its old size.
     }
   } else {
     newHeaderSlots = AllocateObjectBuffer<HeapSlot>(cx, this, newAllocated);
-    if (!newHeaderSlots) {
+    if (!newHeaderSlots) {MOZ_RELEASE_ASSERT(0);
       return false;  // Leave elements at its old size.
     }
     PodCopy(newHeaderSlots, oldHeaderSlots,
@@ -1302,7 +1302,7 @@ static bool ChangeProperty(JSContext* cx
 
   if (!gs) {
     gs = GetterSetter::create(cx, getter, setter);
-    if (!gs) {
+    if (!gs) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1337,7 +1337,7 @@ static MOZ_ALWAYS_INLINE bool AddOrChang
   }
 #endif
 
-  if (!ReshapeForShadowedProp(cx, obj, id)) {
+  if (!ReshapeForShadowedProp(cx, obj, id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1350,12 +1350,12 @@ static MOZ_ALWAYS_INLINE bool AddOrChang
     MOZ_ASSERT(!obj->is<TypedArrayObject>());
     uint32_t index = JSID_TO_INT(id);
     DenseElementResult edResult = obj->ensureDenseElements(cx, index, 1);
-    if (edResult == DenseElementResult::Failure) {
+    if (edResult == DenseElementResult::Failure) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (edResult == DenseElementResult::Success) {
       obj->setDenseElement(index, desc.value());
-      if (!CallAddPropertyHookDense(cx, obj, index, desc.value())) {
+      if (!CallAddPropertyHookDense(cx, obj, index, desc.value())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       return true;
@@ -1368,12 +1368,12 @@ static MOZ_ALWAYS_INLINE bool AddOrChang
     if (desc.isAccessorDescriptor()) {
       Rooted<GetterSetter*> gs(cx, GetterSetter::create(cx, desc.getterObject(),
                                                         desc.setterObject()));
-      if (!gs) {
+      if (!gs) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       Shape* shape = NativeObject::addProperty(cx, obj, id, SHAPE_INVALID_SLOT,
                                                desc.attributes());
-      if (!shape) {
+      if (!shape) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       obj->initSlot(shape->slot(), PrivateGCThingValue(gs));
@@ -1388,12 +1388,12 @@ static MOZ_ALWAYS_INLINE bool AddOrChang
   } else {
     if (desc.isAccessorDescriptor()) {
       if (!ChangeProperty(cx, obj, id, desc.getterObject(), desc.setterObject(),
-                          desc.attributes(), existing)) {
+                          desc.attributes(), existing)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
       Shape* shape = NativeObject::putProperty(cx, obj, id, desc.attributes());
-      if (!shape) {
+      if (!shape) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       obj->setSlot(shape->slot(), desc.value());
@@ -1411,7 +1411,7 @@ static MOZ_ALWAYS_INLINE bool AddOrChang
     }
     DenseElementResult edResult =
         NativeObject::maybeDensifySparseElements(cx, obj);
-    if (edResult == DenseElementResult::Failure) {
+    if (edResult == DenseElementResult::Failure) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (edResult == DenseElementResult::Success) {
@@ -1431,7 +1431,7 @@ static MOZ_ALWAYS_INLINE bool AddDataPro
                                               HandleId id, HandleValue v) {
   MOZ_ASSERT(!JSID_IS_INT(id));
 
-  if (!ReshapeForShadowedProp(cx, obj, id)) {
+  if (!ReshapeForShadowedProp(cx, obj, id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1527,7 +1527,7 @@ static bool DefinePropertyIsRedundant(JS
         // call site. For details, see bug 1125624 comments 13-16.
         currentValue.set(obj->getSlot(prop.shape()->slot()));
       } else {
-        if (!GetExistingPropertyValue(cx, obj, id, prop, &currentValue)) {
+        if (!GetExistingPropertyValue(cx, obj, id, prop, &currentValue)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -1600,7 +1600,7 @@ bool js::NativeDefineProperty(JSContext*
     // 9.4.5.3 step 3. Indexed properties of typed arrays are special.
     Rooted<TypedArrayObject*> tobj(cx, &obj->as<TypedArrayObject>());
     mozilla::Maybe<uint64_t> index;
-    if (!ToTypedArrayIndex(cx, id, &index)) {
+    if (!ToTypedArrayIndex(cx, id, &index)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1625,7 +1625,7 @@ bool js::NativeDefineProperty(JSContext*
                JSID_TO_SYMBOL(id) == cx->wellKnownSymbols().iterator) {
       // Do same thing as .length for [@@iterator].
       if ((desc_.attributes() & JSPROP_RESOLVING) == 0) {
-        if (!ArgumentsObject::reifyIterator(cx, argsobj)) {
+        if (!ArgumentsObject::reifyIterator(cx, argsobj)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -1642,11 +1642,11 @@ bool js::NativeDefineProperty(JSContext*
     // We are being called from a resolve or enumerate hook to reify a
     // lazily-resolved property. To avoid reentering the resolve hook and
     // recursing forever, skip the resolve hook when doing this lookup.
-    if (!NativeLookupOwnPropertyNoResolve(cx, obj, id, prop.address())) {
+    if (!NativeLookupOwnPropertyNoResolve(cx, obj, id, prop.address())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
-    if (!NativeLookupOwnProperty<CanGC>(cx, obj, id, &prop)) {
+    if (!NativeLookupOwnProperty<CanGC>(cx, obj, id, &prop)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1684,7 +1684,7 @@ bool js::NativeDefineProperty(JSContext*
   unsigned shapeAttrs = GetPropertyAttributes(obj, prop);
   bool redundant;
   if (!DefinePropertyIsRedundant(cx, obj, id, prop, shapeAttrs, desc,
-                                 &redundant)) {
+                                 &redundant)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (redundant) {
@@ -1721,7 +1721,7 @@ bool js::NativeDefineProperty(JSContext*
     MOZ_ASSERT(!desc.hasSetterObject());
     if (IsDataDescriptor(shapeAttrs)) {
       RootedValue currentValue(cx);
-      if (!GetExistingPropertyValue(cx, obj, id, prop, &currentValue)) {
+      if (!GetExistingPropertyValue(cx, obj, id, prop, &currentValue)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       desc.setValue(currentValue);
@@ -1749,7 +1749,7 @@ bool js::NativeDefineProperty(JSContext*
 
     if (frozen || !desc.hasValue()) {
       RootedValue currentValue(cx);
-      if (!GetExistingPropertyValue(cx, obj, id, prop, &currentValue)) {
+      if (!GetExistingPropertyValue(cx, obj, id, prop, &currentValue)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -1760,7 +1760,7 @@ bool js::NativeDefineProperty(JSContext*
         // Step 7.a.i.2.
         bool same;
         MOZ_ASSERT(!cx->isHelperThreadContext());
-        if (!SameValue(cx, desc.value(), currentValue, &same)) {
+        if (!SameValue(cx, desc.value(), currentValue, &same)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         if (!same) {
@@ -1834,7 +1834,7 @@ bool js::NativeDefineAccessorProperty(JS
   desc.initFields(nullptr, UndefinedHandleValue, attrs, getter, setter);
 
   ObjectOpResult result;
-  if (!NativeDefineProperty(cx, obj, id, desc, result)) {
+  if (!NativeDefineProperty(cx, obj, id, desc, result)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1854,7 +1854,7 @@ bool js::NativeDefineDataProperty(JSCont
                                   HandleId id, HandleValue value,
                                   unsigned attrs) {
   ObjectOpResult result;
-  if (!NativeDefineDataProperty(cx, obj, id, value, attrs, result)) {
+  if (!NativeDefineDataProperty(cx, obj, id, value, attrs, result)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!result) {
@@ -1896,7 +1896,7 @@ static bool DefineNonexistentProperty(JS
   } else if (obj->is<TypedArrayObject>()) {
     // 9.4.5.5 step 2. Indexed properties of typed arrays are special.
     mozilla::Maybe<uint64_t> index;
-    if (!ToTypedArrayIndex(cx, id, &index)) {
+    if (!ToTypedArrayIndex(cx, id, &index)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2069,7 +2069,7 @@ bool js::NativeGetOwnPropertyDescriptor(
     JSContext* cx, HandleNativeObject obj, HandleId id,
     MutableHandle<PropertyDescriptor> desc) {
   Rooted<PropertyResult> prop(cx);
-  if (!NativeLookupOwnProperty<CanGC>(cx, obj, id, &prop)) {
+  if (!NativeLookupOwnProperty<CanGC>(cx, obj, id, &prop)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (prop.isNotFound()) {
@@ -2089,13 +2089,13 @@ bool js::NativeGetOwnPropertyDescriptor(
     // getter or setter with a null, following CompletePropertyDescriptor.
     if (desc.hasGetterObject()) {
       desc.setGetterObject(obj->getGetter(prop.shape()));
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       desc.setGetterObject(nullptr);
       desc.attributesRef() |= JSPROP_GETTER;
     }
     if (desc.hasSetterObject()) {
       desc.setSetterObject(obj->getSetter(prop.shape()));
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       desc.setSetterObject(nullptr);
       desc.attributesRef() |= JSPROP_SETTER;
     }
@@ -2107,7 +2107,7 @@ bool js::NativeGetOwnPropertyDescriptor(
     } else if (prop.isTypedArrayElement()) {
       size_t idx = prop.typedArrayElementIndex();
       if (!obj->as<TypedArrayObject>().getElement<CanGC>(cx, idx,
-                                                         desc.value())) {
+                                                         desc.value())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -2132,7 +2132,7 @@ bool js::NativeGetOwnPropertyDescriptor(
 
 static bool GetCustomDataProperty(JSContext* cx, HandleObject obj, HandleId id,
                                   MutableHandleValue vp) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2140,11 +2140,11 @@ static bool GetCustomDataProperty(JSCont
 
   const JSClass* clasp = obj->getClass();
   if (clasp == &ArrayObject::class_) {
-    if (!ArrayLengthGetter(cx, obj, id, vp)) {
+    if (!ArrayLengthGetter(cx, obj, id, vp)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else if (clasp == &MappedArgumentsObject::class_) {
-    if (!MappedArgGetter(cx, obj, id, vp)) {
+    if (!MappedArgGetter(cx, obj, id, vp)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -2258,7 +2258,7 @@ static inline bool GeneralizedGetPropert
     // throw ReferenceErrors regardless of strictness, technically a bug.)
 
     bool found;
-    if (!HasProperty(cx, obj, id, &found)) {
+    if (!HasProperty(cx, obj, id, &found)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!found) {
@@ -2385,7 +2385,7 @@ bool js::NativeGetElement(JSContext* cx,
   RootedId id(cx);
 
   if (MOZ_LIKELY(index >= 0)) {
-    if (!IndexToId(cx, index, &id)) {
+    if (!IndexToId(cx, index, &id)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -2423,7 +2423,7 @@ bool js::GetNameBoundInEnvironment(JSCon
 
 static bool SetCustomDataProperty(JSContext* cx, HandleObject obj, HandleId id,
                                   HandleValue v, ObjectOpResult& result) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2445,7 +2445,7 @@ static bool MaybeReportUndeclaredVarAssi
     jsbytecode* pc;
     JSScript* script =
         cx->currentScript(&pc, JSContext::AllowCrossRealm::Allow);
-    if (!script) {
+    if (!script) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
 
@@ -2545,7 +2545,7 @@ bool js::SetPropertyByDefining(JSContext
 // the search up the prototype chain.
 bool js::SetPropertyOnProto(JSContext* cx, HandleObject obj, HandleId id,
                             HandleValue v, HandleValue receiver,
-                            ObjectOpResult& result) {
+                            ObjectOpResult& result) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(!obj->is<ProxyObject>());
 
   RootedObject proto(cx, obj->staticPrototype());
@@ -2718,7 +2718,7 @@ bool js::NativeSetProperty(JSContext* cx
   // also reported at <https://github.com/tc39/ecma262/issues/1541>.
   for (;;) {
     // Steps 2-3.
-    if (!NativeLookupOwnPropertyInline<CanGC>(cx, pobj, id, &prop)) {
+    if (!NativeLookupOwnPropertyInline<CanGC>(cx, pobj, id, &prop)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2753,7 +2753,7 @@ bool js::NativeSetProperty(JSContext* cx
       RootedObject protoRoot(cx, proto);
       if (!IsQualified) {
         bool found;
-        if (!HasProperty(cx, protoRoot, id, &found)) {
+        if (!HasProperty(cx, protoRoot, id, &found)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         if (!found) {
@@ -2795,7 +2795,7 @@ bool js::NativeSetElement(JSContext* cx,
 static bool CallJSDeletePropertyOp(JSContext* cx, JSDeletePropertyOp op,
                                    HandleObject receiver, HandleId id,
                                    ObjectOpResult& result) {
-  if (!CheckRecursionLimit(cx)) {
+  if (!CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2811,7 +2811,7 @@ bool js::NativeDeleteProperty(JSContext*
                               HandleId id, ObjectOpResult& result) {
   // Steps 2-3.
   Rooted<PropertyResult> prop(cx);
-  if (!NativeLookupOwnProperty<CanGC>(cx, obj, id, &prop)) {
+  if (!NativeLookupOwnProperty<CanGC>(cx, obj, id, &prop)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2834,10 +2834,10 @@ bool js::NativeDeleteProperty(JSContext*
   }
 
   if (!CallJSDeletePropertyOp(cx, obj->getClass()->getDelProperty(), obj, id,
-                              result)) {
+                              result)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -2899,7 +2899,7 @@ bool js::CopyDataPropertiesNative(JSCont
       return true;
     }
 
-    if (!shapes.append(shape)) {
+    if (!shapes.append(shape)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2928,7 +2928,7 @@ bool js::CopyDataPropertiesNative(JSCont
       MOZ_ASSERT(!target->contains(cx, key),
                  "didn't expect to find an existing property");
 
-      if (!AddDataPropertyNonPrototype(cx, target, key, value)) {
+      if (!AddDataPropertyNonPrototype(cx, target, key, value)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
diff --git a/js/src/vm/OffThreadScriptCompilation.cpp b/js/src/vm/OffThreadScriptCompilation.cpp
--- a/js/src/vm/OffThreadScriptCompilation.cpp
+++ b/js/src/vm/OffThreadScriptCompilation.cpp
@@ -54,7 +54,7 @@ static bool CanDoOffThread(JSContext* cx
     bool mustWait = options.useOffThreadParseGlobal &&
                     OffThreadParsingMustWaitForGC(cx->runtime());
     if (mustWait) {
-      if (what == OffThread::Compile && length < HUGE_SRC_LENGTH) {
+      if (what == OffThread::Compile && length < HUGE_SRC_LENGTH) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (what == OffThread::Decode && length < HUGE_BC_LENGTH) {
diff --git a/js/src/vm/PIC.cpp b/js/src/vm/PIC.cpp
--- a/js/src/vm/PIC.cpp
+++ b/js/src/vm/PIC.cpp
@@ -44,14 +44,14 @@ bool js::ForOfPIC::Chain::initialize(JSC
   // Get the canonical Array.prototype
   RootedNativeObject arrayProto(
       cx, GlobalObject::getOrCreateArrayPrototype(cx, cx->global()));
-  if (!arrayProto) {
+  if (!arrayProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Get the canonical ArrayIterator.prototype
   RootedNativeObject arrayIteratorProto(
       cx, GlobalObject::getOrCreateArrayIteratorPrototype(cx, cx->global()));
-  if (!arrayIteratorProto) {
+  if (!arrayIteratorProto) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -76,7 +76,7 @@ bool js::ForOfPIC::Chain::initialize(JSC
   // function.
   Value iterator = arrayProto->getSlot(iterShape->slot());
   JSFunction* iterFun;
-  if (!IsFunctionObject(iterator, &iterFun)) {
+  if (!IsFunctionObject(iterator, &iterFun)) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
   if (!IsSelfHostedFunctionWithName(iterFun, cx->names().ArrayValues)) {
@@ -85,7 +85,7 @@ bool js::ForOfPIC::Chain::initialize(JSC
 
   // Look up the 'next' value on ArrayIterator.prototype
   Shape* nextShape = arrayIteratorProto->lookup(cx, cx->names().next);
-  if (!nextShape || !nextShape->isDataProperty()) {
+  if (!nextShape || !nextShape->isDataProperty()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -93,7 +93,7 @@ bool js::ForOfPIC::Chain::initialize(JSC
   // function.
   Value next = arrayIteratorProto->getSlot(nextShape->slot());
   JSFunction* nextFun;
-  if (!IsFunctionObject(next, &nextFun)) {
+  if (!IsFunctionObject(next, &nextFun)) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
   if (!IsSelfHostedFunctionWithName(nextFun, cx->names().ArrayIteratorNext)) {
@@ -119,7 +119,7 @@ bool js::ForOfPIC::Chain::tryOptimizeArr
 
   if (!initialized_) {
     // If PIC is not initialized, initialize it.
-    if (!initialize(cx)) {
+    if (!initialize(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -127,7 +127,7 @@ bool js::ForOfPIC::Chain::tryOptimizeArr
     // Otherwise, if array state is no longer sane, reinitialize.
     reset(cx);
 
-    if (!initialize(cx)) {
+    if (!initialize(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -186,16 +186,16 @@ bool js::ForOfPIC::Chain::tryOptimizeArr
 
   if (!initialized_) {
     // If PIC is not initialized, initialize it.
-    if (!initialize(cx)) {
+    if (!initialize(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-  } else if (!disabled_ && !isArrayNextStillSane()) {
+  } else if (!disabled_ && !isArrayNextStillSane()) {MOZ_RELEASE_ASSERT(0);
     // Otherwise, if array iterator state is no longer sane, reinitialize.
     reset(cx);
 
-    if (!initialize(cx)) {
+    if (!initialize(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
   MOZ_ASSERT(initialized_);
 
@@ -347,7 +347,7 @@ NativeObject* js::ForOfPIC::createForOfP
   cx->check(global);
   ForOfPICObject* obj =
       NewTenuredObjectWithGivenProto<ForOfPICObject>(cx, nullptr);
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   ForOfPIC::Chain* chain = cx->new_<ForOfPIC::Chain>(obj);
diff --git a/js/src/vm/Printer.cpp b/js/src/vm/Printer.cpp
--- a/js/src/vm/Printer.cpp
+++ b/js/src/vm/Printer.cpp
@@ -40,7 +40,7 @@ class GenericPrinterPrintfTarget : publi
 
 namespace js {
 
-void GenericPrinter::reportOutOfMemory() {
+void GenericPrinter::reportOutOfMemory() {MOZ_RELEASE_ASSERT(0);
   if (hadOOM_) {
     return;
   }
@@ -59,7 +59,7 @@ bool GenericPrinter::printf(const char* 
 
 bool GenericPrinter::vprintf(const char* fmt, va_list ap) {
   // Simple shortcut to avoid allocating strings.
-  if (strchr(fmt, '%') == nullptr) {
+  if (strchr(fmt, '%') == nullptr) {MOZ_RELEASE_ASSERT(0);
     return put(fmt);
   }
 
@@ -174,16 +174,16 @@ bool Sprinter::put(const char* s, size_t
   const char* oldEnd = base + size;
 
   char* bp = reserve(len);
-  if (!bp) {
+  if (!bp) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   /* s is within the buffer already */
   if (s >= oldBase && s < oldEnd) {
     /* buffer was realloc'ed */
-    if (base != oldBase) {
+    if (base != oldBase) {MOZ_RELEASE_ASSERT(0);
       s = stringAt(s - oldBase); /* this is where it lives now */
-    }
+    }MOZ_RELEASE_ASSERT(0);
     memmove(bp, s, len);
   } else {
     js_memcpy(bp, s, len);
@@ -197,7 +197,7 @@ bool Sprinter::putString(JSString* s) {
   InvariantChecker ic(this);
 
   JSLinearString* linear = s->ensureLinear(context);
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -218,8 +218,8 @@ bool Sprinter::putString(JSString* s) {
 
 ptrdiff_t Sprinter::getOffset() const { return offset; }
 
-void Sprinter::reportOutOfMemory() {
-  if (hadOOM_) {
+void Sprinter::reportOutOfMemory() {MOZ_RELEASE_ASSERT(0);
+  if (hadOOM_) {MOZ_RELEASE_ASSERT(0);
     return;
   }
   if (context && shouldReportOOM) {
@@ -277,7 +277,7 @@ bool QuoteString(Sprinter* sp, const moz
       (target == QuoteTarget::String) ? js_EscapeMap : JSONEscapeMap;
 
   if (quote) {
-    if (!sp->putChar(quote)) {
+    if (!sp->putChar(quote)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -310,7 +310,7 @@ bool QuoteString(Sprinter* sp, const moz
     {
       ptrdiff_t len = t - s;
       ptrdiff_t base = sp->getOffset();
-      if (!sp->reserve(len)) {
+      if (!sp->reserve(len)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -328,7 +328,7 @@ bool QuoteString(Sprinter* sp, const moz
     const char* escape;
     if (!(c >> 8) && c != 0 &&
         (escape = strchr(escapeMap, int(c))) != nullptr) {
-      if (!sp->jsprintf("\\%c", escape[1])) {
+      if (!sp->jsprintf("\\%c", escape[1])) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -337,7 +337,7 @@ bool QuoteString(Sprinter* sp, const moz
        * because ECMA-262 allows only \u, not \x, in Unicode identifiers
        * (see bug 621814).
        */
-      if (!sp->jsprintf((quote && !(c >> 8)) ? "\\x%02X" : "\\u%04X", c)) {
+      if (!sp->jsprintf((quote && !(c >> 8)) ? "\\x%02X" : "\\u%04X", c)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -380,7 +380,7 @@ bool QuoteString(Sprinter* sp, JSString*
 
 UniqueChars QuoteString(JSContext* cx, JSString* str, char quote /* = '\0' */) {
   Sprinter sprinter(cx);
-  if (!sprinter.init()) {
+  if (!sprinter.init()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (!QuoteString(&sprinter, str, quote)) {
@@ -440,12 +440,12 @@ void Fprinter::finish() {
 bool Fprinter::put(const char* s, size_t len) {
   MOZ_ASSERT(file_);
   int i = fwrite(s, /*size=*/1, /*nitems=*/len, file_);
-  if (size_t(i) != len) {
+  if (size_t(i) != len) {MOZ_RELEASE_ASSERT(0);
     reportOutOfMemory();
     return false;
   }
 #ifdef XP_WIN
-  if ((file_ == stderr) && (IsDebuggerPresent())) {
+  if ((file_ == stderr) && (IsDebuggerPresent())) {MOZ_RELEASE_ASSERT(0);
     UniqueChars buf = DuplicateString(s, len);
     if (!buf) {
       reportOutOfMemory();
@@ -501,7 +501,7 @@ bool LSprinter::put(const char* s, size_
 
     LifoAlloc::AutoFallibleScope fallibleAllocator(alloc_);
     last = reinterpret_cast<Chunk*>(alloc_->alloc(allocLength));
-    if (!last) {
+    if (!last) {MOZ_RELEASE_ASSERT(0);
       reportOutOfMemory();
       return false;
     }
diff --git a/js/src/vm/PromiseLookup.cpp b/js/src/vm/PromiseLookup.cpp
--- a/js/src/vm/PromiseLookup.cpp
+++ b/js/src/vm/PromiseLookup.cpp
@@ -66,7 +66,7 @@ void js::PromiseLookup::initialize(JSCon
   // Check condition 1:
   // Leave the cache uninitialized if the Promise class itself is not yet
   // initialized.
-  if (!promiseProto) {
+  if (!promiseProto) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -83,24 +83,24 @@ void js::PromiseLookup::initialize(JSCon
   // Check condition 2:
   // Look up Promise.prototype.constructor and ensure it's a data property.
   Shape* ctorShape = promiseProto->lookup(cx, cx->names().constructor);
-  if (!ctorShape || !ctorShape->isDataProperty()) {
+  if (!ctorShape || !ctorShape->isDataProperty()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
   // Get the referred value, and ensure it holds the canonical Promise
   // constructor.
   JSFunction* ctorFun;
-  if (!IsFunctionObject(promiseProto->getSlot(ctorShape->slot()), &ctorFun)) {
+  if (!IsFunctionObject(promiseProto->getSlot(ctorShape->slot()), &ctorFun)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
-  if (ctorFun != promiseCtor) {
+  if (ctorFun != promiseCtor) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
   // Check condition 3:
   // Look up Promise.prototype.then and ensure it's a data property.
   Shape* thenShape = promiseProto->lookup(cx, cx->names().then);
-  if (!thenShape || !thenShape->isDataProperty()) {
+  if (!thenShape || !thenShape->isDataProperty()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -183,7 +183,7 @@ bool js::PromiseLookup::isPromiseStateSt
 
   // Ensure that Promise.prototype.constructor is the canonical constructor.
   if (promiseProto->getSlot(promiseProtoConstructorSlot_) !=
-      ObjectValue(*promiseCtor)) {
+      ObjectValue(*promiseCtor)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/vm/ProxyObject.cpp b/js/src/vm/ProxyObject.cpp
--- a/js/src/vm/ProxyObject.cpp
+++ b/js/src/vm/ProxyObject.cpp
@@ -96,7 +96,7 @@ ProxyObject* ProxyObject::New(JSContext*
   if (!realm->newProxyCache.lookup(clasp, proto, shape.address())) {
     shape =
         EmptyShape::getInitialShape(cx, clasp, realm, proto, /* nfixed = */ 0);
-    if (!shape) {
+    if (!shape) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
diff --git a/js/src/vm/Realm.cpp b/js/src/vm/Realm.cpp
--- a/js/src/vm/Realm.cpp
+++ b/js/src/vm/Realm.cpp
@@ -102,7 +102,7 @@ bool Realm::init(JSContext* cx, JSPrinci
    */
   js::ResetTimeZoneInternal(ResetTimeZoneMode::DontResetIfOffsetUnchanged);
 
-  if (!objects_.init(cx)) {
+  if (!objects_.init(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -131,13 +131,13 @@ bool JSRuntime::createJitRuntime(JSConte
 
   if (!CanLikelyAllocateMoreExecutableMemory()) {
     // Try to release memory first instead of potentially reporting OOM below.
-    if (OnLargeAllocationFailure) {
+    if (OnLargeAllocationFailure) {MOZ_RELEASE_ASSERT(0);
       OnLargeAllocationFailure();
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   jit::JitRuntime* jrt = cx->new_<jit::JitRuntime>();
-  if (!jrt) {
+  if (!jrt) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -161,12 +161,12 @@ bool Realm::ensureJitRealmExists(JSConte
     return true;
   }
 
-  if (!zone()->getJitZone(cx)) {
+  if (!zone()->getJitZone(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   UniquePtr<JitRealm> jitRealm = cx->make_unique<JitRealm>();
-  if (!jitRealm) {
+  if (!jitRealm) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -195,7 +195,7 @@ ObjectRealm::getOrCreateNonSyntacticLexi
 
   if (!nonSyntacticLexicalEnvironments_) {
     auto map = cx->make_unique<ObjectWeakMap>(cx);
-    if (!map) {
+    if (!map) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -209,7 +209,7 @@ ObjectRealm::getOrCreateNonSyntacticLexi
                !key->is<EnvironmentObject>());
     lexicalEnv =
         NonSyntacticLexicalEnvironmentObject::create(cx, enclosing, thisv);
-    if (!lexicalEnv) {
+    if (!lexicalEnv) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (!nonSyntacticLexicalEnvironments_->add(cx, key, lexicalEnv)) {
@@ -248,12 +248,12 @@ NonSyntacticLexicalEnvironmentObject*
 ObjectRealm::getNonSyntacticLexicalEnvironment(JSObject* key) const {
   MOZ_ASSERT(&ObjectRealm::get(key) == this);
 
-  if (!nonSyntacticLexicalEnvironments_) {
+  if (!nonSyntacticLexicalEnvironments_) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   // If a wrapped WithEnvironmentObject was passed in, unwrap it as in
   // getOrCreateNonSyntacticLexicalEnvironment.
-  if (key->is<WithEnvironmentObject>()) {
+  if (key->is<WithEnvironmentObject>()) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(!key->as<WithEnvironmentObject>().isSyntactic());
     key = &key->as<WithEnvironmentObject>().object();
   }
@@ -303,7 +303,7 @@ void ObjectRealm::trace(JSTracer* trc) {
 
 void Realm::traceRoots(JSTracer* trc,
                        js::gc::GCRuntime::TraceOrMarkRuntime traceOrMark) {
-  if (objectMetadataState_.is<PendingMetadata>()) {
+  if (objectMetadataState_.is<PendingMetadata>()) {MOZ_RELEASE_ASSERT(0);
     GCPolicy<NewObjectMetadataState>::trace(trc, &objectMetadataState_,
                                             "on-stack object pending metadata");
   }
@@ -519,7 +519,7 @@ void Realm::setNewObjectMetadata(JSConte
 
     if (!objects_.objectMetadataTable) {
       auto table = cx->make_unique<ObjectWeakMap>(cx);
-      if (!table) {
+      if (!table) {MOZ_RELEASE_ASSERT(0);
         oomUnsafe.crash("setNewObjectMetadata");
       }
 
@@ -796,7 +796,7 @@ JS_PUBLIC_API Realm* JS::GetFunctionReal
   RootedObject obj(cx, objArg);
   while (true) {
     obj = CheckedUnwrapStatic(obj);
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       ReportAccessDenied(cx);
       return nullptr;
     }
diff --git a/js/src/vm/RegExpObject.cpp b/js/src/vm/RegExpObject.cpp
--- a/js/src/vm/RegExpObject.cpp
+++ b/js/src/vm/RegExpObject.cpp
@@ -68,7 +68,7 @@ RegExpObject* js::RegExpAlloc(JSContext*
                               HandleObject proto /* = nullptr */) {
   Rooted<RegExpObject*> regexp(
       cx, NewObjectWithClassProtoAndKind<RegExpObject>(cx, proto, newKind));
-  if (!regexp) {
+  if (!regexp) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -224,7 +224,7 @@ RegExpObject* RegExpObject::create(JSCon
   frontend::DummyTokenStream dummyTokenStream(cx, dummyOptions);
 
   LifoAllocScope allocScope(&cx->tempLifoAlloc());
-  if (!irregexp::CheckPatternSyntax(cx, dummyTokenStream, source, flags)) {
+  if (!irregexp::CheckPatternSyntax(cx, dummyTokenStream, source, flags)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -345,7 +345,7 @@ static MOZ_ALWAYS_INLINE bool SetupBuffe
                                           const CharT* oldChars, size_t oldLen,
                                           const CharT* it) {
   if constexpr (std::is_same_v<CharT, char16_t>) {
-    if (!sb.ensureTwoByteChars()) {
+    if (!sb.ensureTwoByteChars()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -377,11 +377,11 @@ static bool EscapeRegExpPattern(StringBu
         if (sb.empty()) {
           // This is the first char we've seen that needs escaping,
           // copy everything up to this point.
-          if (!SetupBuffer(sb, oldChars, oldLen, it)) {
+          if (!SetupBuffer(sb, oldChars, oldLen, it)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
-        if (!sb.append('\\')) {
+        if (!sb.append('\\')) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else if (ch == '[') {
@@ -394,20 +394,20 @@ static bool EscapeRegExpPattern(StringBu
       if (sb.empty()) {
         // This is the first char we've seen that needs escaping,
         // copy everything up to this point.
-        if (!SetupBuffer(sb, oldChars, oldLen, it)) {
+        if (!SetupBuffer(sb, oldChars, oldLen, it)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
       if (!previousCharacterWasBackslash) {
-        if (!sb.append('\\')) {
+        if (!sb.append('\\')) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
-      if (!AppendEscapedLineTerminator(sb, ch)) {
+      if (!AppendEscapedLineTerminator(sb, ch)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (!sb.empty()) {
-      if (!sb.append(ch)) {
+      if (!sb.append(ch)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -434,7 +434,7 @@ JSLinearString* js::EscapeRegExpPattern(
 
   if (src->hasLatin1Chars()) {
     JS::AutoCheckCannotGC nogc;
-    if (!::EscapeRegExpPattern(sb, src->latin1Chars(nogc), src->length())) {
+    if (!::EscapeRegExpPattern(sb, src->latin1Chars(nogc), src->length())) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
@@ -453,7 +453,7 @@ JSLinearString* RegExpObject::toString(J
                                        Handle<RegExpObject*> obj) {
   // Steps 3-4.
   RootedAtom src(cx, obj->getSource());
-  if (!src) {
+  if (!src) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   RootedLinearString escapedSrc(cx, EscapeRegExpPattern(cx, src));
@@ -461,32 +461,32 @@ JSLinearString* RegExpObject::toString(J
   // Step 7.
   JSStringBuilder sb(cx);
   size_t len = escapedSrc->length();
-  if (!sb.reserve(len + 2)) {
+  if (!sb.reserve(len + 2)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   sb.infallibleAppend('/');
-  if (!sb.append(escapedSrc)) {
+  if (!sb.append(escapedSrc)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   sb.infallibleAppend('/');
 
   // Steps 5-7.
-  if (obj->hasIndices() && !sb.append('d')) {
+  if (obj->hasIndices() && !sb.append('d')) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
-  if (obj->global() && !sb.append('g')) {
+  if (obj->global() && !sb.append('g')) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
-  if (obj->ignoreCase() && !sb.append('i')) {
+  if (obj->ignoreCase() && !sb.append('i')) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
-  if (obj->multiline() && !sb.append('m')) {
+  if (obj->multiline() && !sb.append('m')) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
-  if (obj->dotAll() && !sb.append('s')) {
+  if (obj->dotAll() && !sb.append('s')) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
-  if (obj->unicode() && !sb.append('u')) {
+  if (obj->unicode() && !sb.append('u')) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (obj->sticky() && !sb.append('y')) {
@@ -606,7 +606,7 @@ bool RegExpShared::compileIfNecessary(JS
   }
 
   // Fall back to bytecode if native codegen is not available.
-  if (!IsNativeRegExpEnabled() && codeKind == RegExpShared::CodeKind::Jitcode) {
+  if (!IsNativeRegExpEnabled() && codeKind == RegExpShared::CodeKind::Jitcode) {MOZ_RELEASE_ASSERT(0);
     codeKind = RegExpShared::CodeKind::Bytecode;
   }
 
@@ -643,7 +643,7 @@ RegExpRunStatus RegExpShared::execute(JS
    * Ensure sufficient memory for output vector.
    * No need to initialize it. The RegExp engine fills them in on a match.
    */
-  if (!matches->allocOrExpandArray(re->pairCount())) {
+  if (!matches->allocOrExpandArray(re->pairCount())) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return RegExpRunStatus_Error;
   }
@@ -656,7 +656,7 @@ RegExpRunStatus RegExpShared::execute(JS
    * Ensure sufficient memory for output vector.
    * No need to initialize it. The RegExp engine fills them in on a match.
    */
-  if (!matches->allocOrExpandArray(re->pairCount())) {
+  if (!matches->allocOrExpandArray(re->pairCount())) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return RegExpRunStatus_Error;
   }
@@ -738,7 +738,7 @@ bool RegExpShared::initializeNamedCaptur
   // Create a plain template object.
   RootedPlainObject templateObject(
       cx, NewTenuredObjectWithGivenProto<PlainObject>(cx, nullptr));
-  if (!templateObject) {
+  if (!templateObject) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -749,7 +749,7 @@ bool RegExpShared::initializeNamedCaptur
     JSString* name = namedCaptures->getDenseElement(i * 2).toString();
     id = NameToId(name->asAtom().asPropertyName());
     if (!NativeDefineDataProperty(cx, templateObject, id, dummyString,
-                                  JSPROP_ENUMERATE)) {
+                                  JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -757,7 +757,7 @@ bool RegExpShared::initializeNamedCaptur
   // Allocate the capture index array.
   uint32_t arraySize = numNamedCaptures * sizeof(uint32_t);
   uint32_t* captureIndices = static_cast<uint32_t*>(js_malloc(arraySize));
-  if (!captureIndices) {
+  if (!captureIndices) {MOZ_RELEASE_ASSERT(0);
     js::ReportOutOfMemory(cx);
     return false;
   }
@@ -782,7 +782,7 @@ void RegExpShared::tierUpTick() {
 }
 
 bool RegExpShared::markedForTierUp() const {
-  if (!IsNativeRegExpEnabled()) {
+  if (!IsNativeRegExpEnabled()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (kind() != RegExpShared::Kind::RegExp) {
@@ -799,12 +799,12 @@ static RegExpRunStatus ExecuteAtomImpl(R
 
   if (re->sticky()) {
     // First part checks size_t overflow.
-    if (searchLength + start < searchLength || searchLength + start > length) {
+    if (searchLength + start < searchLength || searchLength + start > length) {MOZ_RELEASE_ASSERT(0);
       return RegExpRunStatus_Success_NotFound;
     }
-    if (!HasSubstringAt(input, re->patternAtom(), start)) {
+    if (!HasSubstringAt(input, re->patternAtom(), start)) {MOZ_RELEASE_ASSERT(0);
       return RegExpRunStatus_Success_NotFound;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     (*matches)[0].start = start;
     (*matches)[0].limit = start + searchLength;
@@ -873,7 +873,7 @@ ArrayObject* RegExpRealm::createMatchRes
   RootedArrayObject templateObject(
       cx, NewDenseUnallocatedArray(cx, RegExpObject::MaxPairCount, nullptr,
                                    TenuredObject));
-  if (!templateObject) {
+  if (!templateObject) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -881,7 +881,7 @@ ArrayObject* RegExpRealm::createMatchRes
     /* The |indices| array only has a |groups| property. */
     RootedValue groupsVal(cx, UndefinedValue());
     if (!NativeDefineDataProperty(cx, templateObject, cx->names().groups,
-                                  groupsVal, JSPROP_ENUMERATE)) {
+                                  groupsVal, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     MOZ_ASSERT(templateObject->lastProperty()->slot() == IndicesGroupsSlot);
@@ -893,7 +893,7 @@ ArrayObject* RegExpRealm::createMatchRes
   /* Set dummy index property */
   RootedValue index(cx, Int32Value(0));
   if (!NativeDefineDataProperty(cx, templateObject, cx->names().index, index,
-                                JSPROP_ENUMERATE)) {
+                                JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   MOZ_ASSERT(templateObject->lastProperty()->slot() ==
@@ -902,7 +902,7 @@ ArrayObject* RegExpRealm::createMatchRes
   /* Set dummy input property */
   RootedValue inputVal(cx, StringValue(cx->runtime()->emptyString));
   if (!NativeDefineDataProperty(cx, templateObject, cx->names().input, inputVal,
-                                JSPROP_ENUMERATE)) {
+                                JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   MOZ_ASSERT(templateObject->lastProperty()->slot() ==
@@ -911,7 +911,7 @@ ArrayObject* RegExpRealm::createMatchRes
   /* Set dummy groups property */
   RootedValue groupsVal(cx, UndefinedValue());
   if (!NativeDefineDataProperty(cx, templateObject, cx->names().groups,
-                                groupsVal, JSPROP_ENUMERATE)) {
+                                groupsVal, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   MOZ_ASSERT(templateObject->lastProperty()->slot() ==
@@ -987,7 +987,7 @@ JSObject* js::CloneRegExpObject(JSContex
   Rooted<TaggedProto> proto(cx, regex->staticPrototype());
   Rooted<RegExpObject*> clone(
       cx, NewObjectWithGivenTaggedProto<RegExpObject>(cx, proto));
-  if (!clone) {
+  if (!clone) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1052,7 +1052,7 @@ static bool ParseRegExpFlags(const CharT
 bool js::ParseRegExpFlags(JSContext* cx, JSString* flagStr,
                           RegExpFlags* flagsOut) {
   JSLinearString* linear = flagStr->ensureLinear(cx);
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1064,7 +1064,7 @@ bool js::ParseRegExpFlags(JSContext* cx,
     AutoCheckCannotGC nogc;
     ok = ::ParseRegExpFlags(linear->latin1Chars(nogc), len, flagsOut,
                             &invalidFlag);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     AutoCheckCannotGC nogc;
     ok = ::ParseRegExpFlags(linear->twoByteChars(nogc), len, flagsOut,
                             &invalidFlag);
@@ -1137,7 +1137,7 @@ JS::ubi::Node::Size JS::ubi::Concrete<Re
  * Regular Expressions.
  */
 JS_PUBLIC_API JSObject* JS::NewRegExpObject(JSContext* cx, const char* bytes,
-                                            size_t length, RegExpFlags flags) {
+                                            size_t length, RegExpFlags flags) {MOZ_RELEASE_ASSERT(0);
   AssertHeapIsIdle();
   CHECK_THREAD(cx);
 
@@ -1160,7 +1160,7 @@ JS_PUBLIC_API JSObject* JS::NewUCRegExpO
 }
 
 JS_PUBLIC_API bool JS::SetRegExpInput(JSContext* cx, HandleObject obj,
-                                      HandleString input) {
+                                      HandleString input) {MOZ_RELEASE_ASSERT(0);
   AssertHeapIsIdle();
   CHECK_THREAD(cx);
   cx->check(input);
@@ -1175,7 +1175,7 @@ JS_PUBLIC_API bool JS::SetRegExpInput(JS
   return true;
 }
 
-JS_PUBLIC_API bool JS::ClearRegExpStatics(JSContext* cx, HandleObject obj) {
+JS_PUBLIC_API bool JS::ClearRegExpStatics(JSContext* cx, HandleObject obj) {MOZ_RELEASE_ASSERT(0);
   AssertHeapIsIdle();
   CHECK_THREAD(cx);
   MOZ_ASSERT(obj);
@@ -1193,15 +1193,15 @@ JS_PUBLIC_API bool JS::ClearRegExpStatic
 JS_PUBLIC_API bool JS::ExecuteRegExp(JSContext* cx, HandleObject obj,
                                      HandleObject reobj, char16_t* chars,
                                      size_t length, size_t* indexp, bool test,
-                                     MutableHandleValue rval) {
+                                     MutableHandleValue rval) {MOZ_RELEASE_ASSERT(0);
   AssertHeapIsIdle();
   CHECK_THREAD(cx);
 
   Handle<GlobalObject*> global = obj.as<GlobalObject>();
   RegExpStatics* res = GlobalObject::getRegExpStatics(cx, global);
-  if (!res) {
+  if (!res) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedLinearString input(cx, NewStringCopyN<CanGC>(cx, chars, length));
   if (!input) {
@@ -1281,7 +1281,7 @@ JS_PUBLIC_API bool JS::CheckRegExpSyntax
   error.set(UndefinedValue());
   if (!success) {
     // We can fail because of OOM or over-recursion even if the syntax is valid.
-    if (cx->isThrowingOutOfMemory() || cx->isThrowingOverRecursed()) {
+    if (cx->isThrowingOutOfMemory() || cx->isThrowingOverRecursed()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!cx->getPendingException(error)) {
diff --git a/js/src/vm/RegExpStatics.cpp b/js/src/vm/RegExpStatics.cpp
--- a/js/src/vm/RegExpStatics.cpp
+++ b/js/src/vm/RegExpStatics.cpp
@@ -81,7 +81,7 @@ bool RegExpStatics::executeLazy(JSContex
   RootedAtom source(cx, lazySource);
   RootedRegExpShared shared(cx,
                             cx->zone()->regExps().get(cx, source, lazyFlags));
-  if (!shared) {
+  if (!shared) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/vm/Runtime.cpp b/js/src/vm/Runtime.cpp
--- a/js/src/vm/Runtime.cpp
+++ b/js/src/vm/Runtime.cpp
@@ -200,7 +200,7 @@ bool JSRuntime::init(JSContext* cx, uint
   initialized_ = true;
 #endif
 
-  if (CanUseExtraThreads() && !EnsureHelperThreadsInitialized()) {
+  if (CanUseExtraThreads() && !EnsureHelperThreadsInitialized()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -208,12 +208,12 @@ bool JSRuntime::init(JSContext* cx, uint
 
   defaultFreeOp_ = cx->defaultFreeOp();
 
-  if (!gc.init(maxbytes)) {
+  if (!gc.init(maxbytes)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   UniquePtr<Zone> atomsZone = MakeUnique<Zone>(this, Zone::AtomsZone);
-  if (!atomsZone || !atomsZone->init()) {
+  if (!atomsZone || !atomsZone->init()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -224,7 +224,7 @@ bool JSRuntime::init(JSContext* cx, uint
   // initialized.
   gcInitialized = true;
 
-  if (!InitRuntimeNumberState(this)) {
+  if (!InitRuntimeNumberState(this)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -257,7 +257,7 @@ void JSRuntime::destroyRuntime() {
      * list is empty in CancelOffThreadParses.
      */
     JSContext* cx = mainContextFromOwnThread();
-    if (JS::IsIncrementalGCInProgress(cx)) {
+    if (JS::IsIncrementalGCInProgress(cx)) {MOZ_RELEASE_ASSERT(0);
       gc::FinishGC(cx);
     }
 
@@ -365,7 +365,7 @@ void JSRuntime::addSizeOfIncludingThis(m
   rtSizes->interpreterStack +=
       cx->interpreterStack().sizeOfExcludingThis(mallocSizeOf);
 #ifdef JS_TRACE_LOGGING
-  if (cx->traceLogger) {
+  if (cx->traceLogger) {MOZ_RELEASE_ASSERT(0);
     rtSizes->tracelogger += cx->traceLogger->sizeOfIncludingThis(mallocSizeOf);
   }
 #endif
@@ -426,7 +426,7 @@ static bool HandleInterrupt(JSContext* c
   // Important: Additional callbacks can occur inside the callback handler
   // if it re-enters the JS engine. The embedding must ensure that the
   // callback is disconnected before attempting such re-entry.
-  if (cx->interruptCallbackDisabled) {
+  if (cx->interruptCallbackDisabled) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -460,7 +460,7 @@ static bool HandleInterrupt(JSContext* c
   UniqueTwoByteChars stringChars;
   if (stack) {
     stringChars = JS_CopyStringCharsZ(cx, stack);
-    if (!stringChars) {
+    if (!stringChars) {MOZ_RELEASE_ASSERT(0);
       cx->recoverFromOutOfMemory();
     }
   }
@@ -506,7 +506,7 @@ bool JSContext::handleInterrupt() {
 }
 
 bool JSRuntime::setDefaultLocale(const char* locale) {
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -535,17 +535,17 @@ const char* JSRuntime::getDefaultLocale(
 #endif
 
   // convert to a well-formed BCP 47 language tag
-  if (!locale || !strcmp(locale, "C")) {
+  if (!locale || !strcmp(locale, "C")) {MOZ_RELEASE_ASSERT(0);
     locale = "und";
   }
 
   UniqueChars lang = DuplicateString(mainContextFromOwnThread(), locale);
-  if (!lang) {
+  if (!lang) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   char* p;
-  if ((p = strchr(lang.get(), '.'))) {
+  if ((p = strchr(lang.get(), '.'))) {MOZ_RELEASE_ASSERT(0);
     *p = '\0';
   }
   while ((p = strchr(lang.get(), '_'))) {
@@ -688,7 +688,7 @@ JS_FRIEND_API void* JSRuntime::onOutOfMe
                                              JSContext* maybecx) {
   MOZ_ASSERT_IF(allocFunc != AllocFunction::Realloc, !reallocPtr);
 
-  if (JS::RuntimeHeapIsBusy()) {
+  if (JS::RuntimeHeapIsBusy()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/vm/SavedStacks.cpp b/js/src/vm/SavedStacks.cpp
--- a/js/src/vm/SavedStacks.cpp
+++ b/js/src/vm/SavedStacks.cpp
@@ -304,7 +304,7 @@ bool SavedFrame::HashPolicy::match(Saved
     return false;
   }
 
-  if (existing->getColumn() != lookup.column) {
+  if (existing->getColumn() != lookup.column) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -312,17 +312,17 @@ bool SavedFrame::HashPolicy::match(Saved
     return false;
   }
 
-  if (existing->getPrincipals() != lookup.principals) {
+  if (existing->getPrincipals() != lookup.principals) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JSAtom* source = existing->getSource();
-  if (source != lookup.source) {
+  if (source != lookup.source) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JSAtom* functionDisplayName = existing->getFunctionDisplayName();
-  if (functionDisplayName != lookup.functionDisplayName) {
+  if (functionDisplayName != lookup.functionDisplayName) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -664,12 +664,12 @@ static SavedFrame* GetFirstSubsumedFrame
 JS_FRIEND_API JSObject* GetFirstSubsumedSavedFrame(
     JSContext* cx, JSPrincipals* principals, HandleObject savedFrame,
     JS::SavedFrameSelfHosted selfHosted) {
-  if (!savedFrame) {
+  if (!savedFrame) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   auto subsumes = cx->runtime()->securityCallbacks->subsumes;
-  if (!subsumes) {
+  if (!subsumes) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -689,7 +689,7 @@ JS_FRIEND_API JSObject* GetFirstSubsumed
                                                MutableHandleObject frame) {
   const Value& thisValue = args.thisv();
 
-  if (!thisValue.isObject()) {
+  if (!thisValue.isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_OBJECT_REQUIRED,
                               InformalValueTypeName(thisValue));
@@ -1115,7 +1115,7 @@ JS_PUBLIC_API JSObject* ConvertSavedFram
   RootedValue v(cx);
 
   baseConverted = lastConverted = JS_NewObject(cx, nullptr);
-  if (!baseConverted) {
+  if (!baseConverted) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1126,14 +1126,14 @@ JS_PUBLIC_API JSObject* ConvertSavedFram
         !AssignProperty(cx, lastConverted, savedFrame, "line") ||
         !AssignProperty(cx, lastConverted, savedFrame, "column") ||
         !AssignProperty(cx, lastConverted, savedFrame, "functionDisplayName") ||
-        !AssignProperty(cx, lastConverted, savedFrame, "asyncCause")) {
+        !AssignProperty(cx, lastConverted, savedFrame, "asyncCause")) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     const char* parentProperties[] = {"parent", "asyncParent"};
     foundParent = false;
     for (const char* prop : parentProperties) {
-      if (!JS_GetProperty(cx, savedFrame, prop, &v)) {
+      if (!JS_GetProperty(cx, savedFrame, prop, &v)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       if (v.isObject()) {
@@ -1165,7 +1165,7 @@ bool SavedFrame::sourceProperty(JSContex
   RootedString source(cx);
   if (JS::GetSavedFrameSource(cx, principals, frame, &source) ==
       JS::SavedFrameResult::Ok) {
-    if (!cx->compartment()->wrap(cx, &source)) {
+    if (!cx->compartment()->wrap(cx, &source)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     args.rval().setString(source);
@@ -1226,7 +1226,7 @@ bool SavedFrame::functionDisplayNameProp
   JS::SavedFrameResult result =
       JS::GetSavedFrameFunctionDisplayName(cx, principals, frame, &name);
   if (result == JS::SavedFrameResult::Ok && name) {
-    if (!cx->compartment()->wrap(cx, &name)) {
+    if (!cx->compartment()->wrap(cx, &name)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     args.rval().setString(name);
@@ -1244,7 +1244,7 @@ bool SavedFrame::asyncCauseProperty(JSCo
   JS::SavedFrameResult result =
       JS::GetSavedFrameAsyncCause(cx, principals, frame, &asyncCause);
   if (result == JS::SavedFrameResult::Ok && asyncCause) {
-    if (!cx->compartment()->wrap(cx, &asyncCause)) {
+    if (!cx->compartment()->wrap(cx, &asyncCause)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     args.rval().setString(asyncCause);
@@ -1316,7 +1316,7 @@ bool SavedStacks::copyAsyncStack(JSConte
   MOZ_DIAGNOSTIC_ASSERT(&cx->realm()->savedStacks() == this);
 
   RootedAtom asyncCauseAtom(cx, AtomizeString(cx, asyncCause));
-  if (!asyncCauseAtom) {
+  if (!asyncCauseAtom) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1449,7 +1449,7 @@ bool SavedStacks::insertFrames(JSContext
     if (capture.is<JS::AllFrames>() && framePtr &&
         framePtr->hasCachedSavedFrame()) {
       auto* cache = activation.getLiveSavedFrameCache(cx);
-      if (!cache) {
+      if (!cache) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       cache->find(cx, *framePtr, iter.pc(), &cachedParentFrame);
@@ -1475,7 +1475,7 @@ bool SavedStacks::insertFrames(JSContext
     Rooted<LocationValue> location(cx);
     {
       AutoRealmUnchecked ar(cx, iter.realm());
-      if (!cx->realm()->savedStacks().getLocation(cx, iter, &location)) {
+      if (!cx->realm()->savedStacks().getLocation(cx, iter, &location)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1490,7 +1490,7 @@ bool SavedStacks::insertFrames(JSContext
                                 nullptr,  // asyncCause
                                 nullptr,  // parent (not known yet)
                                 principals, iter.mutedErrors(), framePtr,
-                                iter.pc(), &activation)) {
+                                iter.pc(), &activation)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
@@ -1527,9 +1527,9 @@ bool SavedStacks::insertFrames(JSContext
       // different strings used.
       const char* cause = activation.asyncCause();
       RootedAtom causeAtom(cx, AtomizeUTF8Chars(cx, cause, strlen(cause)));
-      if (!causeAtom) {
+      if (!causeAtom) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       // Translate our capture into a frame count limit for
       // adoptAsyncStack, which will impose further limits.
@@ -1542,7 +1542,7 @@ bool SavedStacks::insertFrames(JSContext
       // Clip the stack if needed, attach the async cause string to the
       // top frame, and copy it into our compartment if necessary.
       RootedSavedFrame asyncParent(cx, activation.asyncStack());
-      if (!adoptAsyncStack(cx, &asyncParent, causeAtom, maxFrames)) {
+      if (!adoptAsyncStack(cx, &asyncParent, causeAtom, maxFrames)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       stackChain[stackChain.length() - 1].setParent(asyncParent);
@@ -1582,7 +1582,7 @@ bool SavedStacks::insertFrames(JSContext
     // evalInFramePrev links, so that the parent is always the last frame we
     // created.
     if (capture.is<JS::AllFrames>() && lookup.framePtr()) {
-      if (!checkForEvalInFramePrev(cx, lookup)) {
+      if (!checkForEvalInFramePrev(cx, lookup)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1622,7 +1622,7 @@ bool SavedStacks::adoptAsyncStack(JSCont
   Rooted<js::GCLookupVector> stackChain(cx, js::GCLookupVector(cx));
   SavedFrame* currentSavedFrame = asyncStack;
   while (currentSavedFrame && stackChain.length() < maxFrames) {
-    if (!stackChain.emplaceBack(*currentSavedFrame)) {
+    if (!stackChain.emplaceBack(*currentSavedFrame)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
@@ -1717,7 +1717,7 @@ bool SavedStacks::checkForEvalInFramePre
     // something in the top cache, and all the lower ones should exist
     // already.
     auto* cache = act->getLiveSavedFrameCache(cx);
-    if (!cache) {
+    if (!cache) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1793,13 +1793,13 @@ bool SavedStacks::getLocation(JSContext*
 
   if (iter.isWasm()) {
     // Only asm.js has a displayURL.
-    if (const char16_t* displayURL = iter.displayURL()) {
+    if (const char16_t* displayURL = iter.displayURL()) {MOZ_RELEASE_ASSERT(0);
       locationp.setSource(AtomizeChars(cx, displayURL, js_strlen(displayURL)));
     } else {
       const char* filename = iter.filename() ? iter.filename() : "";
       locationp.setSource(Atomize(cx, filename, strlen(filename)));
     }
-    if (!locationp.source()) {
+    if (!locationp.source()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1824,7 +1824,7 @@ bool SavedStacks::getLocation(JSContext*
       const char* filename = script->filename() ? script->filename() : "";
       source = Atomize(cx, filename, strlen(filename));
     }
-    if (!source) {
+    if (!source) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1858,7 +1858,7 @@ void SavedStacks::chooseSamplingProbabil
   // Use unbarriered version to prevent triggering read barrier while
   // collecting, this is safe as long as global does not escape.
   GlobalObject* global = realm->unsafeUnbarrieredMaybeGlobal();
-  if (!global) {
+  if (!global) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -1892,12 +1892,12 @@ JSObject* SavedStacks::MetadataBuilder::
   }
 
   RootedSavedFrame frame(cx);
-  if (!stacks.saveCurrentStack(cx, &frame)) {
+  if (!stacks.saveCurrentStack(cx, &frame)) {MOZ_RELEASE_ASSERT(0);
     oomUnsafe.crash("SavedStacksMetadataBuilder");
   }
 
   if (!DebugAPI::onLogAllocationSite(cx, obj, frame,
-                                     mozilla::TimeStamp::Now())) {
+                                     mozilla::TimeStamp::Now())) {MOZ_RELEASE_ASSERT(0);
     oomUnsafe.crash("SavedStacksMetadataBuilder");
   }
 
@@ -1931,7 +1931,7 @@ ReconstructedSavedFramePrincipals
     ReconstructedSavedFramePrincipals::IsNotSystem;
 
 UniqueChars BuildUTF8StackString(JSContext* cx, JSPrincipals* principals,
-                                 HandleObject stack) {
+                                 HandleObject stack) {MOZ_RELEASE_ASSERT(0);
   RootedString stackStr(cx);
   if (!JS::BuildStackString(cx, principals, stack, &stackStr)) {
     return nullptr;
@@ -2010,7 +2010,7 @@ JS_PUBLIC_API bool ConstructSavedFrameSt
     js::RootedAtom source(cx);
     AtomizingMatcher atomizer(cx, ubiFrame.get().sourceLength());
     source = ubiFrame.get().source().match(atomizer);
-    if (!source) {
+    if (!source) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2020,7 +2020,7 @@ JS_PUBLIC_API bool ConstructSavedFrameSt
       AtomizingMatcher atomizer(cx, nameLength);
       functionDisplayName =
           ubiFrame.get().functionDisplayName().match(atomizer);
-      if (!functionDisplayName) {
+      if (!functionDisplayName) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2033,7 +2033,7 @@ JS_PUBLIC_API bool ConstructSavedFrameSt
                                 functionDisplayName,
                                 /* asyncCause */ nullptr,
                                 /* parent */ nullptr, principals,
-                                /* mutedErrors */ true)) {
+                                /* mutedErrors */ true)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
diff --git a/js/src/vm/Scope.cpp b/js/src/vm/Scope.cpp
--- a/js/src/vm/Scope.cpp
+++ b/js/src/vm/Scope.cpp
@@ -35,7 +35,7 @@ using namespace js::frontend;
 
 using mozilla::Maybe;
 
-const char* js::BindingKindString(BindingKind kind) {
+const char* js::BindingKindString(BindingKind kind) {MOZ_RELEASE_ASSERT(0);
   switch (kind) {
     case BindingKind::Import:
       return "import";
@@ -123,7 +123,7 @@ Shape* js::CreateEnvironmentShape(JSCont
                                   const JSClass* cls, uint32_t numSlots,
                                   ObjectFlags objectFlags) {
   RootedShape shape(cx, EmptyEnvironmentShape(cx, cls, numSlots, objectFlags));
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -146,16 +146,16 @@ Shape* js::CreateEnvironmentShape(JSCont
 Shape* js::CreateEnvironmentShape(
     JSContext* cx, frontend::CompilationAtomCache& atomCache,
     AbstractBindingIter<frontend::TaggedParserAtomIndex>& bi,
-    const JSClass* cls, uint32_t numSlots, ObjectFlags objectFlags) {
+    const JSClass* cls, uint32_t numSlots, ObjectFlags objectFlags) {MOZ_RELEASE_ASSERT(0);
   RootedShape shape(cx, EmptyEnvironmentShape(cx, cls, numSlots, objectFlags));
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedAtom name(cx);
-  for (; bi; bi++) {
+  for (; bi; bi++) {MOZ_RELEASE_ASSERT(0);
     BindingLocation loc = bi.location();
-    if (loc.kind() == BindingLocation::Kind::Environment) {
+    if (loc.kind() == BindingLocation::Kind::Environment) {MOZ_RELEASE_ASSERT(0);
       name = atomCache.getExistingAtomAt(cx, bi.name());
       MOZ_ASSERT(name);
       cx->markAtom(name);
@@ -310,7 +310,7 @@ static UniquePtr<typename ConcreteScope:
   // Convert all scope ParserAtoms to rooted JSAtoms.
   // Rooting is necessary as conversion can gc.
   JS::RootedVector<JSAtom*> jsatoms(cx);
-  if (!jsatoms.reserve(data->length)) {
+  if (!jsatoms.reserve(data->length)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   auto names = GetScopeDataTrailingNames(data);
@@ -326,7 +326,7 @@ static UniquePtr<typename ConcreteScope:
   // Allocate a new scope-data of the right kind.
   UniquePtr<ConcreteData> scopeData(
       NewEmptyScopeData<ConcreteScope, JSAtom>(cx, data->length));
-  if (!scopeData) {
+  if (!scopeData) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -409,7 +409,7 @@ XDRResult Scope::XDRSizedBindingNames(
     data.set(&scope->data());
   } else {
     data.set(NewEmptyScopeData<ConcreteScope, JSAtom>(cx, length).release());
-    if (!data) {
+    if (!data) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Throw);
     }
   }
@@ -475,7 +475,7 @@ inline void Scope::initData(
 template <typename EnvironmentT>
 bool Scope::updateEnvShapeIfRequired(JSContext* cx, MutableHandleShape envShape,
                                      bool needsEnvironment) {
-  if (!envShape && needsEnvironment) {
+  if (!envShape && needsEnvironment) {MOZ_RELEASE_ASSERT(0);
     envShape.set(EmptyEnvironmentShape<EnvironmentT>(cx));
     if (!envShape) {
       return false;
@@ -557,7 +557,7 @@ Scope* Scope::clone(JSContext* cx, Handl
   RootedShape envShape(cx);
   if (scope->environmentShape()) {
     envShape = scope->maybeCloneEnvironmentShape(cx);
-    if (!envShape) {
+    if (!envShape) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -652,9 +652,9 @@ size_t Scope::sizeOfExcludingThis(mozill
   return 0;
 }
 
-void Scope::dump() {
+void Scope::dump() {MOZ_RELEASE_ASSERT(0);
   JSContext* cx = TlsContext.get();
-  if (!cx) {
+  if (!cx) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "*** can't get JSContext for current thread\n");
     return;
   }
@@ -829,7 +829,7 @@ LexicalScope* LexicalScope::createWithDa
   RootedShape envShape(cx);
 
   if (!prepareForScopeCreation<JSAtom>(cx, kind, firstFrameSlot, data,
-                                       &envShape)) {
+                                       &envShape)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -920,7 +920,7 @@ bool FunctionScope::prepareForScopeCreat
   uint32_t firstFrameSlot = 0;
   AbstractBindingIter<AtomT> bi(*data, hasParameterExprs);
   if (!PrepareScopeData<FunctionScope, AtomT, CallObject>(
-          cx, bi, data, firstFrameSlot, envShape)) {
+          cx, bi, data, firstFrameSlot, envShape)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -984,7 +984,7 @@ FunctionScope* FunctionScope::clone(JSCo
   RootedShape envShape(cx);
   if (scope->environmentShape()) {
     envShape = scope->maybeCloneEnvironmentShape(cx);
-    if (!envShape) {
+    if (!envShape) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -1128,7 +1128,7 @@ XDRResult VarScope::XDR(XDRState<mode>* 
     MOZ_TRY(xdr->codeUint32(&nextFrameSlot));
 
     if (mode == XDR_DECODE) {
-      if (!data->length) {
+      if (!data->length) {MOZ_RELEASE_ASSERT(0);
         MOZ_ASSERT(!data->slotInfo.nextFrameSlot);
       }
 
@@ -1299,7 +1299,7 @@ bool EvalScope::prepareForScopeCreation(
 /* static */
 EvalScope* EvalScope::createWithData(JSContext* cx, ScopeKind scopeKind,
                                      MutableHandle<UniquePtr<RuntimeData>> data,
-                                     HandleScope enclosing) {
+                                     HandleScope enclosing) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(data);
 
   RootedShape envShape(cx);
@@ -1329,22 +1329,22 @@ Scope* EvalScope::nearestVarScopeForDire
 template <XDRMode mode>
 /* static */
 XDRResult EvalScope::XDR(XDRState<mode>* xdr, ScopeKind kind,
-                         HandleScope enclosing, MutableHandleScope scope) {
+                         HandleScope enclosing, MutableHandleScope scope) {MOZ_RELEASE_ASSERT(0);
   JSContext* cx = xdr->cx();
   Rooted<RuntimeData*> data(cx);
 
-  {
+  {MOZ_RELEASE_ASSERT(0);
     Maybe<Rooted<UniquePtr<RuntimeData>>> uniqueData;
-    if (mode == XDR_DECODE) {
+    if (mode == XDR_DECODE) {MOZ_RELEASE_ASSERT(0);
       uniqueData.emplace(cx, data);
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     MOZ_TRY(XDRSizedBindingNames<EvalScope>(xdr, scope.as<EvalScope>(), &data));
 
     if (mode == XDR_DECODE) {
-      if (!data->length) {
+      if (!data->length) {MOZ_RELEASE_ASSERT(0);
         MOZ_ASSERT(!data->slotInfo.nextFrameSlot);
-      }
+      }MOZ_RELEASE_ASSERT(0);
       scope.set(createWithData(cx, kind, &uniqueData.ref(), enclosing));
       if (!scope) {
         return xdr->fail(JS::TranscodeResult::Throw);
@@ -1422,7 +1422,7 @@ static JSAtom* GenerateWasmName(JSContex
                                 const char (&prefix)[ArrayLength],
                                 uint32_t index) {
   StringBuffer sb(cx);
-  if (!sb.append(prefix)) {
+  if (!sb.append(prefix)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (!NumberValueToStringBuffer(cx, Int32Value(index), sb)) {
@@ -1458,7 +1458,7 @@ XDRResult ModuleScope::XDR(XDRState<mode
     MOZ_TRY(xdr->codeUint32(&nextFrameSlot));
 
     if (mode == XDR_DECODE) {
-      if (!data->length) {
+      if (!data->length) {MOZ_RELEASE_ASSERT(0);
         MOZ_ASSERT(!data->slotInfo.varStart);
         MOZ_ASSERT(!data->slotInfo.letStart);
         MOZ_ASSERT(!data->slotInfo.constStart);
@@ -1522,13 +1522,13 @@ WasmInstanceScope* WasmInstanceScope::cr
 
   Rooted<UniquePtr<RuntimeData>> data(
       cx, NewEmptyScopeData<WasmInstanceScope, JSAtom>(cx, namesCount));
-  if (!data) {
+  if (!data) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   if (instance->instance().memory()) {
     JSAtom* wasmName = GenerateWasmName(cx, "memory", /* index = */ 0);
-    if (!wasmName) {
+    if (!wasmName) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1571,14 +1571,14 @@ WasmFunctionScope* WasmFunctionScope::cr
   size_t argsLength;
   wasm::StackResults unusedStackResults;
   if (!instance->instance().debug().debugGetLocalTypes(
-          funcIndex, &locals, &argsLength, &unusedStackResults)) {
+          funcIndex, &locals, &argsLength, &unusedStackResults)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   uint32_t namesCount = locals.length();
 
   Rooted<UniquePtr<RuntimeData>> data(
       cx, NewEmptyScopeData<WasmFunctionScope, JSAtom>(cx, namesCount));
-  if (!data) {
+  if (!data) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1869,14 +1869,14 @@ PositionalFormalParameterIter::Positiona
 PositionalFormalParameterIter::PositionalFormalParameterIter(JSScript* script)
     : PositionalFormalParameterIter(script->bodyScope()) {}
 
-void js::DumpBindings(JSContext* cx, Scope* scopeArg) {
+void js::DumpBindings(JSContext* cx, Scope* scopeArg) {MOZ_RELEASE_ASSERT(0);
   RootedScope scope(cx, scopeArg);
-  for (Rooted<BindingIter> bi(cx, BindingIter(scope)); bi; bi++) {
+  for (Rooted<BindingIter> bi(cx, BindingIter(scope)); bi; bi++) {MOZ_RELEASE_ASSERT(0);
     UniqueChars bytes = AtomToPrintableString(cx, bi.name());
-    if (!bytes) {
+    if (!bytes) {MOZ_RELEASE_ASSERT(0);
       MaybePrintAndClearPendingException(cx);
       return;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "    %s %s ", BindingKindString(bi.kind()), bytes.get());
     switch (bi.location().kind()) {
       case BindingLocation::Kind::Global:
@@ -1936,7 +1936,7 @@ JSAtom* js::FrameSlotName(JSScript* scri
 
   // If not found, look for it in a lexical scope.
   for (ScopeIter si(script->innermostScope(pc)); si; si++) {
-    if (!si.scope()->is<LexicalScope>()) {
+    if (!si.scope()->is<LexicalScope>()) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
     LexicalScope& lexicalScope = si.scope()->as<LexicalScope>();
@@ -1945,7 +1945,7 @@ JSAtom* js::FrameSlotName(JSScript* scri
     if (slot < lexicalScope.firstFrameSlot()) {
       continue;
     }
-    if (slot >= lexicalScope.nextFrameSlot()) {
+    if (slot >= lexicalScope.nextFrameSlot()) {MOZ_RELEASE_ASSERT(0);
       break;
     }
 
@@ -1969,12 +1969,12 @@ template <typename... Args>
     JSContext* cx, CompilationState& compilationState,
     BaseParserScopeData* data, ScopeIndex* indexOut, Args&&... args) {
   *indexOut = ScopeIndex(compilationState.scopeData.length());
-  if (uint32_t(*indexOut) >= TaggedScriptThingIndex::IndexLimit) {
+  if (uint32_t(*indexOut) >= TaggedScriptThingIndex::IndexLimit) {MOZ_RELEASE_ASSERT(0);
     ReportAllocationOverflow(cx);
     return false;
   }
 
-  if (!compilationState.scopeData.emplaceBack(std::forward<Args>(args)...)) {
+  if (!compilationState.scopeData.emplaceBack(std::forward<Args>(args)...)) {MOZ_RELEASE_ASSERT(0);
     js::ReportOutOfMemory(cx);
     return false;
   }
@@ -2004,7 +2004,7 @@ bool ScopeStencil::createForFunctionScop
     MarkParserScopeData<ScopeType>(cx, data, compilationState);
   } else {
     data = NewEmptyParserScopeData<ScopeType>(cx, compilationState.alloc);
-    if (!data) {
+    if (!data) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2035,9 +2035,9 @@ bool ScopeStencil::createForLexicalScope
 
   if (data) {
     MarkParserScopeData<ScopeType>(cx, data, compilationState);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     data = NewEmptyParserScopeData<ScopeType>(cx, compilationState.alloc);
-    if (!data) {
+    if (!data) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2063,7 +2063,7 @@ bool ScopeStencil::createForVarScope(
     MarkParserScopeData<ScopeType>(cx, data, compilationState);
   } else {
     data = NewEmptyParserScopeData<ScopeType>(cx, compilationState.alloc);
-    if (!data) {
+    if (!data) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2119,7 +2119,7 @@ bool ScopeStencil::createForEvalScope(
     MarkParserScopeData<ScopeType>(cx, data, compilationState);
   } else {
     data = NewEmptyParserScopeData<ScopeType>(cx, compilationState.alloc);
-    if (!data) {
+    if (!data) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2146,9 +2146,9 @@ bool ScopeStencil::createForModuleScope(
 
   if (data) {
     MarkParserScopeData<ScopeType>(cx, data, compilationState);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     data = NewEmptyParserScopeData<ScopeType>(cx, compilationState.alloc);
-    if (!data) {
+    if (!data) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2280,7 +2280,7 @@ Scope* ScopeStencil::createSpecificScope
                                          BaseParserScopeData* baseData) const {
   Rooted<UniquePtr<typename SpecificScopeT::RuntimeData>> rootedData(
       cx, createSpecificScopeData<SpecificScopeT>(cx, atomCache, baseData));
-  if (!rootedData) {
+  if (!rootedData) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/vm/SelfHosting.cpp b/js/src/vm/SelfHosting.cpp
--- a/js/src/vm/SelfHosting.cpp
+++ b/js/src/vm/SelfHosting.cpp
@@ -270,7 +270,7 @@ static bool intrinsic_IsWrappedInstanceO
   if (!obj->is<WrapperObject>()) {
     args.rval().setBoolean(false);
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   JSObject* unwrapped = CheckedUnwrapDynamic(obj, cx);
   if (!unwrapped) {
@@ -336,7 +336,7 @@ static void ThrowErrorWithType(JSContext
     HandleValue val = args[i];
     if (val.isInt32() || val.isString()) {
       JSString* str = ToString<CanGC>(cx, val);
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         return;
       }
       errorArgs[i - 1] = QuoteString(cx, str);
@@ -428,7 +428,7 @@ static bool intrinsic_CreateModuleSyntax
   RootedModuleObject module(cx, &args[0].toObject().as<ModuleObject>());
   RootedString filename(cx,
                         JS_NewStringCopyZ(cx, module->script()->filename()));
-  if (!filename) {
+  if (!filename) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -450,7 +450,7 @@ static bool intrinsic_CreateModuleSyntax
  * failure in C++ code. Information about the failure can be provided in
  * args[0].
  */
-static bool intrinsic_AssertionFailed(JSContext* cx, unsigned argc, Value* vp) {
+static bool intrinsic_AssertionFailed(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
   CallArgs args = CallArgsFromVp(argc, vp);
   if (args.length() > 0) {
@@ -471,7 +471,7 @@ static bool intrinsic_AssertionFailed(JS
 /**
  * Dumps a message to stderr, after stringifying it. Doesn't append a newline.
  */
-static bool intrinsic_DumpMessage(JSContext* cx, unsigned argc, Value* vp) {
+static bool intrinsic_DumpMessage(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 #ifdef DEBUG
   if (args.length() > 0) {
@@ -562,7 +562,7 @@ static bool intrinsic_DefineDataProperty
 
   RootedObject obj(cx, &args[0].toObject());
   RootedId id(cx);
-  if (!ToPropertyKey(cx, args[1], &id)) {
+  if (!ToPropertyKey(cx, args[1], &id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedValue value(cx, args[2]);
@@ -574,7 +574,7 @@ static bool intrinsic_DefineDataProperty
                  bool(attributes & ATTR_NONENUMERABLE),
              "_DefineDataProperty must receive either ATTR_ENUMERABLE xor "
              "ATTR_NONENUMERABLE");
-  if (attributes & ATTR_ENUMERABLE) {
+  if (attributes & ATTR_ENUMERABLE) {MOZ_RELEASE_ASSERT(0);
     attrs |= JSPROP_ENUMERATE;
   }
 
@@ -616,7 +616,7 @@ static bool intrinsic_DefineProperty(JSC
 
   RootedObject obj(cx, &args[0].toObject());
   RootedId id(cx);
-  if (!PrimitiveValueToId<CanGC>(cx, args[1], &id)) {
+  if (!PrimitiveValueToId<CanGC>(cx, args[1], &id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -832,7 +832,7 @@ static bool intrinsic_ArrayIteratorProto
   MOZ_ASSERT(args.length() == 0);
 
   ForOfPIC::Chain* stubChain = ForOfPIC::getOrCreate(cx);
-  if (!stubChain) {
+  if (!stubChain) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -939,7 +939,7 @@ static js::PropertyName* GetUnclonedSelf
 }
 
 js::PropertyName* js::GetClonedSelfHostedFunctionName(const JSFunction* fun) {
-  if (!fun->isExtended()) {
+  if (!fun->isExtended()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   Value name = fun->getExtendedSlot(LAZY_FUNCTION_NAME_SLOT);
@@ -950,7 +950,7 @@ js::PropertyName* js::GetClonedSelfHoste
 }
 
 js::PropertyName* js::GetClonedSelfHostedFunctionNameOffMainThread(
-    JSFunction* fun) {
+    JSFunction* fun) {MOZ_RELEASE_ASSERT(0);
   Value name = fun->getExtendedSlotOffMainThread(LAZY_FUNCTION_NAME_SLOT);
   if (!name.isString()) {
     return nullptr;
@@ -958,7 +958,7 @@ js::PropertyName* js::GetClonedSelfHoste
   return name.toString()->asAtom().asPropertyName();
 }
 
-bool js::IsExtendedUnclonedSelfHostedFunctionName(JSAtom* name) {
+bool js::IsExtendedUnclonedSelfHostedFunctionName(JSAtom* name) {MOZ_RELEASE_ASSERT(0);
   if (name->length() < 2) {
     return false;
   }
@@ -1122,7 +1122,7 @@ static bool intrinsic_ArrayBufferCopyDat
   Rooted<T*> toBuffer(cx);
   if (!isWrapped) {
     toBuffer = &args[0].toObject().as<T>();
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     JSObject* wrapped = &args[0].toObject();
     MOZ_ASSERT(wrapped->is<WrapperObject>());
     toBuffer = wrapped->maybeUnwrapAs<T>();
@@ -1149,7 +1149,7 @@ static bool intrinsic_SharedArrayBuffers
   MOZ_ASSERT(args.length() == 2);
 
   auto* lhs = args[0].toObject().maybeUnwrapAs<SharedArrayBufferObject>();
-  if (!lhs) {
+  if (!lhs) {MOZ_RELEASE_ASSERT(0);
     ReportAccessDenied(cx);
     return false;
   }
@@ -1380,7 +1380,7 @@ static bool intrinsic_TypedArrayBitwiseS
   Rooted<TypedArrayObject*> unsafeTypedArrayCrossCompartment(cx);
   unsafeTypedArrayCrossCompartment =
       DangerouslyUnwrapTypedArray(cx, &args[1].toObject());
-  if (!unsafeTypedArrayCrossCompartment) {
+  if (!unsafeTypedArrayCrossCompartment) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(!unsafeTypedArrayCrossCompartment->hasDetachedBuffer());
@@ -1420,7 +1420,7 @@ static bool intrinsic_TypedArrayBitwiseS
   // need to be optimized.
   if (!TypedArrayObject::sameBuffer(source, unsafeTypedArrayCrossCompartment)) {
     if (source->isSharedMemory() ||
-        unsafeTypedArrayCrossCompartment->isSharedMemory()) {
+        unsafeTypedArrayCrossCompartment->isSharedMemory()) {MOZ_RELEASE_ASSERT(0);
       jit::AtomicOperations::memcpySafeWhenRacy(
           unsafeTargetDataCrossCompartment, sourceData, byteLength);
     } else {
@@ -1497,7 +1497,7 @@ static bool intrinsic_RegExpGetSubstitut
   RootedArrayObject matchResult(cx, &args[0].toObject().as<ArrayObject>());
 
   RootedLinearString string(cx, args[1].toString()->ensureLinear(cx));
-  if (!string) {
+  if (!string) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1606,7 +1606,7 @@ bool CallSelfHostedNonGenericMethod(JSCo
       cx, args[args.length() - 1].toString()->asAtom().asPropertyName());
 
   InvokeArgs args2(cx);
-  if (!args2.init(cx, args.length() - 1)) {
+  if (!args2.init(cx, args.length() - 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1692,7 +1692,7 @@ bool js::ReportIncompatibleSelfHostedMet
     UniqueChars funNameBytes;
     const char* funName =
         GetFunctionNameBytes(cx, iter.callee(cx), &funNameBytes);
-    if (!funName) {
+    if (!funName) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (std::all_of(
@@ -1721,7 +1721,7 @@ static bool intrinsic_RuntimeDefaultLoca
   MOZ_ASSERT(args.length() == 0);
 
   const char* locale = cx->runtime()->getDefaultLocale();
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_DEFAULT_LOCALE_ERROR);
     return false;
@@ -1750,7 +1750,7 @@ static bool intrinsic_IsRuntimeDefaultLo
   }
 
   const char* locale = cx->runtime()->getDefaultLocale();
-  if (!locale) {
+  if (!locale) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_DEFAULT_LOCALE_ERROR);
     return false;
@@ -1826,7 +1826,7 @@ static bool intrinsic_ConstructorForType
   MOZ_ASSERT(args[0].isObject());
 
   auto* object = UnwrapAndDowncastValue<TypedArrayObject>(cx, args[0]);
-  if (!object) {
+  if (!object) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2113,7 +2113,7 @@ static bool intrinsic_CopyDataProperties
     if (!CopyDataPropertiesNative(
             cx, target.as<PlainObject>(), from.as<NativeObject>(),
             (excludedItems ? excludedItems.as<PlainObject>() : nullptr),
-            &optimized)) {
+            &optimized)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2710,7 +2710,7 @@ GlobalObject* JSRuntime::createSelfHosti
   options.behaviors().setDiscardSource(true);
 
   Realm* realm = NewRealm(cx, nullptr, options);
-  if (!realm) {
+  if (!realm) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2733,7 +2733,7 @@ GlobalObject* JSRuntime::createSelfHosti
 
   AutoRealmUnchecked ar(cx, realm);
   Rooted<GlobalObject*> shg(cx, GlobalObject::createInternal(cx, &shgClass));
-  if (!shg) {
+  if (!shg) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2816,14 +2816,14 @@ static bool VerifyGlobalNames(JSContext*
   {
     Rooted<frontend::CompilationGCOutput> output(cx);
     if (!frontend::CompilationStencil::instantiateStencils(cx, input, stencil,
-                                                           output.get())) {
+                                                           output.get())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     // Run the script
     RootedScript script(cx, output.get().script);
     RootedValue rval(cx);
-    if (!JS_ExecuteScript(cx, script, &rval)) {
+    if (!JS_ExecuteScript(cx, script, &rval)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2848,7 +2848,7 @@ bool JSRuntime::initSelfHosting(JSContex
   }
 
   Rooted<GlobalObject*> shg(cx, JSRuntime::createSelfHostingGlobal(cx));
-  if (!shg) {
+  if (!shg) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2874,13 +2874,13 @@ bool JSRuntime::initSelfHosting(JSContex
   if (selfHostedXDR.length() > 0) {
     Rooted<frontend::CompilationInput> input(
         cx, frontend::CompilationInput(options));
-    if (!input.get().initForSelfHostingGlobal(cx)) {
+    if (!input.get().initForSelfHostingGlobal(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     frontend::CompilationStencil stencil(input.get().source);
     if (!stencil.deserializeStencils(cx, input.get(), selfHostedXDR,
-                                     &decodeOk)) {
+                                     &decodeOk)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2895,16 +2895,16 @@ bool JSRuntime::initSelfHosting(JSContex
   const unsigned char* compressed = compressedSources;
   uint32_t compressedLen = GetCompressedSize();
   auto src = cx->make_pod_array<char>(srcLen);
-  if (!src) {
+  if (!src) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!DecompressString(compressed, compressedLen,
-                        reinterpret_cast<unsigned char*>(src.get()), srcLen)) {
+                        reinterpret_cast<unsigned char*>(src.get()), srcLen)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JS::SourceText<mozilla::Utf8Unit> srcBuf;
-  if (!srcBuf.init(cx, std::move(src), srcLen)) {
+  if (!srcBuf.init(cx, std::move(src), srcLen)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2912,14 +2912,14 @@ bool JSRuntime::initSelfHosting(JSContex
                                            frontend::CompilationInput(options));
   auto stencil = frontend::CompileGlobalScriptToStencil(cx, input.get(), srcBuf,
                                                         ScopeKind::Global);
-  if (!stencil) {
+  if (!stencil) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Serialize the stencil to XDR.
   if (selfHostedXDRWriter) {
     JS::TranscodeBuffer xdrBuffer;
-    if (!stencil->serializeStencils(cx, input.get(), xdrBuffer)) {
+    if (!stencil->serializeStencils(cx, input.get(), xdrBuffer)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2979,10 +2979,10 @@ static bool CloneProperties(JSContext* c
 
   for (size_t i = 0; i < selfHostedObject->getDenseInitializedLength(); i++) {
     if (!selfHostedObject->getDenseElement(i).isMagic(JS_ELEMENTS_HOLE)) {
-      if (!ids.append(INT_TO_JSID(i))) {
+      if (!ids.append(INT_TO_JSID(i))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
-      if (!attrs.append(JSPROP_ENUMERATE)) {
+      if (!attrs.append(JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2992,7 +2992,7 @@ static bool CloneProperties(JSContext* c
   for (Shape::Range<NoGC> range(selfHostedObject->lastProperty());
        !range.empty(); range.popFront()) {
     Shape& shape = range.front();
-    if (shape.enumerable() && !shapes.append(&shape)) {
+    if (shape.enumerable() && !shapes.append(&shape)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -3002,13 +3002,13 @@ static bool CloneProperties(JSContext* c
   for (size_t i = 0; i < shapes.length(); ++i) {
     MOZ_ASSERT(shapes[i]->isDataProperty(),
                "Can't handle cloning accessors here yet.");
-    if (!ids.append(shapes[i]->propid())) {
+    if (!ids.append(shapes[i]->propid())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     uint8_t shapeAttrs =
         shapes[i]->attributes() &
         (JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY);
-    if (!attrs.append(shapeAttrs)) {
+    if (!attrs.append(shapeAttrs)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -3036,14 +3036,14 @@ static JSString* CloneString(JSContext* 
     if (selfHostedString->hasLatin1Chars()) {
       clone =
           NewStringCopyN<NoGC>(cx, selfHostedString->latin1Chars(nogc), len);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       clone = NewStringCopyNDontDeflate<NoGC>(
           cx, selfHostedString->twoByteChars(nogc), len);
     }
     if (clone) {
       return clone;
     }
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   AutoStableStringChars chars(cx);
   if (!chars.init(cx, selfHostedString)) {
@@ -3067,17 +3067,17 @@ static ScriptSourceObject* SelfHostingSc
   FillSelfHostingCompileOptions(options);
 
   RefPtr<ScriptSource> source(cx->new_<ScriptSource>());
-  if (!source) {
+  if (!source) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!source->initFromOptions(cx, options)) {
+  if (!source->initFromOptions(cx, options)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RootedScriptSourceObject sourceObject(
       cx, ScriptSourceObject::create(cx, source.get()));
-  if (!sourceObject) {
+  if (!sourceObject) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3127,7 +3127,7 @@ static JSObject* CloneObject(JSContext* 
       RootedScope emptyGlobalScope(cx, &global->emptyGlobalScope());
       Rooted<ScriptSourceObject*> sourceObject(
           cx, SelfHostingScriptSourceObject(cx));
-      if (!sourceObject) {
+      if (!sourceObject) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       MOZ_ASSERT(
@@ -3149,29 +3149,29 @@ static JSObject* CloneObject(JSContext* 
     } else {
       clone = CloneSelfHostingIntrinsic(cx, selfHostedFunction);
     }
-  } else if (selfHostedObject->is<RegExpObject>()) {
+  } else if (selfHostedObject->is<RegExpObject>()) {MOZ_RELEASE_ASSERT(0);
     RegExpObject& reobj = selfHostedObject->as<RegExpObject>();
     RootedAtom source(cx, reobj.getSource());
     MOZ_ASSERT(source->isPermanentAtom());
     clone = RegExpObject::create(cx, source, reobj.getFlags(), TenuredObject);
-  } else if (selfHostedObject->is<DateObject>()) {
+  } else if (selfHostedObject->is<DateObject>()) {MOZ_RELEASE_ASSERT(0);
     clone =
         JS::NewDateObject(cx, selfHostedObject->as<DateObject>().clippedTime());
-  } else if (selfHostedObject->is<BooleanObject>()) {
+  } else if (selfHostedObject->is<BooleanObject>()) {MOZ_RELEASE_ASSERT(0);
     clone = BooleanObject::create(
         cx, selfHostedObject->as<BooleanObject>().unbox());
-  } else if (selfHostedObject->is<NumberObject>()) {
+  } else if (selfHostedObject->is<NumberObject>()) {MOZ_RELEASE_ASSERT(0);
     clone =
         NumberObject::create(cx, selfHostedObject->as<NumberObject>().unbox());
-  } else if (selfHostedObject->is<StringObject>()) {
+  } else if (selfHostedObject->is<StringObject>()) {MOZ_RELEASE_ASSERT(0);
     JSString* selfHostedString = selfHostedObject->as<StringObject>().unbox();
-    if (!selfHostedString->isLinear()) {
+    if (!selfHostedString->isLinear()) {MOZ_RELEASE_ASSERT(0);
       MOZ_CRASH();
-    }
+    }MOZ_RELEASE_ASSERT(0);
     RootedString str(cx, CloneString(cx, &selfHostedString->asLinear()));
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     clone = StringObject::create(cx, str);
   } else if (selfHostedObject->is<ArrayObject>()) {
     clone = NewTenuredDenseEmptyArray(cx, nullptr);
@@ -3197,7 +3197,7 @@ static bool CloneValue(JSContext* cx, Ha
     RootedNativeObject selfHostedObject(
         cx, &selfHostedValue.toObject().as<NativeObject>());
     JSObject* clone = CloneObject(cx, selfHostedObject);
-    if (!clone) {
+    if (!clone) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     vp.setObject(*clone);
@@ -3206,12 +3206,12 @@ static bool CloneValue(JSContext* cx, Ha
     // Nothing to do here: these are represented inline in the value.
     vp.set(selfHostedValue);
   } else if (selfHostedValue.isString()) {
-    if (!selfHostedValue.toString()->isLinear()) {
+    if (!selfHostedValue.toString()->isLinear()) {MOZ_RELEASE_ASSERT(0);
       MOZ_CRASH();
     }
     JSLinearString* selfHostedString = &selfHostedValue.toString()->asLinear();
     JSString* clone = CloneString(cx, selfHostedString);
-    if (!clone) {
+    if (!clone) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     vp.setString(clone);
@@ -3234,7 +3234,7 @@ bool JSRuntime::createLazySelfHostedFunc
 
   RootedAtom funName(cx, name);
   JSFunction* selfHostedFun = getUnclonedSelfHostedFunction(selfHostedName);
-  if (!selfHostedFun) {
+  if (!selfHostedFun) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3248,7 +3248,7 @@ bool JSRuntime::createLazySelfHostedFunc
 
   RootedObject proto(cx);
   if (!GetFunctionPrototype(cx, selfHostedFun->generatorKind(),
-                            selfHostedFun->asyncKind(), &proto)) {
+                            selfHostedFun->asyncKind(), &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3268,20 +3268,20 @@ bool JSRuntime::cloneSelfHostedFunctionS
                                               HandlePropertyName name,
                                               HandleFunction targetFun) {
   RootedFunction sourceFun(cx, getUnclonedSelfHostedFunction(name));
-  if (!sourceFun) {
+  if (!sourceFun) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(targetFun->isExtended());
   MOZ_ASSERT(targetFun->hasSelfHostedLazyScript());
 
   RootedScript sourceScript(cx, JSFunction::getOrCreateScript(cx, sourceFun));
-  if (!sourceScript) {
+  if (!sourceScript) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Rooted<ScriptSourceObject*> sourceObject(cx,
                                            SelfHostingScriptSourceObject(cx));
-  if (!sourceObject) {
+  if (!sourceObject) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3294,7 +3294,7 @@ bool JSRuntime::cloneSelfHostedFunctionS
              ScopeKind::Global);
   RootedScope emptyGlobalScope(cx, &cx->global()->emptyGlobalScope());
   if (!CloneScriptIntoFunction(cx, emptyGlobalScope, targetFun, sourceScript,
-                               sourceObject)) {
+                               sourceObject)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/vm/Shape.cpp b/js/src/vm/Shape.cpp
--- a/js/src/vm/Shape.cpp
+++ b/js/src/vm/Shape.cpp
@@ -57,7 +57,7 @@ bool ShapeTable::init(JSContext* cx, Sha
 
   size = Bit(sizeLog2);
   entries_.reset(cx->pod_calloc<Entry>(size));
-  if (!entries_) {
+  if (!entries_) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -145,7 +145,7 @@ bool Shape::hashify(JSContext* cx, Shape
 
   UniquePtr<ShapeTable> table =
       cx->make_unique<ShapeTable>(shape->entryCount());
-  if (!table) {
+  if (!table) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -179,7 +179,7 @@ bool Shape::cachify(JSContext* cx, Shape
   MOZ_ASSERT(!shape->hasTable() && !shape->hasIC());
 
   UniquePtr<ShapeIC> ic = cx->make_unique<ShapeIC>();
-  if (!ic) {
+  if (!ic) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -204,7 +204,7 @@ bool ShapeTable::change(JSContext* cx, i
   uint32_t oldSize = Bit(oldLog2);
   uint32_t newSize = Bit(newLog2);
   Entry* newTable = cx->maybe_pod_calloc<Entry>(newSize);
-  if (!newTable) {
+  if (!newTable) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -363,7 +363,7 @@ Shape* Shape::replaceLastProperty(JSCont
   if (child.hasMissingSlot()) {
     uint32_t slot;
     if (obj->inDictionaryMode()) {
-      if (!allocDictionarySlot(cx, obj, &slot)) {
+      if (!allocDictionarySlot(cx, obj, &slot)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     } else {
@@ -395,14 +395,14 @@ Shape* Shape::replaceLastProperty(JSCont
   if (obj->inDictionaryMode()) {
     MOZ_ASSERT(parent == obj->lastProperty());
     Shape* shape = Allocate<Shape>(cx);
-    if (!shape) {
+    if (!shape) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (child.slot() >= obj->slotSpan()) {
-      if (!obj->ensureSlotsForDictionaryObject(cx, child.slot() + 1)) {
+      if (!obj->ensureSlotsForDictionaryObject(cx, child.slot() + 1)) {MOZ_RELEASE_ASSERT(0);
         new (shape) Shape(obj->lastProperty()->base(), ObjectFlags(), 0);
         return nullptr;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
     shape->initDictionaryShape(child, obj->numFixedSlots(),
                                DictionaryShapeLink(obj));
@@ -435,7 +435,7 @@ Shape* Shape::replaceLastProperty(JSCont
   if (obj->inDictionaryMode()) {
     MOZ_ASSERT(parent == obj->lastProperty());
     Shape* shape = Allocate<Shape>(cx);
-    if (!shape) {
+    if (!shape) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     shape->initDictionaryShape(child, obj->numFixedSlots(),
@@ -444,7 +444,7 @@ Shape* Shape::replaceLastProperty(JSCont
   }
 
   Shape* shape = cx->zone()->propertyTree().inlinedGetChild(cx, parent, child);
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -476,7 +476,7 @@ bool js::NativeObject::toDictionaryMode(
     MOZ_ASSERT(!shape->inDictionary());
 
     Shape* dprop = Allocate<Shape>(cx);
-    if (!dprop) {
+    if (!dprop) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
@@ -497,7 +497,7 @@ bool js::NativeObject::toDictionaryMode(
     shape = shape->previous();
   }
 
-  if (!Shape::hashify(cx, root)) {
+  if (!Shape::hashify(cx, root)) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -564,7 +564,7 @@ NativeObject::maybeConvertToOrGrowDictio
     if (!ShouldConvertToDictionary(obj)) {
       return true;
     }
-    if (!toDictionaryMode(cx, obj)) {
+    if (!toDictionaryMode(cx, obj)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     *table = obj->lastProperty()->maybeTable(keep);
@@ -622,14 +622,14 @@ Shape* NativeObject::addCustomDataProper
   ShapeTable::Entry* entry = nullptr;
   if (obj->inDictionaryMode()) {
     table = obj->lastProperty()->ensureTableForDictionary(cx, keep);
-    if (!table) {
+    if (!table) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     entry = &table->search<MaybeAdding::Adding>(id, keep);
   }
 
   if (!maybeConvertToOrGrowDictionaryForAdd(cx, obj, id, &table, &entry,
-                                            keep)) {
+                                            keep)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -642,7 +642,7 @@ Shape* NativeObject::addCustomDataProper
     Rooted<StackShape> child(cx, StackShape(last->base(), objectFlags, id,
                                             SHAPE_INVALID_SLOT, attrs));
     shape = getChildCustomDataProperty(cx, obj, last, &child);
-    if (!shape) {
+    if (!shape) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -671,7 +671,7 @@ Shape* NativeObject::addPropertyInternal
              slot < JSCLASS_RESERVED_SLOTS(obj->getClass()));
 
   if (!maybeConvertToOrGrowDictionaryForAdd(cx, obj, id, &table, &entry,
-                                            keep)) {
+                                            keep)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -767,7 +767,7 @@ Shape* NativeObject::addEnumerableDataPr
       break;
     }
 
-    if (!obj->setLastPropertyForNewDataProperty(cx, child)) {
+    if (!obj->setLastPropertyForNewDataProperty(cx, child)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     return child;
@@ -779,7 +779,7 @@ Shape* NativeObject::addEnumerableDataPr
 
   if (!obj->inDictionaryMode()) {
     if (MOZ_UNLIKELY(ShouldConvertToDictionary(obj))) {
-      if (!toDictionaryMode(cx, obj)) {
+      if (!toDictionaryMode(cx, obj)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       table = obj->lastProperty()->maybeTable(keep);
@@ -787,11 +787,11 @@ Shape* NativeObject::addEnumerableDataPr
     }
   } else {
     table = obj->lastProperty()->ensureTableForDictionary(cx, keep);
-    if (!table) {
+    if (!table) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (table->needsToGrow()) {
-      if (!table->grow(cx)) {
+      if (!table->grow(cx)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -806,7 +806,7 @@ Shape* NativeObject::addEnumerableDataPr
   Shape* shape;
   if (obj->inDictionaryMode()) {
     uint32_t slot;
-    if (!allocDictionarySlot(cx, obj, &slot)) {
+    if (!allocDictionarySlot(cx, obj, &slot)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -815,14 +815,14 @@ Shape* NativeObject::addEnumerableDataPr
                        JSPROP_ENUMERATE));
 
     shape = Allocate<Shape>(cx);
-    if (!shape) {
+    if (!shape) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (slot >= obj->slotSpan()) {
-      if (MOZ_UNLIKELY(!obj->ensureSlotsForDictionaryObject(cx, slot + 1))) {
+      if (MOZ_UNLIKELY(!obj->ensureSlotsForDictionaryObject(cx, slot + 1))) {MOZ_RELEASE_ASSERT(0);
         new (shape) Shape(obj->lastProperty()->base(), ObjectFlags(), 0);
         return nullptr;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
     shape->initDictionaryShape(child, obj->numFixedSlots(),
                                DictionaryShapeLink(obj));
@@ -838,10 +838,10 @@ Shape* NativeObject::addEnumerableDataPr
     Rooted<StackShape> child(
         cx, StackShape(last->base(), objectFlags, id, slot, JSPROP_ENUMERATE));
     shape = cx->zone()->propertyTree().inlinedGetChild(cx, last, child);
-    if (!shape) {
+    if (!shape) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (!obj->setLastPropertyForNewDataProperty(cx, shape)) {
+    if (!obj->setLastPropertyForNewDataProperty(cx, shape)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -934,7 +934,7 @@ Shape* NativeObject::putProperty(JSConte
     ShapeTable* table;
     ShapeTable::Entry* entry;
     if (!Shape::search<MaybeAdding::Adding>(cx, obj->lastProperty(), id, keep,
-                                            shape.address(), &table, &entry)) {
+                                            shape.address(), &table, &entry)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -973,7 +973,7 @@ Shape* NativeObject::putProperty(JSConte
     return shape;
   }
 
-  if (!maybeToDictionaryModeForPut(cx, obj, &shape)) {
+  if (!maybeToDictionaryModeForPut(cx, obj, &shape)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -987,15 +987,15 @@ Shape* NativeObject::putProperty(JSConte
     bool updateLast = (shape == obj->lastProperty());
     shape =
         NativeObject::replaceWithNewEquivalentShape(cx, obj, shape, nullptr);
-    if (!shape) {
+    if (!shape) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (!updateLast && !NativeObject::generateOwnShape(cx, obj)) {
+    if (!updateLast && !NativeObject::generateOwnShape(cx, obj)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     if (slot == SHAPE_INVALID_SLOT) {
-      if (!allocDictionarySlot(cx, obj, &slot)) {
+      if (!allocDictionarySlot(cx, obj, &slot)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -1047,7 +1047,7 @@ Shape* NativeObject::changeCustomDataPro
     ShapeTable* table;
     ShapeTable::Entry* entry;
     if (!Shape::search<MaybeAdding::Adding>(cx, obj->lastProperty(), id, keep,
-                                            shape.address(), &table, &entry)) {
+                                            shape.address(), &table, &entry)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1071,7 +1071,7 @@ Shape* NativeObject::changeCustomDataPro
     return shape;
   }
 
-  if (!maybeToDictionaryModeForPut(cx, obj, &shape)) {
+  if (!maybeToDictionaryModeForPut(cx, obj, &shape)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1083,10 +1083,10 @@ Shape* NativeObject::changeCustomDataPro
     bool updateLast = (shape == obj->lastProperty());
     shape =
         NativeObject::replaceWithNewEquivalentShape(cx, obj, shape, nullptr);
-    if (!shape) {
+    if (!shape) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (!updateLast && !NativeObject::generateOwnShape(cx, obj)) {
+    if (!updateLast && !NativeObject::generateOwnShape(cx, obj)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1132,11 +1132,11 @@ bool NativeObject::removeProperty(JSCont
   ShapeTable::Entry* entry;
   RootedShape shape(cx);
   if (!Shape::search(cx, obj->lastProperty(), id, keep, shape.address(), &table,
-                     &entry)) {
+                     &entry)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!shape) {
+  if (!shape) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -1145,12 +1145,12 @@ bool NativeObject::removeProperty(JSCont
   // GetterSetter can be changed indirectly by removing the property and then
   // adding it back with a different GetterSetter value but the same shape.
   if (shape->isAccessorDescriptor() && !obj->hadGetterSetterChange()) {
-    if (!NativeObject::setHadGetterSetterChange(cx, obj)) {
+    if (!NativeObject::setHadGetterSetterChange(cx, obj)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     // Relookup shape/table/entry in case setHadGetterSetterChange changed them.
     if (!Shape::search(cx, obj->lastProperty(), id, keep, shape.address(),
-                       &table, &entry)) {
+                       &table, &entry)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1163,7 +1163,7 @@ bool NativeObject::removeProperty(JSCont
    */
   if (!obj->inDictionaryMode() &&
       (!removingLastProperty || !obj->canRemoveLastProperty())) {
-    if (!toDictionaryMode(cx, obj)) {
+    if (!toDictionaryMode(cx, obj)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     table = obj->lastProperty()->maybeTable(keep);
@@ -1182,7 +1182,7 @@ bool NativeObject::removeProperty(JSCont
   RootedShape spare(cx);
   if (obj->inDictionaryMode()) {
     spare = Allocate<Shape>(cx);
-    if (!spare) {
+    if (!spare) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     new (spare) Shape(shape->base(), ObjectFlags(), 0);
@@ -1275,7 +1275,7 @@ Shape* NativeObject::replaceWithNewEquiv
 
   if (!obj->inDictionaryMode()) {
     RootedShape newRoot(cx, newShape);
-    if (!toDictionaryMode(cx, obj)) {
+    if (!toDictionaryMode(cx, obj)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     oldShape = obj->lastProperty();
@@ -1286,7 +1286,7 @@ Shape* NativeObject::replaceWithNewEquiv
     RootedShape oldRoot(cx, oldShape);
 
     newShape = Allocate<Shape>(cx);
-    if (!newShape) {
+    if (!newShape) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1297,7 +1297,7 @@ Shape* NativeObject::replaceWithNewEquiv
 
   AutoCheckCannotGC nogc;
   ShapeTable* table = obj->lastProperty()->ensureTableForDictionary(cx, nogc);
-  if (!table) {
+  if (!table) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1338,7 +1338,7 @@ bool JSObject::setFlag(JSContext* cx, Ha
 
   if (obj->is<NativeObject>() && obj->as<NativeObject>().inDictionaryMode()) {
     if (generateShape == GENERATE_SHAPE) {
-      if (!NativeObject::generateOwnShape(cx, obj.as<NativeObject>())) {
+      if (!NativeObject::generateOwnShape(cx, obj.as<NativeObject>())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1365,7 +1365,7 @@ bool JSObject::setProtoUnchecked(JSConte
   MOZ_ASSERT(cx->compartment() == obj->compartment());
   MOZ_ASSERT_IF(proto.isObject(), proto.toObject()->isUsedAsPrototype());
 
-  if (obj->shape()->proto() == proto) {
+  if (obj->shape()->proto() == proto) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -1373,11 +1373,11 @@ bool JSObject::setProtoUnchecked(JSConte
     Rooted<StackBaseShape> base(
         cx, StackBaseShape(obj->getClass(), obj->nonCCWRealm(), proto));
     Rooted<BaseShape*> nbase(cx, BaseShape::get(cx, base));
-    if (!nbase) {
+    if (!nbase) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!NativeObject::generateOwnShape(cx, obj.as<NativeObject>())) {
+    if (!NativeObject::generateOwnShape(cx, obj.as<NativeObject>())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1596,7 +1596,7 @@ bool PropertyTree::insertChild(JSContext
     MOZ_ASSERT(!shape->matches(child));
 
     ShapeSet* hash = MakeShapeSet(shape, child);
-    if (!hash) {
+    if (!hash) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
@@ -1892,7 +1892,7 @@ Shape* EmptyShape::getInitialShape(JSCon
 
   if (proto.isObject() && !proto.toObject()->isUsedAsPrototype()) {
     RootedObject protoObj(cx, proto.toObject());
-    if (!JSObject::setIsUsedAsPrototype(cx, protoObj)) {
+    if (!JSObject::setIsUsedAsPrototype(cx, protoObj)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     proto = TaggedProto(protoObj);
@@ -1972,7 +1972,7 @@ void EmptyShape::insertInitialShape(JSCo
 
   // The metadata callback can end up causing redundant changes of the initial
   // shape.
-  if (entry.shape == shape) {
+  if (entry.shape == shape) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
diff --git a/js/src/vm/SharedArrayObject.cpp b/js/src/vm/SharedArrayObject.cpp
--- a/js/src/vm/SharedArrayObject.cpp
+++ b/js/src/vm/SharedArrayObject.cpp
@@ -50,7 +50,7 @@ SharedArrayRawBuffer* SharedArrayRawBuff
   MOZ_RELEASE_ASSERT(length.get() <= ArrayBufferObject::maxBufferByteLength());
 
   size_t accessibleSize = SharedArrayAccessibleSize(length.get());
-  if (accessibleSize < length.get()) {
+  if (accessibleSize < length.get()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -87,7 +87,7 @@ SharedArrayRawBuffer* SharedArrayRawBuff
   return rawbuf;
 }
 
-void SharedArrayRawBuffer::tryGrowMaxSizeInPlace(uint64_t deltaMaxSize) {
+void SharedArrayRawBuffer::tryGrowMaxSizeInPlace(uint64_t deltaMaxSize) {MOZ_RELEASE_ASSERT(0);
   CheckedInt<uint64_t> newMaxSize = maxSize_;
   newMaxSize += deltaMaxSize;
   MOZ_ASSERT(newMaxSize.isValid());
@@ -95,7 +95,7 @@ void SharedArrayRawBuffer::tryGrowMaxSiz
 
   size_t newMappedSize = wasm::ComputeMappedSize(newMaxSize.value());
   MOZ_ASSERT(mappedSize_ <= newMappedSize);
-  if (mappedSize_ == newMappedSize) {
+  if (mappedSize_ == newMappedSize) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -110,13 +110,13 @@ void SharedArrayRawBuffer::tryGrowMaxSiz
 bool SharedArrayRawBuffer::wasmGrowToSizeInPlace(const Lock&,
                                                  BufferSize newLength) {
   // Note, caller must guard on the limit appropriate to the memory type
-  if (newLength.get() > ArrayBufferObject::maxBufferByteLength()) {
+  if (newLength.get() > ArrayBufferObject::maxBufferByteLength()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MOZ_ASSERT(newLength.get() >= length_);
 
-  if (newLength.get() == length_) {
+  if (newLength.get() == length_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -145,7 +145,7 @@ bool SharedArrayRawBuffer::addReference(
   for (;;) {
     uint32_t old_refcount = refcount_;
     uint32_t new_refcount = old_refcount + 1;
-    if (new_refcount == 0) {
+    if (new_refcount == 0) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (refcount_.compareExchange(old_refcount, new_refcount)) {
@@ -198,13 +198,13 @@ bool SharedArrayBufferObject::class_cons
   CallArgs args = CallArgsFromVp(argc, vp);
 
   // Step 1.
-  if (!ThrowIfNotConstructing(cx, args, "SharedArrayBuffer")) {
+  if (!ThrowIfNotConstructing(cx, args, "SharedArrayBuffer")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Step 2.
   uint64_t byteLength;
-  if (!ToIndex(cx, args.get(0), &byteLength)) {
+  if (!ToIndex(cx, args.get(0), &byteLength)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -212,7 +212,7 @@ bool SharedArrayBufferObject::class_cons
   // 24.2.1.1, step 1 (Inlined 9.1.14 OrdinaryCreateFromConstructor).
   RootedObject proto(cx);
   if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_SharedArrayBuffer,
-                                          &proto)) {
+                                          &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -238,7 +238,7 @@ SharedArrayBufferObject* SharedArrayBuff
                                                       HandleObject proto) {
   SharedArrayRawBuffer* buffer =
       SharedArrayRawBuffer::Allocate(length, Nothing(), Nothing());
-  if (!buffer) {
+  if (!buffer) {MOZ_RELEASE_ASSERT(0);
     js::ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -260,7 +260,7 @@ SharedArrayBufferObject* SharedArrayBuff
   AutoSetNewObjectMetadata metadata(cx);
   Rooted<SharedArrayBufferObject*> obj(
       cx, NewObjectWithClassProto<SharedArrayBufferObject>(cx, proto));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -353,7 +353,7 @@ SharedArrayBufferObject* SharedArrayBuff
   AutoSetNewObjectMetadata metadata(cx);
   SharedArrayBufferObject* obj =
       NewBuiltinClassInstance<SharedArrayBufferObject>(cx);
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     buffer->dropReference();
     return nullptr;
   }
diff --git a/js/src/vm/SharedImmutableStringsCache.cpp b/js/src/vm/SharedImmutableStringsCache.cpp
--- a/js/src/vm/SharedImmutableStringsCache.cpp
+++ b/js/src/vm/SharedImmutableStringsCache.cpp
@@ -92,7 +92,7 @@ SharedImmutableStringsCache::getOrCreate
 }
 
 [[nodiscard]] mozilla::Maybe<SharedImmutableString>
-SharedImmutableStringsCache::getOrCreate(const char* chars, size_t length) {
+SharedImmutableStringsCache::getOrCreate(const char* chars, size_t length) {MOZ_RELEASE_ASSERT(0);
   return getOrCreate(chars, length,
                      [&]() { return DuplicateString(chars, length); });
 }
@@ -106,7 +106,7 @@ SharedImmutableStringsCache::getOrCreate
 }
 
 [[nodiscard]] mozilla::Maybe<SharedImmutableTwoByteString>
-SharedImmutableStringsCache::getOrCreate(const char16_t* chars, size_t length) {
+SharedImmutableStringsCache::getOrCreate(const char16_t* chars, size_t length) {MOZ_RELEASE_ASSERT(0);
   return getOrCreate(chars, length,
                      [&]() { return DuplicateString(chars, length); });
 }
diff --git a/js/src/vm/Stack.cpp b/js/src/vm/Stack.cpp
--- a/js/src/vm/Stack.cpp
+++ b/js/src/vm/Stack.cpp
@@ -446,7 +446,7 @@ JS::ProfilingFrameIterator::ProfilingFra
     : cx_(cx),
       samplePositionInProfilerBuffer_(samplePositionInProfilerBuffer),
       activation_(nullptr) {
-  if (!cx->runtime()->geckoProfiler().enabled()) {
+  if (!cx->runtime()->geckoProfiler().enabled()) {MOZ_RELEASE_ASSERT(0);
     MOZ_CRASH(
         "ProfilingFrameIterator called when geckoProfiler not enabled for "
         "runtime.");
@@ -497,7 +497,7 @@ void JS::ProfilingFrameIterator::operato
 void JS::ProfilingFrameIterator::settleFrames() {
   // Handle transition frames (see comment in JitFrameIter::operator++).
   if (isJSJit() && !jsJitIter().done() &&
-      jsJitIter().frameType() == jit::FrameType::WasmToJSJit) {
+      jsJitIter().frameType() == jit::FrameType::WasmToJSJit) {MOZ_RELEASE_ASSERT(0);
     wasm::Frame* fp = (wasm::Frame*)jsJitIter().fp();
     iteratorDestroy();
     new (storage()) wasm::ProfilingFrameIterator(fp);
@@ -653,7 +653,7 @@ JS::ProfilingFrameIterator::getPhysicalF
   }
 
   // Failed to look up a jitcode entry for the given address, ignore.
-  if (!lookedUpEntry) {
+  if (!lookedUpEntry) {MOZ_RELEASE_ASSERT(0);
     return mozilla::Nothing();
   }
   *entry = *lookedUpEntry;
@@ -695,7 +695,7 @@ JS::ProfilingFrameIterator::getPhysicalF
 uint32_t JS::ProfilingFrameIterator::extractStack(Frame* frames,
                                                   uint32_t offset,
                                                   uint32_t end) const {
-  if (offset >= end) {
+  if (offset >= end) {MOZ_RELEASE_ASSERT(0);
     return 0;
   }
 
@@ -751,7 +751,7 @@ bool JS::ProfilingFrameIterator::isJSJit
 }
 
 mozilla::Maybe<JS::ProfilingFrameIterator::RegisterState>
-JS::ProfilingFrameIterator::getCppEntryRegisters() const {
+JS::ProfilingFrameIterator::getCppEntryRegisters() const {MOZ_RELEASE_ASSERT(0);
   if (!isJSJit()) {
     return mozilla::Nothing{};
   }
diff --git a/js/src/vm/StringType.cpp b/js/src/vm/StringType.cpp
--- a/js/src/vm/StringType.cpp
+++ b/js/src/vm/StringType.cpp
@@ -143,7 +143,7 @@ mozilla::Maybe<mozilla::Tuple<size_t, si
   for (;;) {
     if (current->isRope()) {
       JSRope& rope = current->asRope();
-      if (!stack.append(rope.rightChild())) {
+      if (!stack.append(rope.rightChild())) {MOZ_RELEASE_ASSERT(0);
         // OOM
         return mozilla::Nothing();
       }
@@ -154,7 +154,7 @@ mozilla::Maybe<mozilla::Tuple<size_t, si
     JSLinearString& linear = current->asLinear();
     if (MOZ_LIKELY(linear.hasLatin1Chars())) {
       if (MOZ_UNLIKELY(pendingLeadSurrogate)) {
-        if (buffer.Length() < 3) {
+        if (buffer.Length() < 3) {MOZ_RELEASE_ASSERT(0);
           return mozilla::Some(mozilla::MakeTuple(totalRead, totalWritten));
         }
         buffer[0] = '\xEF';
@@ -186,7 +186,7 @@ mozilla::Maybe<mozilla::Tuple<size_t, si
         }
         if (unicode::IsTrailSurrogate(first)) {
           // Got a surrogate pair
-          if (buffer.Length() < 4) {
+          if (buffer.Length() < 4) {MOZ_RELEASE_ASSERT(0);
             return mozilla::Some(mozilla::MakeTuple(totalRead, totalWritten));
           }
           uint32_t astral = unicode::UTF16Decode(pendingLeadSurrogate, first);
@@ -200,7 +200,7 @@ mozilla::Maybe<mozilla::Tuple<size_t, si
           totalWritten += 4;
         } else {
           // unpaired surrogate
-          if (buffer.Length() < 3) {
+          if (buffer.Length() < 3) {MOZ_RELEASE_ASSERT(0);
             return mozilla::Some(mozilla::MakeTuple(totalRead, totalWritten));
           }
           buffer[0] = '\xEF';
@@ -465,7 +465,7 @@ UniquePtr<CharT[], JS::FreePolicy> JSRop
     out.reset(js_pod_arena_malloc<CharT>(destArenaId, n));
   }
 
-  if (!out) {
+  if (!out) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -475,9 +475,9 @@ UniquePtr<CharT[], JS::FreePolicy> JSRop
   while (true) {
     if (str->isRope()) {
       if (!nodeStack.append(str->asRope().leftChild())) {
-        if (maybecx) {
+        if (maybecx) {MOZ_RELEASE_ASSERT(0);
           ReportOutOfMemory(maybecx);
-        }
+        }MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       str = str->asRope().rightChild();
@@ -525,7 +525,7 @@ bool JSRope::hash(uint32_t* outHash) con
 
   while (true) {
     if (str->isRope()) {
-      if (!nodeStack.append(str->asRope().rightChild())) {
+      if (!nodeStack.append(str->asRope().rightChild())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       str = str->asRope().leftChild();
@@ -683,14 +683,14 @@ JSLinearString* JSRope::flattenInternal(
         // nursery-allocated root node.
         if (!nursery.registerMallocedBuffer(wholeChars,
                                             wholeCapacity * sizeof(CharT))) {
-          if (maybecx) {
+          if (maybecx) {MOZ_RELEASE_ASSERT(0);
             ReportOutOfMemory(maybecx);
-          }
+          }MOZ_RELEASE_ASSERT(0);
           return nullptr;
         }
         // leftmost child -> root is a tenured -> nursery edge.
         bufferIfNursery->putWholeCell(&left);
-      } else if (inTenured && !left.isTenured()) {
+      } else if (inTenured && !left.isTenured()) {MOZ_RELEASE_ASSERT(0);
         // leftmost child is giving its nursery-held chars buffer to a
         // tenured string.
         nursery.removeMallocedBuffer(wholeChars, wholeCapacity * sizeof(CharT));
@@ -741,20 +741,20 @@ JSLinearString* JSRope::flattenInternal(
   }
 
   if (!AllocChars(this, wholeLength, &wholeChars, &wholeCapacity)) {
-    if (maybecx) {
+    if (maybecx) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(maybecx);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   if (!isTenured()) {
     Nursery& nursery = runtimeFromMainThread()->gc.nursery();
     if (!nursery.registerMallocedBuffer(wholeChars,
-                                        wholeCapacity * sizeof(CharT))) {
+                                        wholeCapacity * sizeof(CharT))) {MOZ_RELEASE_ASSERT(0);
       js_free(wholeChars);
-      if (maybecx) {
+      if (maybecx) {MOZ_RELEASE_ASSERT(0);
         ReportOutOfMemory(maybecx);
-      }
+      }MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -916,11 +916,11 @@ JSString* js::ConcatStrings(
 
     AutoCheckCannotGC nogc;
     JSLinearString* leftLinear = EnsureLinear<allowGC>(cx, left);
-    if (!leftLinear) {
+    if (!leftLinear) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     JSLinearString* rightLinear = EnsureLinear<allowGC>(cx, right);
-    if (!rightLinear) {
+    if (!rightLinear) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1075,7 +1075,7 @@ bool js::EqualStrings(JSContext* cx, JSS
   }
 
   JSLinearString* linear1 = str1->ensureLinear(cx);
-  if (!linear1) {
+  if (!linear1) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   JSLinearString* linear2 = str2->ensureLinear(cx);
@@ -1136,7 +1136,7 @@ bool js::CompareStrings(JSContext* cx, J
   }
 
   JSLinearString* linear1 = str1->ensureLinear(cx);
-  if (!linear1) {
+  if (!linear1) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1289,7 +1289,7 @@ bool StaticStrings::init(JSContext* cx) 
     Latin1Char ch = Latin1Char(i);
     JSLinearString* s =
         NewInlineString<NoGC>(cx, Latin1Range(&ch, 1), gc::TenuredHeap);
-    if (!s) {
+    if (!s) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     HashNumber hash = mozilla::HashString(&ch, 1);
@@ -1300,7 +1300,7 @@ bool StaticStrings::init(JSContext* cx) 
     Latin1Char buffer[] = {firstCharOfLength2(i), secondCharOfLength2(i)};
     JSLinearString* s =
         NewInlineString<NoGC>(cx, Latin1Range(buffer, 2), gc::TenuredHeap);
-    if (!s) {
+    if (!s) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     HashNumber hash = mozilla::HashString(buffer, 2);
@@ -1371,7 +1371,7 @@ static void MarkStringAndBasesNonDedupli
 
 bool AutoStableStringChars::init(JSContext* cx, JSString* s) {
   RootedLinearString linearString(cx, s->ensureLinear(cx));
-  if (!linearString) {
+  if (!linearString) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1400,7 +1400,7 @@ bool AutoStableStringChars::init(JSConte
 
 bool AutoStableStringChars::initTwoByte(JSContext* cx, JSString* s) {
   RootedLinearString linearString(cx, s->ensureLinear(cx));
-  if (!linearString) {
+  if (!linearString) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1534,7 +1534,7 @@ JSLinearString* js::NewDependentString(J
   }
 
   JSLinearString* base = baseArg->ensureLinear(cx);
-  if (!base) {
+  if (!base) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1617,20 +1617,20 @@ static JSLinearString* NewStringDeflated
 
 static JSLinearString* NewStringDeflatedFromLittleEndianNoGC(
     JSContext* cx, LittleEndianChars chars, size_t length,
-    gc::InitialHeap heap) {
+    gc::InitialHeap heap) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(CanStoreCharsAsLatin1(chars, length));
 
-  if (JSInlineString::lengthFits<Latin1Char>(length)) {
+  if (JSInlineString::lengthFits<Latin1Char>(length)) {MOZ_RELEASE_ASSERT(0);
     Latin1Char* storage;
     JSInlineString* str =
         AllocateInlineString<NoGC>(cx, length, &storage, heap);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     FillFromCompatible(storage, chars, length);
     return str;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   auto news =
       cx->make_pod_arena_array<Latin1Char>(js::StringBufferArena, length);
@@ -1768,7 +1768,7 @@ static JSLinearString* NewUndeflatedStri
     char16_t* storage;
     JSInlineString* str =
         AllocateInlineString<NoGC>(cx, length, &storage, heap);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1824,7 +1824,7 @@ JSLinearString* NewStringFromLittleEndia
                                               LittleEndianChars chars,
                                               size_t length,
                                               gc::InitialHeap heap) {
-  if (JSLinearString* str = TryEmptyOrStaticString(cx, chars, length)) {
+  if (JSLinearString* str = TryEmptyOrStaticString(cx, chars, length)) {MOZ_RELEASE_ASSERT(0);
     return str;
   }
 
@@ -1848,7 +1848,7 @@ JSLinearString* NewStringCopyUTF8N(JSCon
     UniqueLatin1Chars latin1(
         UTF8CharsToNewLatin1CharsZ(cx, utf8, &length, js::StringBufferArena)
             .get());
-    if (!latin1) {
+    if (!latin1) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -2002,14 +2002,14 @@ static bool FillWithRepresentatives(JSCo
 
   // Normal atom.
   RootedString atom1(cx, AtomizeChars(cx, chars, len));
-  if (!atom1 || !AppendString(cx, array, index, atom1)) {
+  if (!atom1 || !AppendString(cx, array, index, atom1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(atom1->isAtom());
 
   // Inline atom.
   RootedString atom2(cx, AtomizeChars(cx, chars, 2));
-  if (!atom2 || !AppendString(cx, array, index, atom2)) {
+  if (!atom2 || !AppendString(cx, array, index, atom2)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(atom2->isAtom());
@@ -2017,7 +2017,7 @@ static bool FillWithRepresentatives(JSCo
 
   // Fat inline atom.
   RootedString atom3(cx, AtomizeChars(cx, chars, fatInlineMaxLength));
-  if (!atom3 || !AppendString(cx, array, index, atom3)) {
+  if (!atom3 || !AppendString(cx, array, index, atom3)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(atom3->isAtom());
@@ -2025,14 +2025,14 @@ static bool FillWithRepresentatives(JSCo
 
   // Normal linear string.
   RootedString linear1(cx, NewStringCopyN<CanGC>(cx, chars, len));
-  if (!linear1 || !AppendString(cx, array, index, linear1)) {
+  if (!linear1 || !AppendString(cx, array, index, linear1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(linear1->isLinear());
 
   // Inline string.
   RootedString linear2(cx, NewStringCopyN<CanGC>(cx, chars, 3));
-  if (!linear2 || !AppendString(cx, array, index, linear2)) {
+  if (!linear2 || !AppendString(cx, array, index, linear2)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(linear2->isLinear());
@@ -2041,7 +2041,7 @@ static bool FillWithRepresentatives(JSCo
   // Fat inline string.
   RootedString linear3(cx,
                        NewStringCopyN<CanGC>(cx, chars, fatInlineMaxLength));
-  if (!linear3 || !AppendString(cx, array, index, linear3)) {
+  if (!linear3 || !AppendString(cx, array, index, linear3)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(linear3->isLinear());
@@ -2049,28 +2049,28 @@ static bool FillWithRepresentatives(JSCo
 
   // Rope.
   RootedString rope(cx, ConcatStrings<CanGC>(cx, atom1, atom3));
-  if (!rope || !AppendString(cx, array, index, rope)) {
+  if (!rope || !AppendString(cx, array, index, rope)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(rope->isRope());
 
   // Dependent.
   RootedString dep(cx, NewDependentString(cx, atom1, 0, len - 2));
-  if (!dep || !AppendString(cx, array, index, dep)) {
+  if (!dep || !AppendString(cx, array, index, dep)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(dep->isDependent());
 
   // Extensible.
   RootedString temp1(cx, NewStringCopyN<CanGC>(cx, chars, len));
-  if (!temp1) {
+  if (!temp1) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedString extensible(cx, ConcatStrings<CanGC>(cx, temp1, atom3));
-  if (!extensible || !extensible->ensureLinear(cx)) {
+  if (!extensible || !extensible->ensureLinear(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!AppendString(cx, array, index, extensible)) {
+  if (!AppendString(cx, array, index, extensible)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(extensible->isExtensible());
@@ -2080,7 +2080,7 @@ static bool FillWithRepresentatives(JSCo
   if constexpr (std::is_same_v<CharT, char16_t>) {
     external1 = JS_NewExternalString(cx, (const char16_t*)chars, len,
                                      &RepresentativeExternalStringCallbacks);
-    if (!external1 || !AppendString(cx, array, index, external1)) {
+    if (!external1 || !AppendString(cx, array, index, external1)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     MOZ_ASSERT(external1->isExternal());
@@ -2128,7 +2128,7 @@ bool JSString::fillWithRepresentatives(J
       u"\u1234abc\0def\u5678ghijklmasdfa\0xyz0123456789";
   if (!FillWithRepresentatives(
           cx, array, &index, twoByteChars, std::size(twoByteChars) - 1,
-          JSFatInlineString::MAX_LENGTH_TWO_BYTE, CheckTwoByte)) {
+          JSFatInlineString::MAX_LENGTH_TWO_BYTE, CheckTwoByte)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2136,7 +2136,7 @@ bool JSString::fillWithRepresentatives(J
   static const Latin1Char latin1Chars[] = "abc\0defghijklmasdfa\0xyz0123456789";
   if (!FillWithRepresentatives(
           cx, array, &index, latin1Chars, std::size(latin1Chars) - 1,
-          JSFatInlineString::MAX_LENGTH_LATIN1, CheckLatin1)) {
+          JSFatInlineString::MAX_LENGTH_LATIN1, CheckLatin1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2150,7 +2150,7 @@ bool JSString::fillWithRepresentatives(J
   // Append TwoByte strings.
   if (!FillWithRepresentatives(
           cx, array, &index, twoByteChars, std::size(twoByteChars) - 1,
-          JSFatInlineString::MAX_LENGTH_TWO_BYTE, CheckTwoByte)) {
+          JSFatInlineString::MAX_LENGTH_TWO_BYTE, CheckTwoByte)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2170,7 +2170,7 @@ bool JSString::fillWithRepresentatives(J
 
 UniqueChars js::EncodeLatin1(JSContext* cx, JSString* str) {
   JSLinearString* linear = str->ensureLinear(cx);
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2233,7 +2233,7 @@ JSString* js::ToStringSlow(
   Value v = arg;
   if (!v.isPrimitive()) {
     MOZ_ASSERT(!cx->isHelperThreadContext());
-    if (!allowGC) {
+    if (!allowGC) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     RootedValue v2(cx, v);
@@ -2262,7 +2262,7 @@ JSString* js::ToStringSlow(
     }
     return nullptr;
   } else if (v.isBigInt()) {
-    if (!allowGC) {
+    if (!allowGC) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     RootedBigInt i(cx, v.toBigInt());
diff --git a/js/src/vm/StructuredClone.cpp b/js/src/vm/StructuredClone.cpp
--- a/js/src/vm/StructuredClone.cpp
+++ b/js/src/vm/StructuredClone.cpp
@@ -256,7 +256,7 @@ SharedArrayRawBufferRefs::~SharedArrayRa
 
 bool SharedArrayRawBufferRefs::acquire(JSContext* cx,
                                        SharedArrayRawBuffer* rawbuf) {
-  if (!refs_.append(rawbuf)) {
+  if (!refs_.append(rawbuf)) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -273,12 +273,12 @@ bool SharedArrayRawBufferRefs::acquire(J
 
 bool SharedArrayRawBufferRefs::acquireAll(
     JSContext* cx, const SharedArrayRawBufferRefs& that) {
-  if (!refs_.reserve(refs_.length() + that.refs_.length())) {
+  if (!refs_.reserve(refs_.length() + that.refs_.length())) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
 
-  for (auto ref : that.refs_) {
+  for (auto ref : that.refs_) {MOZ_RELEASE_ASSERT(0);
     if (!ref->addReference()) {
       JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                 JSMSG_SC_SAB_REFCNT_OFLO);
@@ -810,7 +810,7 @@ bool SCInput::readArray(T* p, size_t nel
   // Fail if nelems is so huge that computing the full size will overflow.
   mozilla::CheckedInt<size_t> size =
       mozilla::CheckedInt<size_t>(nelems) * sizeof(T);
-  if (!size.isValid()) {
+  if (!size.isValid()) {MOZ_RELEASE_ASSERT(0);
     return reportTruncated();
   }
 
@@ -898,7 +898,7 @@ bool SCOutput::writeArray(const T* p, si
 
   for (size_t i = 0; i < nelems; i++) {
     T value = NativeEndian::swapToLittleEndian(p[i]);
-    if (!buf.AppendBytes(reinterpret_cast<char*>(&value), sizeof(value))) {
+    if (!buf.AppendBytes(reinterpret_cast<char*>(&value), sizeof(value))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -919,7 +919,7 @@ bool SCOutput::writeArray<uint8_t>(const
     return true;
   }
 
-  if (!buf.AppendBytes(reinterpret_cast<const char*>(p), nelems)) {
+  if (!buf.AppendBytes(reinterpret_cast<const char*>(p), nelems)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -978,7 +978,7 @@ void JSStructuredCloneData::discardTrans
   }
 
   auto point = BufferIterator<uint64_t, SystemAllocPolicy>(*this);
-  if (point.done()) {
+  if (point.done()) {MOZ_RELEASE_ASSERT(0);
     return;  // Empty buffer
   }
 
@@ -988,7 +988,7 @@ void JSStructuredCloneData::discardTrans
   MOZ_ALWAYS_TRUE(point.advance());
 
   if (tag == SCTAG_HEADER) {
-    if (point.done()) {
+    if (point.done()) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
@@ -1008,7 +1008,7 @@ void JSStructuredCloneData::discardTrans
   // freeTransfer should not GC
   JS::AutoSuppressGCAnalysis nogc;
 
-  if (point.done()) {
+  if (point.done()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -1016,7 +1016,7 @@ void JSStructuredCloneData::discardTrans
   uint64_t numTransferables = NativeEndian::swapFromLittleEndian(point.peek());
   MOZ_ALWAYS_TRUE(point.advance());
   while (numTransferables--) {
-    if (!point.canPeek()) {
+    if (!point.canPeek()) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
@@ -1024,29 +1024,29 @@ void JSStructuredCloneData::discardTrans
     SCInput::getPair(point.peek(), &tag, &ownership);
     MOZ_ALWAYS_TRUE(point.advance());
     MOZ_ASSERT(tag >= SCTAG_TRANSFER_MAP_PENDING_ENTRY);
-    if (!point.canPeek()) {
+    if (!point.canPeek()) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
     void* content;
     SCInput::getPtr(point.peek(), &content);
     MOZ_ALWAYS_TRUE(point.advance());
-    if (!point.canPeek()) {
+    if (!point.canPeek()) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
     uint64_t extraData = NativeEndian::swapFromLittleEndian(point.peek());
     MOZ_ALWAYS_TRUE(point.advance());
 
-    if (ownership < JS::SCTAG_TMO_FIRST_OWNED) {
+    if (ownership < JS::SCTAG_TMO_FIRST_OWNED) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
     if (ownership == JS::SCTAG_TMO_ALLOC_DATA) {
       js_free(content);
-    } else if (ownership == JS::SCTAG_TMO_MAPPED_DATA) {
+    } else if (ownership == JS::SCTAG_TMO_MAPPED_DATA) {MOZ_RELEASE_ASSERT(0);
       JS::ReleaseMappedArrayBufferContents(content, extraData);
-    } else if (freeTransfer) {
+    } else if (freeTransfer) {MOZ_RELEASE_ASSERT(0);
       freeTransfer(tag, JS::TransferableOwnership(ownership), content,
                    extraData, closure_);
     } else {
@@ -1075,27 +1075,27 @@ bool JSStructuredCloneWriter::parseTrans
     return true;
   }
 
-  if (!transferable.isObject()) {
+  if (!transferable.isObject()) {MOZ_RELEASE_ASSERT(0);
     return reportDataCloneError(JS_SCERR_TRANSFERABLE);
   }
 
   JSContext* cx = context();
   RootedObject array(cx, &transferable.toObject());
   bool isArray;
-  if (!JS::IsArrayObject(cx, array, &isArray)) {
+  if (!JS::IsArrayObject(cx, array, &isArray)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!isArray) {
+  if (!isArray) {MOZ_RELEASE_ASSERT(0);
     return reportDataCloneError(JS_SCERR_TRANSFERABLE);
   }
 
   uint32_t length;
-  if (!JS::GetArrayLength(cx, array, &length)) {
+  if (!JS::GetArrayLength(cx, array, &length)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Initialize the set for the provided array's length.
-  if (!transferableObjects.reserve(length)) {
+  if (!transferableObjects.reserve(length)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1107,11 +1107,11 @@ bool JSStructuredCloneWriter::parseTrans
   RootedObject tObj(context());
 
   for (uint32_t i = 0; i < length; ++i) {
-    if (!CheckForInterrupt(cx)) {
+    if (!CheckForInterrupt(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!JS_GetElement(cx, array, i, &v)) {
+    if (!JS_GetElement(cx, array, i, &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1121,7 +1121,7 @@ bool JSStructuredCloneWriter::parseTrans
     tObj = &v.toObject();
 
     RootedObject unwrappedObj(cx, CheckedUnwrapStatic(tObj));
-    if (!unwrappedObj) {
+    if (!unwrappedObj) {MOZ_RELEASE_ASSERT(0);
       ReportAccessDenied(cx);
       return false;
     }
@@ -1150,7 +1150,7 @@ bool JSStructuredCloneWriter::parseTrans
     }
 
     else {
-      if (!out.buf.callbacks_ || !out.buf.callbacks_->canTransfer) {
+      if (!out.buf.callbacks_ || !out.buf.callbacks_->canTransfer) {MOZ_RELEASE_ASSERT(0);
         return reportDataCloneError(JS_SCERR_TRANSFERABLE);
       }
 
@@ -1161,7 +1161,7 @@ bool JSStructuredCloneWriter::parseTrans
         return false;
       }
 
-      if (sameProcessScopeRequired) {
+      if (sameProcessScopeRequired) {MOZ_RELEASE_ASSERT(0);
         output().sameProcessScopeRequired();
       }
     }
@@ -1190,7 +1190,7 @@ bool JSStructuredCloneWriter::reportData
 
 bool JSStructuredCloneWriter::writeString(uint32_t tag, JSString* str) {
   JSLinearString* linear = str->ensureLinear(context());
-  if (!linear) {
+  if (!linear) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1214,7 +1214,7 @@ bool JSStructuredCloneWriter::writeBigIn
   bool signBit = bi->isNegative();
   size_t length = bi->digitLength();
   // The length must fit in 31 bits to leave room for a sign bit.
-  if (length > size_t(INT32_MAX)) {
+  if (length > size_t(INT32_MAX)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   uint32_t lengthAndSign = length | (static_cast<uint32_t>(signBit) << 31);
@@ -1265,16 +1265,16 @@ bool JSStructuredCloneWriter::writeTyped
                                  obj->maybeUnwrapAs<TypedArrayObject>());
   JSAutoRealm ar(context(), tarr);
 
-  if (!TypedArrayObject::ensureHasBuffer(context(), tarr)) {
+  if (!TypedArrayObject::ensureHasBuffer(context(), tarr)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!out.writePair(SCTAG_TYPED_ARRAY_OBJECT, uint32_t(tarr->type()))) {
+  if (!out.writePair(SCTAG_TYPED_ARRAY_OBJECT, uint32_t(tarr->type()))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   uint64_t nelems = tarr->length().get();
-  if (!out.write(nelems)) {
+  if (!out.write(nelems)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1292,12 +1292,12 @@ bool JSStructuredCloneWriter::writeDataV
   Rooted<DataViewObject*> view(context(), obj->maybeUnwrapAs<DataViewObject>());
   JSAutoRealm ar(context(), view);
 
-  if (!out.writePair(SCTAG_DATA_VIEW_OBJECT, 0)) {
+  if (!out.writePair(SCTAG_DATA_VIEW_OBJECT, 0)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   uint64_t byteLength = view->byteLength().get();
-  if (!out.write(byteLength)) {
+  if (!out.write(byteLength)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1316,7 +1316,7 @@ bool JSStructuredCloneWriter::writeArray
                                     obj->maybeUnwrapAs<ArrayBufferObject>());
   JSAutoRealm ar(context(), buffer);
 
-  if (!out.writePair(SCTAG_ARRAY_BUFFER_OBJECT, 0)) {
+  if (!out.writePair(SCTAG_ARRAY_BUFFER_OBJECT, 0)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1345,7 +1345,7 @@ bool JSStructuredCloneWriter::writeShare
   // cross-process.  The cloneDataPolicy should have guarded against this;
   // since it did not then throw, with a very explicit message.
 
-  if (output().scope() > JS::StructuredCloneScope::SameProcess) {
+  if (output().scope() > JS::StructuredCloneScope::SameProcess) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
                               JSMSG_SC_SHMEM_POLICY);
     return false;
@@ -1355,7 +1355,7 @@ bool JSStructuredCloneWriter::writeShare
       context(), obj->maybeUnwrapAs<SharedArrayBufferObject>());
   SharedArrayRawBuffer* rawbuf = sharedArrayBuffer->rawBufferObject();
 
-  if (!out.buf.refsHeld_.acquire(context(), rawbuf)) {
+  if (!out.buf.refsHeld_.acquire(context(), rawbuf)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1368,7 +1368,7 @@ bool JSStructuredCloneWriter::writeShare
   if (!(out.writePair(SCTAG_SHARED_ARRAY_BUFFER_OBJECT,
                       static_cast<uint32_t>(sizeof(p))) &&
         out.writeBytes(&byteLength, sizeof(byteLength)) &&
-        out.writeBytes(&p, sizeof(p)))) {
+        out.writeBytes(&p, sizeof(p)))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1410,7 +1410,7 @@ bool JSStructuredCloneWriter::startObjec
   if ((*backref = p.found())) {
     return out.writePair(SCTAG_BACK_REFERENCE_OBJECT, p->value());
   }
-  if (!memory.add(p, obj, memory.count())) {
+  if (!memory.add(p, obj, memory.count())) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(context());
     return false;
   }
@@ -1454,7 +1454,7 @@ static bool TryAppendNativeProperties(JS
     }
 
     MOZ_ASSERT(JSID_IS_STRING(id));
-    if (!entries.append(id)) {
+    if (!entries.append(id)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1507,7 +1507,7 @@ bool JSStructuredCloneWriter::traverseOb
   size_t count;
   bool optimized = false;
   if (!TryAppendNativeProperties(context(), obj, &objectEntries, &count,
-                                 &optimized)) {
+                                 &optimized)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1515,7 +1515,7 @@ bool JSStructuredCloneWriter::traverseOb
     // Get enumerable property ids and put them in reverse order so that they
     // will come off the stack in forward order.
     RootedIdVector properties(context());
-    if (!GetPropertyKeys(context(), obj, JSITER_OWNONLY, &properties)) {
+    if (!GetPropertyKeys(context(), obj, JSITER_OWNONLY, &properties)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1523,7 +1523,7 @@ bool JSStructuredCloneWriter::traverseOb
       jsid id = properties[i - 1];
 
       MOZ_ASSERT(JSID_IS_STRING(id) || JSID_IS_INT(id));
-      if (!objectEntries.append(id)) {
+      if (!objectEntries.append(id)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1532,7 +1532,7 @@ bool JSStructuredCloneWriter::traverseOb
   }
 
   // Push obj and count to the stack.
-  if (!objs.append(ObjectValue(*obj)) || !counts.append(count)) {
+  if (!objs.append(ObjectValue(*obj)) || !counts.append(count)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1587,16 +1587,16 @@ bool JSStructuredCloneWriter::traverseMa
     RootedObject unwrapped(context(), obj->maybeUnwrapAs<MapObject>());
     MOZ_ASSERT(unwrapped);
     JSAutoRealm ar(context(), unwrapped);
-    if (!MapObject::getKeysAndValuesInterleaved(unwrapped, &newEntries)) {
+    if (!MapObject::getKeysAndValuesInterleaved(unwrapped, &newEntries)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
-  if (!context()->compartment()->wrap(context(), &newEntries)) {
+  if (!context()->compartment()->wrap(context(), &newEntries)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   for (size_t i = newEntries.length(); i > 0; --i) {
-    if (!otherEntries.append(newEntries[i - 1])) {
+    if (!otherEntries.append(newEntries[i - 1])) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1622,16 +1622,16 @@ bool JSStructuredCloneWriter::traverseSe
     RootedObject unwrapped(context(), obj->maybeUnwrapAs<SetObject>());
     MOZ_ASSERT(unwrapped);
     JSAutoRealm ar(context(), unwrapped);
-    if (!SetObject::keys(context(), unwrapped, &keys)) {
+    if (!SetObject::keys(context(), unwrapped, &keys)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
-  if (!context()->compartment()->wrap(context(), &keys)) {
+  if (!context()->compartment()->wrap(context(), &keys)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   for (size_t i = keys.length(); i > 0; --i) {
-    if (!otherEntries.append(keys[i - 1])) {
+    if (!otherEntries.append(keys[i - 1])) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1652,13 +1652,13 @@ bool JSStructuredCloneWriter::traverseSa
   MOZ_ASSERT(savedFrame);
 
   RootedObject parent(context(), savedFrame->getParent());
-  if (!context()->compartment()->wrap(context(), &parent)) {
+  if (!context()->compartment()->wrap(context(), &parent)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (!objs.append(ObjectValue(*obj)) ||
       !otherEntries.append(parent ? ObjectValue(*parent) : NullValue()) ||
-      !counts.append(1)) {
+      !counts.append(1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1669,24 +1669,24 @@ bool JSStructuredCloneWriter::traverseSa
   if (savedFrame->getPrincipals() ==
       &ReconstructedSavedFramePrincipals::IsSystem) {
     if (!out.writePair(SCTAG_SAVED_FRAME_OBJECT,
-                       SCTAG_RECONSTRUCTED_SAVED_FRAME_PRINCIPALS_IS_SYSTEM)) {
+                       SCTAG_RECONSTRUCTED_SAVED_FRAME_PRINCIPALS_IS_SYSTEM)) {MOZ_RELEASE_ASSERT(0);
       return false;
     };
   } else if (savedFrame->getPrincipals() ==
              &ReconstructedSavedFramePrincipals::IsNotSystem) {
     if (!out.writePair(
             SCTAG_SAVED_FRAME_OBJECT,
-            SCTAG_RECONSTRUCTED_SAVED_FRAME_PRINCIPALS_IS_NOT_SYSTEM)) {
+            SCTAG_RECONSTRUCTED_SAVED_FRAME_PRINCIPALS_IS_NOT_SYSTEM)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
     if (auto principals = savedFrame->getPrincipals()) {
       if (!out.writePair(SCTAG_SAVED_FRAME_OBJECT, SCTAG_JSPRINCIPALS) ||
-          !principals->write(context(), this)) {
+          !principals->write(context(), this)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
-      if (!out.writePair(SCTAG_SAVED_FRAME_OBJECT, SCTAG_NULL_JSPRINCIPALS)) {
+      if (!out.writePair(SCTAG_SAVED_FRAME_OBJECT, SCTAG_NULL_JSPRINCIPALS)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1698,23 +1698,23 @@ bool JSStructuredCloneWriter::traverseSa
   RootedValue val(context());
 
   val = BooleanValue(savedFrame->getMutedErrors());
-  if (!startWrite(val)) {
+  if (!startWrite(val)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   context()->markAtom(savedFrame->getSource());
   val = StringValue(savedFrame->getSource());
-  if (!startWrite(val)) {
+  if (!startWrite(val)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   val = NumberValue(savedFrame->getLine());
-  if (!startWrite(val)) {
+  if (!startWrite(val)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   val = NumberValue(savedFrame->getColumn());
-  if (!startWrite(val)) {
+  if (!startWrite(val)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1723,7 +1723,7 @@ bool JSStructuredCloneWriter::traverseSa
     context()->markAtom(name);
   }
   val = name ? StringValue(name) : NullValue();
-  if (!startWrite(val)) {
+  if (!startWrite(val)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1760,7 +1760,7 @@ bool JSStructuredCloneWriter::startWrite
     RootedObject obj(context(), &v.toObject());
 
     bool backref;
-    if (!startObject(obj, &backref)) {
+    if (!startObject(obj, &backref)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (backref) {
@@ -1768,7 +1768,7 @@ bool JSStructuredCloneWriter::startWrite
     }
 
     ESClass cls;
-    if (!GetBuiltinClass(context(), obj, &cls)) {
+    if (!GetBuiltinClass(context(), obj, &cls)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1890,18 +1890,18 @@ bool JSStructuredCloneWriter::writeTrans
     return true;
   }
 
-  if (!out.writePair(SCTAG_TRANSFER_MAP_HEADER, (uint32_t)SCTAG_TM_UNREAD)) {
+  if (!out.writePair(SCTAG_TRANSFER_MAP_HEADER, (uint32_t)SCTAG_TM_UNREAD)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!out.write(transferableObjects.count())) {
+  if (!out.write(transferableObjects.count())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject obj(context());
   for (auto tr = transferableObjects.all(); !tr.empty(); tr.popFront()) {
     obj = tr.front();
-    if (!memory.put(obj, memory.count())) {
+    if (!memory.put(obj, memory.count())) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(context());
       return false;
     }
@@ -1909,10 +1909,10 @@ bool JSStructuredCloneWriter::writeTrans
     // Emit a placeholder pointer.  We defer stealing the data until later
     // (and, if necessary, detaching this object if it's an ArrayBuffer).
     if (!out.writePair(SCTAG_TRANSFER_MAP_PENDING_ENTRY,
-                       JS::SCTAG_TMO_UNFILLED)) {
+                       JS::SCTAG_TMO_UNFILLED)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!out.write(0)) {  // Pointer to ArrayBuffer contents.
+    if (!out.write(0)) {MOZ_RELEASE_ASSERT(0);  // Pointer to ArrayBuffer contents.
       return false;
     }
     if (!out.write(0)) {  // extraData
@@ -1963,7 +1963,7 @@ bool JSStructuredCloneWriter::transferOw
 #endif
 
     ESClass cls;
-    if (!GetBuiltinClass(cx, obj, &cls)) {
+    if (!GetBuiltinClass(cx, obj, &cls)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1999,7 +1999,7 @@ bool JSStructuredCloneWriter::transferOw
         content = nullptr;
         extraData = out.tell() -
                     pointOffset;  // Offset from tag to current end of buffer
-        if (!writeArrayBuffer(arrayBuffer)) {
+        if (!writeArrayBuffer(arrayBuffer)) {MOZ_RELEASE_ASSERT(0);
           ReportOutOfMemory(cx);
           return false;
         }
@@ -2009,7 +2009,7 @@ bool JSStructuredCloneWriter::transferOw
         point = out.iter();
         point += pointOffset;
 
-        if (!JS::DetachArrayBuffer(cx, arrayBuffer)) {
+        if (!JS::DetachArrayBuffer(cx, arrayBuffer)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
@@ -2084,7 +2084,7 @@ bool JSStructuredCloneWriter::write(Hand
       counts.back()--;
 
       ESClass cls;
-      if (!GetBuiltinClass(context(), obj, &cls)) {
+      if (!GetBuiltinClass(context(), obj, &cls)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -2103,7 +2103,7 @@ bool JSStructuredCloneWriter::write(Hand
         key = otherEntries.popCopy();
         checkStack();
 
-        if (!startWrite(key)) {
+        if (!startWrite(key)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
@@ -2122,7 +2122,7 @@ bool JSStructuredCloneWriter::write(Hand
           continue;
         }
 
-        if (!HasOwnProperty(context(), obj, id, &found)) {
+        if (!HasOwnProperty(context(), obj, id, &found)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
@@ -2149,7 +2149,7 @@ bool JSStructuredCloneWriter::write(Hand
 template <typename CharT>
 JSString* JSStructuredCloneReader::readStringImpl(uint32_t nchars,
                                                   gc::InitialHeap heap) {
-  if (nchars > JSString::MAX_LENGTH) {
+  if (nchars > JSString::MAX_LENGTH) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
                               JSMSG_SC_BAD_SERIALIZED_DATA, "string length");
     return nullptr;
@@ -2179,7 +2179,7 @@ BigInt* JSStructuredCloneReader::readBig
   }
   RootedBigInt result(
       context(), BigInt::createUninitialized(context(), length, isNegative));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (!in.readArray(result->digits().data(), length)) {
@@ -2198,7 +2198,7 @@ bool JSStructuredCloneReader::readTypedA
                                              uint64_t nelems,
                                              MutableHandleValue vp,
                                              bool v1Read) {
-  if (arrayType > (v1Read ? Scalar::Uint8Clamped : Scalar::BigUint64)) {
+  if (arrayType > (v1Read ? Scalar::Uint8Clamped : Scalar::BigUint64)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
                               JSMSG_SC_BAD_SERIALIZED_DATA,
                               "unhandled typed array element type");
@@ -2208,7 +2208,7 @@ bool JSStructuredCloneReader::readTypedA
   // Push a placeholder onto the allObjs list to stand in for the typed array.
   uint32_t placeholderIndex = allObjs.length();
   Value dummy = UndefinedValue();
-  if (!allObjs.append(dummy)) {
+  if (!allObjs.append(dummy)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2216,15 +2216,15 @@ bool JSStructuredCloneReader::readTypedA
   RootedValue v(context());
   uint64_t byteOffset;
   if (v1Read) {
-    if (!readV1ArrayBuffer(arrayType, nelems, &v)) {
+    if (!readV1ArrayBuffer(arrayType, nelems, &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     byteOffset = 0;
   } else {
-    if (!startRead(&v)) {
+    if (!startRead(&v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!in.read(&byteOffset)) {
+    if (!in.read(&byteOffset)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2238,7 +2238,7 @@ bool JSStructuredCloneReader::readTypedA
     return false;
   }
 
-  if (!v.isObject() || !v.toObject().is<ArrayBufferObjectMaybeShared>()) {
+  if (!v.isObject() || !v.toObject().is<ArrayBufferObjectMaybeShared>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
                               JSMSG_SC_BAD_SERIALIZED_DATA,
                               "typed array must be backed by an ArrayBuffer");
@@ -2304,16 +2304,16 @@ bool JSStructuredCloneReader::readDataVi
   // Push a placeholder onto the allObjs list to stand in for the DataView.
   uint32_t placeholderIndex = allObjs.length();
   Value dummy = UndefinedValue();
-  if (!allObjs.append(dummy)) {
+  if (!allObjs.append(dummy)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Read the ArrayBuffer object and its contents (but no properties).
   RootedValue v(context());
-  if (!startRead(&v)) {
+  if (!startRead(&v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!v.isObject() || !v.toObject().is<ArrayBufferObjectMaybeShared>()) {
+  if (!v.isObject() || !v.toObject().is<ArrayBufferObjectMaybeShared>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
                               JSMSG_SC_BAD_SERIALIZED_DATA,
                               "DataView must be backed by an ArrayBuffer");
@@ -2322,7 +2322,7 @@ bool JSStructuredCloneReader::readDataVi
 
   // Read byteOffset.
   uint64_t byteOffset;
-  if (!in.read(&byteOffset)) {
+  if (!in.read(&byteOffset)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2355,7 +2355,7 @@ bool JSStructuredCloneReader::readArrayB
   // length separately to allow larger length values.
   uint64_t nbytes = 0;
   if (type == SCTAG_ARRAY_BUFFER_OBJECT) {
-    if (!in.read(&nbytes)) {
+    if (!in.read(&nbytes)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -2365,7 +2365,7 @@ bool JSStructuredCloneReader::readArrayB
 
   // The maximum ArrayBuffer size depends on the platform and prefs, and we cast
   // to BufferSize/size_t below, so we have to check this here.
-  if (nbytes > ArrayBufferObject::maxBufferByteLength()) {
+  if (nbytes > ArrayBufferObject::maxBufferByteLength()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
                               JSMSG_BAD_ARRAY_LENGTH);
     return false;
@@ -2394,20 +2394,20 @@ bool JSStructuredCloneReader::readShared
   }
 
   uint64_t byteLength;
-  if (!in.readBytes(&byteLength, sizeof(byteLength))) {
+  if (!in.readBytes(&byteLength, sizeof(byteLength))) {MOZ_RELEASE_ASSERT(0);
     return in.reportTruncated();
   }
 
   // The maximum ArrayBuffer size depends on the platform and prefs, and we cast
   // to BufferSize/size_t below, so we have to check this here.
-  if (byteLength > ArrayBufferObject::maxBufferByteLength()) {
+  if (byteLength > ArrayBufferObject::maxBufferByteLength()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
                               JSMSG_BAD_ARRAY_LENGTH);
     return false;
   }
 
   intptr_t p;
-  if (!in.readBytes(&p, sizeof(p))) {
+  if (!in.readBytes(&p, sizeof(p))) {MOZ_RELEASE_ASSERT(0);
     return in.reportTruncated();
   }
 
@@ -2421,7 +2421,7 @@ bool JSStructuredCloneReader::readShared
   if (!context()
            ->realm()
            ->creationOptions()
-           .getSharedMemoryAndAtomicsEnabled()) {
+           .getSharedMemoryAndAtomicsEnabled()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
                               JSMSG_SC_SAB_DISABLED);
     return false;
@@ -2429,7 +2429,7 @@ bool JSStructuredCloneReader::readShared
 
   // The new object will have a new reference to the rawbuf.
 
-  if (!rawbuf->addReference()) {
+  if (!rawbuf->addReference()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
                               JSMSG_SC_SAB_REFCNT_OFLO);
     return false;
@@ -2437,7 +2437,7 @@ bool JSStructuredCloneReader::readShared
 
   RootedObject obj(context(), SharedArrayBufferObject::New(
                                   context(), rawbuf, BufferSize(byteLength)));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     rawbuf->dropReference();
     return false;
   }
@@ -2456,7 +2456,7 @@ bool JSStructuredCloneReader::readShared
 bool JSStructuredCloneReader::readSharedWasmMemory(uint32_t nbytes,
                                                    MutableHandleValue vp) {
   JSContext* cx = context();
-  if (nbytes != 0) {
+  if (nbytes != 0) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_SC_BAD_SERIALIZED_DATA,
                               "invalid shared wasm memory tag");
@@ -2464,7 +2464,7 @@ bool JSStructuredCloneReader::readShared
   }
 
   if (!cloneDataPolicy.areIntraClusterClonableSharedObjectsAllowed() ||
-      !cloneDataPolicy.areSharedMemoryObjectsAllowed()) {
+      !cloneDataPolicy.areSharedMemoryObjectsAllowed()) {MOZ_RELEASE_ASSERT(0);
     auto error = context()->realm()->creationOptions().getCoopAndCoepEnabled()
                      ? JS_SCERR_NOT_CLONABLE_WITH_COOP_COEP
                      : JS_SCERR_NOT_CLONABLE;
@@ -2474,11 +2474,11 @@ bool JSStructuredCloneReader::readShared
 
   // Read the SharedArrayBuffer object.
   RootedValue payload(cx);
-  if (!startRead(&payload)) {
+  if (!startRead(&payload)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!payload.isObject() ||
-      !payload.toObject().is<SharedArrayBufferObject>()) {
+      !payload.toObject().is<SharedArrayBufferObject>()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(
         context(), GetErrorMessage, nullptr, JSMSG_SC_BAD_SERIALIZED_DATA,
         "shared wasm memory must be backed by a SharedArrayBuffer");
@@ -2507,28 +2507,28 @@ bool JSStructuredCloneReader::readShared
 bool JSStructuredCloneReader::readV1ArrayBuffer(uint32_t arrayType,
                                                 uint32_t nelems,
                                                 MutableHandleValue vp) {
-  if (arrayType > Scalar::Uint8Clamped) {
+  if (arrayType > Scalar::Uint8Clamped) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
                               JSMSG_SC_BAD_SERIALIZED_DATA,
                               "invalid TypedArray type");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   mozilla::CheckedInt<size_t> nbytes =
       mozilla::CheckedInt<size_t>(nelems) *
       TypedArrayElemSize(static_cast<Scalar::Type>(arrayType));
-  if (!nbytes.isValid() || nbytes.value() > UINT32_MAX) {
+  if (!nbytes.isValid() || nbytes.value() > UINT32_MAX) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
                               JSMSG_SC_BAD_SERIALIZED_DATA,
                               "invalid typed array size");
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   JSObject* obj =
       ArrayBufferObject::createZeroed(context(), BufferSize(nbytes.value()));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   vp.setObject(*obj);
   ArrayBufferObject& buffer = obj->as<ArrayBufferObject>();
   MOZ_ASSERT(buffer.byteLength().get() == nbytes);
@@ -2569,7 +2569,7 @@ bool JSStructuredCloneReader::startRead(
   uint32_t tag, data;
   bool alreadAppended = false;
 
-  if (!in.readPair(&tag, &data)) {
+  if (!in.readPair(&tag, &data)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2854,7 +2854,7 @@ bool JSStructuredCloneReader::startRead(
 
 bool JSStructuredCloneReader::readHeader() {
   uint32_t tag, data;
-  if (!in.getPair(&tag, &data)) {
+  if (!in.getPair(&tag, &data)) {MOZ_RELEASE_ASSERT(0);
     return in.reportTruncated();
   }
 
@@ -2903,7 +2903,7 @@ bool JSStructuredCloneReader::readTransf
   auto headerPos = in.tell();
 
   uint32_t tag, data;
-  if (!in.getPair(&tag, &data)) {
+  if (!in.getPair(&tag, &data)) {MOZ_RELEASE_ASSERT(0);
     return in.reportTruncated();
   }
 
@@ -2914,18 +2914,18 @@ bool JSStructuredCloneReader::readTransf
 
   uint64_t numTransferables;
   MOZ_ALWAYS_TRUE(in.readPair(&tag, &data));
-  if (!in.read(&numTransferables)) {
+  if (!in.read(&numTransferables)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   for (uint64_t i = 0; i < numTransferables; i++) {
     auto pos = in.tell();
 
-    if (!in.readPair(&tag, &data)) {
+    if (!in.readPair(&tag, &data)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (tag == SCTAG_TRANSFER_MAP_PENDING_ENTRY) {
+    if (tag == SCTAG_TRANSFER_MAP_PENDING_ENTRY) {MOZ_RELEASE_ASSERT(0);
       ReportDataCloneError(cx, callbacks, JS_SCERR_TRANSFERABLE, closure);
       return false;
     }
@@ -2933,19 +2933,19 @@ bool JSStructuredCloneReader::readTransf
     RootedObject obj(cx);
 
     void* content;
-    if (!in.readPtr(&content)) {
+    if (!in.readPtr(&content)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     uint64_t extraData;
-    if (!in.read(&extraData)) {
+    if (!in.read(&extraData)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (tag == SCTAG_TRANSFER_MAP_ARRAY_BUFFER) {
       if (allowedScope == JS::StructuredCloneScope::DifferentProcess ||
           allowedScope ==
-              JS::StructuredCloneScope::DifferentProcessForIndexedDB) {
+              JS::StructuredCloneScope::DifferentProcessForIndexedDB) {MOZ_RELEASE_ASSERT(0);
         // Transferred ArrayBuffers in a DifferentProcess clone buffer
         // are treated as if they weren't Transferred at all. We should
         // only see SCTAG_TRANSFER_MAP_STORED_ARRAY_BUFFER.
@@ -2967,31 +2967,31 @@ bool JSStructuredCloneReader::readTransf
       auto savedPos = in.tell();
       auto guard = mozilla::MakeScopeExit([&] { in.seekTo(savedPos); });
       in.seekTo(pos);
-      if (!in.seekBy(static_cast<size_t>(extraData))) {
+      if (!in.seekBy(static_cast<size_t>(extraData))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       uint32_t tag, data;
-      if (!in.readPair(&tag, &data)) {
+      if (!in.readPair(&tag, &data)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (tag != SCTAG_ARRAY_BUFFER_OBJECT_V2 &&
-          tag != SCTAG_ARRAY_BUFFER_OBJECT) {
+          tag != SCTAG_ARRAY_BUFFER_OBJECT) {MOZ_RELEASE_ASSERT(0);
         ReportDataCloneError(cx, callbacks, JS_SCERR_TRANSFERABLE, closure);
         return false;
       }
       RootedValue val(cx);
-      if (!readArrayBuffer(StructuredDataType(tag), data, &val)) {
+      if (!readArrayBuffer(StructuredDataType(tag), data, &val)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       obj = &val.toObject();
     } else {
-      if (!callbacks || !callbacks->readTransfer) {
+      if (!callbacks || !callbacks->readTransfer) {MOZ_RELEASE_ASSERT(0);
         ReportDataCloneError(cx, callbacks, JS_SCERR_TRANSFERABLE, closure);
         return false;
       }
       if (!callbacks->readTransfer(cx, this, tag, content, extraData, closure,
-                                   &obj)) {
+                                   &obj)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       MOZ_ASSERT(obj);
@@ -3001,7 +3001,7 @@ bool JSStructuredCloneReader::readTransf
     // On failure, the buffer will still own the data (since its ownership
     // will not get set to SCTAG_TMO_UNOWNED), so the data will be freed by
     // DiscardTransferables.
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3029,19 +3029,19 @@ bool JSStructuredCloneReader::readTransf
 
 JSObject* JSStructuredCloneReader::readSavedFrame(uint32_t principalsTag) {
   RootedSavedFrame savedFrame(context(), SavedFrame::create(context()));
-  if (!savedFrame) {
+  if (!savedFrame) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   JSPrincipals* principals;
   if (principalsTag == SCTAG_JSPRINCIPALS) {
-    if (!context()->runtime()->readPrincipals) {
+    if (!context()->runtime()->readPrincipals) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
                                 JSMSG_SC_UNSUPPORTED_TYPE);
       return nullptr;
     }
 
-    if (!context()->runtime()->readPrincipals(context(), this, &principals)) {
+    if (!context()->runtime()->readPrincipals(context(), this, &principals)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else if (principalsTag ==
@@ -3054,7 +3054,7 @@ JSObject* JSStructuredCloneReader::readS
     principals->refcount++;
   } else if (principalsTag == SCTAG_NULL_JSPRINCIPALS) {
     principals = nullptr;
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
                               JSMSG_SC_BAD_SERIALIZED_DATA,
                               "bad SavedFrame principals");
@@ -3068,12 +3068,12 @@ JSObject* JSStructuredCloneReader::readS
     // The |mutedErrors| boolean is present in all new structured-clone data,
     // but in older data it will be absent and only the |source| string will be
     // found.
-    if (!startRead(&mutedErrors)) {
+    if (!startRead(&mutedErrors)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     if (mutedErrors.isBoolean()) {
-      if (!startRead(&source, gc::TenuredHeap) || !source.isString()) {
+      if (!startRead(&source, gc::TenuredHeap) || !source.isString()) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     } else if (mutedErrors.isString()) {
@@ -3081,7 +3081,7 @@ JSObject* JSStructuredCloneReader::readS
       // this is actually just a |source| string.
       source = mutedErrors;
       mutedErrors.setBoolean(true);  // Safe default value.
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       // Invalid type.
       return nullptr;
     }
@@ -3091,7 +3091,7 @@ JSObject* JSStructuredCloneReader::readS
                                                       mutedErrors.toBoolean());
 
   auto atomSource = AtomizeString(context(), source.toString());
-  if (!atomSource) {
+  if (!atomSource) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   savedFrame->initSource(atomSource);
@@ -3099,7 +3099,7 @@ JSObject* JSStructuredCloneReader::readS
   RootedValue lineVal(context());
   uint32_t line;
   if (!startRead(&lineVal) || !lineVal.isNumber() ||
-      !ToUint32(context(), lineVal, &line)) {
+      !ToUint32(context(), lineVal, &line)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   savedFrame->initLine(line);
@@ -3107,7 +3107,7 @@ JSObject* JSStructuredCloneReader::readS
   RootedValue columnVal(context());
   uint32_t column;
   if (!startRead(&columnVal) || !columnVal.isNumber() ||
-      !ToUint32(context(), columnVal, &column)) {
+      !ToUint32(context(), columnVal, &column)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   savedFrame->initColumn(column);
@@ -3117,10 +3117,10 @@ JSObject* JSStructuredCloneReader::readS
   savedFrame->initSourceId(0);
 
   RootedValue name(context());
-  if (!startRead(&name, gc::TenuredHeap)) {
+  if (!startRead(&name, gc::TenuredHeap)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
-  if (!(name.isString() || name.isNull())) {
+  if (!(name.isString() || name.isNull())) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
                               JSMSG_SC_BAD_SERIALIZED_DATA,
                               "invalid saved frame cause");
@@ -3129,7 +3129,7 @@ JSObject* JSStructuredCloneReader::readS
   JSAtom* atomName = nullptr;
   if (name.isString()) {
     atomName = AtomizeString(context(), name.toString());
-    if (!atomName) {
+    if (!atomName) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -3137,10 +3137,10 @@ JSObject* JSStructuredCloneReader::readS
   savedFrame->initFunctionDisplayName(atomName);
 
   RootedValue cause(context());
-  if (!startRead(&cause, gc::TenuredHeap)) {
+  if (!startRead(&cause, gc::TenuredHeap)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
-  if (!(cause.isString() || cause.isNull())) {
+  if (!(cause.isString() || cause.isNull())) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
                               JSMSG_SC_BAD_SERIALIZED_DATA,
                               "invalid saved frame cause");
@@ -3232,11 +3232,11 @@ class ChildCounter {
 
 // Perform the whole recursive reading procedure.
 bool JSStructuredCloneReader::read(MutableHandleValue vp) {
-  if (!readHeader()) {
+  if (!readHeader()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!readTransferMap()) {
+  if (!readTransferMap()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3256,12 +3256,12 @@ bool JSStructuredCloneReader::read(Mutab
     childCounter.noteObjIsOnTopOfStack();
 
     uint32_t tag, data;
-    if (!in.getPair(&tag, &data)) {
+    if (!in.getPair(&tag, &data)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (tag == SCTAG_END_OF_KEYS) {
-      if (!childCounter.handleEndOfChildren(objs)) {
+      if (!childCounter.handleEndOfChildren(objs)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -3286,7 +3286,7 @@ bool JSStructuredCloneReader::read(Mutab
     // Note that this means the ordering in the stream is a little funky for
     // things like Map. See the comment above traverseMap() for an example.
     RootedValue key(context());
-    if (!startRead(&key) || !childCounter.postStartRead(objs)) {
+    if (!startRead(&key) || !childCounter.postStartRead(objs)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3294,7 +3294,7 @@ bool JSStructuredCloneReader::read(Mutab
                           obj->is<SavedFrame>())) {
       // Backwards compatibility: Null formerly indicated the end of
       // object properties.
-      if (!childCounter.handleEndOfChildren(objs)) {
+      if (!childCounter.handleEndOfChildren(objs)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       objs.popBack();
@@ -3304,7 +3304,7 @@ bool JSStructuredCloneReader::read(Mutab
     // Set object: the values between obj header (from startRead()) and
     // SCTAG_END_OF_KEYS are all interpreted as values to add to the set.
     if (obj->is<SetObject>()) {
-      if (!SetObject::add(context(), obj, key)) {
+      if (!SetObject::add(context(), obj, key)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       continue;
@@ -3318,7 +3318,7 @@ bool JSStructuredCloneReader::read(Mutab
         parentFrame = nullptr;
       } else if (key.isObject() && key.toObject().is<SavedFrame>()) {
         parentFrame = &key.toObject().as<SavedFrame>();
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
                                   JSMSG_SC_BAD_SERIALIZED_DATA,
                                   "invalid SavedFrame parent");
@@ -3346,21 +3346,21 @@ bool JSStructuredCloneReader::read(Mutab
     if (obj->is<MapObject>()) {
       // For a Map, store those <key,value> pairs in the contained map
       // data structure.
-      if (!MapObject::set(context(), obj, key, val)) {
+      if (!MapObject::set(context(), obj, key, val)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
       // For any other Object, interpret them as plain properties.
       RootedId id(context());
 
-      if (!key.isString() && !key.isInt32()) {
+      if (!key.isString() && !key.isInt32()) {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
                                   JSMSG_SC_BAD_SERIALIZED_DATA,
                                   "property key expected");
         return false;
       }
 
-      if (!PrimitiveValueToId<CanGC>(context(), key, &id)) {
+      if (!PrimitiveValueToId<CanGC>(context(), key, &id)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -3425,7 +3425,7 @@ JS_PUBLIC_API bool JS_StructuredClone(
   // so we copy the string by wrapping it.
   if (value.isString()) {
     RootedString strValue(cx, value.toString());
-    if (!cx->compartment()->wrap(cx, &strValue)) {
+    if (!cx->compartment()->wrap(cx, &strValue)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     vp.setString(strValue);
@@ -3440,7 +3440,7 @@ JS_PUBLIC_API bool JS_StructuredClone(
     if (value.isObject()) {
       RootedObject obj(cx, &value.toObject());
       obj = CheckedUnwrapStatic(obj);
-      if (!obj) {
+      if (!obj) {MOZ_RELEASE_ASSERT(0);
         ReportAccessDenied(cx);
         return false;
       }
@@ -3497,10 +3497,10 @@ void JSAutoStructuredCloneBuffer::adopt(
 void JSAutoStructuredCloneBuffer::steal(
     JSStructuredCloneData* data, uint32_t* versionp,
     const JSStructuredCloneCallbacks** callbacks, void** closure) {
-  if (versionp) {
+  if (versionp) {MOZ_RELEASE_ASSERT(0);
     *versionp = version_;
   }
-  if (callbacks) {
+  if (callbacks) {MOZ_RELEASE_ASSERT(0);
     *callbacks = data_.callbacks_;
   }
   if (closure) {
@@ -3560,20 +3560,20 @@ JS_PUBLIC_API bool JS_ReadBytes(JSStruct
 JS_PUBLIC_API bool JS_ReadTypedArray(JSStructuredCloneReader* r,
                                      MutableHandleValue vp) {
   uint32_t tag, data;
-  if (!r->input().readPair(&tag, &data)) {
+  if (!r->input().readPair(&tag, &data)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (tag >= SCTAG_TYPED_ARRAY_V1_MIN && tag <= SCTAG_TYPED_ARRAY_V1_MAX) {
+  if (tag >= SCTAG_TYPED_ARRAY_V1_MIN && tag <= SCTAG_TYPED_ARRAY_V1_MAX) {MOZ_RELEASE_ASSERT(0);
     return r->readTypedArray(TagToV1ArrayType(tag), data, vp, true);
   }
 
-  if (tag == SCTAG_TYPED_ARRAY_OBJECT_V2) {
+  if (tag == SCTAG_TYPED_ARRAY_OBJECT_V2) {MOZ_RELEASE_ASSERT(0);
     // V2 stores the length (nelems) in |data| and the arrayType separately.
     uint64_t arrayType;
-    if (!r->input().read(&arrayType)) {
+    if (!r->input().read(&arrayType)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     uint64_t nelems = data;
     return r->readTypedArray(arrayType, nelems, vp);
   }
diff --git a/js/src/vm/SymbolType.cpp b/js/src/vm/SymbolType.cpp
--- a/js/src/vm/SymbolType.cpp
+++ b/js/src/vm/SymbolType.cpp
@@ -36,7 +36,7 @@ Symbol* Symbol::new_(JSContext* cx, JS::
   RootedAtom atom(cx);
   if (description) {
     atom = AtomizeString(cx, description);
-    if (!atom) {
+    if (!atom) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -50,7 +50,7 @@ Symbol* Symbol::new_(JSContext* cx, JS::
 
 Symbol* Symbol::for_(JSContext* cx, HandleString description) {
   RootedAtom atom(cx, AtomizeString(cx, description));
-  if (!atom) {
+  if (!atom) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -65,7 +65,7 @@ Symbol* Symbol::for_(JSContext* cx, Hand
   // that is different than the hash of the corresponding atom.
   HashNumber hash = mozilla::HashGeneric(atom->hash());
   Symbol* sym = newInternal(cx, SymbolCode::InSymbolRegistry, hash, atom);
-  if (!sym) {
+  if (!sym) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -118,15 +118,15 @@ bool js::SymbolDescriptiveString(JSConte
                                  MutableHandleValue result) {
   // steps 2-5
   JSStringBuilder sb(cx);
-  if (!sb.append("Symbol(")) {
+  if (!sb.append("Symbol(")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (JSAtom* desc = sym->description()) {
-    if (!sb.append(desc)) {
+    if (!sb.append(desc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
-  if (!sb.append(')')) {
+  if (!sb.append(')')) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/vm/Time.cpp b/js/src/vm/Time.cpp
--- a/js/src/vm/Time.cpp
+++ b/js/src/vm/Time.cpp
@@ -94,7 +94,7 @@ struct CalibrationData {
 
 static CalibrationData calibration = {0};
 
-static void NowCalibrate() {
+static void NowCalibrate() {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(calibration.freq > 0);
 
   // By wrapping a timeBegin/EndPeriod pair of calls around this loop,
@@ -155,17 +155,17 @@ static int64_t PRMJ_NowImpl() {
     FILETIME ft;
     pGetSystemTimePreciseAsFileTime(&ft);
     return int64_t(FileTimeToUnixMicroseconds(ft));
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   bool calibrated = false;
   bool needsCalibration = !calibration.calibrated;
   double cachedOffset = 0.0;
-  while (true) {
-    if (needsCalibration) {
+  while (true) {MOZ_RELEASE_ASSERT(0);
+    if (needsCalibration) {MOZ_RELEASE_ASSERT(0);
       MUTEX_LOCK(&calibration.data_lock);
 
       // Recalibrate only if no one else did before us.
-      if (calibration.offset == cachedOffset) {
+      if (calibration.offset == cachedOffset) {MOZ_RELEASE_ASSERT(0);
         // Since calibration can take a while, make any other
         // threads immediately wait.
         MUTEX_SETSPINCOUNT(&calibration.data_lock, 0);
@@ -176,10 +176,10 @@ static int64_t PRMJ_NowImpl() {
 
         // Restore spin count.
         MUTEX_SETSPINCOUNT(&calibration.data_lock, DataLockSpinCount);
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       MUTEX_UNLOCK(&calibration.data_lock);
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     // Calculate a low resolution time.
     FILETIME ft;
@@ -214,7 +214,7 @@ static int64_t PRMJ_NowImpl() {
     // itself, but I have only seen it triggered by another program
     // doing some kind of file I/O. The symptoms are a negative diff
     // followed by an equally large positive diff.
-    if (mozilla::Abs(diff) <= 2 * KernelTickInMicroseconds) {
+    if (mozilla::Abs(diff) <= 2 * KernelTickInMicroseconds) {MOZ_RELEASE_ASSERT(0);
       // No detectable clock skew.
       return int64_t(highresTime);
     }
diff --git a/js/src/vm/ToSource.cpp b/js/src/vm/ToSource.cpp
--- a/js/src/vm/ToSource.cpp
+++ b/js/src/vm/ToSource.cpp
@@ -80,12 +80,12 @@ static JSString* SymbolToSource(JSContex
 
   JSStringBuilder buf(cx);
   if (code == SymbolCode::InSymbolRegistry ? !buf.append("Symbol.for(")
-                                           : !buf.append("Symbol(")) {
+                                           : !buf.append("Symbol(")) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (desc) {
     UniqueChars quoted = QuoteString(cx, desc, '"');
-    if (!quoted || !buf.append(quoted.get(), strlen(quoted.get()))) {
+    if (!quoted || !buf.append(quoted.get(), strlen(quoted.get()))) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -98,13 +98,13 @@ static JSString* SymbolToSource(JSContex
 static JSString* BoxedToSource(JSContext* cx, HandleObject obj,
                                const char* constructor) {
   RootedValue value(cx);
-  if (!Unbox(cx, obj, &value)) {
+  if (!Unbox(cx, obj, &value)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   MOZ_ASSERT(!value.isUndefined());
 
   RootedString str(cx, ValueToSource(cx, value));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/vm/TraceLogging.cpp b/js/src/vm/TraceLogging.cpp
--- a/js/src/vm/TraceLogging.cpp
+++ b/js/src/vm/TraceLogging.cpp
@@ -40,12 +40,12 @@ static bool getTraceLoggerSupported() {
   if (!str) {
     // Default to unsupported.
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   if (strcmp(str, "false") == 0 || strcmp(str, "no") == 0 ||
-      strcmp(str, "0") == 0) {
+      strcmp(str, "0") == 0) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   if (strcmp(str, "true") == 0 || strcmp(str, "yes") == 0 ||
       strcmp(str, "1") == 0) {
@@ -91,8 +91,8 @@ void js::DestroyTraceLogger(TraceLoggerT
   traceLoggerState->destroyLogger(logger);
 }
 
-bool TraceLoggerThread::init() {
-  if (!events_.init()) {
+bool TraceLoggerThread::init() {MOZ_RELEASE_ASSERT(0);
+  if (!events_.init()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -110,31 +110,31 @@ bool TraceLoggerThread::init() {
   return true;
 }
 
-void TraceLoggerThread::initGraph() {
+void TraceLoggerThread::initGraph() {MOZ_RELEASE_ASSERT(0);
   // Create a graph. I don't like this is called reset, but it locks the
   // graph into the UniquePtr. So it gets deleted when TraceLoggerThread
   // is destructed.
   graph_.reset(js_new<TraceLoggerGraph>());
-  if (!graph_.get()) {
+  if (!graph_.get()) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MOZ_ASSERT(traceLoggerState);
   bool graphFile = traceLoggerState->isGraphFileEnabled();
   double delta =
       traceLoggerState->getTimeStampOffset(mozilla::TimeStamp::NowUnfuzzed());
   uint64_t start = static_cast<uint64_t>(delta);
-  if (!graph_->init(start, graphFile)) {
+  if (!graph_->init(start, graphFile)) {MOZ_RELEASE_ASSERT(0);
     graph_ = nullptr;
     return;
   }
 
-  if (graphFile) {
+  if (graphFile) {MOZ_RELEASE_ASSERT(0);
     // Report the textIds to the graph.
-    for (uint32_t i = 0; i < TraceLogger_TreeItemEnd; i++) {
+    for (uint32_t i = 0; i < TraceLogger_TreeItemEnd; i++) {MOZ_RELEASE_ASSERT(0);
       TraceLoggerTextId id = TraceLoggerTextId(i);
       graph_->addTextId(i, TLTextIdString(id));
-    }
+    }MOZ_RELEASE_ASSERT(0);
     graph_->addTextId(TraceLogger_TreeItemEnd, "TraceLogger internal");
     for (uint32_t i = TraceLogger_TreeItemEnd + 1; i < TraceLogger_Last; i++) {
       TraceLoggerTextId id = TraceLoggerTextId(i);
@@ -143,7 +143,7 @@ void TraceLoggerThread::initGraph() {
   }
 }
 
-void TraceLoggerThreadState::disableAllTextIds() {
+void TraceLoggerThreadState::disableAllTextIds() {MOZ_RELEASE_ASSERT(0);
   for (uint32_t i = 1; i < TraceLogger_Last; i++) {
     enabledTextIds[i] = false;
   }
@@ -234,8 +234,8 @@ void TraceLoggerThreadState::enableFront
   enabledTextIds[TraceLogger_BytecodeNameFunctions] = true;
 }
 
-TraceLoggerThread::~TraceLoggerThread() {
-  if (graph_.get()) {
+TraceLoggerThread::~TraceLoggerThread() {MOZ_RELEASE_ASSERT(0);
+  if (graph_.get()) {MOZ_RELEASE_ASSERT(0);
     if (!failed_) {
       graph_->log(events_, traceLoggerState->startTime);
     }
@@ -243,8 +243,8 @@ TraceLoggerThread::~TraceLoggerThread() 
   }
 }
 
-bool TraceLoggerThread::enable() {
-  if (enabled_ > 0) {
+bool TraceLoggerThread::enable() {MOZ_RELEASE_ASSERT(0);
+  if (enabled_ > 0) {MOZ_RELEASE_ASSERT(0);
     enabled_++;
     return true;
   }
@@ -275,7 +275,7 @@ void TraceLoggerThread::silentFail(const
 }
 
 size_t TraceLoggerThread::sizeOfExcludingThis(
-    mozilla::MallocSizeOf mallocSizeOf) const {
+    mozilla::MallocSizeOf mallocSizeOf) const {MOZ_RELEASE_ASSERT(0);
   size_t size = 0;
 #ifdef DEBUG
   size += graphStack_.sizeOfExcludingThis(mallocSizeOf);
@@ -292,40 +292,40 @@ size_t TraceLoggerThread::sizeOfIncludin
   return mallocSizeOf(this) + sizeOfExcludingThis(mallocSizeOf);
 }
 
-bool TraceLoggerThread::enable(JSContext* cx) {
+bool TraceLoggerThread::enable(JSContext* cx) {MOZ_RELEASE_ASSERT(0);
   using namespace js::jit;
 
-  if (!enable()) {
+  if (!enable()) {MOZ_RELEASE_ASSERT(0);
     return fail(cx, "internal error");
   }
 
-  if (enabled_ == 1) {
+  if (enabled_ == 1) {MOZ_RELEASE_ASSERT(0);
     // Get the top Activation to log the top script/pc (No inlined frames).
     ActivationIterator iter(cx);
     Activation* act = iter.activation();
 
-    if (!act) {
+    if (!act) {MOZ_RELEASE_ASSERT(0);
       return fail(cx, "internal error");
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     JSScript* script = nullptr;
     int32_t engine = 0;
 
-    if (act->isJit()) {
+    if (act->isJit()) {MOZ_RELEASE_ASSERT(0);
       JitFrameIter frame(iter->asJit());
 
-      while (!frame.done()) {
-        if (frame.isWasm()) {
+      while (!frame.done()) {MOZ_RELEASE_ASSERT(0);
+        if (frame.isWasm()) {MOZ_RELEASE_ASSERT(0);
           JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                     JSMSG_TRACELOGGER_ENABLE_FAIL,
                                     "not yet supported in wasm code");
           return false;
         }
-        if (frame.asJSJit().isScripted()) {
+        if (frame.asJSJit().isScripted()) {MOZ_RELEASE_ASSERT(0);
           break;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         ++frame;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       MOZ_ASSERT(!frame.done());
 
@@ -335,7 +335,7 @@ bool TraceLoggerThread::enable(JSContext
       script = jitFrame.script();
       engine =
           jitFrame.isIonJS() ? TraceLogger_IonMonkey : TraceLogger_Baseline;
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(act->isInterpreter());
       InterpreterFrame* fp = act->asInterpreter()->current();
       MOZ_ASSERT(!fp->runningInJit());
@@ -355,17 +355,17 @@ bool TraceLoggerThread::enable(JSContext
   return true;
 }
 
-bool TraceLoggerThread::disable(bool force, const char* error) {
-  if (failed_) {
+bool TraceLoggerThread::disable(bool force, const char* error) {MOZ_RELEASE_ASSERT(0);
+  if (failed_) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(enabled_ == 0);
     return false;
   }
 
-  if (enabled_ == 0) {
+  if (enabled_ == 0) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
-  if (enabled_ > 1 && !force) {
+  if (enabled_ > 1 && !force) {MOZ_RELEASE_ASSERT(0);
     enabled_--;
     return true;
   }
@@ -380,17 +380,17 @@ bool TraceLoggerThread::disable(bool for
   return true;
 }
 
-const char* TraceLoggerThread::maybeEventText(uint32_t id) {
+const char* TraceLoggerThread::maybeEventText(uint32_t id) {MOZ_RELEASE_ASSERT(0);
   if (TLTextIdIsEnumEvent(id)) {
     return TLTextIdString(static_cast<TraceLoggerTextId>(id));
   }
   return traceLoggerState->maybeEventText(id);
 }
 
-TraceLoggerEventPayload* TraceLoggerThreadState::getPayload(uint32_t id) {
-  if (TLTextIdIsEnumEvent(id)) {
+TraceLoggerEventPayload* TraceLoggerThreadState::getPayload(uint32_t id) {MOZ_RELEASE_ASSERT(0);
+  if (TLTextIdIsEnumEvent(id)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   TextIdToPayloadMap::Ptr p = textIdPayloads.lookup(id);
   if (!p) {
@@ -401,7 +401,7 @@ TraceLoggerEventPayload* TraceLoggerThre
   return p->value();
 }
 
-const char* TraceLoggerThreadState::maybeEventText(uint32_t id) {
+const char* TraceLoggerThreadState::maybeEventText(uint32_t id) {MOZ_RELEASE_ASSERT(0);
   LockGuard<Mutex> guard(lock);
 
   TextIdToPayloadMap::Ptr p = textIdPayloads.lookup(id);
@@ -414,7 +414,7 @@ const char* TraceLoggerThreadState::mayb
   return dictionaryData[dictId].get();
 }
 
-const char* TraceLoggerThreadState::maybeEventText(TraceLoggerEventPayload* p) {
+const char* TraceLoggerThreadState::maybeEventText(TraceLoggerEventPayload* p) {MOZ_RELEASE_ASSERT(0);
   LockGuard<Mutex> guard(lock);
   if (!p) {
     return nullptr;
@@ -426,7 +426,7 @@ const char* TraceLoggerThreadState::mayb
 }
 
 size_t TraceLoggerThreadState::sizeOfExcludingThis(
-    mozilla::MallocSizeOf mallocSizeOf) {
+    mozilla::MallocSizeOf mallocSizeOf) {MOZ_RELEASE_ASSERT(0);
   LockGuard<Mutex> guard(lock);
 
   // Do not count threadLoggers since they are counted by
@@ -445,39 +445,39 @@ size_t TraceLoggerThreadState::sizeOfExc
 }
 
 TraceLoggerEventPayload* TraceLoggerThreadState::getOrCreateEventPayload(
-    const char* text) {
+    const char* text) {MOZ_RELEASE_ASSERT(0);
   LockGuard<Mutex> guard(lock);
 
   uint32_t dictId = nextDictionaryId;
 
   StringHashToDictionaryMap::AddPtr dictp =
       payloadDictionary.lookupForAdd(text);
-  if (dictp) {
+  if (dictp) {MOZ_RELEASE_ASSERT(0);
     dictId = dictp->value();
     MOZ_ASSERT(dictId < nextDictionaryId);  // Sanity check.
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     UniqueChars str = DuplicateString(text);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (!payloadDictionary.add(dictp, str.get(), nextDictionaryId)) {
+    if (!payloadDictionary.add(dictp, str.get(), nextDictionaryId)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (!dictionaryData.append(std::move(str))) {
+    if (!dictionaryData.append(std::move(str))) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     nextDictionaryId++;
   }
 
   // Look for a free entry, as some textId's may
   // already be taken from previous profiling sessions.
-  while (textIdPayloads.has(nextTextId)) {
+  while (textIdPayloads.has(nextTextId)) {MOZ_RELEASE_ASSERT(0);
     nextTextId++;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   auto* payload = js_new<TraceLoggerEventPayload>(nextTextId, dictId);
-  if (!payload) {
+  if (!payload) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -495,9 +495,9 @@ TraceLoggerEventPayload* TraceLoggerThre
 
 TraceLoggerEventPayload* TraceLoggerThreadState::getOrCreateEventPayload(
     const char* filename, uint32_t lineno, uint32_t colno) {
-  if (!filename) {
+  if (!filename) {MOZ_RELEASE_ASSERT(0);
     filename = "<unknown>";
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   TraceLoggerEventPayload* payload = getOrCreateEventPayload(filename);
   if (!payload) {
@@ -516,14 +516,14 @@ TraceLoggerEventPayload* TraceLoggerThre
                                  script->column());
 }
 
-void TraceLoggerThreadState::purgeUnusedPayloads() {
+void TraceLoggerThreadState::purgeUnusedPayloads() {MOZ_RELEASE_ASSERT(0);
   // Care needs to be taken to maintain a coherent state in this function,
   // as payloads can have their use count change at any time from non-zero to
   // zero (but not the other way around; see TraceLoggerEventPayload::use()).
   LockGuard<Mutex> guard(lock);
 
   // Free all other payloads that have no uses anymore.
-  for (TextIdToPayloadMap::Enum e(textIdPayloads); !e.empty(); e.popFront()) {
+  for (TextIdToPayloadMap::Enum e(textIdPayloads); !e.empty(); e.popFront()) {MOZ_RELEASE_ASSERT(0);
     if (e.front().value()->uses() == 0) {
       uint32_t dictId = e.front().value()->dictionaryId();
       dictionaryData.erase(dictionaryData.begin() + dictId);
@@ -537,8 +537,8 @@ void TraceLoggerThread::startEvent(Trace
   startEvent(uint32_t(id));
 }
 
-void TraceLoggerThread::startEvent(const TraceLoggerEvent& event) {
-  if (!event.hasTextId()) {
+void TraceLoggerThread::startEvent(const TraceLoggerEvent& event) {MOZ_RELEASE_ASSERT(0);
+  if (!event.hasTextId()) {MOZ_RELEASE_ASSERT(0);
     if (!enabled()) {
       return;
     }
@@ -552,14 +552,14 @@ void TraceLoggerThread::startEvent(const
   startEvent(event.textId());
 }
 
-void TraceLoggerThread::startEvent(uint32_t id) {
-  if (!jit::JitOptions.enableTraceLogger) {
+void TraceLoggerThread::startEvent(uint32_t id) {MOZ_RELEASE_ASSERT(0);
+  if (!jit::JitOptions.enableTraceLogger) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MOZ_ASSERT(TLTextIdIsTreeEvent(id) || id == TraceLogger_Error);
   MOZ_ASSERT(traceLoggerState);
-  if (!traceLoggerState->isTextIdEnabled(id)) {
+  if (!traceLoggerState->isTextIdEnabled(id)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -572,18 +572,18 @@ void TraceLoggerThread::startEvent(uint3
   }
 #endif
 
-  if (graph_.get() && traceLoggerState->isGraphFileEnabled()) {
+  if (graph_.get() && traceLoggerState->isGraphFileEnabled()) {MOZ_RELEASE_ASSERT(0);
     // Flush each textId to disk.  textId values up to TraceLogger_Last are
     // statically defined and each one has an associated constant event string
     // defined by TLTextIdString().  For any events with textId >=
     // TraceLogger_Last the payload associated with that textId must first be
     // found and then maybeEventText() will find the event string form the
     // dictionary.
-    for (uint32_t otherId = graph_->nextTextId(); otherId <= id; otherId++) {
-      if (TLTextIdIsEnumEvent(id)) {
+    for (uint32_t otherId = graph_->nextTextId(); otherId <= id; otherId++) {MOZ_RELEASE_ASSERT(0);
+      if (TLTextIdIsEnumEvent(id)) {MOZ_RELEASE_ASSERT(0);
         const char* text = TLTextIdString(static_cast<TraceLoggerTextId>(id));
         graph_->addTextId(otherId, text);
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         TraceLoggerEventPayload* p = traceLoggerState->getPayload(id);
         if (p) {
           const char* filename = traceLoggerState->maybeEventText(p);
@@ -603,7 +603,7 @@ void TraceLoggerThread::stopEvent(TraceL
   stopEvent(uint32_t(id));
 }
 
-void TraceLoggerThread::stopEvent(const TraceLoggerEvent& event) {
+void TraceLoggerThread::stopEvent(const TraceLoggerEvent& event) {MOZ_RELEASE_ASSERT(0);
   if (!event.hasTextId()) {
     stopEvent(TraceLogger_Error);
     return;
@@ -611,14 +611,14 @@ void TraceLoggerThread::stopEvent(const 
   stopEvent(event.textId());
 }
 
-void TraceLoggerThread::stopEvent(uint32_t id) {
-  if (!jit::JitOptions.enableTraceLogger) {
+void TraceLoggerThread::stopEvent(uint32_t id) {MOZ_RELEASE_ASSERT(0);
+  if (!jit::JitOptions.enableTraceLogger) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MOZ_ASSERT(TLTextIdIsTreeEvent(id) || id == TraceLogger_Error);
   MOZ_ASSERT(traceLoggerState);
-  if (!traceLoggerState->isTextIdEnabled(id)) {
+  if (!traceLoggerState->isTextIdEnabled(id)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -661,29 +661,29 @@ JS::AutoTraceLoggerLockGuard::~AutoTrace
 size_t JS::TraceLoggerDictionaryImpl::NextChunk(JSContext* cx,
                                                 size_t* dataIndex,
                                                 char buffer[],
-                                                size_t bufferSize) {
+                                                size_t bufferSize) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(dataIndex != nullptr);
   if (!traceLoggerState || bufferSize == 0 || !buffer ||
-      !jit::JitOptions.enableTraceLogger) {
+      !jit::JitOptions.enableTraceLogger) {MOZ_RELEASE_ASSERT(0);
     return 0;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   size_t bufferIndex = 0;
 
   const char* eventString = nullptr;
-  if (TLTextIdIsEnumEvent(*dataIndex)) {
+  if (TLTextIdIsEnumEvent(*dataIndex)) {MOZ_RELEASE_ASSERT(0);
     eventString = TLTextIdString(static_cast<TraceLoggerTextId>(*dataIndex));
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     uint32_t dictId = *dataIndex - TraceLogger_Last;
-    if (dictId < traceLoggerState->dictionaryData.length()) {
+    if (dictId < traceLoggerState->dictionaryData.length()) {MOZ_RELEASE_ASSERT(0);
       eventString = traceLoggerState->dictionaryData[dictId].get();
       MOZ_ASSERT(eventString);
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
-  if (eventString) {
+  if (eventString) {MOZ_RELEASE_ASSERT(0);
     size_t length = strlen(eventString);
-    if (length < bufferSize - 1) {
+    if (length < bufferSize - 1) {MOZ_RELEASE_ASSERT(0);
       memcpy(buffer, eventString, length);
       buffer[length] = '\0';
       bufferIndex = length;
@@ -699,37 +699,37 @@ size_t JS::TraceLoggerDictionaryImpl::Ne
 }
 
 size_t JS::TraceLoggerIdImpl::NextChunk(JSContext* cx, size_t* dataIndex,
-                                        uint32_t buffer[], size_t bufferSize) {
+                                        uint32_t buffer[], size_t bufferSize) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(dataIndex != nullptr);
-  if (!cx || !cx->traceLogger) {
+  if (!cx || !cx->traceLogger) {MOZ_RELEASE_ASSERT(0);
     return 0;
   }
 
-  if (bufferSize == 0 || !buffer || !jit::JitOptions.enableTraceLogger) {
+  if (bufferSize == 0 || !buffer || !jit::JitOptions.enableTraceLogger) {MOZ_RELEASE_ASSERT(0);
     return 0;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   size_t bufferIndex = 0;
   ContinuousSpace<EventEntry>& events = cx->traceLogger->events_;
 
-  for (; *dataIndex < events.size(); (*dataIndex)++) {
-    if (TLTextIdIsInternalEvent(events[*dataIndex].textId)) {
+  for (; *dataIndex < events.size(); (*dataIndex)++) {MOZ_RELEASE_ASSERT(0);
+    if (TLTextIdIsInternalEvent(events[*dataIndex].textId)) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
-    if (TLTextIdIsScriptEvent(events[*dataIndex].textId)) {
+    if (TLTextIdIsScriptEvent(events[*dataIndex].textId)) {MOZ_RELEASE_ASSERT(0);
       TraceLoggerEventPayload* payload =
           traceLoggerState->getPayload(events[*dataIndex].textId);
       MOZ_ASSERT(payload);
-      if (!payload) {
+      if (!payload) {MOZ_RELEASE_ASSERT(0);
         return 0;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       // Write the index of this event into the jsTracerDictionary array
       // property
       uint32_t dictId = TraceLogger_Last + payload->dictionaryId();
       buffer[bufferIndex++] = dictId;
       payload->release();
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       buffer[bufferIndex++] = events[*dataIndex].textId;
     }
 
@@ -743,39 +743,39 @@ size_t JS::TraceLoggerIdImpl::NextChunk(
 
 size_t JS::TraceLoggerLineNoImpl::NextChunk(JSContext* cx, size_t* dataIndex,
                                             int32_t buffer[],
-                                            size_t bufferSize) {
+                                            size_t bufferSize) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(dataIndex != nullptr);
-  if (!cx || !cx->traceLogger) {
+  if (!cx || !cx->traceLogger) {MOZ_RELEASE_ASSERT(0);
     return 0;
   }
 
-  if (bufferSize == 0 || !buffer || !jit::JitOptions.enableTraceLogger) {
+  if (bufferSize == 0 || !buffer || !jit::JitOptions.enableTraceLogger) {MOZ_RELEASE_ASSERT(0);
     return 0;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   size_t bufferIndex = 0;
   ContinuousSpace<EventEntry>& events = cx->traceLogger->events_;
 
-  for (; *dataIndex < events.size(); (*dataIndex)++) {
-    if (TLTextIdIsInternalEvent(events[*dataIndex].textId)) {
+  for (; *dataIndex < events.size(); (*dataIndex)++) {MOZ_RELEASE_ASSERT(0);
+    if (TLTextIdIsInternalEvent(events[*dataIndex].textId)) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
-    if (TLTextIdIsScriptEvent(events[*dataIndex].textId)) {
+    if (TLTextIdIsScriptEvent(events[*dataIndex].textId)) {MOZ_RELEASE_ASSERT(0);
       TraceLoggerEventPayload* payload =
           traceLoggerState->getPayload(events[*dataIndex].textId);
       MOZ_ASSERT(payload);
-      if (!payload) {
+      if (!payload) {MOZ_RELEASE_ASSERT(0);
         return 0;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       mozilla::Maybe<uint32_t> line = payload->line();
       payload->release();
-      if (line) {
+      if (line) {MOZ_RELEASE_ASSERT(0);
         buffer[bufferIndex++] = *line;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         buffer[bufferIndex++] = -1;
       }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       buffer[bufferIndex++] = -1;
     }
     if (bufferIndex == bufferSize) {
@@ -788,39 +788,39 @@ size_t JS::TraceLoggerLineNoImpl::NextCh
 
 size_t JS::TraceLoggerColNoImpl::NextChunk(JSContext* cx, size_t* dataIndex,
                                            int32_t buffer[],
-                                           size_t bufferSize) {
+                                           size_t bufferSize) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(dataIndex != nullptr);
-  if (!cx || !cx->traceLogger) {
+  if (!cx || !cx->traceLogger) {MOZ_RELEASE_ASSERT(0);
     return 0;
   }
 
-  if (bufferSize == 0 || !buffer || !jit::JitOptions.enableTraceLogger) {
+  if (bufferSize == 0 || !buffer || !jit::JitOptions.enableTraceLogger) {MOZ_RELEASE_ASSERT(0);
     return 0;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   size_t bufferIndex = 0;
   ContinuousSpace<EventEntry>& events = cx->traceLogger->events_;
 
-  for (; *dataIndex < events.size(); (*dataIndex)++) {
-    if (TLTextIdIsInternalEvent(events[*dataIndex].textId)) {
+  for (; *dataIndex < events.size(); (*dataIndex)++) {MOZ_RELEASE_ASSERT(0);
+    if (TLTextIdIsInternalEvent(events[*dataIndex].textId)) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
-    if (TLTextIdIsScriptEvent(events[*dataIndex].textId)) {
+    if (TLTextIdIsScriptEvent(events[*dataIndex].textId)) {MOZ_RELEASE_ASSERT(0);
       TraceLoggerEventPayload* payload =
           traceLoggerState->getPayload(events[*dataIndex].textId);
       MOZ_ASSERT(payload);
-      if (!payload) {
+      if (!payload) {MOZ_RELEASE_ASSERT(0);
         return 0;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       mozilla::Maybe<uint32_t> column = payload->column();
       payload->release();
-      if (column) {
+      if (column) {MOZ_RELEASE_ASSERT(0);
         buffer[bufferIndex++] = *column;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         buffer[bufferIndex++] = -1;
       }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       buffer[bufferIndex++] = -1;
     }
     if (bufferIndex == bufferSize) {
@@ -833,23 +833,23 @@ size_t JS::TraceLoggerColNoImpl::NextChu
 
 size_t JS::TraceLoggerTimeStampImpl::NextChunk(JSContext* cx, size_t* dataIndex,
                                                mozilla::TimeStamp buffer[],
-                                               size_t bufferSize) {
+                                               size_t bufferSize) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(dataIndex != nullptr);
-  if (!cx || !cx->traceLogger) {
+  if (!cx || !cx->traceLogger) {MOZ_RELEASE_ASSERT(0);
     return 0;
   }
 
-  if (bufferSize == 0 || !buffer || !jit::JitOptions.enableTraceLogger) {
+  if (bufferSize == 0 || !buffer || !jit::JitOptions.enableTraceLogger) {MOZ_RELEASE_ASSERT(0);
     return 0;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   size_t bufferIndex = 0;
   ContinuousSpace<EventEntry>& events = cx->traceLogger->events_;
 
-  for (; *dataIndex < events.size(); (*dataIndex)++) {
-    if (TLTextIdIsInternalEvent(events[*dataIndex].textId)) {
+  for (; *dataIndex < events.size(); (*dataIndex)++) {MOZ_RELEASE_ASSERT(0);
+    if (TLTextIdIsInternalEvent(events[*dataIndex].textId)) {MOZ_RELEASE_ASSERT(0);
       continue;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     buffer[bufferIndex++] = events[*dataIndex].time;
     if (bufferIndex == bufferSize) {
       break;
@@ -861,15 +861,15 @@ size_t JS::TraceLoggerTimeStampImpl::Nex
 
 size_t JS::TraceLoggerDurationImpl::NextChunk(JSContext* cx, size_t* dataIndex,
                                               double buffer[],
-                                              size_t bufferSize) {
+                                              size_t bufferSize) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(dataIndex != nullptr);
-  if (!cx || !cx->traceLogger) {
+  if (!cx || !cx->traceLogger) {MOZ_RELEASE_ASSERT(0);
     return 0;
   }
 
-  if (bufferSize == 0 || !buffer || !jit::JitOptions.enableTraceLogger) {
+  if (bufferSize == 0 || !buffer || !jit::JitOptions.enableTraceLogger) {MOZ_RELEASE_ASSERT(0);
     return 0;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   ContinuousSpace<EventEntry>& events = cx->traceLogger->events_;
   Vector<size_t, 0, js::SystemAllocPolicy> eventStack;
@@ -878,66 +878,66 @@ size_t JS::TraceLoggerDurationImpl::Next
   EventDurationMap eventMap;
 
   size_t bufferIndex = 0;
-  for (; *dataIndex < events.size(); (*dataIndex)++) {
-    if (TLTextIdIsInternalEvent(events[*dataIndex].textId)) {
+  for (; *dataIndex < events.size(); (*dataIndex)++) {MOZ_RELEASE_ASSERT(0);
+    if (TLTextIdIsInternalEvent(events[*dataIndex].textId)) {MOZ_RELEASE_ASSERT(0);
       continue;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     double duration = 0;
-    if (TLTextIdIsLogEvent(events[*dataIndex].textId)) {
+    if (TLTextIdIsLogEvent(events[*dataIndex].textId)) {MOZ_RELEASE_ASSERT(0);
       // log events are snapshot events with no start & stop
       duration = -1;
-    } else if (EventDurationMap::Ptr p = eventMap.lookup(*dataIndex)) {
+    } else if (EventDurationMap::Ptr p = eventMap.lookup(*dataIndex)) {MOZ_RELEASE_ASSERT(0);
       // value has already been cached
       duration = p->value();
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(eventStack.empty());
-      if (!eventStack.append(*dataIndex)) {
+      if (!eventStack.append(*dataIndex)) {MOZ_RELEASE_ASSERT(0);
         return 0;
       }
 
       // Search through the events array to find the matching stop event in
       // order to calculate the duration time.  Cache all other durations we
       // calculate in the meantime.
-      for (size_t j = *dataIndex + 1; j < events.size(); j++) {
+      for (size_t j = *dataIndex + 1; j < events.size(); j++) {MOZ_RELEASE_ASSERT(0);
         uint32_t id = events[j].textId;
-        if (id == TraceLogger_Stop) {
+        if (id == TraceLogger_Stop) {MOZ_RELEASE_ASSERT(0);
           uint32_t prev = eventStack.popCopy();
           double delta = (events[j].time - events[prev].time).ToMicroseconds();
-          if (prev == *dataIndex) {
+          if (prev == *dataIndex) {MOZ_RELEASE_ASSERT(0);
             MOZ_ASSERT(eventStack.empty());
             duration = delta;
             break;
           }
 
-          if (!eventMap.putNew(prev, delta)) {
+          if (!eventMap.putNew(prev, delta)) {MOZ_RELEASE_ASSERT(0);
             return 0;
           }
 
-        } else if (TLTextIdIsTreeEvent(id)) {
-          if (!eventStack.append(j)) {
+        } else if (TLTextIdIsTreeEvent(id)) {MOZ_RELEASE_ASSERT(0);
+          if (!eventStack.append(j)) {MOZ_RELEASE_ASSERT(0);
             return 0;
-          }
+          }MOZ_RELEASE_ASSERT(0);
         }
 
         // If we reach the end of the list, use the last event as the end
         // event for all events remaining on the stack.
-        if (j == events.size() - 1) {
-          while (!eventStack.empty()) {
+        if (j == events.size() - 1) {MOZ_RELEASE_ASSERT(0);
+          while (!eventStack.empty()) {MOZ_RELEASE_ASSERT(0);
             uint32_t prev = eventStack.popCopy();
             double delta =
                 (events[j].time - events[prev].time).ToMicroseconds();
-            if (prev == *dataIndex) {
+            if (prev == *dataIndex) {MOZ_RELEASE_ASSERT(0);
               MOZ_ASSERT(eventStack.empty());
               duration = delta;
             } else {
-              if (!eventMap.putNew(prev, delta)) {
+              if (!eventMap.putNew(prev, delta)) {MOZ_RELEASE_ASSERT(0);
                 return 0;
               }
-            }
-          }
-        }
+            }MOZ_RELEASE_ASSERT(0);
+          }MOZ_RELEASE_ASSERT(0);
+        }MOZ_RELEASE_ASSERT(0);
       }
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     buffer[bufferIndex++] = duration;
     if (bufferIndex == bufferSize) {
@@ -957,15 +957,15 @@ void TraceLoggerThread::logTimestamp(uin
   log(id);
 }
 
-void TraceLoggerThread::log(uint32_t id) {
-  if (enabled_ == 0) {
+void TraceLoggerThread::log(uint32_t id) {MOZ_RELEASE_ASSERT(0);
+  if (enabled_ == 0) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
 #ifdef DEBUG
   if (id == TraceLogger_Disable) {
     graphStack_.clear();
-  }
+  }MOZ_RELEASE_ASSERT(0);
 #endif
 
   MOZ_ASSERT(traceLoggerState);
@@ -973,20 +973,20 @@ void TraceLoggerThread::log(uint32_t id)
   // We request for 3 items to add, since if we don't have enough room
   // we record the time it took to make more space. To log this information
   // we need 2 extra free entries.
-  if (!events_.hasSpaceForAdd(3)) {
+  if (!events_.hasSpaceForAdd(3)) {MOZ_RELEASE_ASSERT(0);
     mozilla::TimeStamp start = mozilla::TimeStamp::NowUnfuzzed();
 
-    if (!events_.ensureSpaceBeforeAdd(3)) {
-      if (graph_.get()) {
+    if (!events_.ensureSpaceBeforeAdd(3)) {MOZ_RELEASE_ASSERT(0);
+      if (graph_.get()) {MOZ_RELEASE_ASSERT(0);
         graph_->log(events_, traceLoggerState->startTime);
       }
 
       // The data structures are full, and the graph file is not enabled
       // so we cannot flush to disk.  Trace logging should stop here.
-      if (!traceLoggerState->isGraphFileEnabled()) {
+      if (!traceLoggerState->isGraphFileEnabled()) {MOZ_RELEASE_ASSERT(0);
         enabled_ = 0;
         return;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       iteration_++;
       events_.clear();
@@ -1018,7 +1018,7 @@ void TraceLoggerThread::log(uint32_t id)
 
 bool TraceLoggerThreadState::remapDictionaryEntries(
     mozilla::Vector<UniqueChars, 0, SystemAllocPolicy>* newDictionary,
-    uint32_t* newNextDictionaryId) {
+    uint32_t* newNextDictionaryId) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(newNextDictionaryId != nullptr && newDictionary != nullptr);
 
   typedef HashMap<uint32_t, uint32_t, DefaultHasher<uint32_t>,
@@ -1030,22 +1030,22 @@ bool TraceLoggerThreadState::remapDictio
   // that still hold a pointer to a payload.  Restarting the profiler may reuse
   // the exact same event as a previous session if it's still alive so we need
   // to maintain it's existence.
-  for (TextIdToPayloadMap::Enum e(textIdPayloads); !e.empty(); e.popFront()) {
-    if (e.front().value()->uses() == 0) {
+  for (TextIdToPayloadMap::Enum e(textIdPayloads); !e.empty(); e.popFront()) {MOZ_RELEASE_ASSERT(0);
+    if (e.front().value()->uses() == 0) {MOZ_RELEASE_ASSERT(0);
       js_delete(e.front().value());
       e.removeFront();
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       TraceLoggerEventPayload* payload = e.front().value();
       uint32_t dictId = payload->dictionaryId();
 
-      if (dictionaryMap.has(dictId)) {
+      if (dictionaryMap.has(dictId)) {MOZ_RELEASE_ASSERT(0);
         DictionaryMap::Ptr mapPointer = dictionaryMap.lookup(dictId);
         MOZ_ASSERT(mapPointer);
         payload->setDictionaryId(mapPointer->value());
       } else {
-        if (!newDictionary->append(std::move(dictionaryData[dictId]))) {
+        if (!newDictionary->append(std::move(dictionaryData[dictId]))) {MOZ_RELEASE_ASSERT(0);
           return false;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         payload->setDictionaryId(*newNextDictionaryId);
 
         if (!dictionaryMap.putNew(dictId, *newNextDictionaryId)) {
@@ -1060,16 +1060,16 @@ bool TraceLoggerThreadState::remapDictio
   return true;
 }
 
-void TraceLoggerThreadState::clear() {
+void TraceLoggerThreadState::clear() {MOZ_RELEASE_ASSERT(0);
   LockGuard<Mutex> guard(lock);
 
   uint32_t newNextDictionaryId = 0;
   mozilla::Vector<UniqueChars, 0, SystemAllocPolicy> newDictionary;
-  if (remapDictionaryEntries(&newDictionary, &newNextDictionaryId)) {
+  if (remapDictionaryEntries(&newDictionary, &newNextDictionaryId)) {MOZ_RELEASE_ASSERT(0);
     // Clear and free any data used for the string dictionary.
-    for (auto range = dictionaryData.all(); !range.empty(); range.popFront()) {
+    for (auto range = dictionaryData.all(); !range.empty(); range.popFront()) {MOZ_RELEASE_ASSERT(0);
       range.front().reset();
-    }
+    }MOZ_RELEASE_ASSERT(0);
     dictionaryData.clearAndFree();
     dictionaryData = std::move(newDictionary);
 
@@ -1084,10 +1084,10 @@ void TraceLoggerThreadState::clear() {
   }
 }
 
-void TraceLoggerThread::clear() {
-  if (graph_.get()) {
+void TraceLoggerThread::clear() {MOZ_RELEASE_ASSERT(0);
+  if (graph_.get()) {MOZ_RELEASE_ASSERT(0);
     graph_.reset();
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   graph_ = nullptr;
 
@@ -1100,10 +1100,10 @@ void TraceLoggerThread::clear() {
   }
 }
 
-TraceLoggerThreadState::~TraceLoggerThreadState() {
-  while (TraceLoggerThread* logger = threadLoggers.popFirst()) {
+TraceLoggerThreadState::~TraceLoggerThreadState() {MOZ_RELEASE_ASSERT(0);
+  while (TraceLoggerThread* logger = threadLoggers.popFirst()) {MOZ_RELEASE_ASSERT(0);
     js_delete(logger);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   threadLoggers.clear();
 
@@ -1117,10 +1117,10 @@ TraceLoggerThreadState::~TraceLoggerThre
 #endif
 }
 
-bool TraceLoggerThreadState::init() {
+bool TraceLoggerThreadState::init() {MOZ_RELEASE_ASSERT(0);
   const char* env = getenv("TLLOG");
-  if (env) {
-    if (strstr(env, "help")) {
+  if (env) {MOZ_RELEASE_ASSERT(0);
+    if (strstr(env, "help")) {MOZ_RELEASE_ASSERT(0);
       fflush(nullptr);
       printf(
           "\n"
@@ -1165,36 +1165,36 @@ bool TraceLoggerThreadState::init() {
           "                 BytecodeEmission, BytecodeFoldConstants, "
           "BytecodeNameFunctions\n"
           "Specific log items:\n");
-      for (uint32_t i = 1; i < TraceLogger_Last; i++) {
+      for (uint32_t i = 1; i < TraceLogger_Last; i++) {MOZ_RELEASE_ASSERT(0);
         TraceLoggerTextId id = TraceLoggerTextId(i);
-        if (!TLTextIdIsTogglable(id)) {
+        if (!TLTextIdIsTogglable(id)) {MOZ_RELEASE_ASSERT(0);
           continue;
-        }
+        }MOZ_RELEASE_ASSERT(0);
         printf("  %s\n", TLTextIdString(id));
-      }
+      }MOZ_RELEASE_ASSERT(0);
       printf("\n");
       exit(0);
       /*NOTREACHED*/
     }
 
-    for (uint32_t i = 1; i < TraceLogger_Last; i++) {
+    for (uint32_t i = 1; i < TraceLogger_Last; i++) {MOZ_RELEASE_ASSERT(0);
       TraceLoggerTextId id = TraceLoggerTextId(i);
-      if (TLTextIdIsTogglable(id)) {
+      if (TLTextIdIsTogglable(id)) {MOZ_RELEASE_ASSERT(0);
         enabledTextIds[i] = ContainsFlag(env, TLTextIdString(id));
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         enabledTextIds[i] = true;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
-    if (ContainsFlag(env, "Default")) {
+    if (ContainsFlag(env, "Default")) {MOZ_RELEASE_ASSERT(0);
       enableDefaultLogging();
     }
 
-    if (ContainsFlag(env, "IonCompiler")) {
+    if (ContainsFlag(env, "IonCompiler")) {MOZ_RELEASE_ASSERT(0);
       enableIonLogging();
     }
 
-    if (ContainsFlag(env, "Frontend")) {
+    if (ContainsFlag(env, "Frontend")) {MOZ_RELEASE_ASSERT(0);
       enableFrontendLogging();
     }
 
@@ -1202,11 +1202,11 @@ bool TraceLoggerThreadState::init() {
     enabledTextIds[TraceLogger_Error] = true;
 #endif
 
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     // Most of the textId's will be enabled through JS::StartTraceLogger when
     // the gecko profiler is started.
     disableTextIdsForProfiler();
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   enabledTextIds[TraceLogger_Interpreter] = enabledTextIds[TraceLogger_Engine];
   enabledTextIds[TraceLogger_Baseline] = enabledTextIds[TraceLogger_Engine];
@@ -1215,8 +1215,8 @@ bool TraceLoggerThreadState::init() {
   enabledTextIds[TraceLogger_Error] = true;
 
   const char* options = getenv("TLOPTIONS");
-  if (options) {
-    if (strstr(options, "help")) {
+  if (options) {MOZ_RELEASE_ASSERT(0);
+    if (strstr(options, "help")) {MOZ_RELEASE_ASSERT(0);
       fflush(nullptr);
       printf(
           "\n"
@@ -1235,20 +1235,20 @@ bool TraceLoggerThreadState::init() {
       /*NOTREACHED*/
     }
 
-    if (strstr(options, "EnableMainThread")) {
+    if (strstr(options, "EnableMainThread")) {MOZ_RELEASE_ASSERT(0);
       mainThreadEnabled = true;
     }
-    if (strstr(options, "EnableOffThread")) {
+    if (strstr(options, "EnableOffThread")) {MOZ_RELEASE_ASSERT(0);
       helperThreadEnabled = true;
     }
-    if (strstr(options, "EnableGraph")) {
+    if (strstr(options, "EnableGraph")) {MOZ_RELEASE_ASSERT(0);
       graphEnabled = true;
     }
-    if (strstr(options, "EnableGraphFile")) {
+    if (strstr(options, "EnableGraphFile")) {MOZ_RELEASE_ASSERT(0);
       graphFileEnabled = true;
       jit::JitOptions.enableTraceLogger = true;
     }
-    if (strstr(options, "Errors")) {
+    if (strstr(options, "Errors")) {MOZ_RELEASE_ASSERT(0);
       spewErrors = true;
     }
   } else {
@@ -1268,46 +1268,46 @@ bool TraceLoggerThreadState::init() {
   return true;
 }
 
-void TraceLoggerThreadState::enableTextId(JSContext* cx, uint32_t textId) {
+void TraceLoggerThreadState::enableTextId(JSContext* cx, uint32_t textId) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(TLTextIdIsTogglable(textId));
 
-  if (enabledTextIds[textId]) {
+  if (enabledTextIds[textId]) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   ReleaseAllJITCode(cx->runtime()->defaultFreeOp());
 
   enabledTextIds[textId] = true;
-  if (textId == TraceLogger_Engine) {
+  if (textId == TraceLogger_Engine) {MOZ_RELEASE_ASSERT(0);
     enabledTextIds[TraceLogger_IonMonkey] = true;
     enabledTextIds[TraceLogger_Baseline] = true;
     enabledTextIds[TraceLogger_Interpreter] = true;
   }
 
-  if (textId == TraceLogger_Scripts) {
+  if (textId == TraceLogger_Scripts) {MOZ_RELEASE_ASSERT(0);
     jit::ToggleBaselineTraceLoggerScripts(cx->runtime(), true);
   }
   if (textId == TraceLogger_Engine) {
     jit::ToggleBaselineTraceLoggerEngine(cx->runtime(), true);
   }
 }
-void TraceLoggerThreadState::disableTextId(JSContext* cx, uint32_t textId) {
+void TraceLoggerThreadState::disableTextId(JSContext* cx, uint32_t textId) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(TLTextIdIsTogglable(textId));
 
-  if (!enabledTextIds[textId]) {
+  if (!enabledTextIds[textId]) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   ReleaseAllJITCode(cx->runtime()->defaultFreeOp());
 
   enabledTextIds[textId] = false;
-  if (textId == TraceLogger_Engine) {
+  if (textId == TraceLogger_Engine) {MOZ_RELEASE_ASSERT(0);
     enabledTextIds[TraceLogger_IonMonkey] = false;
     enabledTextIds[TraceLogger_Baseline] = false;
     enabledTextIds[TraceLogger_Interpreter] = false;
   }
 
-  if (textId == TraceLogger_Scripts) {
+  if (textId == TraceLogger_Scripts) {MOZ_RELEASE_ASSERT(0);
     jit::ToggleBaselineTraceLoggerScripts(cx->runtime(), false);
   }
   if (textId == TraceLogger_Engine) {
@@ -1324,34 +1324,34 @@ TraceLoggerThread* js::TraceLoggerForCur
 
 TraceLoggerThread* TraceLoggerThreadState::forCurrentThread(
     JSContext* maybecx) {
-  if (!jit::JitOptions.enableTraceLogger) {
+  if (!jit::JitOptions.enableTraceLogger) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MOZ_ASSERT(initialized);
   MOZ_ASSERT_IF(maybecx, maybecx == TlsContext.get());
 
   JSContext* cx = maybecx ? maybecx : TlsContext.get();
-  if (!cx) {
+  if (!cx) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!cx->traceLogger) {
+  if (!cx->traceLogger) {MOZ_RELEASE_ASSERT(0);
     LockGuard<Mutex> guard(lock);
 
     TraceLoggerThread* logger = js_new<TraceLoggerThread>(cx);
-    if (!logger) {
+    if (!logger) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (!logger->init()) {
+    if (!logger->init()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     threadLoggers.insertFront(logger);
     cx->traceLogger = logger;
 
-    if (graphEnabled) {
+    if (graphEnabled) {MOZ_RELEASE_ASSERT(0);
       logger->initGraph();
     }
 
@@ -1379,13 +1379,13 @@ bool js::TraceLogTextIdEnabled(uint32_t 
   return traceLoggerState->isTextIdEnabled(textId);
 }
 
-void js::TraceLogEnableTextId(JSContext* cx, uint32_t textId) {
+void js::TraceLogEnableTextId(JSContext* cx, uint32_t textId) {MOZ_RELEASE_ASSERT(0);
   if (!traceLoggerState) {
     return;
   }
   traceLoggerState->enableTextId(cx, textId);
 }
-void js::TraceLogDisableTextId(JSContext* cx, uint32_t textId) {
+void js::TraceLogDisableTextId(JSContext* cx, uint32_t textId) {MOZ_RELEASE_ASSERT(0);
   if (!traceLoggerState) {
     return;
   }
@@ -1418,7 +1418,7 @@ TraceLoggerEvent::TraceLoggerEvent(Trace
       traceLoggerState->getOrCreateEventPayload(filename, line, column));
 }
 
-TraceLoggerEvent::TraceLoggerEvent(const char* text) : payload_() {
+TraceLoggerEvent::TraceLoggerEvent(const char* text) : payload_() {MOZ_RELEASE_ASSERT(0);
   if (jit::JitOptions.enableTraceLogger && traceLoggerState) {
     payload_.setEventPayload(traceLoggerState->getOrCreateEventPayload(text));
   }
@@ -1430,7 +1430,7 @@ TraceLoggerEvent::~TraceLoggerEvent() {
   }
 }
 
-uint32_t TraceLoggerEvent::textId() const {
+uint32_t TraceLoggerEvent::textId() const {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(hasTextId());
   if (hasExtPayload()) {
     return extPayload()->textId();
@@ -1438,8 +1438,8 @@ uint32_t TraceLoggerEvent::textId() cons
   return payload_.textId();
 }
 
-TraceLoggerEvent& TraceLoggerEvent::operator=(const TraceLoggerEvent& other) {
-  if (other.hasExtPayload()) {
+TraceLoggerEvent& TraceLoggerEvent::operator=(const TraceLoggerEvent& other) {MOZ_RELEASE_ASSERT(0);
+  if (other.hasExtPayload()) {MOZ_RELEASE_ASSERT(0);
     other.extPayload()->use();
   }
   if (hasExtPayload()) {
@@ -1452,7 +1452,7 @@ TraceLoggerEvent& TraceLoggerEvent::oper
 }
 
 TraceLoggerEvent::TraceLoggerEvent(const TraceLoggerEvent& other)
-    : payload_(other.payload_) {
+    : payload_(other.payload_) {MOZ_RELEASE_ASSERT(0);
   if (hasExtPayload()) {
     extPayload()->use();
   }
@@ -1463,10 +1463,10 @@ JS_PUBLIC_API bool JS::InitTraceLogger()
 
   if (!getTraceLoggerSupported()) {
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   traceLoggerState = js_new<TraceLoggerThreadState>();
-  if (!traceLoggerState) {
+  if (!traceLoggerState) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1482,7 +1482,7 @@ JS_PUBLIC_API bool JS::TraceLoggerSuppor
 
 // Perform a process wide synchronous spew of every thread that tracelogger has
 // captured.
-void TraceLoggerThreadState::spewTraceLoggerStats() {
+void TraceLoggerThreadState::spewTraceLoggerStats() {MOZ_RELEASE_ASSERT(0);
   for (TraceLoggerThread* logger : threadLoggers) {
     logger->spewTraceLoggerStats();
   }
@@ -1490,25 +1490,25 @@ void TraceLoggerThreadState::spewTraceLo
 
 // Usage here is JS_TRACELOGGER_SPEW=<event1>,<event2>,etc for custom spewing.
 // If the environment variable is not found, we use a default set of events.
-static bool getSpewIds(EventVector& spewIds) {
+static bool getSpewIds(EventVector& spewIds) {MOZ_RELEASE_ASSERT(0);
   const char* env = getenv("JS_TRACELOGGER_SPEW");
-  if (env) {
-    for (uint32_t i = 1; i < TraceLogger_Last; i++) {
+  if (env) {MOZ_RELEASE_ASSERT(0);
+    for (uint32_t i = 1; i < TraceLogger_Last; i++) {MOZ_RELEASE_ASSERT(0);
       TraceLoggerTextId id = TraceLoggerTextId(i);
-      if (ContainsFlag(env, TLTextIdString(id))) {
-        if (!spewIds.append(id)) {
+      if (ContainsFlag(env, TLTextIdString(id))) {MOZ_RELEASE_ASSERT(0);
+        if (!spewIds.append(id)) {MOZ_RELEASE_ASSERT(0);
           return false;
-        }
-      }
+        }MOZ_RELEASE_ASSERT(0);
+      }MOZ_RELEASE_ASSERT(0);
     }
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     const uint32_t defaultSpewEvents[] = {
         TraceLogger_ParsingFull, TraceLogger_Interpreter,
         TraceLogger_Baseline,    TraceLogger_BaselineCompilation,
         TraceLogger_IonMonkey,   TraceLogger_IonCompilation,
         TraceLogger_Bailout};
 
-    for (uint32_t id : defaultSpewEvents) {
+    for (uint32_t id : defaultSpewEvents) {MOZ_RELEASE_ASSERT(0);
       if (!spewIds.append(id)) {
         return false;
       }
@@ -1518,18 +1518,18 @@ static bool getSpewIds(EventVector& spew
   return true;
 }
 
-static void spewHeaderRow(UniqueChars& threadName, EventVector& spewIds) {
-  if (threadName) {
+static void spewHeaderRow(UniqueChars& threadName, EventVector& spewIds) {MOZ_RELEASE_ASSERT(0);
+  if (threadName) {MOZ_RELEASE_ASSERT(0);
     JitSpew(jit::JitSpew_ScriptStats, "Thread: %s (pid=%d)", threadName.get(),
             getpid());
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     JitSpew(jit::JitSpew_ScriptStats, "Unknown Thread (pid=%d)", getpid());
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   UniqueChars header = JS_smprintf("%10s ", "totalTime");
-  for (uint32_t i : spewIds) {
+  for (uint32_t i : spewIds) {MOZ_RELEASE_ASSERT(0);
     TraceLoggerTextId id = TraceLoggerTextId(i);
-    if (TLTextIdIsLogEvent(id)) {
+    if (TLTextIdIsLogEvent(id)) {MOZ_RELEASE_ASSERT(0);
       header =
           JS_sprintf_append(std::move(header), "%12s ", TLTextIdString(id));
     } else {
@@ -1541,71 +1541,71 @@ static void spewHeaderRow(UniqueChars& t
   JitSpew(jit::JitSpew_ScriptStats, "%s Script", header.get());
 }
 
-void TraceLoggerThread::spewTraceLoggerStats() {
-  if (!jit::JitOptions.enableTraceLogger) {
+void TraceLoggerThread::spewTraceLoggerStats() {MOZ_RELEASE_ASSERT(0);
+  if (!jit::JitOptions.enableTraceLogger) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   ScriptMap map;
-  if (!collectTraceLoggerStats(map)) {
+  if (!collectTraceLoggerStats(map)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
-  if (map.empty()) {
+  if (map.empty()) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   SortedStatsVector sorted_map;
-  if (!sortTraceLoggerStats(map, sorted_map)) {
+  if (!sortTraceLoggerStats(map, sorted_map)) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   map.clearAndCompact();
 
   EventVector spewIds;
-  if (!getSpewIds(spewIds)) {
+  if (!getSpewIds(spewIds)) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Dynamically generate the header row in JitSpew.
   spewHeaderRow(threadName_, spewIds);
 
-  for (UniquePtr<ScriptStats>& datap : sorted_map) {
+  for (UniquePtr<ScriptStats>& datap : sorted_map) {MOZ_RELEASE_ASSERT(0);
     auto& tlevents = datap->events_;
     uint32_t selfTime = datap->selfTime;
 
-    if (selfTime == 0) {
+    if (selfTime == 0) {MOZ_RELEASE_ASSERT(0);
       continue;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     UniqueChars row = JS_smprintf("%10u ", selfTime);
-    for (uint32_t i : spewIds) {
+    for (uint32_t i : spewIds) {MOZ_RELEASE_ASSERT(0);
       TraceLoggerTextId id = TraceLoggerTextId(i);
       uint32_t time = tlevents[id].time;
       uint32_t freq = tlevents[id].count;
       uint32_t percent = (time * 100) / selfTime;
-      if (TLTextIdIsLogEvent(id)) {
+      if (TLTextIdIsLogEvent(id)) {MOZ_RELEASE_ASSERT(0);
         row = JS_sprintf_append(std::move(row), "%12u ", freq);
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         row = JS_sprintf_append(std::move(row), "%8u (%3u%%,f=%-7u) ", time,
                                 percent, freq);
-      }
-    }
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
     JitSpew(jit::JitSpew_ScriptStats, "%s %s", row.get(), datap->scriptName);
 
     // If structured spewer is enabled, we might as well spew everything.
     AutoStructuredSpewer spew(cx_, SpewChannel::ScriptStats, nullptr);
-    if (spew) {
+    if (spew) {MOZ_RELEASE_ASSERT(0);
       spew->property("script", datap->scriptName);
       spew->property("totalTime", selfTime);
       spew->beginListProperty("events");
-      for (uint32_t i = 1; i < TraceLogger_Last; i++) {
+      for (uint32_t i = 1; i < TraceLogger_Last; i++) {MOZ_RELEASE_ASSERT(0);
         TraceLoggerTextId id = TraceLoggerTextId(i);
-        if (TLTextIdIsInternalEvent(id) || tlevents[id].count == 0) {
+        if (TLTextIdIsInternalEvent(id) || tlevents[id].count == 0) {MOZ_RELEASE_ASSERT(0);
           continue;
-        }
+        }MOZ_RELEASE_ASSERT(0);
 
         spew->beginObject();
         spew->property("id", TLTextIdString(id));
-        if (TLTextIdIsTreeEvent(id)) {
+        if (TLTextIdIsTreeEvent(id)) {MOZ_RELEASE_ASSERT(0);
           spew->property("time", tlevents[id].time);
           spew->property("frequency", tlevents[id].count);
         } else if (TLTextIdIsLogEvent(id)) {
@@ -1620,17 +1620,17 @@ void TraceLoggerThread::spewTraceLoggerS
 
 static bool updateScriptMap(ScriptMap& map, char* key, uint32_t eventId,
                             uint32_t value) {
-  if (!key) {
+  if (!key) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!map.has(key)) {
+  if (!map.has(key)) {MOZ_RELEASE_ASSERT(0);
     UniquePtr<ScriptStats> datap;
     datap.reset(js_new<ScriptStats>(key));
-    if (!map.putNew(key, std::move(datap))) {
+    if (!map.putNew(key, std::move(datap))) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
-  }
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
   ScriptMap::Ptr p = map.lookup(key);
   p->value()->events_[eventId].time += value;
   p->value()->events_[eventId].count++;
@@ -1641,7 +1641,7 @@ static bool updateScriptMap(ScriptMap& m
   return true;
 }
 
-UniqueChars TraceLoggerThreadState::getFullScriptName(uint32_t textId) {
+UniqueChars TraceLoggerThreadState::getFullScriptName(uint32_t textId) {MOZ_RELEASE_ASSERT(0);
   TraceLoggerEventPayload* payload = getPayload(textId);
   MOZ_ASSERT(payload);
   if (!payload) {
@@ -1662,7 +1662,7 @@ static bool sortBySelfTime(const UniqueP
 
 bool TraceLoggerThread::sortTraceLoggerStats(ScriptMap& map,
                                              SortedStatsVector& sorted_map) {
-  for (auto range = map.all(); !range.empty(); range.popFront()) {
+  for (auto range = map.all(); !range.empty(); range.popFront()) {MOZ_RELEASE_ASSERT(0);
     if (!sorted_map.append(std::move(range.front().value()))) {
       return false;
     }
@@ -1682,7 +1682,7 @@ bool TraceLoggerThread::sortTraceLoggerS
 //                  Elements are popped off whenever a TraceLogger_Stop is
 //                  encountered that matches a script event on the top of
 //                  eventStack.
-bool TraceLoggerThread::collectTraceLoggerStats(ScriptMap& map) {
+bool TraceLoggerThread::collectTraceLoggerStats(ScriptMap& map) {MOZ_RELEASE_ASSERT(0);
   uint32_t totalJSTime = 0;
 
   struct eventInfo {
@@ -1698,7 +1698,7 @@ bool TraceLoggerThread::collectTraceLogg
 
   mozilla::TimeStamp startTime, stopTime;
   uint32_t size = events_.size();
-  for (size_t i = 0; i < size; i++) {
+  for (size_t i = 0; i < size; i++) {MOZ_RELEASE_ASSERT(0);
     uint32_t textId = events_[i].textId;
 
     // Record any log events that have no durations such as Bailouts with a
@@ -1706,53 +1706,53 @@ bool TraceLoggerThread::collectTraceLogg
     // else the Bailout event will not be associated with any script.  This
     // can commonly occur when profiling & tracing starts since we may have
     // already past the point where the script event is created.
-    if (TLTextIdIsLogEvent(textId) && !funcStack.empty()) {
+    if (TLTextIdIsLogEvent(textId) && !funcStack.empty()) {MOZ_RELEASE_ASSERT(0);
       UniqueChars script =
           traceLoggerState->getFullScriptName(funcStack.back());
-      if (!updateScriptMap(map, script.release(), textId, 1)) {
+      if (!updateScriptMap(map, script.release(), textId, 1)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
     // Hit a new tree event or a stop event, so add (new event timestamp - old
     // event timestamp) to the old event's self-time.
-    if (TLTextIdIsTreeEvent(textId)) {
-      if (!eventStack.empty()) {
+    if (TLTextIdIsTreeEvent(textId)) {MOZ_RELEASE_ASSERT(0);
+      if (!eventStack.empty()) {MOZ_RELEASE_ASSERT(0);
         stopTime = events_[i].time;
 
         uint32_t deltaTime =
             static_cast<uint32_t>((stopTime - startTime).ToMicroseconds());
         eventStack.back()->time += deltaTime;
 
-        if (TLTextIdIsEnumEvent(eventStack.back()->textId)) {
-          if (!funcStack.empty() && !eventStack.empty()) {
+        if (TLTextIdIsEnumEvent(eventStack.back()->textId)) {MOZ_RELEASE_ASSERT(0);
+          if (!funcStack.empty() && !eventStack.empty()) {MOZ_RELEASE_ASSERT(0);
             UniqueChars script =
                 traceLoggerState->getFullScriptName(funcStack.back());
             if (!updateScriptMap(map, script.release(),
-                                 eventStack.back()->textId, deltaTime)) {
+                                 eventStack.back()->textId, deltaTime)) {MOZ_RELEASE_ASSERT(0);
               return false;
-            }
-          }
-        }
+            }MOZ_RELEASE_ASSERT(0);
+          }MOZ_RELEASE_ASSERT(0);
+        }MOZ_RELEASE_ASSERT(0);
         totalJSTime += deltaTime;
       }
 
-      if (TLTextIdIsScriptEvent(textId)) {
-        if (!funcStack.append(textId)) {
+      if (TLTextIdIsScriptEvent(textId)) {MOZ_RELEASE_ASSERT(0);
+        if (!funcStack.append(textId)) {MOZ_RELEASE_ASSERT(0);
           return false;
-        }
-      }
+        }MOZ_RELEASE_ASSERT(0);
+      }MOZ_RELEASE_ASSERT(0);
 
       eventInfo* entry = js_new<eventInfo>(textId);
       entry->start = events_[i].time;
-      if (!eventStack.append(entry)) {
+      if (!eventStack.append(entry)) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       startTime = events_[i].time;
 
-    } else if (textId == TraceLogger_Stop) {
-      if (!eventStack.empty()) {
+    } else if (textId == TraceLogger_Stop) {MOZ_RELEASE_ASSERT(0);
+      if (!eventStack.empty()) {MOZ_RELEASE_ASSERT(0);
         stopTime = events_[i].time;
 
         uint32_t deltaTime =
@@ -1762,19 +1762,19 @@ bool TraceLoggerThread::collectTraceLogg
         uint32_t topId = entry->textId;
         entry->time += deltaTime;
 
-        if (TLTextIdIsEnumEvent(topId)) {
+        if (TLTextIdIsEnumEvent(topId)) {MOZ_RELEASE_ASSERT(0);
           // funcStack will usually be empty near the beginning of a profiling
           // session since we may have skipped the point where the script event
           // is created.  If that's the case, then skip this event since we
           // cannot associate it with any script.
-          if (!funcStack.empty()) {
+          if (!funcStack.empty()) {MOZ_RELEASE_ASSERT(0);
             UniqueChars script =
                 traceLoggerState->getFullScriptName(funcStack.back());
-            if (!updateScriptMap(map, script.release(), topId, deltaTime)) {
+            if (!updateScriptMap(map, script.release(), topId, deltaTime)) {MOZ_RELEASE_ASSERT(0);
               return false;
-            }
-          }
-        }
+            }MOZ_RELEASE_ASSERT(0);
+          }MOZ_RELEASE_ASSERT(0);
+        }MOZ_RELEASE_ASSERT(0);
         js_delete(entry);
 
         if (TLTextIdIsScriptEvent(topId) && !funcStack.empty()) {
@@ -1792,8 +1792,8 @@ bool TraceLoggerThread::collectTraceLogg
 
 JS_PUBLIC_API void JS::ResetTraceLogger(void) { js::ResetTraceLogger(); }
 
-JS_PUBLIC_API void JS::SpewTraceLoggerThread(JSContext* cx) {
-  if (!traceLoggerState) {
+JS_PUBLIC_API void JS::SpewTraceLoggerThread(JSContext* cx) {MOZ_RELEASE_ASSERT(0);
+  if (!traceLoggerState) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -1802,24 +1802,24 @@ JS_PUBLIC_API void JS::SpewTraceLoggerTh
   }
 }
 
-JS_PUBLIC_API void JS::SpewTraceLoggerForCurrentProcess() {
+JS_PUBLIC_API void JS::SpewTraceLoggerForCurrentProcess() {MOZ_RELEASE_ASSERT(0);
   if (!traceLoggerState) {
     return;
   }
   traceLoggerState->spewTraceLoggerStats();
 }
 
-JS_PUBLIC_API void JS::StartTraceLogger(JSContext* cx) {
-  if (!traceLoggerState) {
+JS_PUBLIC_API void JS::StartTraceLogger(JSContext* cx) {MOZ_RELEASE_ASSERT(0);
+  if (!traceLoggerState) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
-  if (!jit::JitOptions.enableTraceLogger) {
+  if (!jit::JitOptions.enableTraceLogger) {MOZ_RELEASE_ASSERT(0);
     LockGuard<Mutex> guard(traceLoggerState->lock);
     traceLoggerState->enableTextIdsForProfiler();
     jit::JitOptions.enableTraceLogger = true;
     traceLoggerState->startTime = mozilla::TimeStamp::Now();
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   TraceLoggerThread* logger = traceLoggerState->forCurrentThread(cx);
   if (logger) {
@@ -1827,16 +1827,16 @@ JS_PUBLIC_API void JS::StartTraceLogger(
   }
 }
 
-JS_PUBLIC_API void JS::StopTraceLogger(JSContext* cx) {
-  if (!traceLoggerState) {
+JS_PUBLIC_API void JS::StopTraceLogger(JSContext* cx) {MOZ_RELEASE_ASSERT(0);
+  if (!traceLoggerState) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
-  if (jit::JitOptions.enableTraceLogger) {
+  if (jit::JitOptions.enableTraceLogger) {MOZ_RELEASE_ASSERT(0);
     LockGuard<Mutex> guard(traceLoggerState->lock);
     traceLoggerState->disableTextIdsForProfiler();
     jit::JitOptions.enableTraceLogger = false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   TraceLoggerThread* logger = traceLoggerState->forCurrentThread(cx);
   if (logger) {
diff --git a/js/src/vm/TraceLoggingGraph.cpp b/js/src/vm/TraceLoggingGraph.cpp
--- a/js/src/vm/TraceLoggingGraph.cpp
+++ b/js/src/vm/TraceLoggingGraph.cpp
@@ -45,34 +45,34 @@ TraceLoggerGraphState* traceLoggerGraphS
 // are allowed, with %u standing for a full 32-bit number and %d standing for
 // an up to 3-digit number.
 static js::UniqueChars MOZ_FORMAT_PRINTF(1, 2)
-    AllocTraceLogFilename(const char* pattern, ...) {
+    AllocTraceLogFilename(const char* pattern, ...) {MOZ_RELEASE_ASSERT(0);
   va_list ap;
 
   const char* outdir =
       getenv("TLDIR") ? getenv("TLDIR") : DEFAULT_TRACE_LOG_DIR;
   size_t len = strlen(outdir) + 1;  // "+ 1" is for the '/'
 
-  for (const char* p = pattern; *p; p++) {
-    if (*p == '%') {
+  for (const char* p = pattern; *p; p++) {MOZ_RELEASE_ASSERT(0);
+    if (*p == '%') {MOZ_RELEASE_ASSERT(0);
       p++;
-      if (*p == 'u') {
+      if (*p == 'u') {MOZ_RELEASE_ASSERT(0);
         len += sizeof("4294967295") - 1;
-      } else if (*p == 'd') {
+      } else if (*p == 'd') {MOZ_RELEASE_ASSERT(0);
         len += sizeof(XSTRING(MAX_LOGGERS)) - 1;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         MOZ_CRASH("Invalid format");
       }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       len++;
-    }
-  }
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
 
   len++;  // For the terminating NUL.
 
   js::UniqueChars filename(js_pod_malloc<char>(len));
-  if (!filename) {
+  if (!filename) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   char* rest = filename.get() + sprintf(filename.get(), "%s/", outdir);
 
   va_start(ap, pattern);
@@ -88,16 +88,16 @@ static js::UniqueChars MOZ_FORMAT_PRINTF
   return filename;
 }
 
-bool TraceLoggerGraphState::init() {
+bool TraceLoggerGraphState::init() {MOZ_RELEASE_ASSERT(0);
   pid_ = (uint32_t)getpid();
 
   js::UniqueChars filename = AllocTraceLogFilename("tl-data.%u.json", pid_);
   out = fopen(filename.get(), "w");
-  if (!out) {
+  if (!out) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "warning: failed to create TraceLogger output file %s\n",
             filename.get());
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   fprintf(out, "[");
 
@@ -117,7 +117,7 @@ bool TraceLoggerGraphState::init() {
   return true;
 }
 
-TraceLoggerGraphState::~TraceLoggerGraphState() {
+TraceLoggerGraphState::~TraceLoggerGraphState() {MOZ_RELEASE_ASSERT(0);
   if (out) {
     fprintf(out, "]");
     fclose(out);
@@ -129,25 +129,25 @@ TraceLoggerGraphState::~TraceLoggerGraph
 #endif
 }
 
-uint32_t TraceLoggerGraphState::nextLoggerId() {
+uint32_t TraceLoggerGraphState::nextLoggerId() {MOZ_RELEASE_ASSERT(0);
   js::LockGuard<js::Mutex> guard(lock);
 
   MOZ_ASSERT(initialized);
 
-  if (numLoggers > MAX_LOGGERS) {
+  if (numLoggers > MAX_LOGGERS) {MOZ_RELEASE_ASSERT(0);
     fputs("TraceLogging: Can't create more than " XSTRING(
               MAX_LOGGERS) " different loggers.",
           stderr);
     return uint32_t(-1);
   }
 
-  if (numLoggers > 0) {
+  if (numLoggers > 0) {MOZ_RELEASE_ASSERT(0);
     int written = fprintf(out, ",\n");
-    if (written < 0) {
+    if (written < 0) {MOZ_RELEASE_ASSERT(0);
       fprintf(stderr, "TraceLogging: Error while writing.\n");
       return uint32_t(-1);
-    }
-  }
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
 
   int written = fprintf(
       out,
@@ -155,15 +155,15 @@ uint32_t TraceLoggerGraphState::nextLogg
       "\"dict\":\"tl-dict.%u.%u.json\", \"treeFormat\":\"64,64,31,1,32\"",
       pid_, numLoggers, pid_, numLoggers, pid_, numLoggers);
 
-  if (written > 0) {
+  if (written > 0) {MOZ_RELEASE_ASSERT(0);
     char threadName[16];
     js::ThisThread::GetName(threadName, sizeof(threadName));
-    if (threadName[0]) {
+    if (threadName[0]) {MOZ_RELEASE_ASSERT(0);
       written = fprintf(out, R"(, "threadName":"%s")", threadName);
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
-  if (written > 0) {
+  if (written > 0) {MOZ_RELEASE_ASSERT(0);
     written = fprintf(out, "}");
   }
 
@@ -180,13 +180,13 @@ size_t TraceLoggerGraphState::sizeOfExcl
   return 0;
 }
 
-static bool EnsureTraceLoggerGraphState() {
-  if (MOZ_LIKELY(traceLoggerGraphState)) {
+static bool EnsureTraceLoggerGraphState() {MOZ_RELEASE_ASSERT(0);
+  if (MOZ_LIKELY(traceLoggerGraphState)) {MOZ_RELEASE_ASSERT(0);
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   traceLoggerGraphState = js_new<TraceLoggerGraphState>();
-  if (!traceLoggerGraphState) {
+  if (!traceLoggerGraphState) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -211,25 +211,25 @@ void js::DestroyTraceLoggerGraphState() 
   }
 }
 
-bool TraceLoggerGraph::init(uint64_t startTimestamp, bool graphFileEnabled) {
+bool TraceLoggerGraph::init(uint64_t startTimestamp, bool graphFileEnabled) {MOZ_RELEASE_ASSERT(0);
   auto fail = MakeScopeExit([&] { failed = true; });
 
-  if (graphFileEnabled) {
-    if (!EnsureTraceLoggerGraphState()) {
+  if (graphFileEnabled) {MOZ_RELEASE_ASSERT(0);
+    if (!EnsureTraceLoggerGraphState()) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     uint32_t loggerId = traceLoggerGraphState->nextLoggerId();
-    if (loggerId == uint32_t(-1)) {
+    if (loggerId == uint32_t(-1)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     uint32_t pid = traceLoggerGraphState->pid();
 
     js::UniqueChars dictFilename =
         AllocTraceLogFilename("tl-dict.%u.%u.json", pid, loggerId);
     dictFile = fopen(dictFilename.get(), "w");
-    if (!dictFile) {
+    if (!dictFile) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     auto cleanupDict = MakeScopeExit([&] {
@@ -240,7 +240,7 @@ bool TraceLoggerGraph::init(uint64_t sta
     js::UniqueChars treeFilename =
         AllocTraceLogFilename("tl-tree.%u.%u.tl", pid, loggerId);
     treeFile = fopen(treeFilename.get(), "w+b");
-    if (!treeFile) {
+    if (!treeFile) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     auto cleanupTree = MakeScopeExit([&] {
@@ -251,7 +251,7 @@ bool TraceLoggerGraph::init(uint64_t sta
     js::UniqueChars eventFilename =
         AllocTraceLogFilename("tl-event.%u.%u.tl", pid, loggerId);
     eventFile = fopen(eventFilename.get(), "wb");
-    if (!eventFile) {
+    if (!eventFile) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     auto cleanupEvent = MakeScopeExit([&] {
@@ -259,17 +259,17 @@ bool TraceLoggerGraph::init(uint64_t sta
       eventFile = nullptr;
     });
 
-    if (fprintf(dictFile, "[") < 0) {
+    if (fprintf(dictFile, "[") < 0) {MOZ_RELEASE_ASSERT(0);
       fprintf(stderr, "TraceLogging: Error while writing.\n");
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     cleanupDict.release();
     cleanupTree.release();
     cleanupEvent.release();
   }
 
-  if (!tree.init()) {
+  if (!tree.init()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!stack.init()) {
@@ -294,36 +294,36 @@ bool TraceLoggerGraph::init(uint64_t sta
   return true;
 }
 
-TraceLoggerGraph::~TraceLoggerGraph() {
+TraceLoggerGraph::~TraceLoggerGraph() {MOZ_RELEASE_ASSERT(0);
   // Write dictionary to disk
-  if (dictFile) {
+  if (dictFile) {MOZ_RELEASE_ASSERT(0);
     int written = fprintf(dictFile, "]");
-    if (written < 0) {
+    if (written < 0) {MOZ_RELEASE_ASSERT(0);
       fprintf(stderr, "TraceLogging: Error while writing.\n");
-    }
+    }MOZ_RELEASE_ASSERT(0);
     fclose(dictFile);
 
     dictFile = nullptr;
   }
 
-  if (!failed && treeFile) {
+  if (!failed && treeFile) {MOZ_RELEASE_ASSERT(0);
     // Make sure every start entry has a corresponding stop value.
     // We temporarily enable logging for this. Stop doesn't need any extra data,
     // so is safe to do even when we have encountered OOM.
     enabled = true;
-    while (stack.size() > 1) {
+    while (stack.size() > 1) {MOZ_RELEASE_ASSERT(0);
       stopEvent(0);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     enabled = false;
   }
 
-  if (!failed && !flush()) {
+  if (!failed && !flush()) {MOZ_RELEASE_ASSERT(0);
     fprintf(stderr, "TraceLogging: Couldn't write the data to disk.\n");
     enabled = false;
     failed = true;
   }
 
-  if (treeFile) {
+  if (treeFile) {MOZ_RELEASE_ASSERT(0);
     fclose(treeFile);
     treeFile = nullptr;
   }
@@ -334,19 +334,19 @@ TraceLoggerGraph::~TraceLoggerGraph() {
   }
 }
 
-bool TraceLoggerGraph::flush() {
+bool TraceLoggerGraph::flush() {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(!failed);
 
-  if (treeFile) {
+  if (treeFile) {MOZ_RELEASE_ASSERT(0);
     // Format data in big endian.
-    for (size_t i = 0; i < tree.size(); i++) {
+    for (size_t i = 0; i < tree.size(); i++) {MOZ_RELEASE_ASSERT(0);
       entryToBigEndian(&tree[i]);
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     int success = fseek(treeFile, 0, SEEK_END);
-    if (success != 0) {
+    if (success != 0) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     size_t bytesWritten =
         fwrite(tree.data(), sizeof(TreeEntry), tree.size(), treeFile);
@@ -380,25 +380,25 @@ void TraceLoggerGraph::entryToSystemEndi
   entry->nextId_ = NativeEndian::swapFromBigEndian(entry->nextId_);
 }
 
-void TraceLoggerGraph::startEvent(uint32_t id, uint64_t timestamp) {
-  if (failed || enabled == 0) {
+void TraceLoggerGraph::startEvent(uint32_t id, uint64_t timestamp) {MOZ_RELEASE_ASSERT(0);
+  if (failed || enabled == 0) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
-  if (!tree.hasSpaceForAdd()) {
-    if (tree.size() >= treeSizeFlushLimit() || !tree.ensureSpaceBeforeAdd()) {
-      if (!treeFile) {
+  if (!tree.hasSpaceForAdd()) {MOZ_RELEASE_ASSERT(0);
+    if (tree.size() >= treeSizeFlushLimit() || !tree.ensureSpaceBeforeAdd()) {MOZ_RELEASE_ASSERT(0);
+      if (!treeFile) {MOZ_RELEASE_ASSERT(0);
         disable(timestamp);
         return;
       }
 
-      if (!flush()) {
+      if (!flush()) {MOZ_RELEASE_ASSERT(0);
         fprintf(stderr, "TraceLogging: Couldn't write the data to disk.\n");
         enabled = false;
         failed = true;
         return;
-      }
-    }
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   if (!startEventInternal(id, timestamp)) {
@@ -409,7 +409,7 @@ void TraceLoggerGraph::startEvent(uint32
   }
 }
 
-TraceLoggerGraph::StackEntry& TraceLoggerGraph::getActiveAncestor() {
+TraceLoggerGraph::StackEntry& TraceLoggerGraph::getActiveAncestor() {MOZ_RELEASE_ASSERT(0);
   uint32_t parentId = stack.lastEntryId();
   while (!stack[parentId].active()) {
     parentId--;
@@ -417,10 +417,10 @@ TraceLoggerGraph::StackEntry& TraceLogge
   return stack[parentId];
 }
 
-bool TraceLoggerGraph::startEventInternal(uint32_t id, uint64_t timestamp) {
-  if (!stack.ensureSpaceBeforeAdd()) {
+bool TraceLoggerGraph::startEventInternal(uint32_t id, uint64_t timestamp) {MOZ_RELEASE_ASSERT(0);
+  if (!stack.ensureSpaceBeforeAdd()) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Patch up the tree to be correct. There are two scenarios:
   // 1) Parent has no children yet. So update parent to include children.
@@ -434,14 +434,14 @@ bool TraceLoggerGraph::startEventInterna
   }
 #endif
 
-  if (parent.lastChildId() == 0) {
+  if (parent.lastChildId() == 0) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(!entry.hasChildren());
     MOZ_ASSERT(parent.treeId() == treeOffset + tree.size() - 1);
 
-    if (!updateHasChildren(parent.treeId())) {
+    if (!updateHasChildren(parent.treeId())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(entry.hasChildren());
 
     if (!updateNextId(parent.lastChildId(), tree.size() + treeOffset)) {
@@ -469,7 +469,7 @@ bool TraceLoggerGraph::startEventInterna
   return true;
 }
 
-void TraceLoggerGraph::stopEvent(uint32_t id, uint64_t timestamp) {
+void TraceLoggerGraph::stopEvent(uint32_t id, uint64_t timestamp) {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
   if (id != TraceLogger_Scripts && id != TraceLogger_Engine &&
       stack.size() > 1 && stack.lastEntry().active()) {
@@ -482,16 +482,16 @@ void TraceLoggerGraph::stopEvent(uint32_
   stopEvent(timestamp);
 }
 
-void TraceLoggerGraph::stopEvent(uint64_t timestamp) {
-  if (enabled && stack.lastEntry().active()) {
-    if (!updateStop(stack.lastEntry().treeId(), timestamp)) {
+void TraceLoggerGraph::stopEvent(uint64_t timestamp) {MOZ_RELEASE_ASSERT(0);
+  if (enabled && stack.lastEntry().active()) {MOZ_RELEASE_ASSERT(0);
+    if (!updateStop(stack.lastEntry().treeId(), timestamp)) {MOZ_RELEASE_ASSERT(0);
       fprintf(stderr, "TraceLogging: Failed to stop an event.\n");
       enabled = false;
       failed = true;
       return;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
-  if (stack.size() == 1) {
+  if (stack.size() == 1) {MOZ_RELEASE_ASSERT(0);
     if (!enabled) {
       return;
     }
@@ -503,26 +503,26 @@ void TraceLoggerGraph::stopEvent(uint64_
   stack.pop();
 }
 
-void TraceLoggerGraph::logTimestamp(uint32_t id, uint64_t timestamp) {
-  if (failed) {
+void TraceLoggerGraph::logTimestamp(uint32_t id, uint64_t timestamp) {MOZ_RELEASE_ASSERT(0);
+  if (failed) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
-  if (id == TraceLogger_Enable) {
+  if (id == TraceLogger_Enable) {MOZ_RELEASE_ASSERT(0);
     enabled = true;
   }
 
-  if (!enabled) {
+  if (!enabled) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
-  if (id == TraceLogger_Disable) {
+  if (id == TraceLogger_Disable) {MOZ_RELEASE_ASSERT(0);
     disable(timestamp);
   }
 
-  if (!eventFile) {
+  if (!eventFile) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Format data in big endian
   timestamp = NativeEndian::swapToBigEndian(timestamp);
@@ -539,23 +539,23 @@ void TraceLoggerGraph::logTimestamp(uint
   }
 }
 
-bool TraceLoggerGraph::getTreeEntry(uint32_t treeId, TreeEntry* entry) {
+bool TraceLoggerGraph::getTreeEntry(uint32_t treeId, TreeEntry* entry) {MOZ_RELEASE_ASSERT(0);
   // Entry is still in memory
-  if (treeId >= treeOffset) {
+  if (treeId >= treeOffset) {MOZ_RELEASE_ASSERT(0);
     *entry = tree[treeId - treeOffset];
     return true;
   }
 
   // If treeFile is null and treeOffset is non-zero then something is wrong
-  if (!treeFile) {
+  if (!treeFile) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Entry has been flushed to disk. Look it up.
   int success = fseek(treeFile, treeId * sizeof(TreeEntry), SEEK_SET);
-  if (success != 0) {
+  if (success != 0) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   size_t itemsRead = fread((void*)entry, sizeof(TreeEntry), 1, treeFile);
   if (itemsRead < 1) {
@@ -566,12 +566,12 @@ bool TraceLoggerGraph::getTreeEntry(uint
   return true;
 }
 
-bool TraceLoggerGraph::saveTreeEntry(uint32_t treeId, TreeEntry* entry) {
+bool TraceLoggerGraph::saveTreeEntry(uint32_t treeId, TreeEntry* entry) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(treeFile != nullptr);
   int success = fseek(treeFile, treeId * sizeof(TreeEntry), SEEK_SET);
-  if (success != 0) {
+  if (success != 0) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   entryToBigEndian(entry);
 
@@ -583,12 +583,12 @@ bool TraceLoggerGraph::saveTreeEntry(uin
   return true;
 }
 
-bool TraceLoggerGraph::updateHasChildren(uint32_t treeId, bool hasChildren) {
-  if (treeId < treeOffset) {
+bool TraceLoggerGraph::updateHasChildren(uint32_t treeId, bool hasChildren) {MOZ_RELEASE_ASSERT(0);
+  if (treeId < treeOffset) {MOZ_RELEASE_ASSERT(0);
     TreeEntry entry;
-    if (!getTreeEntry(treeId, &entry)) {
+    if (!getTreeEntry(treeId, &entry)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     entry.setHasChildren(hasChildren);
     if (treeFile && !saveTreeEntry(treeId, &entry)) {
       return false;
@@ -600,12 +600,12 @@ bool TraceLoggerGraph::updateHasChildren
   return true;
 }
 
-bool TraceLoggerGraph::updateNextId(uint32_t treeId, uint32_t nextId) {
-  if (treeId < treeOffset) {
+bool TraceLoggerGraph::updateNextId(uint32_t treeId, uint32_t nextId) {MOZ_RELEASE_ASSERT(0);
+  if (treeId < treeOffset) {MOZ_RELEASE_ASSERT(0);
     TreeEntry entry;
-    if (!getTreeEntry(treeId, &entry)) {
+    if (!getTreeEntry(treeId, &entry)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     entry.setNextId(nextId);
     if (treeFile && !saveTreeEntry(treeId, &entry)) {
       return false;
@@ -617,12 +617,12 @@ bool TraceLoggerGraph::updateNextId(uint
   return true;
 }
 
-bool TraceLoggerGraph::updateStop(uint32_t treeId, uint64_t timestamp) {
-  if (treeId < treeOffset) {
+bool TraceLoggerGraph::updateStop(uint32_t treeId, uint64_t timestamp) {MOZ_RELEASE_ASSERT(0);
+  if (treeId < treeOffset) {MOZ_RELEASE_ASSERT(0);
     TreeEntry entry;
-    if (!getTreeEntry(treeId, &entry)) {
+    if (!getTreeEntry(treeId, &entry)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     entry.setStop(timestamp);
     if (treeFile && !saveTreeEntry(treeId, &entry)) {
       return false;
@@ -634,7 +634,7 @@ bool TraceLoggerGraph::updateStop(uint32
   return true;
 }
 
-void TraceLoggerGraph::disable(uint64_t timestamp) {
+void TraceLoggerGraph::disable(uint64_t timestamp) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(enabled);
   while (stack.size() > 1) {
     stopEvent(timestamp);
@@ -645,13 +645,13 @@ void TraceLoggerGraph::disable(uint64_t 
 
 void TraceLoggerGraph::log(ContinuousSpace<EventEntry>& events,
                            mozilla::TimeStamp startTime) {
-  for (uint32_t i = 0; i < events.size(); i++) {
+  for (uint32_t i = 0; i < events.size(); i++) {MOZ_RELEASE_ASSERT(0);
     mozilla::TimeDuration delta = events[i].time - startTime;
     uint64_t timeOffset = static_cast<uint64_t>(delta.ToMicroseconds());
 
-    if (events[i].textId == TraceLogger_Stop) {
+    if (events[i].textId == TraceLogger_Stop) {MOZ_RELEASE_ASSERT(0);
       stopEvent(timeOffset);
-    } else if (TLTextIdIsTreeEvent(events[i].textId)) {
+    } else if (TLTextIdIsTreeEvent(events[i].textId)) {MOZ_RELEASE_ASSERT(0);
       startEvent(events[i].textId, timeOffset);
     } else {
       logTimestamp(events[i].textId, timeOffset);
@@ -668,28 +668,28 @@ void TraceLoggerGraph::addTextId(uint32_
 void TraceLoggerGraph::addTextId(uint32_t id, const char* text,
                                  mozilla::Maybe<uint32_t>& line,
                                  mozilla::Maybe<uint32_t>& column) {
-  if (failed) {
+  if (failed) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Assume ids are given in order. Which is currently true.
   MOZ_ASSERT(id == nextTextId_);
   nextTextId_++;
 
-  if (id > 0) {
+  if (id > 0) {MOZ_RELEASE_ASSERT(0);
     int written = fprintf(dictFile, ",\n");
-    if (written < 0) {
+    if (written < 0) {MOZ_RELEASE_ASSERT(0);
       failed = true;
       return;
-    }
-  }
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
 
   js::UniqueChars str;
-  if (line && column) {
+  if (line && column) {MOZ_RELEASE_ASSERT(0);
     str = JS_smprintf("script %s:%u:%u", text, *line, *column);
-  } else if (line) {
+  } else if (line) {MOZ_RELEASE_ASSERT(0);
     str = JS_smprintf("script %s:%u", text, *line);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     str = JS_smprintf("%s", text);
   }
 
diff --git a/js/src/vm/TypedArrayObject.cpp b/js/src/vm/TypedArrayObject.cpp
--- a/js/src/vm/TypedArrayObject.cpp
+++ b/js/src/vm/TypedArrayObject.cpp
@@ -118,7 +118,7 @@ bool TypedArrayObject::ensureHasBuffer(J
   AutoRealm ar(cx, tarray);
   Rooted<ArrayBufferObject*> buffer(
       cx, ArrayBufferObject::createZeroed(cx, tarray->byteLength()));
-  if (!buffer) {
+  if (!buffer) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -203,7 +203,7 @@ size_t TypedArrayObject::objectMoved(JSO
 
   // Discarded objects (which didn't have enough room for inner elements) don't
   // have any data to move.
-  if (!buf) {
+  if (!buf) {MOZ_RELEASE_ASSERT(0);
     return 0;
   }
 
@@ -351,7 +351,7 @@ class TypedArrayObjectTemplate : public 
     Handle<GlobalObject*> global = cx->global();
     RootedFunction ctorProto(
         cx, GlobalObject::getOrCreateTypedArrayConstructor(cx, global));
-    if (!ctorProto) {
+    if (!ctorProto) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -499,7 +499,7 @@ class TypedArrayObjectTemplate : public 
 
     RootedObject proto(cx, templateObj->staticPrototype());
     TypedArrayObject* obj = makeProtoInstance(cx, proto, allocKind);
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -753,12 +753,12 @@ class TypedArrayObjectTemplate : public 
                                      uint64_t byteOffset, uint64_t lengthIndex,
                                      HandleObject proto) {
     JSObject* unwrapped = CheckedUnwrapStatic(bufobj);
-    if (!unwrapped) {
+    if (!unwrapped) {MOZ_RELEASE_ASSERT(0);
       ReportAccessDenied(cx);
       return nullptr;
     }
 
-    if (!unwrapped->is<ArrayBufferObjectMaybeShared>()) {
+    if (!unwrapped->is<ArrayBufferObjectMaybeShared>()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                 JSMSG_TYPED_ARRAY_BAD_ARGS);
       return nullptr;
@@ -769,7 +769,7 @@ class TypedArrayObjectTemplate : public 
 
     BufferSize length(0);
     if (!computeAndCheckLength(cx, unwrappedBuffer, byteOffset, lengthIndex,
-                               &length)) {
+                               &length)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -778,7 +778,7 @@ class TypedArrayObjectTemplate : public 
     RootedObject protoRoot(cx, proto);
     if (!protoRoot) {
       protoRoot = GlobalObject::getOrCreatePrototype(cx, protoKey());
-      if (!protoRoot) {
+      if (!protoRoot) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -788,13 +788,13 @@ class TypedArrayObjectTemplate : public 
       JSAutoRealm ar(cx, unwrappedBuffer);
 
       RootedObject wrappedProto(cx, protoRoot);
-      if (!cx->compartment()->wrap(cx, &wrappedProto)) {
+      if (!cx->compartment()->wrap(cx, &wrappedProto)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
       typedArray = makeInstance(cx, unwrappedBuffer, BufferSize(byteOffset),
                                 length, wrappedProto);
-      if (!typedArray) {
+      if (!typedArray) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -913,7 +913,7 @@ bool TypedArrayObjectTemplate<NativeType
     return false;
   }
 
-  if (js::SupportDifferentialTesting()) {
+  if (js::SupportDifferentialTesting()) {MOZ_RELEASE_ASSERT(0);
     // See the comment in ElementSpecific::doubleToNative.
     d = JS::CanonicalizeNaN(d);
   }
@@ -1052,7 +1052,7 @@ template <typename T>
 
   JSObject* arrayBufferCtor =
       GlobalObject::getOrCreateArrayBufferConstructor(cx, cx->global());
-  if (!arrayBufferCtor) {
+  if (!arrayBufferCtor) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1081,7 +1081,7 @@ static JSObject* GetBufferSpeciesConstru
     SpeciesConstructorOverride override) {
   RootedObject defaultCtor(
       cx, GlobalObject::getOrCreateArrayBufferConstructor(cx, cx->global()));
-  if (!defaultCtor) {
+  if (!defaultCtor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1102,7 +1102,7 @@ static JSObject* GetBufferSpeciesConstru
 
     JSObject* proto =
         GlobalObject::getOrCreateArrayBufferPrototype(cx, cx->global());
-    if (!proto) {
+    if (!proto) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1119,7 +1119,7 @@ static JSObject* GetBufferSpeciesConstru
       }
     }
 
-    if (!TypedArrayObject::ensureHasBuffer(cx, typedArray)) {
+    if (!TypedArrayObject::ensureHasBuffer(cx, typedArray)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1170,7 +1170,7 @@ template <typename T>
     srcArray = &other->as<TypedArrayObject>();
   } else {
     srcArray = other->maybeUnwrapAs<TypedArrayObject>();
-    if (!srcArray) {
+    if (!srcArray) {MOZ_RELEASE_ASSERT(0);
       ReportAccessDenied(cx);
       return nullptr;
     }
@@ -1180,7 +1180,7 @@ template <typename T>
   // wrapped typed arrays. Note: isWrapped does not imply cross-realm, because
   // of same-compartment wrappers.
   if (cx->realm() != srcArray->realm() || isWrapped) {
-    if (!TypedArrayObject::ensureHasBuffer(cx, srcArray)) {
+    if (!TypedArrayObject::ensureHasBuffer(cx, srcArray)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -1241,14 +1241,14 @@ template <typename T>
   // Steps 3-4 (remaining part), 20-23.
   Rooted<TypedArrayObject*> obj(
       cx, makeInstance(cx, buffer, BufferSize(0), elementLength, proto));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   // Steps 19.c-f or 24.1.1.4 steps 5-7.
   MOZ_ASSERT(!obj->isSharedMemory());
   if (isShared) {
-    if (!ElementSpecific<T, SharedOps>::setFromTypedArray(obj, srcArray, 0)) {
+    if (!ElementSpecific<T, SharedOps>::setFromTypedArray(obj, srcArray, 0)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
@@ -1288,7 +1288,7 @@ template <typename T>
   // Steps 3-4 (Allocation deferred until later).
 
   bool optimized = false;
-  if (!IsOptimizableInit(cx, other, &optimized)) {
+  if (!IsOptimizableInit(cx, other, &optimized)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1302,13 +1302,13 @@ template <typename T>
 
     // Step 6.c.
     Rooted<ArrayBufferObject*> buffer(cx);
-    if (!maybeCreateArrayBuffer(cx, len, nullptr, &buffer)) {
+    if (!maybeCreateArrayBuffer(cx, len, nullptr, &buffer)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     Rooted<TypedArrayObject*> obj(
         cx, makeInstance(cx, buffer, BufferSize(0), BufferSize(len), proto));
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1340,7 +1340,7 @@ template <typename T>
       RootedValue otherVal(cx, ObjectValue(*other));
       UniqueChars bytes =
           DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, otherVal, nullptr);
-      if (!bytes) {
+      if (!bytes) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       JS_ReportErrorNumberUTF8(cx, GetErrorMessage, nullptr, JSMSG_NOT_ITERABLE,
@@ -1383,7 +1383,7 @@ template <typename T>
 
   Rooted<TypedArrayObject*> obj(
       cx, makeInstance(cx, buffer, BufferSize(0), BufferSize(len), proto));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1410,7 +1410,7 @@ template <typename T>
 static bool GetTemplateObjectForNative(JSContext* cx,
                                        const JS::HandleValueArray args,
                                        MutableHandleObject res) {
-  if (args.length() == 0) {
+  if (args.length() == 0) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -1422,7 +1422,7 @@ static bool GetTemplateObjectForNative(J
     }
 
     size_t nbytes;
-    if (!js::CalculateAllocSize<T>(len, &nbytes)) {
+    if (!js::CalculateAllocSize<T>(len, &nbytes)) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
 
@@ -1523,7 +1523,7 @@ static bool TypedArray_toStringTagGetter
   }
 
   JSObject* obj = CheckedUnwrapStatic(&args.thisv().toObject());
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     ReportAccessDenied(cx);
     return false;
   }
@@ -1624,7 +1624,7 @@ bool TypedArrayObject::set_impl(JSContex
   Rooted<TypedArrayObject*> srcTypedArray(cx);
   {
     JSObject* obj = CheckedUnwrapStatic(src);
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       ReportAccessDenied(cx);
       return false;
     }
@@ -1890,7 +1890,7 @@ bool TypedArrayObject::copyWithin_impl(J
 #endif
 
   SharedMem<uint8_t*> data = tarray->dataPointerEither().cast<uint8_t*>();
-  if (tarray->isSharedMemory()) {
+  if (tarray->isSharedMemory()) {MOZ_RELEASE_ASSERT(0);
     jit::AtomicOperations::memmoveSafeWhenRacy(data + byteDest, data + byteSrc,
                                                byteSize);
   } else {
@@ -2301,7 +2301,7 @@ bool js::IsBufferSource(JSObject* object
     return true;
   }
 
-  if (object->is<DataViewObject>()) {
+  if (object->is<DataViewObject>()) {MOZ_RELEASE_ASSERT(0);
     DataViewObject& view = object->as<DataViewObject>();
     *dataPointer = view.dataPointerEither().cast<uint8_t*>();
     *byteLength = view.byteLength().get();
@@ -2387,12 +2387,12 @@ static bool StringToTypedArrayIndexSlow(
 
   const CharT* actualEnd;
   double result;
-  if (!js_strtod(cx, start.get(), end.get(), &actualEnd, &result)) {
+  if (!js_strtod(cx, start.get(), end.get(), &actualEnd, &result)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // The complete string must have been parsed.
-  if (actualEnd != end.get()) {
+  if (actualEnd != end.get()) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(indexp->isNothing());
     return true;
   }
@@ -2400,7 +2400,7 @@ static bool StringToTypedArrayIndexSlow(
   // Now convert it back to a string.
   ToCStringBuf cbuf;
   const char* cstr = js::NumberToCString(cx, &cbuf, result);
-  if (!cstr) {
+  if (!cstr) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -2446,7 +2446,7 @@ bool js::StringToTypedArrayIndex(JSConte
   bool negative = false;
   if (*cp == '-') {
     negative = true;
-    if (++cp == end) {
+    if (++cp == end) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(indexp->isNothing());
       return true;
     }
@@ -2471,7 +2471,7 @@ bool js::StringToTypedArrayIndex(JSConte
     // when the string starts with "0".
     if (*cp == '.') {
       return StringToTypedArrayIndexSlow(cx, s, indexp);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(indexp->isNothing());
     return true;
   }
@@ -2715,7 +2715,7 @@ JS_FRIEND_API bool JS_GetTypedArrayShare
 
 JS_FRIEND_API js::Scalar::Type JS_GetArrayBufferViewType(JSObject* obj) {
   ArrayBufferViewObject* view = obj->maybeUnwrapAs<ArrayBufferViewObject>();
-  if (!view) {
+  if (!view) {MOZ_RELEASE_ASSERT(0);
     return Scalar::MaxTypedArrayViewType;
   }
 
diff --git a/js/src/vm/UbiNode.cpp b/js/src/vm/UbiNode.cpp
--- a/js/src/vm/UbiNode.cpp
+++ b/js/src/vm/UbiNode.cpp
@@ -172,11 +172,11 @@ Value Node::exposeToJS() const {
     } else {
       v.setObject(obj);
     }
-  } else if (is<JSString>()) {
+  } else if (is<JSString>()) {MOZ_RELEASE_ASSERT(0);
     v.setString(as<JSString>());
-  } else if (is<JS::Symbol>()) {
+  } else if (is<JS::Symbol>()) {MOZ_RELEASE_ASSERT(0);
     v.setSymbol(as<JS::Symbol>());
-  } else if (is<BigInt>()) {
+  } else if (is<BigInt>()) {MOZ_RELEASE_ASSERT(0);
     v.setBigInt(as<BigInt>());
   } else {
     v.setUndefined();
@@ -197,7 +197,7 @@ class EdgeVectorTracer final : public JS
   bool wantNames;
 
   void onChild(const JS::GCCellPtr& thing) override {
-    if (!okay) {
+    if (!okay) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
@@ -219,7 +219,7 @@ class EdgeVectorTracer final : public JS
 
       // Convert the name to char16_t characters.
       name16 = js_pod_malloc<char16_t>(strlen(name) + 1);
-      if (!name16) {
+      if (!name16) {MOZ_RELEASE_ASSERT(0);
         okay = false;
         return;
       }
@@ -268,7 +268,7 @@ template <typename Referent>
 UniquePtr<EdgeRange> TracerConcrete<Referent>::edges(JSContext* cx,
                                                      bool wantNames) const {
   auto range = js::MakeUnique<SimpleEdgeRange>();
-  if (!range) {
+  if (!range) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -376,17 +376,17 @@ bool RootList::init(CompartmentSet& debu
 
   ZoneSet debuggeeZones;
   for (auto range = debuggees.all(); !range.empty(); range.popFront()) {
-    if (!debuggeeZones.put(range.front()->zone())) {
+    if (!debuggeeZones.put(range.front()->zone())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   js::TraceRuntime(&tracer);
-  if (!tracer.okay) {
+  if (!tracer.okay) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   js::gc::TraceIncomingCCWs(&tracer, debuggees);
-  if (!tracer.okay) {
+  if (!tracer.okay) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -420,12 +420,12 @@ bool RootList::init(HandleObject debugge
 
   for (js::WeakGlobalObjectSet::Range r = dbg->allDebuggees(); !r.empty();
        r.popFront()) {
-    if (!debuggeeCompartments.put(r.front()->compartment())) {
+    if (!debuggeeCompartments.put(r.front()->compartment())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!init(debuggeeCompartments)) {
+  if (!init(debuggeeCompartments)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/vm/UbiNodeCensus.cpp b/js/src/vm/UbiNodeCensus.cpp
--- a/js/src/vm/UbiNodeCensus.cpp
+++ b/js/src/vm/UbiNodeCensus.cpp
@@ -88,25 +88,25 @@ bool SimpleCount::report(JSContext* cx, 
   Count& count = static_cast<Count&>(countBase);
 
   RootedPlainObject obj(cx, NewBuiltinClassInstance<PlainObject>(cx));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedValue countValue(cx, NumberValue(count.total_));
   if (reportCount &&
-      !DefineDataProperty(cx, obj, cx->names().count, countValue)) {
+      !DefineDataProperty(cx, obj, cx->names().count, countValue)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedValue bytesValue(cx, NumberValue(count.totalBytes_));
   if (reportBytes &&
-      !DefineDataProperty(cx, obj, cx->names().bytes, bytesValue)) {
+      !DefineDataProperty(cx, obj, cx->names().bytes, bytesValue)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (label) {
     JSString* labelString = JS_NewUCStringCopyZ(cx, label.get());
-    if (!labelString) {
+    if (!labelString) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     RootedValue labelValue(cx, StringValue(labelString));
@@ -157,7 +157,7 @@ bool BucketCount::report(JSContext* cx, 
 
   size_t length = count.ids_.length();
   RootedArrayObject arr(cx, NewDenseFullyAllocatedArray(cx, length));
-  if (!arr) {
+  if (!arr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   arr->ensureDenseInitializedLength(0, length);
@@ -350,7 +350,7 @@ static PlainObject* countMapToObject(JSC
   // more interesting, and a little less non-deterministic.
 
   JS::ubi::Vector<typename Map::Entry*> entries;
-  if (!entries.reserve(map.count())) {
+  if (!entries.reserve(map.count())) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -365,21 +365,21 @@ static PlainObject* countMapToObject(JSC
   }
 
   RootedPlainObject obj(cx, NewBuiltinClassInstance<PlainObject>(cx));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   for (auto& entry : entries) {
     CountBasePtr& thenCount = entry->value();
     RootedValue thenReport(cx);
-    if (!thenCount->report(cx, &thenReport)) {
+    if (!thenCount->report(cx, &thenReport)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     const char* name = getName(entry->key());
     MOZ_ASSERT(name);
     JSAtom* atom = Atomize(cx, name, strlen(name));
-    if (!atom) {
+    if (!atom) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -400,7 +400,7 @@ static PlainObject* countMap16ToObject(J
   // more interesting, and a little less non-deterministic.
 
   JS::ubi::Vector<typename Map::Entry*> entries;
-  if (!entries.reserve(map.count())) {
+  if (!entries.reserve(map.count())) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -415,21 +415,21 @@ static PlainObject* countMap16ToObject(J
   }
 
   RootedPlainObject obj(cx, NewBuiltinClassInstance<PlainObject>(cx));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   for (auto& entry : entries) {
     CountBasePtr& thenCount = entry->value();
     RootedValue thenReport(cx);
-    if (!thenCount->report(cx, &thenReport)) {
+    if (!thenCount->report(cx, &thenReport)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     const char16_t* name = getName(entry->key());
     MOZ_ASSERT(name);
     JSAtom* atom = AtomizeChars(cx, name, js_strlen(name));
-    if (!atom) {
+    if (!atom) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -485,7 +485,7 @@ class ByObjectClass : public CountType {
 
 CountBasePtr ByObjectClass::makeCount() {
   CountBasePtr otherCount(otherType->makeCount());
-  if (!otherCount) {
+  if (!otherCount) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -613,12 +613,12 @@ bool ByDomObjectClass::count(CountBase& 
   Count& count = static_cast<Count&>(countBase);
 
   const char16_t* nodeName = node.descriptiveTypeName();
-  if (!nodeName) {
+  if (!nodeName) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   UniqueC16String name = DuplicateString(nodeName);
-  if (!name) {
+  if (!name) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -724,7 +724,7 @@ bool ByUbinodeType::report(JSContext* cx
   // that to build the result object. This makes the ordering of entries
   // more interesting, and a little less non-deterministic.
   JS::ubi::Vector<Entry*> entries;
-  if (!entries.reserve(count.table.count())) {
+  if (!entries.reserve(count.table.count())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (Table::Range r = count.table.all(); !r.empty(); r.popFront()) {
@@ -737,7 +737,7 @@ bool ByUbinodeType::report(JSContext* cx
 
   // Now build the result by iterating over the sorted vector.
   RootedPlainObject obj(cx, NewBuiltinClassInstance<PlainObject>(cx));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (Entry** entryPtr = entries.begin(); entryPtr < entries.end();
@@ -745,14 +745,14 @@ bool ByUbinodeType::report(JSContext* cx
     Entry& entry = **entryPtr;
     CountBasePtr& typeCount = entry.value();
     RootedValue typeReport(cx);
-    if (!typeCount->report(cx, &typeReport)) {
+    if (!typeCount->report(cx, &typeReport)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     const char16_t* name = entry.key();
     MOZ_ASSERT(name);
     JSAtom* atom = AtomizeChars(cx, name, js_strlen(name));
-    if (!atom) {
+    if (!atom) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     RootedId entryId(cx, AtomToId(atom));
@@ -832,7 +832,7 @@ class ByAllocationStack : public CountTy
 
 CountBasePtr ByAllocationStack::makeCount() {
   CountBasePtr noStackCount(noStackType->makeCount());
-  if (!noStackCount) {
+  if (!noStackCount) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -896,7 +896,7 @@ bool ByAllocationStack::report(JSContext
   // that to build the result object. This makes the ordering of entries
   // more interesting, and a little less non-deterministic.
   JS::ubi::Vector<Entry*> entries;
-  if (!entries.reserve(count.table.count())) {
+  if (!entries.reserve(count.table.count())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (Table::Range r = count.table.all(); !r.empty(); r.popFront()) {
@@ -909,7 +909,7 @@ bool ByAllocationStack::report(JSContext
 
   // Now build the result by iterating over the sorted vector.
   Rooted<MapObject*> map(cx, MapObject::create(cx));
-  if (!map) {
+  if (!map) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (Entry** entryPtr = entries.begin(); entryPtr < entries.end();
@@ -919,25 +919,25 @@ bool ByAllocationStack::report(JSContext
 
     RootedObject stack(cx);
     if (!entry.key().constructSavedFrameStack(cx, &stack) ||
-        !cx->compartment()->wrap(cx, &stack)) {
+        !cx->compartment()->wrap(cx, &stack)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     RootedValue stackVal(cx, ObjectValue(*stack));
 
     CountBasePtr& stackCount = entry.value();
     RootedValue stackReport(cx);
-    if (!stackCount->report(cx, &stackReport)) {
+    if (!stackCount->report(cx, &stackReport)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!MapObject::set(cx, map, stackVal, stackReport)) {
+    if (!MapObject::set(cx, map, stackVal, stackReport)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   if (count.noStack->total_ > 0) {
     RootedValue noStackReport(cx);
-    if (!count.noStack->report(cx, &noStackReport)) {
+    if (!count.noStack->report(cx, &noStackReport)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     RootedValue noStack(cx, StringValue(cx->names().noStack));
@@ -1010,12 +1010,12 @@ class ByFilename : public CountType {
 
 CountBasePtr ByFilename::makeCount() {
   CountBasePtr thenCount(thenType->makeCount());
-  if (!thenCount) {
+  if (!thenCount) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   CountBasePtr noFilenameCount(noFilenameType->makeCount());
-  if (!noFilenameCount) {
+  if (!noFilenameCount) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1046,7 +1046,7 @@ bool ByFilename::count(CountBase& countB
   }
 
   UniqueCString myFilename = DuplicateString(filename);
-  if (!myFilename) {
+  if (!myFilename) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1068,7 +1068,7 @@ bool ByFilename::report(JSContext* cx, C
   RootedPlainObject obj(
       cx, countMapToObject(cx, count.table,
                            [](const UniqueCString& key) { return key.get(); }));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1135,7 +1135,7 @@ JS_PUBLIC_API CountTypePtr ParseBreakdow
   }
 
   RootedObject breakdown(cx, ToObject(cx, breakdownValue));
-  if (!breakdown) {
+  if (!breakdown) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1144,11 +1144,11 @@ JS_PUBLIC_API CountTypePtr ParseBreakdow
     return nullptr;
   }
   RootedString byString(cx, ToString(cx, byValue));
-  if (!byString) {
+  if (!byString) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   RootedLinearString by(cx, byString->ensureLinear(cx));
-  if (!by) {
+  if (!by) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1168,19 +1168,19 @@ JS_PUBLIC_API CountTypePtr ParseBreakdow
     // a 'label' property whose value is converted to a string and included as
     // a 'label' property on the report object.
     RootedValue label(cx);
-    if (!GetProperty(cx, breakdown, breakdown, cx->names().label, &label)) {
+    if (!GetProperty(cx, breakdown, breakdown, cx->names().label, &label)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     UniqueTwoByteChars labelUnique(nullptr);
     if (!label.isUndefined()) {
       RootedString labelString(cx, ToString(cx, label));
-      if (!labelString) {
+      if (!labelString) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
       labelUnique = JS_CopyStringCharsZ(cx, labelString);
-      if (!labelUnique) {
+      if (!labelUnique) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -1232,7 +1232,7 @@ JS_PUBLIC_API CountTypePtr ParseBreakdow
     }
     CountTypePtr domNodeType(
         ParseChildBreakdown(cx, breakdown, cx->names().domNode));
-    if (!domNodeType) {
+    if (!domNodeType) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1251,7 +1251,7 @@ JS_PUBLIC_API CountTypePtr ParseBreakdow
 
   if (StringEqualsLiteral(by, "descriptiveType")) {
     CountTypePtr thenType(ParseChildBreakdown(cx, breakdown, cx->names().then));
-    if (!thenType) {
+    if (!thenType) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     return CountTypePtr(cx->new_<ByDomObjectClass>(thenType));
@@ -1259,12 +1259,12 @@ JS_PUBLIC_API CountTypePtr ParseBreakdow
 
   if (StringEqualsLiteral(by, "allocationStack")) {
     CountTypePtr thenType(ParseChildBreakdown(cx, breakdown, cx->names().then));
-    if (!thenType) {
+    if (!thenType) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     CountTypePtr noStackType(
         ParseChildBreakdown(cx, breakdown, cx->names().noStack));
-    if (!noStackType) {
+    if (!noStackType) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1273,13 +1273,13 @@ JS_PUBLIC_API CountTypePtr ParseBreakdow
 
   if (StringEqualsLiteral(by, "filename")) {
     CountTypePtr thenType(ParseChildBreakdown(cx, breakdown, cx->names().then));
-    if (!thenType) {
+    if (!thenType) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     CountTypePtr noFilenameType(
         ParseChildBreakdown(cx, breakdown, cx->names().noFilename));
-    if (!noFilenameType) {
+    if (!noFilenameType) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1307,41 +1307,41 @@ JS_PUBLIC_API CountTypePtr ParseBreakdow
 // }
 static CountTypePtr GetDefaultBreakdown(JSContext* cx) {
   CountTypePtr byDomClass(cx->new_<SimpleCount>());
-  if (!byDomClass) {
+  if (!byDomClass) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   CountTypePtr byClass(cx->new_<SimpleCount>());
-  if (!byClass) {
+  if (!byClass) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   CountTypePtr byClassElse(cx->new_<SimpleCount>());
-  if (!byClassElse) {
+  if (!byClassElse) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   CountTypePtr objects(cx->new_<ByObjectClass>(byClass, byClassElse));
-  if (!objects) {
+  if (!objects) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   CountTypePtr scripts(cx->new_<SimpleCount>());
-  if (!scripts) {
+  if (!scripts) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   CountTypePtr strings(cx->new_<SimpleCount>());
-  if (!strings) {
+  if (!strings) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   CountTypePtr byType(cx->new_<SimpleCount>());
-  if (!byType) {
+  if (!byType) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   CountTypePtr other(cx->new_<ByUbinodeType>(byType));
-  if (!other) {
+  if (!other) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   CountTypePtr domNode(cx->new_<ByDomObjectClass>(byDomClass));
diff --git a/js/src/vm/UbiNodeShortestPaths.cpp b/js/src/vm/UbiNodeShortestPaths.cpp
--- a/js/src/vm/UbiNodeShortestPaths.cpp
+++ b/js/src/vm/UbiNodeShortestPaths.cpp
@@ -17,7 +17,7 @@ namespace ubi {
 
 JS_PUBLIC_API BackEdge::Ptr BackEdge::clone() const {
   auto clone = js::MakeUnique<BackEdge>();
-  if (!clone) {
+  if (!clone) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/src/vm/Xdr.cpp b/js/src/vm/Xdr.cpp
--- a/js/src/vm/Xdr.cpp
+++ b/js/src/vm/Xdr.cpp
@@ -68,7 +68,7 @@ XDRResult XDRState<mode>::codeChars(Utf8
 
   if (mode == XDR_ENCODE) {
     uint8_t* ptr = buf->write(count);
-    if (!ptr) {
+    if (!ptr) {MOZ_RELEASE_ASSERT(0);
       return fail(JS::TranscodeResult::Throw);
     }
 
@@ -76,7 +76,7 @@ XDRResult XDRState<mode>::codeChars(Utf8
                    [](const Utf8Unit& unit) { return unit.toUint8(); });
   } else {
     const uint8_t* ptr = buf->read(count);
-    if (!ptr) {
+    if (!ptr) {MOZ_RELEASE_ASSERT(0);
       return fail(JS::TranscodeResult::Failure_BadDecode);
     }
 
@@ -96,7 +96,7 @@ XDRResult XDRState<mode>::codeChars(char
   size_t nbytes = nchars * sizeof(char16_t);
   if (mode == XDR_ENCODE) {
     uint8_t* ptr = buf->write(nbytes);
-    if (!ptr) {
+    if (!ptr) {MOZ_RELEASE_ASSERT(0);
       return fail(JS::TranscodeResult::Throw);
     }
 
@@ -134,7 +134,7 @@ static XDRResult XDRCodeCharsZ(XDRState<
 
     // Set a reasonable limit on string length.
     size_t lengthSizeT = std::char_traits<CharT>::length(chars);
-    if (lengthSizeT > JSString::MAX_LENGTH) {
+    if (lengthSizeT > JSString::MAX_LENGTH) {MOZ_RELEASE_ASSERT(0);
       ReportAllocationOverflow(xdr->cx());
       return xdr->fail(JS::TranscodeResult::Throw);
     }
@@ -144,7 +144,7 @@ static XDRResult XDRCodeCharsZ(XDRState<
 
   if (mode == XDR_DECODE) {
     owned = xdr->cx()->template make_pod_array<CharT>(length + 1);
-    if (!owned) {
+    if (!owned) {MOZ_RELEASE_ASSERT(0);
       return xdr->fail(JS::TranscodeResult::Throw);
     }
     chars = owned.get();
@@ -181,14 +181,14 @@ static bool GetScriptTranscodingBuildId(
   MOZ_ASSERT(buildId->empty());
   MOZ_ASSERT(GetBuildId);
 
-  if (!GetBuildId(buildId)) {
+  if (!GetBuildId(buildId)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Note: the buildId returned here is also used for the bytecode cache MIME
   // type so use plain ASCII characters.
 
-  if (!buildId->reserve(buildId->length() + 4)) {
+  if (!buildId->reserve(buildId->length() + 4)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -228,7 +228,7 @@ JS_PUBLIC_API bool JS::GetScriptTranscod
 template <XDRMode mode>
 static XDRResult VersionCheck(XDRState<mode>* xdr, XDRFormatType formatType) {
   JS::BuildIdCharVector buildId;
-  if (!GetScriptTranscodingBuildId(formatType, &buildId)) {
+  if (!GetScriptTranscodingBuildId(formatType, &buildId)) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(xdr->cx());
     return xdr->fail(JS::TranscodeResult::Throw);
   }
@@ -241,7 +241,7 @@ static XDRResult VersionCheck(XDRState<m
 
   MOZ_TRY(xdr->codeUint32(&buildIdLength));
 
-  if (mode == XDR_DECODE && buildIdLength != buildId.length()) {
+  if (mode == XDR_DECODE && buildIdLength != buildId.length()) {MOZ_RELEASE_ASSERT(0);
     return xdr->fail(JS::TranscodeResult::Failure_BadBuildId);
   }
 
@@ -252,7 +252,7 @@ static XDRResult VersionCheck(XDRState<m
 
     // buildIdLength is already checked against the length of current
     // buildId.
-    if (!decodedBuildId.resize(buildIdLength)) {
+    if (!decodedBuildId.resize(buildIdLength)) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(xdr->cx());
       return xdr->fail(JS::TranscodeResult::Throw);
     }
@@ -381,14 +381,14 @@ XDRIncrementalStencilEncoder::~XDRIncrem
 XDRResult XDRIncrementalStencilEncoder::setInitial(
     JSContext* cx, const JS::ReadOnlyCompileOptions& options,
     UniquePtr<frontend::ExtensibleCompilationStencil>&& initial) {
-  if (!IsOptionCompatibleWithEncoding(options)) {
+  if (!IsOptionCompatibleWithEncoding(options)) {MOZ_RELEASE_ASSERT(0);
     return mozilla::Err(JS::TranscodeResult::Failure);
   }
 
   MOZ_TRY(frontend::StencilXDR::checkCompilationStencil(*initial));
 
   merger_ = cx->new_<frontend::CompilationStencilMerger>();
-  if (!merger_) {
+  if (!merger_) {MOZ_RELEASE_ASSERT(0);
     return mozilla::Err(JS::TranscodeResult::Throw);
   }
 
diff --git a/js/src/wasm/AsmJS.cpp b/js/src/wasm/AsmJS.cpp
--- a/js/src/wasm/AsmJS.cpp
+++ b/js/src/wasm/AsmJS.cpp
@@ -1392,7 +1392,7 @@ class MOZ_STACK_CLASS ModuleValidatorSha
     };
 
     for (const auto& info : functions) {
-      if (!AddMathFunction(info.name, info.func)) {
+      if (!AddMathFunction(info.name, info.func)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1488,13 +1488,13 @@ class MOZ_STACK_CLASS ModuleValidatorSha
 
     uint32_t index = moduleEnv_.globals.length();
     if (!moduleEnv_.globals.emplaceBack(type.canonicalToValType(), !isConst,
-                                        index, ModuleKind::AsmJS)) {
+                                        index, ModuleKind::AsmJS)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     Global::Which which = isConst ? Global::ConstantLiteral : Global::Variable;
     Global* global = validationLifo_.new_<Global>(which);
-    if (!global) {
+    if (!global) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (isConst) {
@@ -1517,20 +1517,20 @@ class MOZ_STACK_CLASS ModuleValidatorSha
     MOZ_ASSERT(type.isGlobalVarType());
 
     UniqueChars fieldChars = parserAtoms_.toNewUTF8CharsZ(cx_, field);
-    if (!fieldChars) {
+    if (!fieldChars) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     uint32_t index = moduleEnv_.globals.length();
     ValType valType = type.canonicalToValType();
     if (!moduleEnv_.globals.emplaceBack(valType, !isConst, index,
-                                        ModuleKind::AsmJS)) {
+                                        ModuleKind::AsmJS)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     Global::Which which = isConst ? Global::ConstantImport : Global::Variable;
     Global* global = validationLifo_.new_<Global>(which);
-    if (!global) {
+    if (!global) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     new (&global->u.varOrConst) Global::U::VarOrConst(index, type.which());
@@ -1548,17 +1548,17 @@ class MOZ_STACK_CLASS ModuleValidatorSha
     UniqueChars fieldChars;
     if (maybeField) {
       fieldChars = parserAtoms_.toNewUTF8CharsZ(cx_, maybeField);
-      if (!fieldChars) {
+      if (!fieldChars) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
 
-    if (!arrayViews_.append(ArrayView(var, vt))) {
+    if (!arrayViews_.append(ArrayView(var, vt))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     Global* global = validationLifo_.new_<Global>(Global::ArrayView);
-    if (!global) {
+    if (!global) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     new (&global->u.viewType_) Scalar::Type(vt);
@@ -1574,12 +1574,12 @@ class MOZ_STACK_CLASS ModuleValidatorSha
                               AsmJSMathBuiltinFunction func,
                               TaggedParserAtomIndex field) {
     UniqueChars fieldChars = parserAtoms_.toNewUTF8CharsZ(cx_, field);
-    if (!fieldChars) {
+    if (!fieldChars) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     Global* global = validationLifo_.new_<Global>(Global::MathBuiltinFunction);
-    if (!global) {
+    if (!global) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     new (&global->u.mathBuiltinFunc_) AsmJSMathBuiltinFunction(func);
@@ -1606,7 +1606,7 @@ class MOZ_STACK_CLASS ModuleValidatorSha
   bool addMathBuiltinConstant(TaggedParserAtomIndex var, double constant,
                               TaggedParserAtomIndex field) {
     UniqueChars fieldChars = parserAtoms_.toNewUTF8CharsZ(cx_, field);
-    if (!fieldChars) {
+    if (!fieldChars) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1622,7 +1622,7 @@ class MOZ_STACK_CLASS ModuleValidatorSha
   bool addGlobalConstant(TaggedParserAtomIndex var, double constant,
                          TaggedParserAtomIndex field) {
     UniqueChars fieldChars = parserAtoms_.toNewUTF8CharsZ(cx_, field);
-    if (!fieldChars) {
+    if (!fieldChars) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1638,12 +1638,12 @@ class MOZ_STACK_CLASS ModuleValidatorSha
   bool addArrayViewCtor(TaggedParserAtomIndex var, Scalar::Type vt,
                         TaggedParserAtomIndex field) {
     UniqueChars fieldChars = parserAtoms_.toNewUTF8CharsZ(cx_, field);
-    if (!fieldChars) {
+    if (!fieldChars) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     Global* global = validationLifo_.new_<Global>(Global::ArrayViewCtor);
-    if (!global) {
+    if (!global) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     new (&global->u.viewType_) Scalar::Type(vt);
@@ -1657,17 +1657,17 @@ class MOZ_STACK_CLASS ModuleValidatorSha
   }
   bool addFFI(TaggedParserAtomIndex var, TaggedParserAtomIndex field) {
     UniqueChars fieldChars = parserAtoms_.toNewUTF8CharsZ(cx_, field);
-    if (!fieldChars) {
+    if (!fieldChars) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (asmJSMetadata_->numFFIs == UINT32_MAX) {
+    if (asmJSMetadata_->numFFIs == UINT32_MAX) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     uint32_t ffiIndex = asmJSMetadata_->numFFIs++;
 
     Global* global = validationLifo_.new_<Global>(Global::FFI);
-    if (!global) {
+    if (!global) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     new (&global->u.ffiIndex_) uint32_t(ffiIndex);
@@ -1687,7 +1687,7 @@ class MOZ_STACK_CLASS ModuleValidatorSha
     } else {
       fieldChars = DuplicateString("");
     }
-    if (!fieldChars) {
+    if (!fieldChars) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1708,7 +1708,7 @@ class MOZ_STACK_CLASS ModuleValidatorSha
 
   bool defineFuncPtrTable(uint32_t tableIndex, Uint32Vector&& elems) {
     Table& table = *tables_[tableIndex];
-    if (table.defined()) {
+    if (table.defined()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1949,21 +1949,21 @@ class MOZ_STACK_CLASS ModuleValidator : 
   bool addFuncDef(TaggedParserAtomIndex name, uint32_t firstUse, FuncType&& sig,
                   Func** func) {
     uint32_t sigIndex;
-    if (!declareSig(std::move(sig), &sigIndex)) {
+    if (!declareSig(std::move(sig), &sigIndex)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     uint32_t funcDefIndex = funcDefs_.length();
-    if (funcDefIndex >= MaxFuncs) {
+    if (funcDefIndex >= MaxFuncs) {MOZ_RELEASE_ASSERT(0);
       return failCurrentOffset("too many functions");
     }
 
     Global* global = validationLifo_.new_<Global>(Global::Function);
-    if (!global) {
+    if (!global) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     new (&global->u.funcDefIndex_) uint32_t(funcDefIndex);
-    if (!globalMap_.putNew(name, global)) {
+    if (!globalMap_.putNew(name, global)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!funcDefs_.emplaceBack(name, sigIndex, firstUse, funcDefIndex)) {
@@ -1983,23 +1983,23 @@ class MOZ_STACK_CLASS ModuleValidator : 
     *tableIndex = moduleEnv_.tables.length();
 
     uint32_t sigIndex;
-    if (!newSig(std::move(sig), &sigIndex)) {
+    if (!newSig(std::move(sig), &sigIndex)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     MOZ_ASSERT(sigIndex >= moduleEnv_.asmJSSigToTableIndex.length());
-    if (!moduleEnv_.asmJSSigToTableIndex.resize(sigIndex + 1)) {
+    if (!moduleEnv_.asmJSSigToTableIndex.resize(sigIndex + 1)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     moduleEnv_.asmJSSigToTableIndex[sigIndex] = moduleEnv_.tables.length();
     if (!moduleEnv_.tables.emplaceBack(RefType::func(), mask + 1, Nothing(),
-                                       /*isAsmJS*/ true)) {
+                                       /*isAsmJS*/ true)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     Global* global = validationLifo_.new_<Global>(Global::Table);
-    if (!global) {
+    if (!global) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2023,11 +2023,11 @@ class MOZ_STACK_CLASS ModuleValidator : 
     *importIndex = funcImportMap_.count();
     MOZ_ASSERT(*importIndex == asmJSMetadata_->asmJSImports.length());
 
-    if (*importIndex >= MaxImports) {
+    if (*importIndex >= MaxImports) {MOZ_RELEASE_ASSERT(0);
       return failCurrentOffset("too many imports");
     }
 
-    if (!asmJSMetadata_->asmJSImports.emplaceBack(ffiIndex)) {
+    if (!asmJSMetadata_->asmJSImports.emplaceBack(ffiIndex)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2048,7 +2048,7 @@ class MOZ_STACK_CLASS ModuleValidator : 
 
   SharedModule finish() {
     MOZ_ASSERT(moduleEnv_.funcs.empty());
-    if (!moduleEnv_.funcs.resize(funcImportMap_.count() + funcDefs_.length())) {
+    if (!moduleEnv_.funcs.resize(funcImportMap_.count() + funcDefs_.length())) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     for (FuncImportMap::Range r = funcImportMap_.all(); !r.empty();
@@ -2070,18 +2070,18 @@ class MOZ_STACK_CLASS ModuleValidator : 
     }
 
     if (!moduleEnv_.funcImportGlobalDataOffsets.resize(
-            funcImportMap_.count())) {
+            funcImportMap_.count())) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     MOZ_ASSERT(asmJSMetadata_->asmJSFuncNames.empty());
-    if (!asmJSMetadata_->asmJSFuncNames.resize(funcImportMap_.count())) {
+    if (!asmJSMetadata_->asmJSFuncNames.resize(funcImportMap_.count())) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     for (const Func& func : funcDefs_) {
       CacheableChars funcName = parserAtoms_.toNewUTF8CharsZ(cx_, func.name());
       if (!funcName ||
-          !asmJSMetadata_->asmJSFuncNames.emplaceBack(std::move(funcName))) {
+          !asmJSMetadata_->asmJSFuncNames.emplaceBack(std::move(funcName))) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -2101,7 +2101,7 @@ class MOZ_STACK_CLASS ModuleValidator : 
     if (parser_.ss->filename()) {
       scriptedCaller.line = 0;  // unused
       scriptedCaller.filename = DuplicateString(parser_.ss->filename());
-      if (!scriptedCaller.filename) {
+      if (!scriptedCaller.filename) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -2110,7 +2110,7 @@ class MOZ_STACK_CLASS ModuleValidator : 
     FeatureOptions options;
     SharedCompileArgs args =
         CompileArgs::build(cx_, std::move(scriptedCaller), options);
-    if (!args) {
+    if (!args) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -2126,12 +2126,12 @@ class MOZ_STACK_CLASS ModuleValidator : 
     // asm.js does not have any wasm bytecode to save; view-source is
     // provided through the ScriptSource.
     SharedBytes bytes = cx_->new_<ShareableBytes>();
-    if (!bytes) {
+    if (!bytes) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     ModuleGenerator mg(*args, &moduleEnv_, &compilerEnv_, nullptr, nullptr);
-    if (!mg.init(asmJSMetadata_.get())) {
+    if (!mg.init(asmJSMetadata_.get())) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -2139,7 +2139,7 @@ class MOZ_STACK_CLASS ModuleValidator : 
       if (!mg.compileFuncDef(funcImportMap_.count() + func.funcDefIndex(),
                              func.line(), func.bytes().begin(),
                              func.bytes().end(),
-                             std::move(func.callSiteLineNums()))) {
+                             std::move(func.callSiteLineNums()))) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
     }
@@ -2524,7 +2524,7 @@ class MOZ_STACK_CLASS FunctionValidatorS
   bool addLabels(const LabelVector& labels, uint32_t relativeBreakDepth,
                  uint32_t relativeContinueDepth) {
     for (TaggedParserAtomIndex label : labels) {
-      if (!breakLabels_.putNew(label, blockDepth_ + relativeBreakDepth)) {
+      if (!breakLabels_.putNew(label, blockDepth_ + relativeBreakDepth)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (!continueLabels_.putNew(label, blockDepth_ + relativeContinueDepth)) {
@@ -2669,7 +2669,7 @@ static bool CheckFunctionHead(ModuleVali
   FunctionBox* funbox = funNode->funbox();
   MOZ_ASSERT(!funbox->hasExprBody());
 
-  if (funbox->hasRest()) {
+  if (funbox->hasRest()) {MOZ_RELEASE_ASSERT(0);
     return m.fail(funNode, "rest args not allowed");
   }
   if (funbox->hasDestructuringArgs) {
@@ -2715,7 +2715,7 @@ static bool CheckModuleArguments(ModuleV
   ParseNode* arg2 = arg1 ? NextNode(arg1) : nullptr;
   ParseNode* arg3 = arg2 ? NextNode(arg2) : nullptr;
 
-  if (numFormals > 3) {
+  if (numFormals > 3) {MOZ_RELEASE_ASSERT(0);
     return m.fail(funNode, "asm.js modules takes at most 3 argument");
   }
 
@@ -2723,7 +2723,7 @@ static bool CheckModuleArguments(ModuleV
   if (arg1 && !CheckModuleArgument(m, arg1, &arg1Name)) {
     return false;
   }
-  if (!m.initGlobalArgumentName(arg1Name)) {
+  if (!m.initGlobalArgumentName(arg1Name)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2731,7 +2731,7 @@ static bool CheckModuleArguments(ModuleV
   if (arg2 && !CheckModuleArgument(m, arg2, &arg2Name)) {
     return false;
   }
-  if (!m.initImportArgumentName(arg2Name)) {
+  if (!m.initImportArgumentName(arg2Name)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2826,7 +2826,7 @@ static bool CheckGlobalVariableInitImpor
                       varName);
   }
 
-  if (!coerceTo.isGlobalVarType()) {
+  if (!coerceTo.isGlobalVarType()) {MOZ_RELEASE_ASSERT(0);
     return m.fail(initNode, "global variable type not allowed");
   }
 
@@ -2876,7 +2876,7 @@ static bool CheckNewArrayViewArgs(Module
   ParseNode* ctorExpr = BinaryLeft(newExpr);
   ParseNode* ctorArgs = BinaryRight(newExpr);
   ParseNode* bufArg = ListHead(ctorArgs);
-  if (!bufArg || NextNode(bufArg) != nullptr) {
+  if (!bufArg || NextNode(bufArg) != nullptr) {MOZ_RELEASE_ASSERT(0);
     return m.fail(ctorExpr,
                   "array view constructor takes exactly one argument");
   }
@@ -2893,13 +2893,13 @@ static bool CheckNewArrayView(ModuleVali
                               TaggedParserAtomIndex varName,
                               ParseNode* newExpr) {
   TaggedParserAtomIndex globalName = m.globalArgumentName();
-  if (!globalName) {
+  if (!globalName) {MOZ_RELEASE_ASSERT(0);
     return m.fail(
         newExpr, "cannot create array view without an asm.js global parameter");
   }
 
   TaggedParserAtomIndex bufferName = m.bufferArgumentName();
-  if (!bufferName) {
+  if (!bufferName) {MOZ_RELEASE_ASSERT(0);
     return m.fail(newExpr,
                   "cannot create array view without an asm.js heap parameter");
   }
@@ -2911,32 +2911,32 @@ static bool CheckNewArrayView(ModuleVali
   if (ctorExpr->isKind(ParseNodeKind::DotExpr)) {
     ParseNode* base = DotBase(ctorExpr);
 
-    if (!IsUseOfName(base, globalName)) {
+    if (!IsUseOfName(base, globalName)) {MOZ_RELEASE_ASSERT(0);
       return m.failName(base, "expecting '%s.*Array", globalName);
     }
 
     field = DotMember(ctorExpr);
-    if (!IsArrayViewCtorName(m, field, &type)) {
+    if (!IsArrayViewCtorName(m, field, &type)) {MOZ_RELEASE_ASSERT(0);
       return m.fail(ctorExpr, "could not match typed array name");
     }
   } else {
-    if (!ctorExpr->isKind(ParseNodeKind::Name)) {
+    if (!ctorExpr->isKind(ParseNodeKind::Name)) {MOZ_RELEASE_ASSERT(0);
       return m.fail(ctorExpr,
                     "expecting name of imported array view constructor");
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     TaggedParserAtomIndex globalName = ctorExpr->as<NameNode>().name();
     const ModuleValidatorShared::Global* global = m.lookupGlobal(globalName);
-    if (!global) {
+    if (!global) {MOZ_RELEASE_ASSERT(0);
       return m.failName(ctorExpr, "%s not found in module global scope",
                         globalName);
     }
 
-    if (global->which() != ModuleValidatorShared::Global::ArrayViewCtor) {
+    if (global->which() != ModuleValidatorShared::Global::ArrayViewCtor) {MOZ_RELEASE_ASSERT(0);
       return m.failName(ctorExpr,
                         "%s must be an imported array view constructor",
                         globalName);
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     type = global->viewType();
   }
@@ -2985,22 +2985,22 @@ static bool CheckGlobalDotImport(ModuleV
     }
 
     if (!IsUseOfName(global, globalName)) {
-      if (global->isKind(ParseNodeKind::DotExpr)) {
+      if (global->isKind(ParseNodeKind::DotExpr)) {MOZ_RELEASE_ASSERT(0);
         return m.failName(base,
                           "imports can have at most two dot accesses "
                           "(e.g. %s.Math.sin)",
                           globalName);
-      }
+      }MOZ_RELEASE_ASSERT(0);
       return m.failName(base, "expecting %s.*", globalName);
     }
 
     if (math == TaggedParserAtomIndex::WellKnown::Math()) {
       return CheckGlobalMathImport(m, initNode, varName, field);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return m.failName(base, "expecting %s.Math", globalName);
   }
 
-  if (!base->isKind(ParseNodeKind::Name)) {
+  if (!base->isKind(ParseNodeKind::Name)) {MOZ_RELEASE_ASSERT(0);
     return m.fail(base, "expected name of variable or parameter");
   }
 
@@ -3089,7 +3089,7 @@ static bool CheckModuleProcessingDirecti
     }
 
     TokenKind tt;
-    if (!ts.getToken(&tt)) {
+    if (!ts.getToken(&tt)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (tt != TokenKind::Semi) {
@@ -3134,7 +3134,7 @@ static bool CheckArgumentType(FunctionVa
   }
 
   ParseNode* initNode = ExpressionStatementExpr(stmt);
-  if (!initNode->isKind(ParseNodeKind::AssignExpr)) {
+  if (!initNode->isKind(ParseNodeKind::AssignExpr)) {MOZ_RELEASE_ASSERT(0);
     return ArgFail(f, name, stmt);
   }
 
@@ -3150,7 +3150,7 @@ static bool CheckArgumentType(FunctionVa
     return false;
   }
 
-  if (!type->isArgType()) {
+  if (!type->isArgType()) {MOZ_RELEASE_ASSERT(0);
     return f.failName(stmt, "invalid type for argument '%s'", name);
   }
 
@@ -3183,7 +3183,7 @@ static bool CheckArguments(FunctionValid
   for (unsigned i = 0; i < numFormals;
        i++, argpn = NextNode(argpn), stmt = NextNode(stmt)) {
     TaggedParserAtomIndex name;
-    if (!CheckArgument(f.m(), argpn, &name)) {
+    if (!CheckArgument(f.m(), argpn, &name)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3192,7 +3192,7 @@ static bool CheckArguments(FunctionValid
       return false;
     }
 
-    if (!argTypes->append(type.canonicalToValType())) {
+    if (!argTypes->append(type.canonicalToValType())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3229,7 +3229,7 @@ static bool IsLiteralOrConst(FunctionVal
 
 static bool CheckFinalReturn(FunctionValidatorShared& f,
                              ParseNode* lastNonEmptyStmt) {
-  if (!f.encoder().writeOp(Op::End)) {
+  if (!f.encoder().writeOp(Op::End)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3258,13 +3258,13 @@ static bool CheckVariable(FunctionValida
 
   ParseNode* var = assignNode->left();
 
-  if (!var->isKind(ParseNodeKind::Name)) {
+  if (!var->isKind(ParseNodeKind::Name)) {MOZ_RELEASE_ASSERT(0);
     return f.fail(var, "local variable is not a plain name");
   }
 
   TaggedParserAtomIndex name = var->as<NameNode>().name();
 
-  if (!CheckIdentifier(f.m(), var, name)) {
+  if (!CheckIdentifier(f.m(), var, name)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3314,10 +3314,10 @@ static bool CheckVariables(FunctionValid
     if (lit.isZeroBits()) {
       continue;
     }
-    if (!f.writeConstExpr(lit)) {
+    if (!f.writeConstExpr(lit)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!f.encoder().writeOp(Op::SetLocal)) {
+    if (!f.encoder().writeOp(Op::SetLocal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!f.encoder().writeVarU32(firstVar + i)) {
@@ -3348,10 +3348,10 @@ static bool CheckVarRef(FunctionValidato
   TaggedParserAtomIndex name = varRef->as<NameNode>().name();
 
   if (const FunctionValidatorShared::Local* local = f.lookupLocal(name)) {
-    if (!f.encoder().writeOp(Op::GetLocal)) {
+    if (!f.encoder().writeOp(Op::GetLocal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!f.encoder().writeVarU32(local->slot)) {
+    if (!f.encoder().writeVarU32(local->slot)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     *type = local->type;
@@ -3400,7 +3400,7 @@ static const int32_t NoMask = -1;
 template <typename Unit>
 static bool CheckArrayAccess(FunctionValidator<Unit>& f, ParseNode* viewName,
                              ParseNode* indexExpr, Scalar::Type* viewType) {
-  if (!viewName->isKind(ParseNodeKind::Name)) {
+  if (!viewName->isKind(ParseNodeKind::Name)) {MOZ_RELEASE_ASSERT(0);
     return f.fail(viewName,
                   "base of array access must be a typed array view name");
   }
@@ -3434,7 +3434,7 @@ static bool CheckArrayAccess(FunctionVal
     ParseNode* shiftAmountNode = BitwiseRight(indexExpr);
 
     uint32_t shift;
-    if (!IsLiteralInt(f.m(), shiftAmountNode, &shift)) {
+    if (!IsLiteralInt(f.m(), shiftAmountNode, &shift)) {MOZ_RELEASE_ASSERT(0);
       return f.failf(shiftAmountNode, "shift amount must be constant");
     }
 
@@ -3450,7 +3450,7 @@ static bool CheckArrayAccess(FunctionVal
       return false;
     }
 
-    if (!pointerType.isIntish()) {
+    if (!pointerType.isIntish()) {MOZ_RELEASE_ASSERT(0);
       return f.failf(pointerNode, "%s is not a subtype of int",
                      pointerType.toChars());
     }
@@ -3491,7 +3491,7 @@ static bool WriteArrayAccessFlags(Functi
   // asm.js only has naturally-aligned accesses.
   size_t align = TypedArrayElemSize(viewType);
   MOZ_ASSERT(IsPowerOfTwo(align));
-  if (!f.encoder().writeFixedU8(CeilingLog2(align))) {
+  if (!f.encoder().writeFixedU8(CeilingLog2(align))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3570,7 +3570,7 @@ static bool CheckStoreArray(FunctionVali
   }
 
   Type rhsType;
-  if (!CheckExpr(f, rhs, &rhsType)) {
+  if (!CheckExpr(f, rhs, &rhsType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3665,10 +3665,10 @@ static bool CheckAssignName(FunctionVali
       return false;
     }
 
-    if (!f.encoder().writeOp(Op::TeeLocal)) {
+    if (!f.encoder().writeOp(Op::TeeLocal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!f.encoder().writeVarU32(lhsVar->slot)) {
+    if (!f.encoder().writeVarU32(lhsVar->slot)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3686,7 +3686,7 @@ static bool CheckAssignName(FunctionVali
     }
 
     Type rhsType;
-    if (!CheckExpr(f, rhs, &rhsType)) {
+    if (!CheckExpr(f, rhs, &rhsType)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3695,7 +3695,7 @@ static bool CheckAssignName(FunctionVali
       return f.failf(lhs, "%s is not a subtype of %s", rhsType.toChars(),
                      globType.toChars());
     }
-    if (!f.encoder().writeOp(MozOp::TeeGlobal)) {
+    if (!f.encoder().writeOp(MozOp::TeeGlobal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!f.encoder().writeVarU32(global->varOrConstIndex())) {
@@ -3734,7 +3734,7 @@ static bool CheckAssign(FunctionValidato
 template <typename Unit>
 static bool CheckMathIMul(FunctionValidator<Unit>& f, ParseNode* call,
                           Type* type) {
-  if (CallArgListLength(call) != 2) {
+  if (CallArgListLength(call) != 2) {MOZ_RELEASE_ASSERT(0);
     return f.fail(call, "Math.imul must be passed 2 arguments");
   }
 
@@ -3742,12 +3742,12 @@ static bool CheckMathIMul(FunctionValida
   ParseNode* rhs = NextNode(lhs);
 
   Type lhsType;
-  if (!CheckExpr(f, lhs, &lhsType)) {
+  if (!CheckExpr(f, lhs, &lhsType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Type rhsType;
-  if (!CheckExpr(f, rhs, &rhsType)) {
+  if (!CheckExpr(f, rhs, &rhsType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3765,14 +3765,14 @@ static bool CheckMathIMul(FunctionValida
 template <typename Unit>
 static bool CheckMathClz32(FunctionValidator<Unit>& f, ParseNode* call,
                            Type* type) {
-  if (CallArgListLength(call) != 1) {
+  if (CallArgListLength(call) != 1) {MOZ_RELEASE_ASSERT(0);
     return f.fail(call, "Math.clz32 must be passed 1 argument");
   }
 
   ParseNode* arg = CallArgList(call);
 
   Type argType;
-  if (!CheckExpr(f, arg, &argType)) {
+  if (!CheckExpr(f, arg, &argType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3787,14 +3787,14 @@ static bool CheckMathClz32(FunctionValid
 template <typename Unit>
 static bool CheckMathAbs(FunctionValidator<Unit>& f, ParseNode* call,
                          Type* type) {
-  if (CallArgListLength(call) != 1) {
+  if (CallArgListLength(call) != 1) {MOZ_RELEASE_ASSERT(0);
     return f.fail(call, "Math.abs must be passed 1 argument");
   }
 
   ParseNode* arg = CallArgList(call);
 
   Type argType;
-  if (!CheckExpr(f, arg, &argType)) {
+  if (!CheckExpr(f, arg, &argType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3820,14 +3820,14 @@ static bool CheckMathAbs(FunctionValidat
 template <typename Unit>
 static bool CheckMathSqrt(FunctionValidator<Unit>& f, ParseNode* call,
                           Type* type) {
-  if (CallArgListLength(call) != 1) {
+  if (CallArgListLength(call) != 1) {MOZ_RELEASE_ASSERT(0);
     return f.fail(call, "Math.sqrt must be passed 1 argument");
   }
 
   ParseNode* arg = CallArgList(call);
 
   Type argType;
-  if (!CheckExpr(f, arg, &argType)) {
+  if (!CheckExpr(f, arg, &argType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3854,7 +3854,7 @@ static bool CheckMathMinMax(FunctionVali
 
   ParseNode* firstArg = CallArgList(callNode);
   Type firstType;
-  if (!CheckExpr(f, firstArg, &firstType)) {
+  if (!CheckExpr(f, firstArg, &firstType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3881,7 +3881,7 @@ static bool CheckMathMinMax(FunctionVali
   ParseNode* nextArg = NextNode(firstArg);
   for (unsigned i = 1; i < numArgs; i++, nextArg = NextNode(nextArg)) {
     Type nextType;
-    if (!CheckExpr(f, nextArg, &nextType)) {
+    if (!CheckExpr(f, nextArg, &nextType)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!(nextType <= firstType)) {
@@ -3890,7 +3890,7 @@ static bool CheckMathMinMax(FunctionVali
     }
 
     if (op != Op::Limit) {
-      if (!f.encoder().writeOp(op)) {
+      if (!f.encoder().writeOp(op)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -3941,7 +3941,7 @@ template <typename Unit>
 static bool CheckFunctionSignature(ModuleValidator<Unit>& m, ParseNode* usepn,
                                    FuncType&& sig, TaggedParserAtomIndex name,
                                    ModuleValidatorShared::Func** func) {
-  if (sig.args().length() > MaxParams) {
+  if (sig.args().length() > MaxParams) {MOZ_RELEASE_ASSERT(0);
     return m.failf(usepn, "too many parameters");
   }
 
@@ -3985,7 +3985,7 @@ static bool CheckInternalCall(FunctionVa
 
   ValTypeVector results;
   Maybe<ValType> retType = ret.canonicalToReturnType();
-  if (retType && !results.append(retType.ref())) {
+  if (retType && !results.append(retType.ref())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3997,7 +3997,7 @@ static bool CheckInternalCall(FunctionVa
     return false;
   }
 
-  if (!f.writeCall(callNode, MozOp::OldCallDirect)) {
+  if (!f.writeCall(callNode, MozOp::OldCallDirect)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4085,7 +4085,7 @@ static bool CheckFuncPtrCall(FunctionVal
   }
 
   Type indexType;
-  if (!CheckExpr(f, indexNode, &indexType)) {
+  if (!CheckExpr(f, indexNode, &indexType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4095,13 +4095,13 @@ static bool CheckFuncPtrCall(FunctionVal
   }
 
   ValTypeVector args;
-  if (!CheckCallArgs<CheckIsArgType>(f, callNode, &args)) {
+  if (!CheckCallArgs<CheckIsArgType>(f, callNode, &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   ValTypeVector results;
   Maybe<ValType> retType = ret.canonicalToReturnType();
-  if (retType && !results.append(retType.ref())) {
+  if (retType && !results.append(retType.ref())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4113,7 +4113,7 @@ static bool CheckFuncPtrCall(FunctionVal
     return false;
   }
 
-  if (!f.writeCall(callNode, MozOp::OldCallIndirect)) {
+  if (!f.writeCall(callNode, MozOp::OldCallIndirect)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4153,7 +4153,7 @@ static bool CheckFFICall(FunctionValidat
 
   ValTypeVector results;
   Maybe<ValType> retType = ret.canonicalToReturnType();
-  if (retType && !results.append(retType.ref())) {
+  if (retType && !results.append(retType.ref())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4161,7 +4161,7 @@ static bool CheckFFICall(FunctionValidat
 
   uint32_t importIndex;
   if (!f.m().declareImport(calleeName, std::move(sig), ffiIndex,
-                           &importIndex)) {
+                           &importIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4216,7 +4216,7 @@ static bool CheckCoercionArg(FunctionVal
   }
 
   if (expected.isFloat()) {
-    if (!CheckFloatCoercionArg(f, arg, argType)) {
+    if (!CheckFloatCoercionArg(f, arg, argType)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -4333,18 +4333,18 @@ static bool CheckMathBuiltinCall(Functio
   }
 
   unsigned actualArity = CallArgListLength(callNode);
-  if (actualArity != arity) {
+  if (actualArity != arity) {MOZ_RELEASE_ASSERT(0);
     return f.failf(callNode, "call passed %u arguments, expected %u",
                    actualArity, arity);
   }
 
-  if (!f.prepareCall(callNode)) {
+  if (!f.prepareCall(callNode)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Type firstType;
   ParseNode* argNode = CallArgList(callNode);
-  if (!CheckExpr(f, argNode, &firstType)) {
+  if (!CheckExpr(f, argNode, &firstType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4362,16 +4362,16 @@ static bool CheckMathBuiltinCall(Functio
   if (arity == 2) {
     Type secondType;
     argNode = NextNode(argNode);
-    if (!CheckExpr(f, argNode, &secondType)) {
+    if (!CheckExpr(f, argNode, &secondType)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (firstType.isMaybeDouble() && !secondType.isMaybeDouble()) {
+    if (firstType.isMaybeDouble() && !secondType.isMaybeDouble()) {MOZ_RELEASE_ASSERT(0);
       return f.fail(
           argNode,
           "both arguments to math builtin call should be the same type");
     }
-    if (firstType.isMaybeFloat() && !secondType.isMaybeFloat()) {
+    if (firstType.isMaybeFloat() && !secondType.isMaybeFloat()) {MOZ_RELEASE_ASSERT(0);
       return f.fail(
           argNode,
           "both arguments to math builtin call should be the same type");
@@ -4380,11 +4380,11 @@ static bool CheckMathBuiltinCall(Functio
 
   if (opIsDouble) {
     if (f64 != Op::Limit) {
-      if (!f.encoder().writeOp(f64)) {
+      if (!f.encoder().writeOp(f64)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
-      if (!f.encoder().writeOp(mozf64)) {
+      if (!f.encoder().writeOp(mozf64)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -4485,13 +4485,13 @@ static bool CheckCoercedCall(FunctionVal
                              Type ret, Type* type) {
   MOZ_ASSERT(ret.isCanonical());
 
-  if (!CheckRecursionLimitDontReport(f.cx())) {
+  if (!CheckRecursionLimitDontReport(f.cx())) {MOZ_RELEASE_ASSERT(0);
     return f.m().failOverRecursed();
   }
 
   if (IsNumericLiteral(f.m(), call)) {
     NumLit lit = ExtractNumericLiteral(f.m(), call);
-    if (!f.writeConstExpr(lit)) {
+    if (!f.writeConstExpr(lit)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     return CoerceResult(f, call, ret, Type::lit(lit), type);
@@ -4555,7 +4555,7 @@ static bool CheckNot(FunctionValidator<U
   ParseNode* operand = UnaryKid(expr);
 
   Type operandType;
-  if (!CheckExpr(f, operand, &operandType)) {
+  if (!CheckExpr(f, operand, &operandType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4635,11 +4635,11 @@ static bool CheckBitNot(FunctionValidato
   }
 
   Type operandType;
-  if (!CheckExpr(f, operand, &operandType)) {
-    return false;
-  }
-
-  if (!operandType.isIntish()) {
+  if (!CheckExpr(f, operand, &operandType)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!operandType.isIntish()) {MOZ_RELEASE_ASSERT(0);
     return f.failf(operand, "%s is not a subtype of intish",
                    operandType.toChars());
   }
@@ -4664,18 +4664,18 @@ static bool CheckComma(FunctionValidator
 
   // The block depth isn't taken into account here, because a comma list can't
   // contain breaks and continues and nested control flow structures.
-  if (!f.encoder().writeOp(Op::Block)) {
+  if (!f.encoder().writeOp(Op::Block)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   size_t typeAt;
-  if (!f.encoder().writePatchableFixedU7(&typeAt)) {
+  if (!f.encoder().writePatchableFixedU7(&typeAt)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   ParseNode* pn = operands;
   for (; NextNode(pn); pn = NextNode(pn)) {
-    if (!CheckAsExprStatement(f, pn)) {
+    if (!CheckAsExprStatement(f, pn)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -4699,30 +4699,30 @@ static bool CheckConditional(FunctionVal
   ParseNode* elseExpr = TernaryKid3(ternary);
 
   Type condType;
-  if (!CheckExpr(f, cond, &condType)) {
-    return false;
-  }
-
-  if (!condType.isInt()) {
+  if (!CheckExpr(f, cond, &condType)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!condType.isInt()) {MOZ_RELEASE_ASSERT(0);
     return f.failf(cond, "%s is not a subtype of int", condType.toChars());
   }
 
   size_t typeAt;
-  if (!f.pushIf(&typeAt)) {
+  if (!f.pushIf(&typeAt)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Type thenType;
-  if (!CheckExpr(f, thenExpr, &thenType)) {
-    return false;
-  }
-
-  if (!f.switchToElse()) {
+  if (!CheckExpr(f, thenExpr, &thenType)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.switchToElse()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Type elseType;
-  if (!CheckExpr(f, elseExpr, &elseType)) {
+  if (!CheckExpr(f, elseExpr, &elseType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4730,7 +4730,7 @@ static bool CheckConditional(FunctionVal
     *type = Type::Int;
   } else if (thenType.isDouble() && elseType.isDouble()) {
     *type = Type::Double;
-  } else if (thenType.isFloat() && elseType.isFloat()) {
+  } else if (thenType.isFloat() && elseType.isFloat()) {MOZ_RELEASE_ASSERT(0);
     *type = Type::Float;
   } else {
     return f.failf(
@@ -4780,12 +4780,12 @@ static bool CheckMultiply(FunctionValida
   ParseNode* rhs = MultiplyRight(star);
 
   Type lhsType;
-  if (!CheckExpr(f, lhs, &lhsType)) {
+  if (!CheckExpr(f, lhs, &lhsType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Type rhsType;
-  if (!CheckExpr(f, rhs, &rhsType)) {
+  if (!CheckExpr(f, rhs, &rhsType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4817,7 +4817,7 @@ static bool CheckMultiply(FunctionValida
 template <typename Unit>
 static bool CheckAddOrSub(FunctionValidator<Unit>& f, ParseNode* expr,
                           Type* type, unsigned* numAddOrSubOut = nullptr) {
-  if (!CheckRecursionLimitDontReport(f.cx())) {
+  if (!CheckRecursionLimitDontReport(f.cx())) {MOZ_RELEASE_ASSERT(0);
     return f.m().failOverRecursed();
   }
 
@@ -4831,7 +4831,7 @@ static bool CheckAddOrSub(FunctionValida
 
   if (lhs->isKind(ParseNodeKind::AddExpr) ||
       lhs->isKind(ParseNodeKind::SubExpr)) {
-    if (!CheckAddOrSub(f, lhs, &lhsType, &lhsNumAddOrSub)) {
+    if (!CheckAddOrSub(f, lhs, &lhsType, &lhsNumAddOrSub)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (lhsType == Type::Intish) {
@@ -4846,7 +4846,7 @@ static bool CheckAddOrSub(FunctionValida
 
   if (rhs->isKind(ParseNodeKind::AddExpr) ||
       rhs->isKind(ParseNodeKind::SubExpr)) {
-    if (!CheckAddOrSub(f, rhs, &rhsType, &rhsNumAddOrSub)) {
+    if (!CheckAddOrSub(f, rhs, &rhsType, &rhsNumAddOrSub)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (rhsType == Type::Intish) {
@@ -4860,25 +4860,25 @@ static bool CheckAddOrSub(FunctionValida
   }
 
   unsigned numAddOrSub = lhsNumAddOrSub + rhsNumAddOrSub + 1;
-  if (numAddOrSub > (1 << 20)) {
+  if (numAddOrSub > (1 << 20)) {MOZ_RELEASE_ASSERT(0);
     return f.fail(expr, "too many + or - without intervening coercion");
   }
 
   if (lhsType.isInt() && rhsType.isInt()) {
     if (!f.encoder().writeOp(
-            expr->isKind(ParseNodeKind::AddExpr) ? Op::I32Add : Op::I32Sub)) {
+            expr->isKind(ParseNodeKind::AddExpr) ? Op::I32Add : Op::I32Sub)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     *type = Type::Intish;
   } else if (lhsType.isMaybeDouble() && rhsType.isMaybeDouble()) {
     if (!f.encoder().writeOp(
-            expr->isKind(ParseNodeKind::AddExpr) ? Op::F64Add : Op::F64Sub)) {
+            expr->isKind(ParseNodeKind::AddExpr) ? Op::F64Add : Op::F64Sub)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     *type = Type::Double;
   } else if (lhsType.isMaybeFloat() && rhsType.isMaybeFloat()) {
     if (!f.encoder().writeOp(
-            expr->isKind(ParseNodeKind::AddExpr) ? Op::F32Add : Op::F32Sub)) {
+            expr->isKind(ParseNodeKind::AddExpr) ? Op::F32Add : Op::F32Sub)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     *type = Type::Floatish;
@@ -4905,10 +4905,10 @@ static bool CheckDivOrMod(FunctionValida
   ParseNode* rhs = DivOrModRight(expr);
 
   Type lhsType, rhsType;
-  if (!CheckExpr(f, lhs, &lhsType)) {
-    return false;
-  }
-  if (!CheckExpr(f, rhs, &rhsType)) {
+  if (!CheckExpr(f, lhs, &lhsType)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!CheckExpr(f, rhs, &rhsType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4961,10 +4961,10 @@ static bool CheckComparison(FunctionVali
   ParseNode* rhs = ComparisonRight(comp);
 
   Type lhsType, rhsType;
-  if (!CheckExpr(f, lhs, &lhsType)) {
-    return false;
-  }
-  if (!CheckExpr(f, rhs, &rhsType)) {
+  if (!CheckExpr(f, lhs, &lhsType)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!CheckExpr(f, rhs, &rhsType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5127,10 +5127,10 @@ static bool CheckBitwise(FunctionValidat
   if (!onlyOnRight && IsLiteralInt(f.m(), lhs, &i) &&
       i == uint32_t(identityElement)) {
     Type rhsType;
-    if (!CheckExpr(f, rhs, &rhsType)) {
+    if (!CheckExpr(f, rhs, &rhsType)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!rhsType.isIntish()) {
+    if (!rhsType.isIntish()) {MOZ_RELEASE_ASSERT(0);
       return f.failf(bitwise, "%s is not a subtype of intish",
                      rhsType.toChars());
     }
@@ -5160,14 +5160,14 @@ static bool CheckBitwise(FunctionValidat
   }
 
   Type rhsType;
-  if (!CheckExpr(f, rhs, &rhsType)) {
-    return false;
-  }
-
-  if (!lhsType.isIntish()) {
+  if (!CheckExpr(f, rhs, &rhsType)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!lhsType.isIntish()) {MOZ_RELEASE_ASSERT(0);
     return f.failf(lhs, "%s is not a subtype of intish", lhsType.toChars());
   }
-  if (!rhsType.isIntish()) {
+  if (!rhsType.isIntish()) {MOZ_RELEASE_ASSERT(0);
     return f.failf(rhs, "%s is not a subtype of intish", rhsType.toChars());
   }
 
@@ -5199,7 +5199,7 @@ static bool CheckBitwise(FunctionValidat
 
 template <typename Unit>
 static bool CheckExpr(FunctionValidator<Unit>& f, ParseNode* expr, Type* type) {
-  if (!CheckRecursionLimitDontReport(f.cx())) {
+  if (!CheckRecursionLimitDontReport(f.cx())) {MOZ_RELEASE_ASSERT(0);
     return f.m().failOverRecursed();
   }
 
@@ -5301,14 +5301,14 @@ static bool CheckLoopConditionOnEntry(Fu
   }
 
   Type condType;
-  if (!CheckExpr(f, cond, &condType)) {
+  if (!CheckExpr(f, cond, &condType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!condType.isInt()) {
     return f.failf(cond, "%s is not a subtype of int", condType.toChars());
   }
 
-  if (!f.encoder().writeOp(Op::I32Eqz)) {
+  if (!f.encoder().writeOp(Op::I32Eqz)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5335,25 +5335,25 @@ static bool CheckWhile(FunctionValidator
   //       (br $top)
   //    )
   // )
-  if (labels && !f.addLabels(*labels, 0, 1)) {
-    return false;
-  }
-
-  if (!f.pushLoop()) {
+  if (labels && !f.addLabels(*labels, 0, 1)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.pushLoop()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (!CheckLoopConditionOnEntry(f, cond)) {
     return false;
   }
-  if (!CheckStatement(f, body)) {
-    return false;
-  }
-  if (!f.writeContinue()) {
-    return false;
-  }
-
-  if (!f.popLoop()) {
+  if (!CheckStatement(f, body)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.writeContinue()) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.popLoop()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (labels) {
@@ -5369,7 +5369,7 @@ static bool CheckFor(FunctionValidator<U
   ParseNode* forHead = BinaryLeft(forStmt);
   ParseNode* body = BinaryRight(forStmt);
 
-  if (!forHead->isKind(ParseNodeKind::ForHead)) {
+  if (!forHead->isKind(ParseNodeKind::ForHead)) {MOZ_RELEASE_ASSERT(0);
     return f.fail(forHead, "unsupported for-loop statement");
   }
 
@@ -5391,20 +5391,20 @@ static bool CheckFor(FunctionValidator<U
   // )
   // A break in the body should break out to $after_loop, i.e. depth + 1.
   // A continue in the body should break out to $after_body, i.e. depth + 3.
-  if (labels && !f.addLabels(*labels, 1, 3)) {
-    return false;
-  }
-
-  if (!f.pushUnbreakableBlock()) {
-    return false;
-  }
-
-  if (maybeInit && !CheckAsExprStatement(f, maybeInit)) {
+  if (labels && !f.addLabels(*labels, 1, 3)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.pushUnbreakableBlock()) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (maybeInit && !CheckAsExprStatement(f, maybeInit)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   {
-    if (!f.pushLoop()) {
+    if (!f.pushLoop()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5414,30 +5414,30 @@ static bool CheckFor(FunctionValidator<U
 
     {
       // Continuing in the body should just break out to the increment.
-      if (!f.pushContinuableBlock()) {
+      if (!f.pushContinuableBlock()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (!CheckStatement(f, body)) {
         return false;
       }
-      if (!f.popContinuableBlock()) {
+      if (!f.popContinuableBlock()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
 
-    if (maybeInc && !CheckAsExprStatement(f, maybeInc)) {
+    if (maybeInc && !CheckAsExprStatement(f, maybeInc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (!f.writeContinue()) {
+    if (!f.writeContinue()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!f.popLoop()) {
+    if (!f.popLoop()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!f.popUnbreakableBlock()) {
+  if (!f.popUnbreakableBlock()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5464,40 +5464,40 @@ static bool CheckDoWhile(FunctionValidat
   // )
   // A break should break out of the entire loop, i.e. at depth 0.
   // A continue should break out to the condition, i.e. at depth 2.
-  if (labels && !f.addLabels(*labels, 0, 2)) {
-    return false;
-  }
-
-  if (!f.pushLoop()) {
+  if (labels && !f.addLabels(*labels, 0, 2)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.pushLoop()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   {
     // An unlabeled continue in the body should break out to the condition.
-    if (!f.pushContinuableBlock()) {
+    if (!f.pushContinuableBlock()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!CheckStatement(f, body)) {
+    if (!CheckStatement(f, body)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!f.popContinuableBlock()) {
+    if (!f.popContinuableBlock()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   Type condType;
-  if (!CheckExpr(f, cond, &condType)) {
+  if (!CheckExpr(f, cond, &condType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!condType.isInt()) {
     return f.failf(cond, "%s is not a subtype of int", condType.toChars());
   }
 
-  if (!f.writeContinueIf()) {
-    return false;
-  }
-
-  if (!f.popLoop()) {
+  if (!f.writeContinueIf()) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.popLoop()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (labels) {
@@ -5517,7 +5517,7 @@ static bool CheckLabel(FunctionValidator
   LabelVector labels;
   ParseNode* innermost = labeledStmt;
   do {
-    if (!labels.append(LabeledStatementLabel(innermost))) {
+    if (!labels.append(LabeledStatementLabel(innermost))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     innermost = LabeledStatementStatement(innermost);
@@ -5536,11 +5536,11 @@ static bool CheckLabel(FunctionValidator
       break;
   }
 
-  if (!f.pushUnbreakableBlock(&labels)) {
-    return false;
-  }
-
-  if (!CheckStatement(f, innermost)) {
+  if (!f.pushUnbreakableBlock(&labels)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!CheckStatement(f, innermost)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5564,12 +5564,12 @@ recurse:
   if (!CheckExpr(f, cond, &condType)) {
     return false;
   }
-  if (!condType.isInt()) {
+  if (!condType.isInt()) {MOZ_RELEASE_ASSERT(0);
     return f.failf(cond, "%s is not a subtype of int", condType.toChars());
   }
 
   size_t typeAt;
-  if (!f.pushIf(&typeAt)) {
+  if (!f.pushIf(&typeAt)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5580,19 +5580,19 @@ recurse:
   }
 
   if (elseStmt) {
-    if (!f.switchToElse()) {
+    if (!f.switchToElse()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (elseStmt->isKind(ParseNodeKind::IfStmt)) {
       ifStmt = elseStmt;
-      if (numIfEnd++ == UINT32_MAX) {
+      if (numIfEnd++ == UINT32_MAX) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       goto recurse;
     }
 
-    if (!CheckStatement(f, elseStmt)) {
+    if (!CheckStatement(f, elseStmt)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -5608,7 +5608,7 @@ recurse:
 
 static bool CheckCaseExpr(FunctionValidatorShared& f, ParseNode* caseExpr,
                           int32_t* value) {
-  if (!IsNumericLiteral(f.m(), caseExpr)) {
+  if (!IsNumericLiteral(f.m(), caseExpr)) {MOZ_RELEASE_ASSERT(0);
     return f.fail(caseExpr,
                   "switch case expression must be an integer literal");
   }
@@ -5652,7 +5652,7 @@ static bool CheckSwitchRange(FunctionVal
   }
 
   int32_t i = 0;
-  if (!CheckCaseExpr(f, CaseExpr(stmt), &i)) {
+  if (!CheckCaseExpr(f, CaseExpr(stmt), &i)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5662,7 +5662,7 @@ static bool CheckSwitchRange(FunctionVal
   for (stmt = NextNode(stmt); stmt && !IsDefaultCase(stmt);
        stmt = NextNode(stmt)) {
     int32_t i = 0;
-    if (!CheckCaseExpr(f, CaseExpr(stmt), &i)) {
+    if (!CheckCaseExpr(f, CaseExpr(stmt), &i)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5684,7 +5684,7 @@ static bool CheckSwitchRange(FunctionVal
 template <typename Unit>
 static bool CheckSwitchExpr(FunctionValidator<Unit>& f, ParseNode* switchExpr) {
   Type exprType;
-  if (!CheckExpr(f, switchExpr, &exprType)) {
+  if (!CheckExpr(f, switchExpr, &exprType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!exprType.isSigned()) {
@@ -5715,7 +5715,7 @@ static bool CheckSwitch(FunctionValidato
 
   if (switchBody->is<LexicalScopeNode>()) {
     LexicalScopeNode* scope = &switchBody->as<LexicalScopeNode>();
-    if (!scope->isEmptyScope()) {
+    if (!scope->isEmptyScope()) {MOZ_RELEASE_ASSERT(0);
       return f.fail(scope, "switch body may not contain lexical declarations");
     }
     switchBody = scope->scopeBody();
@@ -5726,26 +5726,26 @@ static bool CheckSwitch(FunctionValidato
     if (!CheckSwitchExpr(f, switchExpr)) {
       return false;
     }
-    if (!f.encoder().writeOp(Op::Drop)) {
+    if (!f.encoder().writeOp(Op::Drop)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     return true;
   }
 
-  if (!CheckDefaultAtEnd(f, stmt)) {
+  if (!CheckDefaultAtEnd(f, stmt)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   int32_t low = 0, high = 0;
   uint32_t tableLength = 0;
-  if (!CheckSwitchRange(f, stmt, &low, &high, &tableLength)) {
+  if (!CheckSwitchRange(f, stmt, &low, &high, &tableLength)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   static const uint32_t CASE_NOT_DEFINED = UINT32_MAX;
 
   Uint32Vector caseDepths;
-  if (!caseDepths.appendN(CASE_NOT_DEFINED, tableLength)) {
+  if (!caseDepths.appendN(CASE_NOT_DEFINED, tableLength)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5764,19 +5764,19 @@ static bool CheckSwitch(FunctionValidato
   }
 
   // Open the wrapping breakable default block.
-  if (!f.pushBreakableBlock()) {
+  if (!f.pushBreakableBlock()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Open all the case blocks.
   for (uint32_t i = 0; i < numCases; i++) {
-    if (!f.pushUnbreakableBlock()) {
+    if (!f.pushUnbreakableBlock()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // Open the br_table block.
-  if (!f.pushUnbreakableBlock()) {
+  if (!f.pushUnbreakableBlock()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5785,29 +5785,29 @@ static bool CheckSwitch(FunctionValidato
 
   // Subtract lowest case value, so that all the cases start from 0.
   if (low) {
-    if (!CheckSwitchExpr(f, switchExpr)) {
+    if (!CheckSwitchExpr(f, switchExpr)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!f.writeInt32Lit(low)) {
+    if (!f.writeInt32Lit(low)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!f.encoder().writeOp(Op::I32Sub)) {
+    if (!f.encoder().writeOp(Op::I32Sub)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
-    if (!CheckSwitchExpr(f, switchExpr)) {
+    if (!CheckSwitchExpr(f, switchExpr)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // Start the br_table block.
-  if (!f.encoder().writeOp(Op::BrTable)) {
+  if (!f.encoder().writeOp(Op::BrTable)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Write the number of cases (tableLength - 1 + 1 (default)).
   // Write the number of cases (tableLength - 1 + 1 (default)).
-  if (!f.encoder().writeVarU32(tableLength)) {
+  if (!f.encoder().writeVarU32(tableLength)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5816,26 +5816,26 @@ static bool CheckSwitch(FunctionValidato
   for (size_t i = 0; i < tableLength; i++) {
     uint32_t target =
         caseDepths[i] == CASE_NOT_DEFINED ? defaultDepth : caseDepths[i];
-    if (!f.encoder().writeVarU32(target)) {
+    if (!f.encoder().writeVarU32(target)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   // Write the default depth.
-  if (!f.encoder().writeVarU32(defaultDepth)) {
+  if (!f.encoder().writeVarU32(defaultDepth)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Our br_table is done. Close its block, write the cases down in order.
-  if (!f.popUnbreakableBlock()) {
+  if (!f.popUnbreakableBlock()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   for (; stmt && !IsDefaultCase(stmt); stmt = NextNode(stmt)) {
-    if (!CheckStatement(f, CaseBody(stmt))) {
+    if (!CheckStatement(f, CaseBody(stmt))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!f.popUnbreakableBlock()) {
+    if (!f.popUnbreakableBlock()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -5873,7 +5873,7 @@ static bool CheckReturn(FunctionValidato
   ParseNode* expr = ReturnExpr(returnStmt);
 
   if (!expr) {
-    if (!CheckReturnType(f, returnStmt, Type::Void)) {
+    if (!CheckReturnType(f, returnStmt, Type::Void)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -5882,7 +5882,7 @@ static bool CheckReturn(FunctionValidato
       return false;
     }
 
-    if (!type.isReturnType()) {
+    if (!type.isReturnType()) {MOZ_RELEASE_ASSERT(0);
       return f.failf(expr, "%s is not a valid return type", type.toChars());
     }
 
@@ -5899,7 +5899,7 @@ static bool CheckStatementList(FunctionV
                                const LabelVector* labels /*= nullptr */) {
   MOZ_ASSERT(stmtList->isKind(ParseNodeKind::StatementList));
 
-  if (!f.pushUnbreakableBlock(labels)) {
+  if (!f.pushUnbreakableBlock(labels)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5932,7 +5932,7 @@ static bool CheckBreakOrContinue(Functio
 
 template <typename Unit>
 static bool CheckStatement(FunctionValidator<Unit>& f, ParseNode* stmt) {
-  if (!CheckRecursionLimitDontReport(f.cx())) {
+  if (!CheckRecursionLimitDontReport(f.cx())) {MOZ_RELEASE_ASSERT(0);
     return f.m().failOverRecursed();
   }
 
@@ -6000,7 +6000,7 @@ static bool ParseFunction(ModuleValidato
 
   FunctionNode* funNode = m.parser().handler_.newFunction(
       FunctionSyntaxKind::Statement, m.parser().pos());
-  if (!funNode) {
+  if (!funNode) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6010,7 +6010,7 @@ static bool ParseFunction(ModuleValidato
   FunctionBox* funbox = m.parser().newFunctionBox(
       funNode, name, flags, toStringStart, directives,
       GeneratorKind::NotGenerator, FunctionAsyncKind::SyncFunction);
-  if (!funbox) {
+  if (!funbox) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   funbox->initWithEnclosingParseContext(outerpc, flags,
@@ -6018,7 +6018,7 @@ static bool ParseFunction(ModuleValidato
 
   Directives newDirectives = directives;
   SourceParseContext funpc(&m.parser(), funbox, &newDirectives);
-  if (!funpc.init()) {
+  if (!funpc.init()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6053,7 +6053,7 @@ static bool CheckFunction(ModuleValidato
     return false;
   }
 
-  if (!CheckFunctionHead(m, funNode)) {
+  if (!CheckFunctionHead(m, funNode)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6061,7 +6061,7 @@ static bool CheckFunction(ModuleValidato
 
   ParseNode* stmtIter = ListHead(FunctionStatementList(funNode));
 
-  if (!CheckProcessingDirectives(m, &stmtIter)) {
+  if (!CheckProcessingDirectives(m, &stmtIter)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6088,7 +6088,7 @@ static bool CheckFunction(ModuleValidato
 
   ValTypeVector results;
   if (f.returnedType()) {
-    if (!results.append(f.returnedType().ref())) {
+    if (!results.append(f.returnedType().ref())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -6151,7 +6151,7 @@ static bool CheckFuncPtrTable(ModuleVali
 
   ParseNode* var = assignNode->left();
 
-  if (!var->isKind(ParseNodeKind::Name)) {
+  if (!var->isKind(ParseNodeKind::Name)) {MOZ_RELEASE_ASSERT(0);
     return m.fail(var, "function-pointer table name is not a plain name");
   }
 
@@ -6196,13 +6196,13 @@ static bool CheckFuncPtrTable(ModuleVali
       sig = &funcSig;
     }
 
-    if (!elemFuncDefIndices.append(func->funcDefIndex())) {
+    if (!elemFuncDefIndices.append(func->funcDefIndex())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   FuncType copy;
-  if (!copy.clone(*sig)) {
+  if (!copy.clone(*sig)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6295,7 +6295,7 @@ static bool CheckModuleExportObject(Modu
 template <typename Unit>
 static bool CheckModuleReturn(ModuleValidator<Unit>& m) {
   TokenKind tk;
-  if (!GetToken(m.parser(), &tk)) {
+  if (!GetToken(m.parser(), &tk)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   auto& ts = m.parser().tokenStream;
@@ -6355,7 +6355,7 @@ static SharedModule CheckModule(JSContex
   FunctionNode* moduleFunctionNode = parser.pc_->functionBox()->functionNode;
 
   ModuleValidator<Unit> m(cx, parserAtoms, parser, moduleFunctionNode);
-  if (!m.init()) {
+  if (!m.init()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -6379,7 +6379,7 @@ static SharedModule CheckModule(JSContex
     return nullptr;
   }
 
-  if (!m.startFunctionBodies()) {
+  if (!m.startFunctionBodies()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -6434,7 +6434,7 @@ static bool GetDataProperty(JSContext* c
 
   Rooted<PropertyDescriptor> desc(cx);
   RootedId id(cx, AtomToId(field));
-  if (!GetPropertyDescriptor(cx, obj, id, &desc)) {
+  if (!GetPropertyDescriptor(cx, obj, id, &desc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6469,7 +6469,7 @@ static bool GetDataProperty(JSContext* c
 
 static bool HasObjectValueOfMethodPure(JSObject* obj, JSContext* cx) {
   Value v;
-  if (!GetPropertyPure(cx, obj, NameToId(cx->names().valueOf), &v)) {
+  if (!GetPropertyPure(cx, obj, NameToId(cx->names().valueOf), &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6573,16 +6573,16 @@ static bool ValidateFFI(JSContext* cx, c
 
 static bool ValidateArrayView(JSContext* cx, const AsmJSGlobal& global,
                               HandleValue globalVal) {
-  if (!global.field()) {
+  if (!global.field()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
-  if (Scalar::isBigIntType(global.viewType())) {
+  if (Scalar::isBigIntType(global.viewType())) {MOZ_RELEASE_ASSERT(0);
     return LinkFail(cx, "bad typed array constructor");
   }
 
   RootedValue v(cx);
-  if (!GetDataProperty(cx, globalVal, global.field(), &v)) {
+  if (!GetDataProperty(cx, globalVal, global.field(), &v)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6694,7 +6694,7 @@ static bool ValidateConstant(JSContext* 
 
   // NaN != NaN
   if (IsNaN(global.constantValue())) {
-    if (!IsNaN(v.toNumber())) {
+    if (!IsNaN(v.toNumber())) {MOZ_RELEASE_ASSERT(0);
       return LinkFail(cx, "global constant value needs to be NaN");
     }
   } else {
@@ -6715,10 +6715,10 @@ static bool CheckBuffer(JSContext* cx, c
   JSObject* bufferObj = &bufferVal.toObject();
 
   if (metadata.memoryUsage == MemoryUsage::Shared) {
-    if (!bufferObj->is<SharedArrayBufferObject>()) {
+    if (!bufferObj->is<SharedArrayBufferObject>()) {MOZ_RELEASE_ASSERT(0);
       return LinkFail(
           cx, "shared views can only be constructed onto SharedArrayBuffer");
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return LinkFail(cx, "Unable to prepare SharedArrayBuffer for asm.js use");
   }
 
@@ -6738,7 +6738,7 @@ static bool CheckBuffer(JSContext* cx, c
                     "valid length is 0x%" PRIx64,
                     uint64_t(memoryLength),
                     RoundUpToNextValidAsmJSHeapLength(memoryLength)));
-    if (!msg) {
+    if (!msg) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     return LinkFail(cx, msg.get());
@@ -6755,7 +6755,7 @@ static bool CheckBuffer(JSContext* cx, c
                                 "by const heap accesses).",
                                 uint64_t(memoryLength),
                                 metadata.minMemoryLength));
-    if (!msg) {
+    if (!msg) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     return LinkFail(cx, msg.get());
@@ -6770,7 +6770,7 @@ static bool CheckBuffer(JSContext* cx, c
         JS_smprintf("ArrayBuffer byteLength 0x%" PRIx64
                     " is too large for asm.js (implementation limit).",
                     uint64_t(memoryLength)));
-    if (!msg) {
+    if (!msg) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     return LinkFail(cx, msg.get());
@@ -6788,7 +6788,7 @@ static bool GetImports(JSContext* cx, co
                        HandleValue globalVal, HandleValue importVal,
                        ImportValues* imports) {
   Rooted<FunctionVector> ffis(cx, FunctionVector(cx));
-  if (!ffis.resize(metadata.numFFIs)) {
+  if (!ffis.resize(metadata.numFFIs)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6847,7 +6847,7 @@ static bool TryInstantiate(JSContext* cx
 
   // Re-check HasPlatformSupport(cx) since this varies per-thread and
   // 'module' may have been produced on a parser thread.
-  if (!HasPlatformSupport(cx)) {
+  if (!HasPlatformSupport(cx)) {MOZ_RELEASE_ASSERT(0);
     return LinkFail(cx, "no platform support");
   }
 
@@ -6860,7 +6860,7 @@ static bool TryInstantiate(JSContext* cx
     }
 
     imports.get().memory = WasmMemoryObject::create(cx, buffer, nullptr);
-    if (!imports.get().memory) {
+    if (!imports.get().memory) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -6892,7 +6892,7 @@ static bool HandleInstantiationFailure(J
   // Source discarding is allowed to affect JS semantics because it is never
   // enabled for normal JS content.
   bool haveSource;
-  if (!ScriptSource::loadSource(cx, source, &haveSource)) {
+  if (!ScriptSource::loadSource(cx, source, &haveSource)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!haveSource) {
@@ -6904,7 +6904,7 @@ static bool HandleInstantiationFailure(J
   uint32_t begin = metadata.toStringStart;
   uint32_t end = metadata.srcEndAfterCurly();
   Rooted<JSLinearString*> src(cx, source->substringDontDeflate(cx, begin, end));
-  if (!src) {
+  if (!src) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6921,7 +6921,7 @@ static bool HandleInstantiationFailure(J
   }
 
   AutoStableStringChars stableChars(cx);
-  if (!stableChars.initTwoByte(cx, src)) {
+  if (!stableChars.initTwoByte(cx, src)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -6931,7 +6931,7 @@ static bool HandleInstantiationFailure(J
   SourceOwnership ownership = stableChars.maybeGiveOwnershipToCaller()
                                   ? SourceOwnership::TakeOwnership
                                   : SourceOwnership::Borrowed;
-  if (!srcBuf.init(cx, chars, end - begin, ownership)) {
+  if (!srcBuf.init(cx, chars, end - begin, ownership)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -7043,7 +7043,7 @@ static bool EstablishPreconditions(JSCon
     return TypeFailureWarning(parser, "Disabled by generator context");
   }
 
-  if (parser.pc_->isAsync()) {
+  if (parser.pc_->isAsync()) {MOZ_RELEASE_ASSERT(0);
     return TypeFailureWarning(parser, "Disabled by async context");
   }
 
@@ -7189,32 +7189,32 @@ JSString* js::AsmJSModuleToString(JSCont
 
   JSStringBuilder out(cx);
 
-  if (isToSource && fun->isLambda() && !out.append("(")) {
+  if (isToSource && fun->isLambda() && !out.append("(")) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   bool haveSource;
-  if (!ScriptSource::loadSource(cx, source, &haveSource)) {
+  if (!ScriptSource::loadSource(cx, source, &haveSource)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   if (!haveSource) {
-    if (!out.append("function ")) {
+    if (!out.append("function ")) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (fun->explicitName() && !out.append(fun->explicitName())) {
+    if (fun->explicitName() && !out.append(fun->explicitName())) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (!out.append("() {\n    [native code]\n}")) {
+    if (!out.append("() {\n    [native code]\n}")) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
     Rooted<JSLinearString*> src(cx, source->substring(cx, begin, end));
-    if (!src) {
+    if (!src) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (!out.append(src)) {
+    if (!out.append(src)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -7240,27 +7240,27 @@ JSString* js::AsmJSFunctionToString(JSCo
   ScriptSource* source = metadata.maybeScriptSource();
   JSStringBuilder out(cx);
 
-  if (!out.append("function ")) {
+  if (!out.append("function ")) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   bool haveSource;
-  if (!ScriptSource::loadSource(cx, source, &haveSource)) {
+  if (!ScriptSource::loadSource(cx, source, &haveSource)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   if (!haveSource) {
     // asm.js functions can't be anonymous
     MOZ_ASSERT(fun->explicitName());
-    if (!out.append(fun->explicitName())) {
+    if (!out.append(fun->explicitName())) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (!out.append("() {\n    [native code]\n}")) {
+    if (!out.append("() {\n    [native code]\n}")) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   } else {
     Rooted<JSLinearString*> src(cx, source->substring(cx, begin, end));
-    if (!src) {
+    if (!src) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (!out.append(src)) {
diff --git a/js/src/wasm/TypedObject.cpp b/js/src/wasm/TypedObject.cpp
--- a/js/src/wasm/TypedObject.cpp
+++ b/js/src/wasm/TypedObject.cpp
@@ -91,12 +91,12 @@ RttValue* RttValue::createFromHandle(JSC
 
   Rooted<RttValue*> rtt(cx,
                         NewTenuredObjectWithGivenProto<RttValue>(cx, nullptr));
-  if (!rtt) {
+  if (!rtt) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   Rooted<TypedProto*> proto(cx, TypedProto::create(cx));
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -121,7 +121,7 @@ RttValue* RttValue::createFromHandle(JSC
   return rtt;
 }
 
-RttValue* RttValue::createFromParent(JSContext* cx, HandleRttValue parent) {
+RttValue* RttValue::createFromParent(JSContext* cx, HandleRttValue parent) {MOZ_RELEASE_ASSERT(0);
   wasm::TypeHandle parentHandle = parent->handle();
   Rooted<RttValue*> rtt(cx, createFromHandle(cx, parentHandle));
   if (!rtt) {
@@ -214,7 +214,7 @@ OutlineTypedObject* OutlineTypedObject::
       (heap == gc::TenuredHeap) ? TenuredObject : GenericObject;
   auto* obj = NewObjectWithGivenProtoAndKinds<OutlineTypedObject>(
       cx, proto, allocKind(), newKind);
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -300,7 +300,7 @@ gc::AllocKind OutlineTypedObject::allocK
 }
 
 /* static */
-void OutlineTypedObject::obj_trace(JSTracer* trc, JSObject* object) {
+void OutlineTypedObject::obj_trace(JSTracer* trc, JSObject* object) {MOZ_RELEASE_ASSERT(0);
   OutlineTypedObject& typedObj = object->as<OutlineTypedObject>();
 
   TraceEdge(trc, &typedObj.rttValue_, "OutlineTypedObject_rttvalue");
@@ -385,13 +385,13 @@ bool RttValue::lookupProperty(JSContext*
 /* static */
 bool TypedObject::obj_lookupProperty(JSContext* cx, HandleObject obj,
                                      HandleId id, MutableHandleObject objp,
-                                     MutableHandle<PropertyResult> propp) {
+                                     MutableHandle<PropertyResult> propp) {MOZ_RELEASE_ASSERT(0);
   RootedTypedObject typedObj(cx, &obj->as<TypedObject>());
-  if (typedObj->rttValue().hasProperty(cx, typedObj, id)) {
+  if (typedObj->rttValue().hasProperty(cx, typedObj, id)) {MOZ_RELEASE_ASSERT(0);
     propp.setTypedObjectProperty();
     objp.set(obj);
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedObject proto(cx, obj->staticPrototype());
   if (!proto) {
@@ -469,12 +469,12 @@ bool TypedObject::obj_setProperty(JSCont
 
 bool TypedObject::obj_getOwnPropertyDescriptor(
     JSContext* cx, HandleObject obj, HandleId id,
-    MutableHandle<PropertyDescriptor> desc) {
+    MutableHandle<PropertyDescriptor> desc) {MOZ_RELEASE_ASSERT(0);
   Rooted<TypedObject*> typedObj(cx, &obj->as<TypedObject>());
 
   uint32_t offset;
   FieldType type;
-  if (typedObj->rttValue().lookupProperty(cx, typedObj, id, &offset, &type)) {
+  if (typedObj->rttValue().lookupProperty(cx, typedObj, id, &offset, &type)) {MOZ_RELEASE_ASSERT(0);
     if (!typedObj->loadValue(cx, offset, type, desc.value())) {
       return false;
     }
@@ -488,11 +488,11 @@ bool TypedObject::obj_getOwnPropertyDesc
 }
 
 bool TypedObject::obj_deleteProperty(JSContext* cx, HandleObject obj,
-                                     HandleId id, ObjectOpResult& result) {
+                                     HandleId id, ObjectOpResult& result) {MOZ_RELEASE_ASSERT(0);
   RootedTypedObject typedObj(cx, &obj->as<TypedObject>());
-  if (typedObj->rttValue().hasProperty(cx, typedObj, id)) {
+  if (typedObj->rttValue().hasProperty(cx, typedObj, id)) {MOZ_RELEASE_ASSERT(0);
     return Throw(cx, id, JSMSG_CANT_DELETE);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedObject proto(cx, obj->staticPrototype());
   if (!proto) {
@@ -504,7 +504,7 @@ bool TypedObject::obj_deleteProperty(JSC
 
 bool TypedObject::obj_newEnumerate(JSContext* cx, HandleObject obj,
                                    MutableHandleIdVector properties,
-                                   bool enumerableOnly) {
+                                   bool enumerableOnly) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(obj->is<TypedObject>());
   Rooted<TypedObject*> typedObj(cx, &obj->as<TypedObject>());
 
@@ -527,11 +527,11 @@ bool TypedObject::obj_newEnumerate(JSCon
       MOZ_ASSERT_UNREACHABLE();
   }
 
-  if (!properties.reserve(indexCount + otherCount)) {
+  if (!properties.reserve(indexCount + otherCount)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   RootedId id(cx);
-  for (size_t index = 0; index < indexCount; index++) {
+  for (size_t index = 0; index < indexCount; index++) {MOZ_RELEASE_ASSERT(0);
     id = INT_TO_JSID(index);
     properties.infallibleAppend(id);
   }
diff --git a/js/src/wasm/WasmBaselineCompile.cpp b/js/src/wasm/WasmBaselineCompile.cpp
--- a/js/src/wasm/WasmBaselineCompile.cpp
+++ b/js/src/wasm/WasmBaselineCompile.cpp
@@ -1889,7 +1889,7 @@ class BaseStackFrame final : public Base
   [[nodiscard]] bool setupLocals(const ValTypeVector& locals,
                                  const ArgTypeVector& args, bool debugEnabled,
                                  LocalVector* localInfo) {
-    if (!localInfo->reserve(locals.length())) {
+    if (!localInfo->reserve(locals.length())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5259,7 +5259,7 @@ class BaseCompiler final : public BaseCo
       //
       // Also make sure we leave headroom for other pushes that will occur after
       // pushing results, just to be safe.
-      if (!stk_.reserve(stk_.length() + type.length() + MaxPushesPerOpcode)) {
+      if (!stk_.reserve(stk_.length() + type.length() + MaxPushesPerOpcode)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -5616,7 +5616,7 @@ class BaseCompiler final : public BaseCo
 
     MOZ_ASSERT(stackMapGenerator_.machineStackTracker.length() == 0);
     if (!stackMapGenerator_.machineStackTracker.pushNonGCPointers(
-            stackMapGenerator_.numStackArgWords)) {
+            stackMapGenerator_.numStackArgWords)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5642,7 +5642,7 @@ class BaseCompiler final : public BaseCo
     // GenerateFunctionPrologue pushes exactly one wasm::Frame's worth of
     // stuff, and none of the values are GC pointers.  Hence:
     if (!stackMapGenerator_.machineStackTracker.pushNonGCPointers(
-            sizeof(Frame) / sizeof(void*))) {
+            sizeof(Frame) / sizeof(void*))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5656,7 +5656,7 @@ class BaseCompiler final : public BaseCo
 #endif
       masm.reserveStack(DebugFrame::offsetOfFrame());
       if (!stackMapGenerator_.machineStackTracker.pushNonGCPointers(
-              DebugFrame::offsetOfFrame() / sizeof(void*))) {
+              DebugFrame::offsetOfFrame() / sizeof(void*))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -5676,10 +5676,10 @@ class BaseCompiler final : public BaseCo
     fr.checkStack(ABINonArgReg0, BytecodeOffset(func_.lineOrBytecode));
 
     ExitStubMapVector extras;
-    if (!stackMapGenerator_.generateStackmapEntriesForTrapExit(args, &extras)) {
-      return false;
-    }
-    if (!createStackMap("stack check", extras, masm.currentOffset())) {
+    if (!stackMapGenerator_.generateStackmapEntriesForTrapExit(args, &extras)) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }
+    if (!createStackMap("stack check", extras, masm.currentOffset())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5689,7 +5689,7 @@ class BaseCompiler final : public BaseCo
     masm.reserveStack(reservedBytes);
     fr.onFixedStackAllocated();
     if (!stackMapGenerator_.machineStackTracker.pushNonGCPointers(
-            reservedBytes / sizeof(void*))) {
+            reservedBytes / sizeof(void*))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5904,7 +5904,7 @@ class BaseCompiler final : public BaseCo
     masm.flush();
 
     // Precondition for patching.
-    if (masm.oom()) {
+    if (masm.oom()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5921,11 +5921,11 @@ class BaseCompiler final : public BaseCo
       // it can be clobbered, and/or modified by the debug trap.
       saveRegisterReturnValues(resultType);
       insertBreakablePoint(CallSiteDesc::Breakpoint);
-      if (!createStackMap("debug: breakpoint")) {
+      if (!createStackMap("debug: breakpoint")) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       insertBreakablePoint(CallSiteDesc::LeaveFrame);
-      if (!createStackMap("debug: leave frame")) {
+      if (!createStackMap("debug: leave frame")) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       restoreRegisterReturnValues(resultType);
@@ -5945,7 +5945,7 @@ class BaseCompiler final : public BaseCo
 
     JitSpew(JitSpew_Codegen, "# endFunction: end of function epilogue");
     JitSpew(JitSpew_Codegen, "# endFunction: start of OOL code");
-    if (!generateOutOfLineCode()) {
+    if (!generateOutOfLineCode()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -6434,7 +6434,7 @@ class BaseCompiler final : public BaseCo
     return r;
   }
 
-  RegF32 captureReturnedF32(const FunctionCall& call) {
+  RegF32 captureReturnedF32(const FunctionCall& call) {MOZ_RELEASE_ASSERT(0);
     RegF32 r = RegF32(ReturnFloat32Reg);
     MOZ_ASSERT(isAvailableF32(r));
     needF32(r);
@@ -6446,7 +6446,7 @@ class BaseCompiler final : public BaseCo
     return r;
   }
 
-  RegF64 captureReturnedF64(const FunctionCall& call) {
+  RegF64 captureReturnedF64(const FunctionCall& call) {MOZ_RELEASE_ASSERT(0);
     RegF64 r = RegF64(ReturnDoubleReg);
     MOZ_ASSERT(isAvailableF64(r));
     needF64(r);
@@ -6685,7 +6685,7 @@ class BaseCompiler final : public BaseCo
     OutOfLineCode* ool =
         addOutOfLineCode(new (alloc_) OutOfLineTruncateCheckF32OrF64ToI32(
             AnyReg(src), dest, flags, off));
-    if (!ool) {
+    if (!ool) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     bool isSaturating = flags & TRUNC_SATURATING;
@@ -6704,7 +6704,7 @@ class BaseCompiler final : public BaseCo
     OutOfLineCode* ool =
         addOutOfLineCode(new (alloc_) OutOfLineTruncateCheckF32OrF64ToI32(
             AnyReg(src), dest, flags, off));
-    if (!ool) {
+    if (!ool) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     bool isSaturating = flags & TRUNC_SATURATING;
@@ -6756,7 +6756,7 @@ class BaseCompiler final : public BaseCo
     OutOfLineCode* ool =
         addOutOfLineCode(new (alloc_) OutOfLineTruncateCheckF32OrF64ToI64(
             AnyReg(src), dest, flags, bytecodeOffset()));
-    if (!ool) {
+    if (!ool) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     bool isSaturating = flags & TRUNC_SATURATING;
@@ -6775,7 +6775,7 @@ class BaseCompiler final : public BaseCo
     OutOfLineCode* ool =
         addOutOfLineCode(new (alloc_) OutOfLineTruncateCheckF32OrF64ToI64(
             AnyReg(src), dest, flags, bytecodeOffset()));
-    if (!ool) {
+    if (!ool) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     bool isSaturating = flags & TRUNC_SATURATING;
@@ -6881,7 +6881,7 @@ class BaseCompiler final : public BaseCo
 
   void bceCheckLocal(MemoryAccessDesc* access, AccessCheck* check,
                      uint32_t local) {
-    if (local >= sizeof(BCESet) * 8) {
+    if (local >= sizeof(BCESet) * 8) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
@@ -6961,7 +6961,7 @@ class BaseCompiler final : public BaseCo
       // we can use a 32-bit check and avoid extension and wrapping.
       if ((moduleEnv_.maxMemoryLength.isNothing() ||
            moduleEnv_.maxMemoryLength.value() >= 0x100000000) &&
-          ArrayBufferObject::maxBufferByteLength() >= 0x100000000) {
+          ArrayBufferObject::maxBufferByteLength() >= 0x100000000) {MOZ_RELEASE_ASSERT(0);
         // Note, ptr and ptr64 are the same register.
         RegI64 ptr64 = fromI32(ptr);
 
@@ -8295,7 +8295,7 @@ class BaseCompiler final : public BaseCo
     pushRef(value);
 
     // Consumes valueAddr
-    if (!emitPostBarrierCall(valueAddr)) {
+    if (!emitPostBarrierCall(valueAddr)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -8437,7 +8437,7 @@ class BaseCompiler final : public BaseCo
                                                 Lhs lhs, Rhs rhs) {
     if (b->hasBlockResults()) {
       StackHeight resultsBase(0);
-      if (!topBranchParams(b->resultType, &resultsBase)) {
+      if (!topBranchParams(b->resultType, &resultsBase)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (b->stackHeight != resultsBase) {
@@ -9941,7 +9941,7 @@ bool BaseCompiler::sniffConditionalContr
 #endif
 
   // No optimization for pointer compares yet.
-  if (operandType.isReference()) {
+  if (operandType.isReference()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -10192,7 +10192,7 @@ bool BaseCompiler::emitLoop() {
   if (!deadCode_) {
     // Loop entry is a control join, so shuffle the entry parameters into the
     // well-known locations.
-    if (!topBlockParams(params)) {
+    if (!topBlockParams(params)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     masm.nopAlign(CodeAlignment);
@@ -10244,7 +10244,7 @@ bool BaseCompiler::emitIf() {
     // Because params can flow immediately to results in the case of an empty
     // "then" or "else" block, and the result of an if/then is a join in
     // general, we shuffle params eagerly to the result allocations.
-    if (!topBlockParams(params)) {
+    if (!topBlockParams(params)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!emitBranchPerform(&b)) {
@@ -10538,11 +10538,11 @@ bool BaseCompiler::emitBrOnNull() {
   NothingVector unused_values{};
   Nothing unused_condition;
   if (!iter_.readBrOnNull(&relativeDepth, &type, &unused_values,
-                          &unused_condition)) {
-    return false;
-  }
-
-  if (deadCode_) {
+                          &unused_condition)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -10597,7 +10597,7 @@ bool BaseCompiler::emitBrTable() {
   freeIntegerResultRegisters(branchParams);
 
   StackHeight resultsBase(0);
-  if (!topBranchParams(branchParams, &resultsBase)) {
+  if (!topBranchParams(branchParams, &resultsBase)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -10620,7 +10620,7 @@ bool BaseCompiler::emitBrTable() {
   // can, don't emit an intermediate stub.
 
   LabelVector stubs;
-  if (!stubs.reserve(depths.length())) {
+  if (!stubs.reserve(depths.length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -10745,7 +10745,7 @@ bool BaseCompiler::emitCatch() {
 
   // Construct info used for the exception landing pad.
   CatchInfo catchInfo(eventIndex);
-  if (!tryCatch.catchInfos.emplaceBack(catchInfo)) {
+  if (!tryCatch.catchInfos.emplaceBack(catchInfo)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11085,7 +11085,7 @@ bool BaseCompiler::endTryCatch(ResultTyp
   pushRef(exn);
   pushRef(scratch);
 
-  if (!emitInstanceCall(lineOrBytecode, SASigGetLocalExceptionIndex)) {
+  if (!emitInstanceCall(lineOrBytecode, SASigGetLocalExceptionIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11115,7 +11115,7 @@ bool BaseCompiler::endTryCatch(ResultTyp
 
   // If none of the tag checks succeed and there is no catch_all,
   // then we rethrow the exception.
-  if (!hasCatchAll && !throwFrom(exn, lineOrBytecode)) {
+  if (!hasCatchAll && !throwFrom(exn, lineOrBytecode)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11148,7 +11148,7 @@ bool BaseCompiler::endTryUnwind(ResultTy
 
     RegRef exn = popRef();
 
-    if (!throwFrom(exn, lineOrBytecode)) {
+    if (!throwFrom(exn, lineOrBytecode)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     MOZ_ASSERT(stk_.length() == tryUnwind.stackSize);
@@ -11158,7 +11158,7 @@ bool BaseCompiler::endTryUnwind(ResultTy
 
   deadCode_ = tryUnwind.deadOnArrival;
 
-  if (deadCode_) {
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -11199,7 +11199,7 @@ bool BaseCompiler::emitThrow() {
   // Create the new exception object that we will throw.
   pushI32(exnIndex);
   pushI32(exnBytes);
-  if (!emitInstanceCall(lineOrBytecode, SASigExceptionNew)) {
+  if (!emitInstanceCall(lineOrBytecode, SASigExceptionNew)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11444,7 +11444,7 @@ bool BaseCompiler::pushStackResultsForCa
   // This method is the only one in the class that can increase stk_.length() by
   // an unbounded amount, so it's the only one that requires an allocation.
   // (The general case is handled in emitBody.)
-  if (!stk_.reserve(stk_.length() + type.length())) {
+  if (!stk_.reserve(stk_.length() + type.length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11535,7 +11535,7 @@ bool BaseCompiler::emitCall() {
 
   ResultType resultType(ResultType::Vector(funcType.results()));
   StackResultsLoc results;
-  if (!pushStackResultsForCall(resultType, RegPtr(ABINonArgReg0), &results)) {
+  if (!pushStackResultsForCall(resultType, RegPtr(ABINonArgReg0), &results)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11544,7 +11544,7 @@ bool BaseCompiler::emitCall() {
             import ? InterModule::True : InterModule::False);
 
   if (!emitCallArgs(funcType.args(), results, &baselineCall,
-                    CalleeOnStack::False)) {
+                    CalleeOnStack::False)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11596,7 +11596,7 @@ bool BaseCompiler::emitCallIndirect() {
 
   ResultType resultType(ResultType::Vector(funcType.results()));
   StackResultsLoc results;
-  if (!pushStackResultsForCall(resultType, RegPtr(ABINonArgReg0), &results)) {
+  if (!pushStackResultsForCall(resultType, RegPtr(ABINonArgReg0), &results)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11604,7 +11604,7 @@ bool BaseCompiler::emitCallIndirect() {
   beginCall(baselineCall, UseABI::Wasm, InterModule::True);
 
   if (!emitCallArgs(funcType.args(), results, &baselineCall,
-                    CalleeOnStack::True)) {
+                    CalleeOnStack::True)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -11657,7 +11657,7 @@ bool BaseCompiler::emitUnaryMathBuiltinC
       supportsRoundInstruction(roundingMode)) {
     emitRound(roundingMode, operandType);
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   sync();
 
@@ -11671,9 +11671,9 @@ bool BaseCompiler::emitUnaryMathBuiltinC
   beginCall(baselineCall, UseABI::Builtin, InterModule::False);
 
   if (!emitCallArgs(signature, noStackResults, &baselineCall,
-                    CalleeOnStack::False)) {
-    return false;
-  }
+                    CalleeOnStack::False)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
 
   CodeOffset raOffset = builtinCall(callee, baselineCall);
   if (!createStackMap("emitUnaryMathBuiltin[..]", raOffset)) {
@@ -11985,7 +11985,7 @@ bool BaseCompiler::emitTeeLocal() {
 
 bool BaseCompiler::emitGetGlobal() {
   uint32_t id;
-  if (!iter_.readGetGlobal(&id)) {
+  if (!iter_.readGetGlobal(&id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -12756,7 +12756,7 @@ bool BaseCompiler::emitInstanceCall(uint
   }
   CodeOffset raOffset =
       builtinInstanceMethodCall(builtin, instanceArg, baselineCall);
-  if (!createStackMap("emitInstanceCall", raOffset)) {
+  if (!createStackMap("emitInstanceCall", raOffset)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -12857,7 +12857,7 @@ bool BaseCompiler::emitRefIsNull() {
 #ifdef ENABLE_WASM_FUNCTION_REFERENCES
 bool BaseCompiler::emitRefAsNonNull() {
   Nothing nothing;
-  if (!iter_.readRefAsNonNull(&nothing)) {
+  if (!iter_.readRefAsNonNull(&nothing)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -12881,11 +12881,11 @@ bool BaseCompiler::emitAtomicCmpXchg(Val
   Nothing unused{};
 
   if (!iter_.readAtomicCmpXchg(&addr, type, Scalar::byteSize(viewType), &unused,
-                               &unused)) {
-    return false;
-  }
-
-  if (deadCode_) {
+                               &unused)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -12941,11 +12941,11 @@ bool BaseCompiler::emitAtomicCmpXchg(Val
 
 bool BaseCompiler::emitAtomicLoad(ValType type, Scalar::Type viewType) {
   LinearMemoryAddress<Nothing> addr;
-  if (!iter_.readAtomicLoad(&addr, type, Scalar::byteSize(viewType))) {
-    return false;
-  }
-
-  if (deadCode_) {
+  if (!iter_.readAtomicLoad(&addr, type, Scalar::byteSize(viewType))) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -12990,11 +12990,11 @@ bool BaseCompiler::emitAtomicRMW(ValType
   LinearMemoryAddress<Nothing> addr;
   Nothing unused_value;
   if (!iter_.readAtomicRMW(&addr, type, Scalar::byteSize(viewType),
-                           &unused_value)) {
-    return false;
-  }
-
-  if (deadCode_) {
+                           &unused_value)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -13058,11 +13058,11 @@ bool BaseCompiler::emitAtomicStore(ValTy
   LinearMemoryAddress<Nothing> addr;
   Nothing unused_value;
   if (!iter_.readAtomicStore(&addr, type, Scalar::byteSize(viewType),
-                             &unused_value)) {
-    return false;
-  }
-
-  if (deadCode_) {
+                             &unused_value)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -13087,11 +13087,11 @@ bool BaseCompiler::emitAtomicXchg(ValTyp
   LinearMemoryAddress<Nothing> addr;
   Nothing unused_value;
   if (!iter_.readAtomicRMW(&addr, type, Scalar::byteSize(viewType),
-                           &unused_value)) {
-    return false;
-  }
-
-  if (deadCode_) {
+                           &unused_value)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -13155,11 +13155,11 @@ bool BaseCompiler::emitWait(ValType type
 
   Nothing nothing;
   LinearMemoryAddress<Nothing> addr;
-  if (!iter_.readWait(&addr, type, byteSize, &nothing, &nothing)) {
-    return false;
-  }
-
-  if (deadCode_) {
+  if (!iter_.readWait(&addr, type, byteSize, &nothing, &nothing)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -13208,7 +13208,7 @@ bool BaseCompiler::emitWake() {
 
   Nothing nothing;
   LinearMemoryAddress<Nothing> addr;
-  if (!iter_.readWake(&addr, &nothing)) {
+  if (!iter_.readWake(&addr, &nothing)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -13228,7 +13228,7 @@ bool BaseCompiler::emitWake() {
 }
 
 bool BaseCompiler::emitFence() {
-  if (!iter_.readFence()) {
+  if (!iter_.readFence()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (deadCode_) {
@@ -13250,7 +13250,7 @@ bool BaseCompiler::emitMemCopy() {
     return false;
   }
 
-  if (deadCode_) {
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -13314,7 +13314,7 @@ bool BaseCompiler::emitMemCopyInline() {
     MemoryAccessDesc access(Scalar::Int64, 1, offset, bytecodeOffset());
     AccessCheck check;
     check.omitBoundsCheck = omitBoundsCheck;
-    if (!loadCommon(&access, check, ValType::I64)) {
+    if (!loadCommon(&access, check, ValType::I64)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -13331,7 +13331,7 @@ bool BaseCompiler::emitMemCopyInline() {
     MemoryAccessDesc access(Scalar::Uint32, 1, offset, bytecodeOffset());
     AccessCheck check;
     check.omitBoundsCheck = omitBoundsCheck;
-    if (!loadCommon(&access, check, ValType::I32)) {
+    if (!loadCommon(&access, check, ValType::I32)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -13347,7 +13347,7 @@ bool BaseCompiler::emitMemCopyInline() {
     MemoryAccessDesc access(Scalar::Uint16, 1, offset, bytecodeOffset());
     AccessCheck check;
     check.omitBoundsCheck = omitBoundsCheck;
-    if (!loadCommon(&access, check, ValType::I32)) {
+    if (!loadCommon(&access, check, ValType::I32)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -13363,7 +13363,7 @@ bool BaseCompiler::emitMemCopyInline() {
     MemoryAccessDesc access(Scalar::Uint8, 1, offset, bytecodeOffset());
     AccessCheck check;
     check.omitBoundsCheck = omitBoundsCheck;
-    if (!loadCommon(&access, check, ValType::I32)) {
+    if (!loadCommon(&access, check, ValType::I32)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -13385,7 +13385,7 @@ bool BaseCompiler::emitMemCopyInline() {
 
     MemoryAccessDesc access(Scalar::Uint8, 1, offset, bytecodeOffset());
     AccessCheck check;
-    if (!storeCommon(&access, check, ValType::I32)) {
+    if (!storeCommon(&access, check, ValType::I32)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -13404,7 +13404,7 @@ bool BaseCompiler::emitMemCopyInline() {
     MemoryAccessDesc access(Scalar::Uint16, 1, offset, bytecodeOffset());
     AccessCheck check;
     check.omitBoundsCheck = omitBoundsCheck;
-    if (!storeCommon(&access, check, ValType::I32)) {
+    if (!storeCommon(&access, check, ValType::I32)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -13423,7 +13423,7 @@ bool BaseCompiler::emitMemCopyInline() {
     MemoryAccessDesc access(Scalar::Uint32, 1, offset, bytecodeOffset());
     AccessCheck check;
     check.omitBoundsCheck = omitBoundsCheck;
-    if (!storeCommon(&access, check, ValType::I32)) {
+    if (!storeCommon(&access, check, ValType::I32)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -13582,7 +13582,7 @@ bool BaseCompiler::emitMemFillInline() {
 
     MemoryAccessDesc access(Scalar::Uint8, 1, offset, bytecodeOffset());
     AccessCheck check;
-    if (!storeCommon(&access, check, ValType::I32)) {
+    if (!storeCommon(&access, check, ValType::I32)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -13600,7 +13600,7 @@ bool BaseCompiler::emitMemFillInline() {
     MemoryAccessDesc access(Scalar::Uint16, 1, offset, bytecodeOffset());
     AccessCheck check;
     check.omitBoundsCheck = omitBoundsCheck;
-    if (!storeCommon(&access, check, ValType::I32)) {
+    if (!storeCommon(&access, check, ValType::I32)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -13618,7 +13618,7 @@ bool BaseCompiler::emitMemFillInline() {
     MemoryAccessDesc access(Scalar::Uint32, 1, offset, bytecodeOffset());
     AccessCheck check;
     check.omitBoundsCheck = omitBoundsCheck;
-    if (!storeCommon(&access, check, ValType::I32)) {
+    if (!storeCommon(&access, check, ValType::I32)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -13667,7 +13667,7 @@ bool BaseCompiler::emitMemOrTableInit(bo
   pushI32(int32_t(segIndex));
   if (isMem) {
     if (!emitInstanceCall(lineOrBytecode, SASigMemInit32,
-                          /*pushReturnedValue=*/false)) {
+                          /*pushReturnedValue=*/false)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -13965,7 +13965,7 @@ bool BaseCompiler::emitGcArraySet(RegRef
   bool shiftedIndex = false;
   if (IsShiftInScaleRange(shift)) {
     scale = ShiftToScale(shift);
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     masm.lshiftPtr(Imm32(shift), index);
     scale = TimesOne;
     shiftedIndex = true;
@@ -14015,7 +14015,7 @@ bool BaseCompiler::emitStructNewWithRtt(
     return false;
   }
 
-  if (deadCode_) {
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -14025,7 +14025,7 @@ bool BaseCompiler::emitStructNewWithRtt(
   // guaranteed to be at the top of the stack by validation.
   //
   // Traps on OOM.
-  if (!emitInstanceCall(lineOrBytecode, SASigStructNew)) {
+  if (!emitInstanceCall(lineOrBytecode, SASigStructNew)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -14113,7 +14113,7 @@ bool BaseCompiler::emitStructGet(FieldEx
     return false;
   }
 
-  if (deadCode_) {
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -14165,7 +14165,7 @@ bool BaseCompiler::emitStructSet() {
     return false;
   }
 
-  if (deadCode_) {
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -14228,11 +14228,11 @@ bool BaseCompiler::emitArrayNewWithRtt()
 
   uint32_t typeIndex;
   Nothing nothing;
-  if (!iter_.readArrayNewWithRtt(&typeIndex, &nothing, &nothing, &nothing)) {
-    return false;
-  }
-
-  if (deadCode_) {
+  if (!iter_.readArrayNewWithRtt(&typeIndex, &nothing, &nothing, &nothing)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -14242,7 +14242,7 @@ bool BaseCompiler::emitArrayNewWithRtt()
   // length that are guaranteed to be at the top of the stack by validation.
   //
   // Traps on OOM.
-  if (!emitInstanceCall(lineOrBytecode, SASigArrayNew)) {
+  if (!emitInstanceCall(lineOrBytecode, SASigArrayNew)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -14300,7 +14300,7 @@ bool BaseCompiler::emitArrayNewDefaultWi
 
   uint32_t typeIndex;
   Nothing nothing;
-  if (!iter_.readArrayNewDefaultWithRtt(&typeIndex, &nothing, &nothing)) {
+  if (!iter_.readArrayNewDefaultWithRtt(&typeIndex, &nothing, &nothing)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -14322,7 +14322,7 @@ bool BaseCompiler::emitArrayGet(FieldExt
     return false;
   }
 
-  if (deadCode_) {
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -14370,7 +14370,7 @@ bool BaseCompiler::emitArraySet() {
     return false;
   }
 
-  if (deadCode_) {
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -14430,7 +14430,7 @@ bool BaseCompiler::emitArraySet() {
 bool BaseCompiler::emitArrayLen() {
   uint32_t typeIndex;
   Nothing nothing;
-  if (!iter_.readArrayLen(&typeIndex, &nothing)) {
+  if (!iter_.readArrayLen(&typeIndex, &nothing)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -14456,7 +14456,7 @@ bool BaseCompiler::emitArrayLen() {
 
 bool BaseCompiler::emitRttCanon() {
   ValType rttType;
-  if (!iter_.readRttCanon(&rttType)) {
+  if (!iter_.readRttCanon(&rttType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -14472,15 +14472,15 @@ bool BaseCompiler::emitRttCanon() {
   return true;
 }
 
-bool BaseCompiler::emitRttSub() {
+bool BaseCompiler::emitRttSub() {MOZ_RELEASE_ASSERT(0);
   uint32_t lineOrBytecode = readCallSiteLineOrBytecode();
 
   Nothing nothing;
-  if (!iter_.readRttSub(&nothing)) {
-    return false;
-  }
-
-  if (deadCode_) {
+  if (!iter_.readRttSub(&nothing)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -14498,7 +14498,7 @@ bool BaseCompiler::emitRefTest() {
   Nothing nothing;
   uint32_t rttTypeIndex;
   uint32_t rttDepth;
-  if (!iter_.readRefTest(&nothing, &rttTypeIndex, &rttDepth, &nothing)) {
+  if (!iter_.readRefTest(&nothing, &rttTypeIndex, &rttDepth, &nothing)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -14517,11 +14517,11 @@ bool BaseCompiler::emitRefCast() {
   Nothing nothing;
   uint32_t rttTypeIndex;
   uint32_t rttDepth;
-  if (!iter_.readRefCast(&nothing, &rttTypeIndex, &rttDepth, &nothing)) {
-    return false;
-  }
-
-  if (deadCode_) {
+  if (!iter_.readRefCast(&nothing, &rttTypeIndex, &rttDepth, &nothing)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -14566,7 +14566,7 @@ bool BaseCompiler::emitBrOnCast() {
     return false;
   }
 
-  if (deadCode_) {
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -14584,7 +14584,7 @@ bool BaseCompiler::emitBrOnCast() {
   pushRef(rttPtr);
 
   // 2. ref.test : [ref, rtt] -> [i32]
-  if (!emitInstanceCall(lineOrBytecode, SASigRefTest)) {
+  if (!emitInstanceCall(lineOrBytecode, SASigRefTest)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -15621,7 +15621,7 @@ bool BaseCompiler::emitLoadSplat(Scalar:
     return false;
   }
 
-  if (deadCode_) {
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -15664,7 +15664,7 @@ bool BaseCompiler::emitLoadSplat(Scalar:
 bool BaseCompiler::emitLoadZero(Scalar::Type viewType) {
   // LoadZero has the structure of LoadSplat
   LinearMemoryAddress<Nothing> addr;
-  if (!iter_.readLoadSplat(Scalar::byteSize(viewType), &addr)) {
+  if (!iter_.readLoadSplat(Scalar::byteSize(viewType), &addr)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -15683,13 +15683,13 @@ bool BaseCompiler::emitLoadExtend(Scalar
     return false;
   }
 
-  if (deadCode_) {
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   MemoryAccessDesc access(Scalar::Int64, addr.align, addr.offset,
                           bytecodeOffset());
-  if (!loadCommon(&access, AccessCheck(), ValType::I64)) {
+  if (!loadCommon(&access, AccessCheck(), ValType::I64)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -15728,11 +15728,11 @@ bool BaseCompiler::emitLoadLane(uint32_t
   Nothing nothing;
   LinearMemoryAddress<Nothing> addr;
   uint32_t laneIndex;
-  if (!iter_.readLoadLane(laneSize, &addr, &laneIndex, &nothing)) {
-    return false;
-  }
-
-  if (deadCode_) {
+  if (!iter_.readLoadLane(laneSize, &addr, &laneIndex, &nothing)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -15762,7 +15762,7 @@ bool BaseCompiler::emitLoadLane(uint32_t
   }
 
   MemoryAccessDesc access(viewType, addr.align, addr.offset, bytecodeOffset());
-  if (!loadCommon(&access, AccessCheck(), type)) {
+  if (!loadCommon(&access, AccessCheck(), type)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -15796,11 +15796,11 @@ bool BaseCompiler::emitStoreLane(uint32_
   Nothing nothing;
   LinearMemoryAddress<Nothing> addr;
   uint32_t laneIndex;
-  if (!iter_.readStoreLane(laneSize, &addr, &laneIndex, &nothing)) {
-    return false;
-  }
-
-  if (deadCode_) {
+  if (!iter_.readStoreLane(laneSize, &addr, &laneIndex, &nothing)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -15935,7 +15935,7 @@ bool BaseCompiler::emitVectorShiftRightI
     return false;
   }
 
-  if (deadCode_) {
+  if (deadCode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -15953,7 +15953,7 @@ bool BaseCompiler::emitVectorShiftRightI
   RegI32 count;
   if (Assembler::HasBMI2()) {
     count = popI32();
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     needI32(specific_.ecx);
     count = popI32ToSpecific(specific_.ecx);
   }
@@ -15964,14 +15964,14 @@ bool BaseCompiler::emitVectorShiftRightI
   RegI64 tmp = needI64();
   masm.and32(Imm32(63), count);
   masm.extractLaneInt64x2(0, lhsDest, tmp);
-  if (isUnsigned) {
+  if (isUnsigned) {MOZ_RELEASE_ASSERT(0);
     masm.rshift64(count, tmp);
   } else {
     masm.rshift64Arithmetic(count, tmp);
   }
   masm.replaceLaneInt64x2(0, tmp, lhsDest);
   masm.extractLaneInt64x2(1, lhsDest, tmp);
-  if (isUnsigned) {
+  if (isUnsigned) {MOZ_RELEASE_ASSERT(0);
     masm.rshift64(count, tmp);
   } else {
     masm.rshift64Arithmetic(count, tmp);
@@ -16026,7 +16026,7 @@ bool BaseCompiler::emitVectorMulI64x2() 
 bool BaseCompiler::emitBody() {
   MOZ_ASSERT(stackMapGenerator_.framePushedAtEntryToBody.isSome());
 
-  if (!iter_.readFunctionStart(func_.index)) {
+  if (!iter_.readFunctionStart(func_.index)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -16142,7 +16142,7 @@ bool BaseCompiler::emitBody() {
       sync();
 
       insertBreakablePoint(CallSiteDesc::Breakpoint);
-      if (!createStackMap("debug: per insn")) {
+      if (!createStackMap("debug: per insn")) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -17702,7 +17702,7 @@ bool BaseCompiler::emitBody() {
 }
 
 bool BaseCompiler::emitFunction() {
-  if (!beginFunction()) {
+  if (!beginFunction()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -17767,7 +17767,7 @@ BaseCompiler::~BaseCompiler() {
 bool BaseCompiler::init() {
   ra.init(this);
 
-  if (!SigD_.append(ValType::F64)) {
+  if (!SigD_.append(ValType::F64)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!SigF_.append(ValType::F32)) {
@@ -17833,7 +17833,7 @@ bool js::wasm::BaselineCompileFunctions(
 
   // Swap in already-allocated empty vectors to avoid malloc/free.
   MOZ_ASSERT(code->empty());
-  if (!code->swap(masm)) {
+  if (!code->swap(masm)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -17846,7 +17846,7 @@ bool js::wasm::BaselineCompileFunctions(
   // avoid malloc/free.  Presize it to 128 elements in the hope of avoiding
   // reallocation later.
   StkVector stk;
-  if (!stk.reserve(128)) {
+  if (!stk.reserve(128)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -17856,7 +17856,7 @@ bool js::wasm::BaselineCompileFunctions(
     // Build the local types vector.
 
     ValTypeVector locals;
-    if (!locals.appendAll(moduleEnv.funcs[func.index].type->args())) {
+    if (!locals.appendAll(moduleEnv.funcs[func.index].type->args())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!DecodeLocalEntries(d, moduleEnv.types, moduleEnv.features, &locals)) {
@@ -17868,14 +17868,14 @@ bool js::wasm::BaselineCompileFunctions(
     BaseCompiler f(moduleEnv, compilerEnv, func, locals, trapExitLayout,
                    trapExitLayoutNumWords, d, stk, &alloc, &masm,
                    &code->stackMaps);
-    if (!f.init()) {
+    if (!f.init()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!f.emitFunction()) {
       return false;
     }
     if (!code->codeRanges.emplaceBack(func.index, func.lineOrBytecode,
-                                      f.finish())) {
+                                      f.finish())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
diff --git a/js/src/wasm/WasmBuiltins.cpp b/js/src/wasm/WasmBuiltins.cpp
--- a/js/src/wasm/WasmBuiltins.cpp
+++ b/js/src/wasm/WasmBuiltins.cpp
@@ -350,7 +350,7 @@ static bool WasmHandleDebugTrap() {
   DebugFrame* debugFrame = DebugFrame::from(fp);
 
   if (site->kind() == CallSite::EnterFrame) {
-    if (!instance->debug().enterFrameTrapsEnabled()) {
+    if (!instance->debug().enterFrameTrapsEnabled()) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
     debugFrame->setIsDebuggee();
@@ -369,7 +369,7 @@ static bool WasmHandleDebugTrap() {
     return true;
   }
   if (site->kind() == CallSite::LeaveFrame) {
-    if (!debugFrame->updateReturnJSValue(cx)) {
+    if (!debugFrame->updateReturnJSValue(cx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     bool ok = DebugAPI::onLeaveFrame(cx, debugFrame, nullptr, true);
@@ -381,12 +381,12 @@ static bool WasmHandleDebugTrap() {
   MOZ_ASSERT(debug.hasBreakpointTrapAtOffset(site->lineOrBytecode()));
   if (debug.stepModeEnabled(debugFrame->funcIndex())) {
     if (!DebugAPI::onSingleStep(cx)) {
-      if (cx->isPropagatingForcedReturn()) {
+      if (cx->isPropagatingForcedReturn()) {MOZ_RELEASE_ASSERT(0);
         cx->clearPropagatingForcedReturn();
         // TODO properly handle forced return.
         JS_ReportErrorASCII(cx,
                             "Unexpected resumption value from onSingleStep");
-      }
+      }MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -502,7 +502,7 @@ bool wasm::HandleThrow(JSContext* cx, Wa
         if (!exn.isObject() ||
             !exn.toObject().is<WasmRuntimeExceptionObject>()) {
           RootedObject obj(cx, WasmJSExceptionObject::create(cx, &exn));
-          if (!obj) {
+          if (!obj) {MOZ_RELEASE_ASSERT(0);
             MOZ_ASSERT(cx->isThrowingOutOfMemory());
             continue;
           }
@@ -539,14 +539,14 @@ bool wasm::HandleThrow(JSContext* cx, Wa
     // no onExceptionUnwind handlers must be fired.
     if (cx->isExceptionPending()) {
       if (!DebugAPI::onExceptionUnwind(cx, frame)) {
-        if (cx->isPropagatingForcedReturn()) {
+        if (cx->isPropagatingForcedReturn()) {MOZ_RELEASE_ASSERT(0);
           cx->clearPropagatingForcedReturn();
           // Unexpected trap return -- raising error since throw recovery
           // is not yet implemented in the wasm baseline.
           // TODO properly handle forced return and resume wasm execution.
           JS_ReportErrorASCII(
               cx, "Unexpected resumption value from onExceptionUnwind");
-        }
+        }MOZ_RELEASE_ASSERT(0);
       }
     }
 
@@ -841,7 +841,7 @@ static int64_t UModI64(uint32_t x_hi, ui
   return x % y;
 }
 
-static int64_t TruncateDoubleToInt64(double input) {
+static int64_t TruncateDoubleToInt64(double input) {MOZ_RELEASE_ASSERT(0);
   // Note: INT64_MAX is not representable in double. It is actually
   // INT64_MAX + 1.  Therefore also sending the failure value.
   if (input >= double(INT64_MAX) || input < double(INT64_MIN) || IsNaN(input)) {
@@ -850,7 +850,7 @@ static int64_t TruncateDoubleToInt64(dou
   return int64_t(input);
 }
 
-static uint64_t TruncateDoubleToUint64(double input) {
+static uint64_t TruncateDoubleToUint64(double input) {MOZ_RELEASE_ASSERT(0);
   // Note: UINT64_MAX is not representable in double. It is actually
   // UINT64_MAX + 1.  Therefore also sending the failure value.
   if (input >= double(UINT64_MAX) || input <= -1.0 || IsNaN(input)) {
@@ -859,13 +859,13 @@ static uint64_t TruncateDoubleToUint64(d
   return uint64_t(input);
 }
 
-static int64_t SaturatingTruncateDoubleToInt64(double input) {
+static int64_t SaturatingTruncateDoubleToInt64(double input) {MOZ_RELEASE_ASSERT(0);
   // Handle in-range values (except INT64_MIN).
-  if (fabs(input) < -double(INT64_MIN)) {
+  if (fabs(input) < -double(INT64_MIN)) {MOZ_RELEASE_ASSERT(0);
     return int64_t(input);
   }
   // Handle NaN.
-  if (IsNaN(input)) {
+  if (IsNaN(input)) {MOZ_RELEASE_ASSERT(0);
     return 0;
   }
   // Handle positive overflow.
@@ -876,9 +876,9 @@ static int64_t SaturatingTruncateDoubleT
   return INT64_MIN;
 }
 
-static uint64_t SaturatingTruncateDoubleToUint64(double input) {
+static uint64_t SaturatingTruncateDoubleToUint64(double input) {MOZ_RELEASE_ASSERT(0);
   // Handle positive overflow.
-  if (input >= -double(INT64_MIN) * 2.0) {
+  if (input >= -double(INT64_MIN) * 2.0) {MOZ_RELEASE_ASSERT(0);
     return UINT64_MAX;
   }
   // Handle in-range values.
@@ -1532,7 +1532,7 @@ bool wasm::EnsureBuiltinThunksInitialize
   }
 
   auto thunks = MakeUnique<BuiltinThunks>();
-  if (!thunks) {
+  if (!thunks) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1555,16 +1555,16 @@ bool wasm::EnsureBuiltinThunksInitialize
     ExitReason exitReason(sym);
 
     CallableOffsets offsets;
-    if (!GenerateBuiltinThunk(masm, abiType, exitReason, funcPtr, &offsets)) {
+    if (!GenerateBuiltinThunk(masm, abiType, exitReason, funcPtr, &offsets)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!thunks->codeRanges.emplaceBack(CodeRange::BuiltinThunk, offsets)) {
+    if (!thunks->codeRanges.emplaceBack(CodeRange::BuiltinThunk, offsets)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   TypedNativeToFuncPtrMap typedNatives;
-  if (!PopulateTypedNatives(&typedNatives)) {
+  if (!PopulateTypedNatives(&typedNatives)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1573,7 +1573,7 @@ bool wasm::EnsureBuiltinThunksInitialize
     TypedNative typedNative = r.front().key();
 
     uint32_t codeRangeIndex = thunks->codeRanges.length();
-    if (!thunks->typedNativeToCodeRange.putNew(typedNative, codeRangeIndex)) {
+    if (!thunks->typedNativeToCodeRange.putNew(typedNative, codeRangeIndex)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1583,10 +1583,10 @@ bool wasm::EnsureBuiltinThunksInitialize
     ExitReason exitReason = ExitReason::Fixed::BuiltinNative;
 
     CallableOffsets offsets;
-    if (!GenerateBuiltinThunk(masm, abiType, exitReason, funcPtr, &offsets)) {
+    if (!GenerateBuiltinThunk(masm, abiType, exitReason, funcPtr, &offsets)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!thunks->codeRanges.emplaceBack(CodeRange::BuiltinThunk, offsets)) {
+    if (!thunks->codeRanges.emplaceBack(CodeRange::BuiltinThunk, offsets)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1606,7 +1606,7 @@ bool wasm::EnsureBuiltinThunksInitialize
 
   Offsets provisionalLazyJitEntryOffsets;
   if (!GenerateProvisionalLazyJitEntryStub(masm,
-                                           &provisionalLazyJitEntryOffsets)) {
+                                           &provisionalLazyJitEntryOffsets)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   thunks->provisionalLazyJitEntryOffset = provisionalLazyJitEntryOffsets.begin;
@@ -1616,7 +1616,7 @@ bool wasm::EnsureBuiltinThunksInitialize
 #endif
 
   masm.finish();
-  if (masm.oom()) {
+  if (masm.oom()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1625,7 +1625,7 @@ bool wasm::EnsureBuiltinThunksInitialize
   thunks->codeSize = allocSize;
   thunks->codeBase = (uint8_t*)AllocateExecutableMemory(
       allocSize, ProtectionSetting::Writable, MemCheckKind::MakeUndefined);
-  if (!thunks->codeBase) {
+  if (!thunks->codeBase) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/wasm/WasmCode.cpp b/js/src/wasm/WasmCode.cpp
--- a/js/src/wasm/WasmCode.cpp
+++ b/js/src/wasm/WasmCode.cpp
@@ -74,7 +74,7 @@ const uint8_t* LinkData::SymbolicLinkArr
 }
 
 size_t LinkData::SymbolicLinkArray::sizeOfExcludingThis(
-    MallocSizeOf mallocSizeOf) const {
+    MallocSizeOf mallocSizeOf) const {MOZ_RELEASE_ASSERT(0);
   size_t size = 0;
   for (const Uint32Vector& offsets : *this) {
     size += offsets.sizeOfExcludingThis(mallocSizeOf);
@@ -118,7 +118,7 @@ static uint32_t RoundupCodeLength(uint32
 
 /* static */
 UniqueCodeBytes CodeSegment::AllocateCodeBytes(uint32_t codeLength) {
-  if (codeLength > MaxCodeBytesPerProcess) {
+  if (codeLength > MaxCodeBytesPerProcess) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -133,12 +133,12 @@ UniqueCodeBytes CodeSegment::AllocateCod
   // to purge all memory (which, in gecko, does a purging GC/CC/GC), do that
   // then retry the allocation.
   if (!p) {
-    if (OnLargeAllocationFailure) {
+    if (OnLargeAllocationFailure) {MOZ_RELEASE_ASSERT(0);
       OnLargeAllocationFailure();
       p = AllocateExecutableMemory(roundedCodeLength,
                                    ProtectionSetting::Writable,
                                    MemCheckKind::MakeUndefined);
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   if (!p) {
@@ -203,7 +203,7 @@ static bool StaticallyLink(const ModuleS
     Assembler::Bind(ms.base(), label);
   }
 
-  if (!EnsureBuiltinThunksInitialized()) {
+  if (!EnsureBuiltinThunksInitialized()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -272,16 +272,16 @@ static void SendCodeRangesToProfiler(con
     return;
   }
 
-  for (const CodeRange& codeRange : codeRanges) {
-    if (!codeRange.hasFuncIndex()) {
+  for (const CodeRange& codeRange : codeRanges) {MOZ_RELEASE_ASSERT(0);
+    if (!codeRange.hasFuncIndex()) {MOZ_RELEASE_ASSERT(0);
       continue;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     uintptr_t start = uintptr_t(ms.base() + codeRange.begin());
     uintptr_t size = codeRange.end() - codeRange.begin();
 
     UTF8Bytes name;
-    if (!metadata.getFuncNameStandalone(codeRange.funcIndex(), &name)) {
+    if (!metadata.getFuncNameStandalone(codeRange.funcIndex(), &name)) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
@@ -324,10 +324,10 @@ static void SendCodeRangesToProfiler(con
     }
 #endif
 #ifdef MOZ_VTUNE
-    if (!vtune::IsProfilingActive()) {
+    if (!vtune::IsProfilingActive()) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
-    if (!codeRange.isFunction()) {
+    if (!codeRange.isFunction()) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
     if (!name.append('\0')) {
@@ -381,7 +381,7 @@ bool ModuleSegment::initialize(IsTier2 i
                                const LinkData& linkData,
                                const Metadata& metadata,
                                const MetadataTier& metadataTier) {
-  if (!StaticallyLink(*this, linkData)) {
+  if (!StaticallyLink(*this, linkData)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -429,17 +429,17 @@ uint8_t* ModuleSegment::serialize(uint8_
     UniqueModuleSegment* segment) {
   uint32_t length;
   cursor = ReadScalar<uint32_t>(cursor, &length);
-  if (!cursor) {
+  if (!cursor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   UniqueCodeBytes bytes = AllocateCodeBytes(length);
-  if (!bytes) {
+  if (!bytes) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   cursor = ReadBytes(cursor, bytes.get(), length);
-  if (!cursor) {
+  if (!cursor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -517,7 +517,7 @@ const uint8_t* CacheableChars::deseriali
 
   if (lengthWithNullChar) {
     reset(js_pod_malloc<char>(lengthWithNullChar));
-    if (!get()) {
+    if (!get()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -587,7 +587,7 @@ uint8_t* MetadataTier::serialize(uint8_t
 UniqueLazyStubSegment LazyStubSegment::create(const CodeTier& codeTier,
                                               size_t length) {
   UniqueCodeBytes codeBytes = AllocateCodeBytes(length);
-  if (!codeBytes) {
+  if (!codeBytes) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -618,7 +618,7 @@ bool LazyStubSegment::addStubs(size_t co
 
   *indexFirstInsertedCodeRange = codeRanges_.length();
 
-  if (!codeRanges_.reserve(codeRanges_.length() + 2 * codeRanges.length())) {
+  if (!codeRanges_.reserve(codeRanges_.length() + 2 * codeRanges.length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -633,7 +633,7 @@ bool LazyStubSegment::addStubs(size_t co
     codeRanges_.back().offsetBy(offsetInSegment);
     i++;
 
-    if (funcExports[funcExportIndex].funcType().hasUnexposableArgOrRet()) {
+    if (funcExports[funcExportIndex].funcType().hasUnexposableArgOrRet()) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
     if (funcExports[funcExportIndex]
@@ -706,7 +706,7 @@ bool LazyStubTier::createMany(const Uint
     Maybe<ImmPtr> callee;
     callee.emplace(calleePtr, ImmPtr::NoCheckToken());
     if (!GenerateEntryStubs(masm, funcExportIndex, fe, callee,
-                            /* asmjs */ false, &codeRanges)) {
+                            /* asmjs */ false, &codeRanges)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -722,7 +722,7 @@ bool LazyStubTier::createMany(const Uint
   MOZ_ASSERT(masm.tryNotes().empty());
 #endif
 
-  if (masm.oom()) {
+  if (masm.oom()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -733,11 +733,11 @@ bool LazyStubTier::createMany(const Uint
     size_t newSegmentSize = std::max(codeLength, ExecutableCodePageSize);
     UniqueLazyStubSegment newSegment =
         LazyStubSegment::create(codeTier, newSegmentSize);
-    if (!newSegment) {
+    if (!newSegment) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     lastStubSegmentIndex_ = stubSegments_.length();
-    if (!stubSegments_.emplaceBack(std::move(newSegment))) {
+    if (!stubSegments_.emplaceBack(std::move(newSegment))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -748,7 +748,7 @@ bool LazyStubTier::createMany(const Uint
   size_t interpRangeIndex;
   uint8_t* codePtr = nullptr;
   if (!segment->addStubs(codeLength, funcExportIndices, funcExports, codeRanges,
-                         &codePtr, &interpRangeIndex)) {
+                         &codePtr, &interpRangeIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -756,7 +756,7 @@ bool LazyStubTier::createMany(const Uint
   PatchDebugSymbolicAccesses(codePtr, masm);
   memset(codePtr + masm.bytesNeeded(), 0, codeLength - masm.bytesNeeded());
 
-  for (const CodeLabel& label : masm.codeLabels()) {
+  for (const CodeLabel& label : masm.codeLabels()) {MOZ_RELEASE_ASSERT(0);
     Assembler::Bind(codePtr, label);
   }
 
@@ -766,12 +766,12 @@ bool LazyStubTier::createMany(const Uint
                                         ? FlushICacheSpec::AllThreads
                                         : FlushICacheSpec::LocalThreadOnly;
   if (!ExecutableAllocator::makeExecutableAndFlushICache(flushIcacheSpec,
-                                                         codePtr, codeLength)) {
+                                                         codePtr, codeLength)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Create lazy function exports for funcIndex -> entry lookup.
-  if (!exports_.reserve(exports_.length() + funcExportIndices.length())) {
+  if (!exports_.reserve(exports_.length() + funcExportIndices.length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -806,7 +806,7 @@ bool LazyStubTier::createMany(const Uint
 bool LazyStubTier::createOne(uint32_t funcExportIndex,
                              const CodeTier& codeTier) {
   Uint32Vector funcExportIndexes;
-  if (!funcExportIndexes.append(funcExportIndex)) {
+  if (!funcExportIndexes.append(funcExportIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -817,7 +817,7 @@ bool LazyStubTier::createOne(uint32_t fu
 
   size_t stubSegmentIndex;
   if (!createMany(funcExportIndexes, codeTier, flushAllThreadIcaches,
-                  &stubSegmentIndex)) {
+                  &stubSegmentIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -902,7 +902,7 @@ void* LazyStubTier::lookupInterpEntry(ui
 }
 
 void LazyStubTier::addSizeOfMisc(MallocSizeOf mallocSizeOf, size_t* code,
-                                 size_t* data) const {
+                                 size_t* data) const {MOZ_RELEASE_ASSERT(0);
   *data += sizeof(*this);
   *data += exports_.sizeOfExcludingThis(mallocSizeOf);
   for (const UniqueLazyStubSegment& stub : stubSegments_) {
@@ -911,38 +911,38 @@ void LazyStubTier::addSizeOfMisc(MallocS
 }
 
 bool MetadataTier::clone(const MetadataTier& src) {
-  if (!funcToCodeRange.appendAll(src.funcToCodeRange)) {
+  if (!funcToCodeRange.appendAll(src.funcToCodeRange)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!codeRanges.appendAll(src.codeRanges)) {
+  if (!codeRanges.appendAll(src.codeRanges)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!callSites.appendAll(src.callSites)) {
+  if (!callSites.appendAll(src.callSites)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!debugTrapFarJumpOffsets.appendAll(src.debugTrapFarJumpOffsets)) {
+  if (!debugTrapFarJumpOffsets.appendAll(src.debugTrapFarJumpOffsets)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 #ifdef ENABLE_WASM_EXCEPTIONS
-  if (!tryNotes.appendAll(src.tryNotes)) {
+  if (!tryNotes.appendAll(src.tryNotes)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 #endif
 
   for (Trap trap : MakeEnumeratedRange(Trap::Limit)) {
-    if (!trapSites[trap].appendAll(src.trapSites[trap])) {
+    if (!trapSites[trap].appendAll(src.trapSites[trap])) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!funcImports.resize(src.funcImports.length())) {
+  if (!funcImports.resize(src.funcImports.length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (size_t i = 0; i < src.funcImports.length(); i++) {
     funcImports[i].clone(src.funcImports[i]);
   }
 
-  if (!funcExports.resize(src.funcExports.length())) {
+  if (!funcExports.resize(src.funcExports.length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (size_t i = 0; i < src.funcExports.length(); i++) {
@@ -1022,7 +1022,7 @@ FuncExport& MetadataTier::lookupFuncExpo
     uint32_t funcIndex, size_t* funcExportIndex /* = nullptr */) {
   size_t match;
   if (!BinarySearch(ProjectFuncIndex(funcExports), 0, funcExports.length(),
-                    funcIndex, &match)) {
+                    funcIndex, &match)) {MOZ_RELEASE_ASSERT(0);
     MOZ_CRASH("missing function export");
   }
   if (funcExportIndex) {
@@ -1062,10 +1062,10 @@ static bool AppendFunctionIndexName(uint
 bool Metadata::getFuncName(NameContext ctx, uint32_t funcIndex,
                            UTF8Bytes* name) const {
   if (moduleName && moduleName->length != 0) {
-    if (!AppendName(namePayload->bytes, *moduleName, name)) {
+    if (!AppendName(namePayload->bytes, *moduleName, name)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!name->append('.')) {
+    if (!name->append('.')) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1111,17 +1111,17 @@ uint8_t* CodeTier::serialize(uint8_t* cu
                                                   const LinkData& linkData,
                                                   UniqueCodeTier* codeTier) {
   auto metadata = js::MakeUnique<MetadataTier>(Tier::Serialized);
-  if (!metadata) {
+  if (!metadata) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   cursor = metadata->deserialize(cursor);
-  if (!cursor) {
+  if (!cursor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   UniqueModuleSegment segment;
   cursor = ModuleSegment::deserialize(cursor, linkData, &segment);
-  if (!cursor) {
+  if (!cursor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1180,7 +1180,7 @@ bool JumpTables::init(CompileMode mode, 
 
   if (mode_ == CompileMode::Tier1) {
     tiering_ = TablePointer(js_pod_calloc<void*>(numFuncs));
-    if (!tiering_) {
+    if (!tiering_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1190,7 +1190,7 @@ bool JumpTables::init(CompileMode mode, 
   // because of a null deref when trying to call the jit entry of an
   // unexported function).
   jit_ = TablePointer(js_pod_calloc<void*>(numFuncs));
-  if (!jit_) {
+  if (!jit_) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1298,8 +1298,8 @@ const CodeTier& Code::codeTier(Tier tier
   MOZ_CRASH();
 }
 
-bool Code::containsCodePC(const void* pc) const {
-  for (Tier t : tiers()) {
+bool Code::containsCodePC(const void* pc) const {MOZ_RELEASE_ASSERT(0);
+  for (Tier t : tiers()) {MOZ_RELEASE_ASSERT(0);
     const ModuleSegment& ms = segment(t);
     if (ms.containsCodePC(pc)) {
       return true;
@@ -1427,30 +1427,30 @@ void Code::ensureProfilingLabels(bool pr
     MOZ_ASSERT(bytecodeStr);
 
     UTF8Bytes name;
-    if (!metadata().getFuncNameStandalone(codeRange.funcIndex(), &name)) {
+    if (!metadata().getFuncNameStandalone(codeRange.funcIndex(), &name)) {MOZ_RELEASE_ASSERT(0);
       return;
     }
-    if (!name.append(" (", 2)) {
+    if (!name.append(" (", 2)) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
     if (const char* filename = metadata().filename.get()) {
-      if (!name.append(filename, strlen(filename))) {
+      if (!name.append(filename, strlen(filename))) {MOZ_RELEASE_ASSERT(0);
         return;
       }
     } else {
-      if (!name.append('?')) {
+      if (!name.append('?')) {MOZ_RELEASE_ASSERT(0);
         return;
       }
     }
 
     if (!name.append(':') || !name.append(bytecodeStr, strlen(bytecodeStr)) ||
-        !name.append(")\0", 2)) {
+        !name.append(")\0", 2)) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
     UniqueChars label(name.extractOrCopyRawBuffer());
-    if (!label) {
+    if (!label) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
@@ -1477,11 +1477,11 @@ const char* Code::profilingLabel(uint32_
 void Code::addSizeOfMiscIfNotSeen(MallocSizeOf mallocSizeOf,
                                   Metadata::SeenSet* seenMetadata,
                                   Code::SeenSet* seenCode, size_t* code,
-                                  size_t* data) const {
+                                  size_t* data) const {MOZ_RELEASE_ASSERT(0);
   auto p = seenCode->lookupForAdd(this);
-  if (p) {
+  if (p) {MOZ_RELEASE_ASSERT(0);
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   bool ok = seenCode->add(p, this);
   (void)ok;  // oh well
 
@@ -1513,19 +1513,19 @@ uint8_t* Code::serialize(uint8_t* cursor
                                               Metadata& metadata,
                                               SharedCode* out) {
   cursor = metadata.deserialize(cursor);
-  if (!cursor) {
+  if (!cursor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   UniqueCodeTier codeTier;
   cursor = CodeTier::deserialize(cursor, linkData, &codeTier);
-  if (!cursor) {
+  if (!cursor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   JumpTables jumpTables;
   if (!jumpTables.init(CompileMode::Once, codeTier->segment(),
-                       codeTier->metadata().codeRanges)) {
+                       codeTier->metadata().codeRanges)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1540,13 +1540,13 @@ uint8_t* Code::serialize(uint8_t* cursor
 }
 
 void Code::disassemble(JSContext* cx, Tier tier, int kindSelection,
-                       PrintCallback printString) const {
+                       PrintCallback printString) const {MOZ_RELEASE_ASSERT(0);
   const MetadataTier& metadataTier = metadata(tier);
   const CodeTier& codeTier = this->codeTier(tier);
   const ModuleSegment& segment = codeTier.segment();
 
-  for (const CodeRange& range : metadataTier.codeRanges) {
-    if (kindSelection & (1 << range.kind())) {
+  for (const CodeRange& range : metadataTier.codeRanges) {MOZ_RELEASE_ASSERT(0);
+    if (kindSelection & (1 << range.kind())) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(range.begin() < segment.length());
       MOZ_ASSERT(range.end() < segment.length());
 
@@ -1578,13 +1578,13 @@ void Code::disassemble(JSContext* cx, Ti
       // The buffer is quite large in order to accomodate mangled C++ names;
       // lengths over 3500 have been observed in the wild.
       char buf[4096];
-      if (range.hasFuncIndex()) {
+      if (range.hasFuncIndex()) {MOZ_RELEASE_ASSERT(0);
         const char* funcName = "(unknown)";
         UTF8Bytes namebuf;
         if (metadata().getFuncNameStandalone(range.funcIndex(), &namebuf) &&
-            namebuf.append('\0')) {
+            namebuf.append('\0')) {MOZ_RELEASE_ASSERT(0);
           funcName = namebuf.begin();
-        }
+        }MOZ_RELEASE_ASSERT(0);
         SprintfLiteral(buf, "%sKind = %s, index = %d, name = %s:\n", separator,
                        kind, range.funcIndex(), funcName);
       } else {
diff --git a/js/src/wasm/WasmCompile.cpp b/js/src/wasm/WasmCompile.cpp
--- a/js/src/wasm/WasmCompile.cpp
+++ b/js/src/wasm/WasmCompile.cpp
@@ -119,7 +119,7 @@ SharedCompileArgs CompileArgs::build(JSC
   // The <Compiler>Available() predicates should ensure no failure here, but
   // when we're fuzzing we allow inconsistent switches and the check may thus
   // fail.  Let it go to a run-time error instead of crashing.
-  if (debug && (ion || cranelift)) {
+  if (debug && (ion || cranelift)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "no WebAssembly compiler available");
     return nullptr;
   }
@@ -483,7 +483,7 @@ static bool TieringBeneficial(uint32_t c
   // some kind of sense.  That said, this is a non-issue: as of September 2017
   // 1-core was down to 3.5% of our population and falling.
 
-  if (cpuCount == 1) {
+  if (cpuCount == 1) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -623,11 +623,11 @@ template <class DecoderT>
 static bool DecodeFunctionBody(DecoderT& d, ModuleGenerator& mg,
                                uint32_t funcIndex) {
   uint32_t bodySize;
-  if (!d.readVarU32(&bodySize)) {
+  if (!d.readVarU32(&bodySize)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("expected number of function body bytes");
   }
 
-  if (bodySize > MaxFunctionBytes) {
+  if (bodySize > MaxFunctionBytes) {MOZ_RELEASE_ASSERT(0);
     return d.fail("function body too big");
   }
 
@@ -693,7 +693,7 @@ SharedModule wasm::CompileBuffer(const C
   compilerEnv.computeParameters(d);
 
   ModuleGenerator mg(args, &moduleEnv, &compilerEnv, nullptr, error);
-  if (!mg.init(nullptr)) {
+  if (!mg.init(nullptr)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -718,7 +718,7 @@ void wasm::CompileTier2(const CompileArg
                                           : OptimizedBackend::Ion;
 
   ModuleEnvironment moduleEnv(args.features);
-  if (!DecodeModuleEnvironment(d, &moduleEnv)) {
+  if (!DecodeModuleEnvironment(d, &moduleEnv)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
   CompilerEnvironment compilerEnv(CompileMode::Tier2, Tier::Optimized,
@@ -726,7 +726,7 @@ void wasm::CompileTier2(const CompileArg
   compilerEnv.computeParameters(d);
 
   ModuleGenerator mg(args, &moduleEnv, &compilerEnv, cancelled, &error);
-  if (!mg.init(nullptr)) {
+  if (!mg.init(nullptr)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -734,7 +734,7 @@ void wasm::CompileTier2(const CompileArg
     return;
   }
 
-  if (!DecodeModuleTail(d, &moduleEnv)) {
+  if (!DecodeModuleTail(d, &moduleEnv)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -795,7 +795,7 @@ class StreamingDecoder {
 static SharedBytes CreateBytecode(const Bytes& env, const Bytes& code,
                                   const Bytes& tail, UniqueChars* error) {
   size_t size = env.length() + code.length() + tail.length();
-  if (size > MaxModuleBytes) {
+  if (size > MaxModuleBytes) {MOZ_RELEASE_ASSERT(0);
     *error = DuplicateString("module too big");
     return nullptr;
   }
@@ -833,7 +833,7 @@ SharedModule wasm::CompileStreaming(
   {
     Decoder d(envBytes, 0, error, warnings);
 
-    if (!DecodeModuleEnvironment(d, &moduleEnv)) {
+    if (!DecodeModuleEnvironment(d, &moduleEnv)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     compilerEnv.computeParameters(d);
@@ -848,7 +848,7 @@ SharedModule wasm::CompileStreaming(
   }
 
   ModuleGenerator mg(args, &moduleEnv, &compilerEnv, &cancelled, error);
-  if (!mg.init(nullptr)) {
+  if (!mg.init(nullptr)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -856,7 +856,7 @@ SharedModule wasm::CompileStreaming(
     StreamingDecoder d(moduleEnv, codeBytes, codeBytesEnd, cancelled, error,
                        warnings);
 
-    if (!DecodeCodeSection(moduleEnv, d, mg)) {
+    if (!DecodeCodeSection(moduleEnv, d, mg)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -879,7 +879,7 @@ SharedModule wasm::CompileStreaming(
   {
     Decoder d(tailBytes, moduleEnv.codeSection->end(), error, warnings);
 
-    if (!DecodeModuleTail(d, &moduleEnv)) {
+    if (!DecodeModuleTail(d, &moduleEnv)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
diff --git a/js/src/wasm/WasmDebug.cpp b/js/src/wasm/WasmDebug.cpp
--- a/js/src/wasm/WasmDebug.cpp
+++ b/js/src/wasm/WasmDebug.cpp
@@ -113,12 +113,12 @@ bool DebugState::incrementStepperCount(J
   MOZ_ASSERT(codeRange.isFunction());
 
   StepperCounters::AddPtr p = stepperCounters_.lookupForAdd(funcIndex);
-  if (p) {
+  if (p) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(p->value() > 0);
     p->value()++;
     return true;
   }
-  if (!stepperCounters_.add(p, funcIndex, 1)) {
+  if (!stepperCounters_.add(p, funcIndex, 1)) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -147,7 +147,7 @@ void DebugState::decrementStepperCount(J
   MOZ_ASSERT(!stepperCounters_.empty());
   StepperCounters::Ptr p = stepperCounters_.lookup(funcIndex);
   MOZ_ASSERT(p);
-  if (--p->value()) {
+  if (--p->value()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -177,7 +177,7 @@ void DebugState::toggleBreakpointTrap(JS
                                       bool enabled) {
   const CallSite* callSite =
       SlowCallSiteSearchByOffset(metadata(Tier::Debug), offset);
-  if (!callSite) {
+  if (!callSite) {MOZ_RELEASE_ASSERT(0);
     return;
   }
   size_t debugTrapOffset = callSite->returnAddressOffset();
@@ -212,11 +212,11 @@ WasmBreakpointSite* DebugState::getOrCre
   WasmBreakpointSiteMap::AddPtr p = breakpointSites_.lookupForAdd(offset);
   if (!p) {
     site = cx->new_<WasmBreakpointSite>(instance->object(), offset);
-    if (!site) {
+    if (!site) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (!breakpointSites_.add(p, offset, site)) {
+    if (!breakpointSites_.add(p, offset, site)) {MOZ_RELEASE_ASSERT(0);
       js_delete(site);
       ReportOutOfMemory(cx);
       return nullptr;
@@ -254,7 +254,7 @@ void DebugState::clearBreakpointsIn(JSFr
   // Make sure we don't try to search for the unwrapped handler.
   MOZ_ASSERT_IF(handler, instance->compartment() == handler->compartment());
 
-  if (breakpointSites_.empty()) {
+  if (breakpointSites_.empty()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
   for (WasmBreakpointSiteMap::Enum e(breakpointSites_); !e.empty();
@@ -288,10 +288,10 @@ void DebugState::toggleDebugTrap(uint32_
     size_t i = 0;
     while (i < farJumpOffsets.length() && offset < farJumpOffsets[i]) {
       i++;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     if (i >= farJumpOffsets.length() ||
         (i > 0 &&
-         offset - farJumpOffsets[i - 1] < farJumpOffsets[i] - offset)) {
+         offset - farJumpOffsets[i - 1] < farJumpOffsets[i] - offset)) {MOZ_RELEASE_ASSERT(0);
       i--;
     }
     uint8_t* farJump = code_->segment(Tier::Debug).base() + farJumpOffsets[i];
@@ -401,7 +401,7 @@ bool DebugState::getGlobal(Instance& ins
 
   uint8_t* globalData = instance.globalData();
   void* dataPtr = globalData + global.offset();
-  if (global.isIndirect()) {
+  if (global.isIndirect()) {MOZ_RELEASE_ASSERT(0);
     dataPtr = *static_cast<void**>(dataPtr);
   }
   switch (global.type().kind()) {
@@ -448,7 +448,7 @@ bool DebugState::getSourceMappingURL(JSC
     const Bytes& sectionName = customSection.name;
     if (strlen(SourceMappingURLSectionName) != sectionName.length() ||
         memcmp(SourceMappingURLSectionName, sectionName.begin(),
-               sectionName.length()) != 0) {
+               sectionName.length()) != 0) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
@@ -456,17 +456,17 @@ bool DebugState::getSourceMappingURL(JSC
     Decoder d(customSection.payload->begin(), customSection.payload->end(), 0,
               /* error = */ nullptr);
     uint32_t nchars;
-    if (!d.readVarU32(&nchars)) {
+    if (!d.readVarU32(&nchars)) {MOZ_RELEASE_ASSERT(0);
       return true;  // ignoring invalid section data
     }
     const uint8_t* chars;
-    if (!d.readBytes(nchars, &chars) || d.currentPosition() != d.end()) {
+    if (!d.readBytes(nchars, &chars) || d.currentPosition() != d.end()) {MOZ_RELEASE_ASSERT(0);
       return true;  // ignoring invalid section data
     }
 
     JS::UTF8Chars utf8Chars(reinterpret_cast<const char*>(chars), nchars);
     JSString* str = JS_NewStringCopyUTF8N(cx, utf8Chars);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     result.set(str);
diff --git a/js/src/wasm/WasmFrameIter.cpp b/js/src/wasm/WasmFrameIter.cpp
--- a/js/src/wasm/WasmFrameIter.cpp
+++ b/js/src/wasm/WasmFrameIter.cpp
@@ -800,7 +800,7 @@ ProfilingFrameIterator::ProfilingFrameIt
   initFromExitFP(fp);
 }
 
-static inline void AssertDirectJitCall(const void* fp) {
+static inline void AssertDirectJitCall(const void* fp) {MOZ_RELEASE_ASSERT(0);
   // Called via an inlined fast JIT to wasm call: in this case, FP is
   // pointing in the middle of the exit frame, right before the exit
   // footer; ensure the exit frame type is the expected one.
@@ -846,7 +846,7 @@ void ProfilingFrameIterator::initFromExi
   stackAddress_ = (void*)fp;
   code_ = LookupCode(fp->returnAddress(), &codeRange_);
 
-  if (!code_) {
+  if (!code_) {MOZ_RELEASE_ASSERT(0);
     // This is a direct call from the JIT, the caller FP is pointing to a
     // tagged JIT caller's frame.
     AssertDirectJitCall(fp->jitEntryCaller());
@@ -945,7 +945,7 @@ TlsData* js::wasm::GetNearestEffectiveTl
 }
 
 bool js::wasm::StartUnwinding(const RegisterState& registers,
-                              UnwindState* unwindState, bool* unwoundCaller) {
+                              UnwindState* unwindState, bool* unwoundCaller) {MOZ_RELEASE_ASSERT(0);
   // Shorthands.
   uint8_t* const pc = (uint8_t*)registers.pc;
   void** const sp = (void**)registers.sp;
@@ -972,7 +972,7 @@ bool js::wasm::StartUnwinding(const Regi
     code = &codeSegment->code();
     codeBase = codeSegment->base();
     MOZ_ASSERT(codeRange);
-  } else if (!LookupBuiltinThunk(pc, &codeRange, &codeBase)) {
+  } else if (!LookupBuiltinThunk(pc, &codeRange, &codeBase)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -999,7 +999,7 @@ bool js::wasm::StartUnwinding(const Regi
     } else {
       offsetFromEntry = offsetInCode - codeRange->funcUncheckedCallEntry();
     }
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     offsetFromEntry = offsetInCode - codeRange->begin();
   }
 
@@ -1194,26 +1194,26 @@ ProfilingFrameIterator::ProfilingFrameIt
       callerPC_(nullptr),
       stackAddress_(nullptr),
       unwoundIonCallerFP_(nullptr),
-      exitReason_(ExitReason::Fixed::None) {
+      exitReason_(ExitReason::Fixed::None) {MOZ_RELEASE_ASSERT(0);
   // Let wasmExitFP take precedence to StartUnwinding when it is set since
   // during the body of an exit stub, the register state may not be valid
   // causing StartUnwinding() to abandon unwinding this activation.
-  if (activation.hasWasmExitFP()) {
+  if (activation.hasWasmExitFP()) {MOZ_RELEASE_ASSERT(0);
     exitReason_ = activation.wasmExitReason();
     initFromExitFP(activation.wasmExitFP());
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   bool unwoundCaller;
   UnwindState unwindState;
-  if (!StartUnwinding(state, &unwindState, &unwoundCaller)) {
+  if (!StartUnwinding(state, &unwindState, &unwoundCaller)) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(done());
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MOZ_ASSERT(unwindState.codeRange);
 
-  if (unwoundCaller) {
+  if (unwoundCaller) {MOZ_RELEASE_ASSERT(0);
     callerFP_ = unwindState.fp;
     callerPC_ = unwindState.pc;
     // In the case of a function call, if the original FP value is tagged,
@@ -1222,21 +1222,21 @@ ProfilingFrameIterator::ProfilingFrameIt
     // transient tagged values of FP (during wasm::SetExitFP) here because
     // StartUnwinding would not have unwound then.
     if (unwindState.codeRange->isFunction() &&
-        Frame::isExitOrJitEntryFP(reinterpret_cast<uint8_t*>(state.fp))) {
+        Frame::isExitOrJitEntryFP(reinterpret_cast<uint8_t*>(state.fp))) {MOZ_RELEASE_ASSERT(0);
       unwoundIonCallerFP_ = callerFP_;
     }
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     callerFP_ = Frame::fromUntaggedWasmExitFP(unwindState.fp)->rawCaller();
     callerPC_ = Frame::fromUntaggedWasmExitFP(unwindState.fp)->returnAddress();
     // See comment above. The only way to get a tagged FP here means that
     // the caller is a fast JIT caller which called into a wasm function.
-    if (Frame::isExitOrJitEntryFP(callerFP_)) {
+    if (Frame::isExitOrJitEntryFP(callerFP_)) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(unwindState.codeRange->isFunction());
       unwoundIonCallerFP_ = Frame::toJitEntryCaller(callerFP_);
     }
   }
 
-  if (unwindState.codeRange->isJitEntry()) {
+  if (unwindState.codeRange->isJitEntry()) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(!unwoundIonCallerFP_);
     unwoundIonCallerFP_ = callerFP_;
   }
@@ -1261,7 +1261,7 @@ void ProfilingFrameIterator::operator++(
     return;
   }
 
-  if (unwoundIonCallerFP_) {
+  if (unwoundIonCallerFP_) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(codeRange_->isFunction() || codeRange_->isJitEntry());
     callerPC_ = nullptr;
     callerFP_ = nullptr;
@@ -1270,7 +1270,7 @@ void ProfilingFrameIterator::operator++(
     return;
   }
 
-  if (!callerPC_) {
+  if (!callerPC_) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(!callerFP_);
     codeRange_ = nullptr;
     MOZ_ASSERT(done());
@@ -1285,11 +1285,11 @@ void ProfilingFrameIterator::operator++(
     callerPC_ = nullptr;
     MOZ_ASSERT(!done());
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   code_ = LookupCode(callerPC_, &codeRange_);
 
-  if (!code_ && Frame::isExitOrJitEntryFP(callerFP_)) {
+  if (!code_ && Frame::isExitOrJitEntryFP(callerFP_)) {MOZ_RELEASE_ASSERT(0);
     // The parent frame is an inlined wasm call, the tagged FP points to
     // the fake exit frame.
     MOZ_ASSERT(!codeRange_);
@@ -1297,15 +1297,15 @@ void ProfilingFrameIterator::operator++(
     unwoundIonCallerFP_ = Frame::toJitEntryCaller(callerFP_);
     MOZ_ASSERT(done());
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MOZ_ASSERT(codeRange_);
 
-  if (codeRange_->isJitEntry()) {
+  if (codeRange_->isJitEntry()) {MOZ_RELEASE_ASSERT(0);
     unwoundIonCallerFP_ = callerFP_;
     MOZ_ASSERT(!done());
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MOZ_ASSERT(code_ ==
              &GetNearestEffectiveTls(Frame::fromUntaggedWasmExitFP(callerFP_))
@@ -1337,7 +1337,7 @@ void ProfilingFrameIterator::operator++(
   MOZ_ASSERT(!done());
 }
 
-static const char* ThunkedNativeToDescription(SymbolicAddress func) {
+static const char* ThunkedNativeToDescription(SymbolicAddress func) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(NeedsBuiltinThunk(func));
   switch (func) {
     case SymbolicAddress::HandleDebugTrap:
@@ -1522,7 +1522,7 @@ const char* ProfilingFrameIterator::labe
   static const char trapDescription[] = "trap handling (in wasm)";
   static const char debugTrapDescription[] = "debug trap handling (in wasm)";
 
-  if (!exitReason_.isFixed()) {
+  if (!exitReason_.isFixed()) {MOZ_RELEASE_ASSERT(0);
     return ThunkedNativeToDescription(exitReason_.symbolic());
   }
 
diff --git a/js/src/wasm/WasmGC.cpp b/js/src/wasm/WasmGC.cpp
--- a/js/src/wasm/WasmGC.cpp
+++ b/js/src/wasm/WasmGC.cpp
@@ -26,7 +26,7 @@ namespace wasm {
 wasm::StackMap* ConvertStackMapBoolVectorToStackMap(
     const StackMapBoolVector& vec, bool hasRefs) {
   wasm::StackMap* stackMap = wasm::StackMap::create(vec.length());
-  if (!stackMap) {
+  if (!stackMap) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -95,12 +95,12 @@ bool CreateStackMapForFunctionEntryTrap(
   // REG DUMP AREA
   wasm::ExitStubMapVector trapExitExtras;
   if (!GenerateStackmapEntriesForTrapExit(
-          argTypes, trapExitLayout, trapExitLayoutWords, &trapExitExtras)) {
+          argTypes, trapExitLayout, trapExitLayoutWords, &trapExitExtras)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MOZ_ASSERT(trapExitExtras.length() == trapExitLayoutWords);
 
-  if (!vec.appendN(false, trapExitLayoutWords)) {
+  if (!vec.appendN(false, trapExitLayoutWords)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (size_t i = 0; i < trapExitLayoutWords; i++) {
@@ -110,12 +110,12 @@ bool CreateStackMapForFunctionEntryTrap(
 
   // SPACE RESERVED BEFORE TRAP
   MOZ_ASSERT(nBytesReservedBeforeTrap % sizeof(void*) == 0);
-  if (!vec.appendN(false, nBytesReservedBeforeTrap / sizeof(void*))) {
+  if (!vec.appendN(false, nBytesReservedBeforeTrap / sizeof(void*))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // SPACE FOR FRAME
-  if (!vec.appendN(false, nFrameBytes / sizeof(void*))) {
+  if (!vec.appendN(false, nFrameBytes / sizeof(void*))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -124,7 +124,7 @@ bool CreateStackMapForFunctionEntryTrap(
   const size_t numStackArgWords = nInboundStackArgBytes / sizeof(void*);
 
   const size_t wordsSoFar = vec.length();
-  if (!vec.appendN(false, numStackArgWords)) {
+  if (!vec.appendN(false, numStackArgWords)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -151,7 +151,7 @@ bool CreateStackMapForFunctionEntryTrap(
   // Convert vec into a wasm::StackMap.
   MOZ_ASSERT(vec.length() * sizeof(void*) == nTotalBytes);
   wasm::StackMap* stackMap = ConvertStackMapBoolVectorToStackMap(vec, hasRefs);
-  if (!stackMap) {
+  if (!stackMap) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   stackMap->setExitStubWords(trapExitLayoutWords);
@@ -179,7 +179,7 @@ bool GenerateStackmapEntriesForTrapExit(
   // registers in the MachineState.  See MachineState::MachineState().
   MOZ_ASSERT(trapExitLayoutNumWords < 0x100);
 
-  if (!extras->appendN(false, trapExitLayoutNumWords)) {
+  if (!extras->appendN(false, trapExitLayoutNumWords)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/wasm/WasmGenerator.cpp b/js/src/wasm/WasmGenerator.cpp
--- a/js/src/wasm/WasmGenerator.cpp
+++ b/js/src/wasm/WasmGenerator.cpp
@@ -153,7 +153,7 @@ bool ModuleGenerator::allocateGlobalByte
 
   newGlobalDataLength +=
       ComputeByteAlignment(newGlobalDataLength.value(), align);
-  if (!newGlobalDataLength.isValid()) {
+  if (!newGlobalDataLength.isValid()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -176,7 +176,7 @@ bool ModuleGenerator::init(Metadata* may
     metadata_ = maybeAsmJSMetadata;
   } else {
     metadata_ = js_new<Metadata>();
-    if (!metadata_) {
+    if (!metadata_) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -184,7 +184,7 @@ bool ModuleGenerator::init(Metadata* may
   if (compileArgs_->scriptedCaller.filename) {
     metadata_->filename =
         DuplicateString(compileArgs_->scriptedCaller.filename.get());
-    if (!metadata_->filename) {
+    if (!metadata_->filename) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -195,18 +195,18 @@ bool ModuleGenerator::init(Metadata* may
 
   if (compileArgs_->sourceMapURL) {
     metadata_->sourceMapURL = DuplicateString(compileArgs_->sourceMapURL.get());
-    if (!metadata_->sourceMapURL) {
+    if (!metadata_->sourceMapURL) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   linkData_ = js::MakeUnique<LinkData>(tier());
-  if (!linkData_) {
+  if (!linkData_) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   metadataTier_ = js::MakeUnique<MetadataTier>(tier());
-  if (!metadataTier_) {
+  if (!metadataTier_) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -214,7 +214,7 @@ bool ModuleGenerator::init(Metadata* may
   // elements will be initialized by the time module generation is finished.
 
   if (!metadataTier_->funcToCodeRange.appendN(BAD_CODE_RANGE,
-                                              moduleEnv_->funcs.length())) {
+                                              moduleEnv_->funcs.length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -249,25 +249,25 @@ bool ModuleGenerator::init(Metadata* may
        i++) {
     uint32_t globalDataOffset;
     if (!allocateGlobalBytes(sizeof(FuncImportTls), sizeof(void*),
-                             &globalDataOffset)) {
+                             &globalDataOffset)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     moduleEnv_->funcImportGlobalDataOffsets[i] = globalDataOffset;
 
     FuncType copy;
-    if (!copy.clone(*moduleEnv_->funcs[i].type)) {
+    if (!copy.clone(*moduleEnv_->funcs[i].type)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!metadataTier_->funcImports.emplaceBack(std::move(copy),
-                                                globalDataOffset)) {
+                                                globalDataOffset)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   for (TableDesc& table : moduleEnv_->tables) {
     if (!allocateGlobalBytes(sizeof(TableTls), sizeof(void*),
-                             &table.globalDataOffset)) {
+                             &table.globalDataOffset)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -284,18 +284,18 @@ bool ModuleGenerator::init(Metadata* may
       if (TypeIdDesc::isGlobal(typeDef)) {
         uint32_t globalDataOffset;
         if (!allocateGlobalBytes(sizeof(void*), sizeof(void*),
-                                 &globalDataOffset)) {
+                                 &globalDataOffset)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
         typeId = TypeIdDesc::global(typeDef, globalDataOffset);
 
         TypeDef copy;
-        if (!copy.clone(typeDef)) {
+        if (!copy.clone(typeDef)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
 
-        if (!metadata_->types.emplaceBack(std::move(copy), typeId)) {
+        if (!metadata_->types.emplaceBack(std::move(copy), typeId)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
@@ -315,7 +315,7 @@ bool ModuleGenerator::init(Metadata* may
         if (!TypeIdDesc::isGlobal(typeDef)) {
           continue;
         }
-        if (!map.put(srcIndex, destIndex++)) {
+        if (!map.put(srcIndex, destIndex++)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
@@ -336,7 +336,7 @@ bool ModuleGenerator::init(Metadata* may
         global.isIndirect() ? sizeof(void*) : SizeOf(global.type());
 
     uint32_t globalDataOffset;
-    if (!allocateGlobalBytes(width, width, &globalDataOffset)) {
+    if (!allocateGlobalBytes(width, width, &globalDataOffset)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -372,14 +372,14 @@ bool ModuleGenerator::init(Metadata* may
     }
     bool isInvalid() const { return value == UINT32_MAX; }
     void mergeExplicit(bool explicitBit) {
-      if (!isExplicit() && explicitBit) {
+      if (!isExplicit() && explicitBit) {MOZ_RELEASE_ASSERT(0);
         value |= 0x1;
       }
     }
   };
 
   Vector<ExportedFunc, 8, SystemAllocPolicy> exportedFuncs;
-  if (!exportedFuncs.resize(moduleEnv_->numFuncs())) {
+  if (!exportedFuncs.resize(moduleEnv_->numFuncs())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -432,13 +432,13 @@ bool ModuleGenerator::init(Metadata* may
                      [](const ExportedFunc& exp) { return exp.isInvalid(); });
   exportedFuncs.erase(newEnd, exportedFuncs.end());
 
-  if (!metadataTier_->funcExports.reserve(exportedFuncs.length())) {
+  if (!metadataTier_->funcExports.reserve(exportedFuncs.length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   for (const ExportedFunc& funcIndex : exportedFuncs) {
     FuncType funcType;
-    if (!funcType.clone(*moduleEnv_->funcs[funcIndex.index()].type)) {
+    if (!funcType.clone(*moduleEnv_->funcs[funcIndex.index()].type)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     metadataTier_->funcExports.infallibleEmplaceBack(
@@ -459,7 +459,7 @@ bool ModuleGenerator::init(Metadata* may
     numTasks = 1;
   }
 
-  if (!tasks_.initCapacity(numTasks)) {
+  if (!tasks_.initCapacity(numTasks)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (size_t i = 0; i < numTasks; i++) {
@@ -467,7 +467,7 @@ bool ModuleGenerator::init(Metadata* may
                                  COMPILATION_LIFO_DEFAULT_CHUNK_SIZE);
   }
 
-  if (!freeTasks_.reserve(numTasks)) {
+  if (!freeTasks_.reserve(numTasks)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (size_t i = 0; i < numTasks; i++) {
@@ -482,7 +482,7 @@ bool ModuleGenerator::init(Metadata* may
   MOZ_ASSERT(importCode.empty());
 
   if (!GenerateImportFunctions(*moduleEnv_, metadataTier_->funcImports,
-                               &importCode)) {
+                               &importCode)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -650,7 +650,7 @@ void ModuleGenerator::noteCodeRange(uint
 
 template <class Vec, class Op>
 static bool AppendForEach(Vec* dstVec, const Vec& srcVec, Op op) {
-  if (!dstVec->growByUninitialized(srcVec.length())) {
+  if (!dstVec->growByUninitialized(srcVec.length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -677,7 +677,7 @@ bool ModuleGenerator::linkCompiledCode(C
   if (!InRange(startOfUnpatchedCallsites_,
                masm_.size() + code.bytes.length())) {
     startOfUnpatchedCallsites_ = masm_.size();
-    if (!linkCallSites()) {
+    if (!linkCallSites()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -687,7 +687,7 @@ bool ModuleGenerator::linkCompiledCode(C
 
   masm_.haltingAlign(CodeAlignment);
   const size_t offsetInModule = masm_.size();
-  if (!masm_.appendRawCode(code.bytes.begin(), code.bytes.length())) {
+  if (!masm_.appendRawCode(code.bytes.begin(), code.bytes.length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -696,18 +696,18 @@ bool ModuleGenerator::linkCompiledCode(C
     noteCodeRange(codeRangeIndex, *codeRange);
   };
   if (!AppendForEach(&metadataTier_->codeRanges, code.codeRanges,
-                     codeRangeOp)) {
+                     codeRangeOp)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   auto callSiteOp = [=](uint32_t, CallSite* cs) {
     cs->offsetBy(offsetInModule);
   };
-  if (!AppendForEach(&metadataTier_->callSites, code.callSites, callSiteOp)) {
+  if (!AppendForEach(&metadataTier_->callSites, code.callSites, callSiteOp)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!callSiteTargets_.appendAll(code.callSiteTargets)) {
+  if (!callSiteTargets_.appendAll(code.callSiteTargets)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -716,14 +716,14 @@ bool ModuleGenerator::linkCompiledCode(C
       ts->offsetBy(offsetInModule);
     };
     if (!AppendForEach(&metadataTier_->trapSites[trap], code.trapSites[trap],
-                       trapSiteOp)) {
+                       trapSiteOp)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   for (const SymbolicAccess& access : code.symbolicAccesses) {
     uint32_t patchAt = offsetInModule + access.patchAt.offset();
-    if (!linkData_->symbolicLinks[access.target].append(patchAt)) {
+    if (!linkData_->symbolicLinks[access.target].append(patchAt)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -735,7 +735,7 @@ bool ModuleGenerator::linkCompiledCode(C
 #ifdef JS_CODELABEL_LINKMODE
     link.mode = codeLabel.linkMode();
 #endif
-    if (!linkData_->internalLinks.append(link)) {
+    if (!linkData_->internalLinks.append(link)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -743,7 +743,7 @@ bool ModuleGenerator::linkCompiledCode(C
   for (size_t i = 0; i < code.stackMaps.length(); i++) {
     StackMaps::Maplet maplet = code.stackMaps.move(i);
     maplet.offsetBy(offsetInModule);
-    if (!metadataTier_->stackMaps.add(maplet)) {
+    if (!metadataTier_->stackMaps.add(maplet)) {MOZ_RELEASE_ASSERT(0);
       // This function is now the only owner of maplet.map, so we'd better
       // free it right now.
       maplet.map->destroy();
@@ -816,7 +816,7 @@ void CompileTask::runHelperThreadTask(Au
   // Don't release the lock between updating our state and returning from this
   // method.
 
-  if (!ok || !state.finished().append(this)) {
+  if (!ok || !state.finished().append(this)) {MOZ_RELEASE_ASSERT(0);
     state.numFailed()++;
     if (!state.errorMessage()) {
       state.errorMessage() = std::move(error);
@@ -883,7 +883,7 @@ bool ModuleGenerator::finishOutstandingT
     while (true) {
       MOZ_ASSERT(outstanding_ > 0);
 
-      if (taskState_.numFailed() > 0) {
+      if (taskState_.numFailed() > 0) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -946,7 +946,7 @@ bool ModuleGenerator::compileFuncDef(uin
   }
 
   if (!currentTask_) {
-    if (freeTasks_.empty() && !finishOutstandingTask()) {
+    if (freeTasks_.empty() && !finishOutstandingTask()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     currentTask_ = freeTasks_.popCopy();
@@ -978,7 +978,7 @@ bool ModuleGenerator::finishCodegen() {
   // known, patch all calls (which can emit far jumps) and far jumps. Linking
   // can emit tiny far-jump stubs, so there is an ordering dependency here.
 
-  if (!linkCallSites()) {
+  if (!linkCallSites()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1089,7 +1089,7 @@ UniqueCodeTier ModuleGenerator::finishCo
   MOZ_ASSERT(finishedFuncDefs_);
 
   while (outstanding_ > 0) {
-    if (!finishOutstandingTask()) {
+    if (!finishOutstandingTask()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -1107,27 +1107,27 @@ UniqueCodeTier ModuleGenerator::finishCo
   MOZ_ASSERT(stubCode.empty());
 
   if (!GenerateStubs(*moduleEnv_, metadataTier_->funcImports,
-                     metadataTier_->funcExports, &stubCode)) {
+                     metadataTier_->funcExports, &stubCode)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!linkCompiledCode(stubCode)) {
+  if (!linkCompiledCode(stubCode)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   // Finish linking and metadata.
 
-  if (!finishCodegen()) {
+  if (!finishCodegen()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (!finishMetadataTier()) {
+  if (!finishMetadataTier()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   UniqueModuleSegment segment =
       ModuleSegment::create(tier(), masm_, *linkData_);
-  if (!segment) {
+  if (!segment) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1173,15 +1173,15 @@ SharedMetadata ModuleGenerator::finishMe
     metadata_->debugEnabled = true;
 
     const size_t numFuncs = moduleEnv_->funcs.length();
-    if (!metadata_->debugFuncArgTypes.resize(numFuncs)) {
+    if (!metadata_->debugFuncArgTypes.resize(numFuncs)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
-    if (!metadata_->debugFuncReturnTypes.resize(numFuncs)) {
+    if (!metadata_->debugFuncReturnTypes.resize(numFuncs)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     for (size_t i = 0; i < numFuncs; i++) {
       if (!metadata_->debugFuncArgTypes[i].appendAll(
-              moduleEnv_->funcs[i].type->args())) {
+              moduleEnv_->funcs[i].type->args())) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       if (!metadata_->debugFuncReturnTypes[i].appendAll(
@@ -1213,13 +1213,13 @@ SharedModule ModuleGenerator::finishModu
   MOZ_ASSERT(mode() == CompileMode::Once || mode() == CompileMode::Tier1);
 
   UniqueCodeTier codeTier = finishCodeTier();
-  if (!codeTier) {
+  if (!codeTier) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   JumpTables jumpTables;
   if (!jumpTables.init(mode(), codeTier->segment(),
-                       codeTier->metadata().codeRanges)) {
+                       codeTier->metadata().codeRanges)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1227,37 +1227,37 @@ SharedModule ModuleGenerator::finishModu
   // compilation.
 
   DataSegmentVector dataSegments;
-  if (!dataSegments.reserve(moduleEnv_->dataSegments.length())) {
+  if (!dataSegments.reserve(moduleEnv_->dataSegments.length())) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   for (const DataSegmentEnv& srcSeg : moduleEnv_->dataSegments) {
     MutableDataSegment dstSeg = js_new<DataSegment>(srcSeg);
-    if (!dstSeg) {
+    if (!dstSeg) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (!dstSeg->bytes.append(bytecode.begin() + srcSeg.bytecodeOffset,
-                              srcSeg.length)) {
+                              srcSeg.length)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     dataSegments.infallibleAppend(std::move(dstSeg));
   }
 
   CustomSectionVector customSections;
-  if (!customSections.reserve(moduleEnv_->customSections.length())) {
+  if (!customSections.reserve(moduleEnv_->customSections.length())) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   for (const CustomSectionEnv& srcSec : moduleEnv_->customSections) {
     CustomSection sec;
     if (!sec.name.append(bytecode.begin() + srcSec.nameOffset,
-                         srcSec.nameLength)) {
+                         srcSec.nameLength)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     MutableBytes payload = js_new<ShareableBytes>();
-    if (!payload) {
+    if (!payload) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (!payload->append(bytecode.begin() + srcSec.payloadOffset,
-                         srcSec.payloadLength)) {
+                         srcSec.payloadLength)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     sec.payload = std::move(payload);
@@ -1270,13 +1270,13 @@ SharedModule ModuleGenerator::finishModu
   }
 
   SharedMetadata metadata = finishMetadata(bytecode.bytes);
-  if (!metadata) {
+  if (!metadata) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   MutableCode code =
       js_new<Code>(std::move(codeTier), *metadata, std::move(jumpTables));
-  if (!code || !code->initialize(*linkData_)) {
+  if (!code || !code->initialize(*linkData_)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1291,7 +1291,7 @@ SharedModule ModuleGenerator::finishModu
     MOZ_ASSERT(tier() == Tier::Debug);
 
     debugUnlinkedCode = js::MakeUnique<Bytes>();
-    if (!debugUnlinkedCode || !debugUnlinkedCode->resize(masm_.bytesNeeded())) {
+    if (!debugUnlinkedCode || !debugUnlinkedCode->resize(masm_.bytesNeeded())) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1309,7 +1309,7 @@ SharedModule ModuleGenerator::finishModu
       std::move(dataSegments), std::move(moduleEnv_->elemSegments),
       std::move(customSections), std::move(debugUnlinkedCode),
       std::move(debugLinkData), debugBytecode);
-  if (!module) {
+  if (!module) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1332,7 +1332,7 @@ bool ModuleGenerator::finishTier2(const 
   }
 
   UniqueCodeTier codeTier = finishCodeTier();
-  if (!codeTier) {
+  if (!codeTier) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1346,7 +1346,7 @@ bool ModuleGenerator::finishTier2(const 
 }
 
 size_t CompiledCode::sizeOfExcludingThis(
-    mozilla::MallocSizeOf mallocSizeOf) const {
+    mozilla::MallocSizeOf mallocSizeOf) const {MOZ_RELEASE_ASSERT(0);
   size_t trapSitesSize = 0;
   for (const TrapSiteVector& vec : trapSites) {
     trapSitesSize += vec.sizeOfExcludingThis(mallocSizeOf);
diff --git a/js/src/wasm/WasmInstance.cpp b/js/src/wasm/WasmInstance.cpp
--- a/js/src/wasm/WasmInstance.cpp
+++ b/js/src/wasm/WasmInstance.cpp
@@ -125,14 +125,14 @@ static bool IterableToArray(JSContext* c
   }
 
   array.set(NewDenseEmptyArray(cx));
-  if (!array) {
+  if (!array) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedValue nextValue(cx);
   while (true) {
     bool done;
-    if (!iterator.next(&nextValue, &done)) {
+    if (!iterator.next(&nextValue, &done)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (done) {
@@ -233,7 +233,7 @@ bool Instance::callImport(JSContext* cx,
 
   ArgTypeVector argTypes(fi.funcType());
   InvokeArgs args(cx);
-  if (!args.init(cx, argTypes.lengthWithoutStackResults())) {
+  if (!args.init(cx, argTypes.lengthWithoutStackResults())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -254,7 +254,7 @@ bool Instance::callImport(JSContext* cx,
     size_t naturalIndex = argTypes.naturalIndex(i);
     ValType type = fi.funcType().args()[naturalIndex];
     MutableHandleValue argValue = args[naturalIndex];
-    if (!ToJSValue(cx, rawArgLoc, type, argValue)) {
+    if (!ToJSValue(cx, rawArgLoc, type, argValue)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -275,7 +275,7 @@ bool Instance::callImport(JSContext* cx,
     return false;
   }
 
-  if (!JitOptions.enableWasmJitExit) {
+  if (!JitOptions.enableWasmJitExit) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -381,13 +381,13 @@ static int32_t PerformWait(Instance* ins
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_WASM_OUT_OF_BOUNDS);
     return -1;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   mozilla::Maybe<mozilla::TimeDuration> timeout;
-  if (timeout_ns >= 0) {
+  if (timeout_ns >= 0) {MOZ_RELEASE_ASSERT(0);
     timeout = mozilla::Some(
         mozilla::TimeDuration::FromMicroseconds(timeout_ns / 1000));
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   switch (atomics_wait_impl(cx, instance->sharedMemoryBuffer(), byteOffset,
                             value, timeout)) {
@@ -440,7 +440,7 @@ static int32_t PerformWait(Instance* ins
 
   if (!instance->memory()->isShared()) {
     return 0;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   int64_t woken = atomics_notify_impl(instance->sharedMemoryBuffer(),
                                       byteOffset, int64_t(count));
@@ -612,7 +612,7 @@ inline int32_t WasmMemoryFill32(T memBas
   // The required read/write direction is upward, but that is not currently
   // observable as there are no fences nor any read/write protect operation.
   SharedMem<uint8_t*> dataPtr = mem->buffer().dataPointerEither();
-  if (mem->isShared()) {
+  if (mem->isShared()) {MOZ_RELEASE_ASSERT(0);
     AtomicOperations::memcpySafeWhenRacy(
         dataPtr + dstOffset, (uint8_t*)seg.bytes.begin() + srcOffset, len);
   } else {
@@ -649,7 +649,7 @@ inline int32_t WasmMemoryFill32(T memBas
   if (&srcTable == &dstTable && dstOffset > srcOffset) {
     for (uint32_t i = len; i > 0; i--) {
       if (!dstTable->copy(*srcTable, dstOffset + (i - 1),
-                          srcOffset + (i - 1))) {
+                          srcOffset + (i - 1))) {MOZ_RELEASE_ASSERT(0);
         isOOM = true;
         break;
       }
@@ -658,7 +658,7 @@ inline int32_t WasmMemoryFill32(T memBas
     // No-op
   } else {
     for (uint32_t i = 0; i < len; i++) {
-      if (!dstTable->copy(*srcTable, dstOffset + i, srcOffset + i)) {
+      if (!dstTable->copy(*srcTable, dstOffset + i, srcOffset + i)) {MOZ_RELEASE_ASSERT(0);
         isOOM = true;
         break;
       }
@@ -709,12 +709,12 @@ bool Instance::initElems(uint32_t tableI
     uint32_t funcIndex = elemFuncIndices[srcOffset + i];
     if (funcIndex == NullFuncIndex) {
       table.setNull(dstOffset + i);
-    } else if (!table.isFunction()) {
+    } else if (!table.isFunction()) {MOZ_RELEASE_ASSERT(0);
       // Note, fnref must be rooted if we do anything more than just store it.
       void* fnref = Instance::refFunc(this, funcIndex);
-      if (fnref == AnyRef::invalid().forCompiledCode()) {
+      if (fnref == AnyRef::invalid().forCompiledCode()) {MOZ_RELEASE_ASSERT(0);
         return false;  // OOM, which has already been reported.
-      }
+      }MOZ_RELEASE_ASSERT(0);
       table.fillAnyRef(dstOffset + i, 1, AnyRef::fromCompiledCode(fnref));
     } else {
       if (funcIndex < funcImports.length()) {
@@ -1005,7 +1005,7 @@ bool Instance::initElems(uint32_t tableI
   RootedArrayBufferObject buf(
       cx, ArrayBufferObject::createZeroed(cx, BufferSize(nbytes)));
 
-  if (!buf) {
+  if (!buf) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1335,13 +1335,13 @@ bool Instance::init(JSContext* cx, const
 
   // Add observer if our memory base may grow
   if (memory_ && memory_->movingGrowable() &&
-      !memory_->addMovingGrowObserver(cx, object_)) {
+      !memory_->addMovingGrowObserver(cx, object_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Add observers if our tables may grow
   for (const SharedTable& table : tables_) {
-    if (table->movingGrowable() && !table->addMovingGrowObserver(cx, object_)) {
+    if (table->movingGrowable() && !table->addMovingGrowObserver(cx, object_)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1352,7 +1352,7 @@ bool Instance::init(JSContext* cx, const
     if (GcTypesAvailable(cx)) {
       uint32_t baseIndex = 0;
       if (!cx->wasm().typeContext->transferTypes(metadata().types,
-                                                 &baseIndex)) {
+                                                 &baseIndex)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -1369,7 +1369,7 @@ bool Instance::init(JSContext* cx, const
         Rooted<RttValue*> rttValue(
             cx, RttValue::createFromHandle(cx, TypeHandle(globalTypeIndex)));
 
-        if (!rttValue) {
+        if (!rttValue) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         *((GCPtrObject*)addressOfTypeId(typeDef.id)) = rttValue;
@@ -1405,7 +1405,7 @@ bool Instance::init(JSContext* cx, const
   }
 
   // Take references to the passive data segments
-  if (!passiveDataSegments_.resize(dataSegments.length())) {
+  if (!passiveDataSegments_.resize(dataSegments.length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (size_t i = 0; i < dataSegments.length(); i++) {
@@ -1415,7 +1415,7 @@ bool Instance::init(JSContext* cx, const
   }
 
   // Take references to the passive element segments
-  if (!passiveElemSegments_.resize(elemSegments.length())) {
+  if (!passiveElemSegments_.resize(elemSegments.length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   for (size_t i = 0; i < elemSegments.length(); i++) {
@@ -1451,12 +1451,12 @@ size_t Instance::memoryMappedSize() cons
 }
 
 bool Instance::memoryAccessInGuardRegion(const uint8_t* addr,
-                                         unsigned numBytes) const {
+                                         unsigned numBytes) const {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(numBytes > 0);
 
-  if (!metadata().usesMemory()) {
+  if (!metadata().usesMemory()) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   uint8_t* base = memoryBase().unwrap(/* comparison */);
   if (addr < base) {
@@ -1469,17 +1469,17 @@ bool Instance::memoryAccessInGuardRegion
 }
 
 bool Instance::memoryAccessInBounds(const uint8_t* addr,
-                                    unsigned numBytes) const {
+                                    unsigned numBytes) const {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(numBytes > 0 && numBytes <= sizeof(double));
 
-  if (!metadata().usesMemory()) {
+  if (!metadata().usesMemory()) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   uint8_t* base = memoryBase().unwrap(/* comparison */);
-  if (addr < base) {
+  if (addr < base) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   size_t length = memory()->volatileMemoryLength().get();
   if (addr >= base + length) {
@@ -1630,7 +1630,7 @@ uintptr_t Instance::traceFrame(JSTracer*
     ASSERT_ANYREF_IS_JSOBJECT;
 
     for (size_t i = 0; i < MaxRegisterResults; i++) {
-      if (debugFrame->hasSpilledRegisterRefResult(i)) {
+      if (debugFrame->hasSpilledRegisterRefResult(i)) {MOZ_RELEASE_ASSERT(0);
         char* resultRefP = debugFrameP + DebugFrame::offsetOfRegisterResult(i);
         TraceNullableRoot(
             trc, (JSObject**)resultRefP,
@@ -1715,14 +1715,14 @@ static bool EnsureEntryStubs(const Insta
   tier = instance.code().bestTier();
   const CodeTier& codeTier = instance.code(tier);
   if (tier == prevTier) {
-    if (!stubs->createOne(funcExportIndex, codeTier)) {
+    if (!stubs->createOne(funcExportIndex, codeTier)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     *interpEntry = stubs->lookupInterpEntry(fe.funcIndex());
     MOZ_ASSERT(*interpEntry);
     return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MOZ_RELEASE_ASSERT(prevTier == Tier::Baseline && tier == Tier::Optimized);
   auto stubs2 = instance.code(tier).lazyStubs().lock();
@@ -1745,7 +1745,7 @@ static bool GetInterpEntryAndEnsureStubs
                                          void** interpEntry,
                                          const FuncType** funcType) {
   const FuncExport* funcExport;
-  if (!EnsureEntryStubs(instance, funcIndex, &funcExport, interpEntry)) {
+  if (!EnsureEntryStubs(instance, funcIndex, &funcExport, interpEntry)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1797,7 +1797,7 @@ bool wasm::ResultsToJSValue(JSContext* c
     if (iter.cur().inRegister()) {
       MOZ_ASSERT(!usedRegisterResult);
       if (!ToJSValue<DebugCodegenVal>(cx, registerResultLoc, iter.cur().type(),
-                                      rval)) {
+                                      rval)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       usedRegisterResult = true;
@@ -1813,7 +1813,7 @@ bool wasm::ResultsToJSValue(JSContext* c
 
   // Otherwise, collect results in an array, in push order.
   Rooted<ArrayObject*> array(cx, NewDenseEmptyArray(cx));
-  if (!array) {
+  if (!array) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedValue tmp(cx);
@@ -1821,10 +1821,10 @@ bool wasm::ResultsToJSValue(JSContext* c
     const ABIResult& result = iter.cur();
     if (result.onStack()) {
       char* loc = stackResultsLoc.value() + result.stackOffset();
-      if (!ToJSValue<DebugCodegenVal>(cx, loc, result.type(), &tmp)) {
+      if (!ToJSValue<DebugCodegenVal>(cx, loc, result.type(), &tmp)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
-      if (!NewbornArrayPush(cx, array, tmp)) {
+      if (!NewbornArrayPush(cx, array, tmp)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -1879,7 +1879,7 @@ class MOZ_RAII ReturnToJSResultCollector
       // It is necessary to zero storage for ref results, and it doesn't
       // hurt to do so for other POD results.
       stackResultsArea_ = cx->make_zeroed_pod_array<char>(areaBytes);
-      if (!stackResultsArea_) {
+      if (!stackResultsArea_) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (needRooter) {
@@ -1912,7 +1912,7 @@ bool Instance::callExport(JSContext* cx,
   void* interpEntry;
   const FuncType* funcType;
   if (!GetInterpEntryAndEnsureStubs(cx, *this, funcIndex, args, &interpEntry,
-                                    &funcType)) {
+                                    &funcType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1925,7 +1925,7 @@ bool Instance::callExport(JSContext* cx,
   ArgTypeVector argTypes(*funcType);
   ResultType resultType(ResultType::Vector(funcType->results()));
   ReturnToJSResultCollector results(resultType);
-  if (!results.init(cx)) {
+  if (!results.init(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1939,7 +1939,7 @@ bool Instance::callExport(JSContext* cx,
   // length >= 1).
   Vector<ExportArg, 8> exportArgs(cx);
   if (!exportArgs.resize(
-          std::max<size_t>(1, argTypes.lengthWithStackResults()))) {
+          std::max<size_t>(1, argTypes.lengthWithStackResults()))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2026,7 +2026,7 @@ bool Instance::callExport(JSContext* cx,
     // exported functions, the returned value is discarded and an empty
     // object is returned instead.
     PlainObject* obj = NewBuiltinClassInstance<PlainObject>(cx);
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     args.rval().set(ObjectValue(*obj));
@@ -2115,7 +2115,7 @@ JSString* Instance::createDisplayURL(JSC
   // - 64-bit hash of the module bytes (as hex dump).
 
   JSStringBuilder result(cx);
-  if (!result.append("wasm:")) {
+  if (!result.append("wasm:")) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2124,22 +2124,22 @@ JSString* Instance::createDisplayURL(JSC
     // during OOM.
     JSString* filenamePrefix = EncodeURI(cx, filename, strlen(filename));
     if (!filenamePrefix) {
-      if (cx->isThrowingOutOfMemory()) {
+      if (cx->isThrowingOutOfMemory()) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       MOZ_ASSERT(!cx->isThrowingOverRecursed());
       cx->clearPendingException();
       return nullptr;
     }
 
-    if (!result.append(filenamePrefix)) {
+    if (!result.append(filenamePrefix)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
 
   if (metadata().debugEnabled) {
-    if (!result.append(":")) {
+    if (!result.append(":")) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -2147,7 +2147,7 @@ JSString* Instance::createDisplayURL(JSC
     for (unsigned char byte : hash) {
       char digit1 = byte / 16, digit2 = byte % 16;
       if (!result.append(
-              (char)(digit1 < 10 ? digit1 + '0' : digit1 + 'a' - 10))) {
+              (char)(digit1 < 10 ? digit1 + '0' : digit1 + 'a' - 10))) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
       if (!result.append(
@@ -2190,10 +2190,10 @@ void Instance::addSizeOfMisc(MallocSizeO
                              Metadata::SeenSet* seenMetadata,
                              Code::SeenSet* seenCode,
                              Table::SeenSet* seenTables, size_t* code,
-                             size_t* data) const {
+                             size_t* data) const {MOZ_RELEASE_ASSERT(0);
   *data += mallocSizeOf(this);
   *data += mallocSizeOf(tlsData_.get());
-  for (const SharedTable& table : tables_) {
+  for (const SharedTable& table : tables_) {MOZ_RELEASE_ASSERT(0);
     *data += table->sizeOfIncludingThisIfNotSeen(mallocSizeOf, seenTables);
   }
 
diff --git a/js/src/wasm/WasmIonCompile.cpp b/js/src/wasm/WasmIonCompile.cpp
--- a/js/src/wasm/WasmIonCompile.cpp
+++ b/js/src/wasm/WasmIonCompile.cpp
@@ -160,10 +160,10 @@ class FunctionCompiler {
 
     const ArgTypeVector args(funcType());
 
-    if (!mirGen_.ensureBallast()) {
+    if (!mirGen_.ensureBallast()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!newBlock(/* prev */ nullptr, &curBlock_)) {
+    if (!newBlock(/* prev */ nullptr, &curBlock_)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -177,7 +177,7 @@ class FunctionCompiler {
         curBlock_->initSlot(info().localSlot(args.naturalIndex(i.index())),
                             ins);
       }
-      if (!mirGen_.ensureBallast()) {
+      if (!mirGen_.ensureBallast()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -186,7 +186,7 @@ class FunctionCompiler {
     tlsPointer_ =
         MWasmParameter::New(alloc(), ABIArg(WasmTlsReg), MIRType::Pointer);
     curBlock_->add(tlsPointer_);
-    if (!mirGen_.ensureBallast()) {
+    if (!mirGen_.ensureBallast()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -413,7 +413,7 @@ class FunctionCompiler {
 
   MDefinition* minMax(MDefinition* lhs, MDefinition* rhs, MIRType type,
                       bool isMax) {
-    if (inDeadCode()) {
+    if (inDeadCode()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -496,7 +496,7 @@ class FunctionCompiler {
 
   MDefinition* mod(MDefinition* lhs, MDefinition* rhs, MIRType type,
                    bool unsignd) {
-    if (inDeadCode()) {
+    if (inDeadCode()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     bool trapOnError = !moduleEnv().isAsmJS();
@@ -567,7 +567,7 @@ class FunctionCompiler {
 
   MDefinition* signExtend(MDefinition* op, uint32_t srcSize,
                           uint32_t targetSize) {
-    if (inDeadCode()) {
+    if (inDeadCode()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     MInstruction* ins;
@@ -716,7 +716,7 @@ class FunctionCompiler {
 
   // (v128,i32) -> v128 effect-free shift operations
   MDefinition* shiftSimd128(MDefinition* lhs, MDefinition* rhs, SimdOp op) {
-    if (inDeadCode()) {
+    if (inDeadCode()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -845,7 +845,7 @@ class FunctionCompiler {
   MDefinition* loadSplatSimd128(Scalar::Type viewType,
                                 const LinearMemoryAddress<MDefinition*>& addr,
                                 wasm::SimdOp splatOp) {
-    if (inDeadCode()) {
+    if (inDeadCode()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -899,7 +899,7 @@ class FunctionCompiler {
   MDefinition* loadLaneSimd128(uint32_t laneSize,
                                const LinearMemoryAddress<MDefinition*>& addr,
                                uint32_t laneIndex, MDefinition* src) {
-    if (inDeadCode()) {
+    if (inDeadCode()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -921,7 +921,7 @@ class FunctionCompiler {
   void storeLaneSimd128(uint32_t laneSize,
                         const LinearMemoryAddress<MDefinition*>& addr,
                         uint32_t laneIndex, MDefinition* src) {
-    if (inDeadCode()) {
+    if (inDeadCode()) {MOZ_RELEASE_ASSERT(0);
       return;
     }
     MemoryAccessDesc access(Scalar::Simd128, addr.align, addr.offset,
@@ -1112,7 +1112,7 @@ class FunctionCompiler {
  public:
   MDefinition* computeEffectiveAddress(MDefinition* base,
                                        MemoryAccessDesc* access) {
-    if (inDeadCode()) {
+    if (inDeadCode()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (!access->offset()) {
@@ -1178,7 +1178,7 @@ class FunctionCompiler {
                                          MemoryAccessDesc* access,
                                          ValType result, MDefinition* oldv,
                                          MDefinition* newv) {
-    if (inDeadCode()) {
+    if (inDeadCode()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1200,7 +1200,7 @@ class FunctionCompiler {
     MInstruction* cas =
         MWasmCompareExchangeHeap::New(alloc(), bytecodeOffset(), memoryBase,
                                       base, *access, oldv, newv, tlsPointer_);
-    if (!cas) {
+    if (!cas) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     curBlock_->add(cas);
@@ -1215,7 +1215,7 @@ class FunctionCompiler {
 
   MDefinition* atomicExchangeHeap(MDefinition* base, MemoryAccessDesc* access,
                                   ValType result, MDefinition* value) {
-    if (inDeadCode()) {
+    if (inDeadCode()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1232,7 +1232,7 @@ class FunctionCompiler {
     MInstruction* xchg =
         MWasmAtomicExchangeHeap::New(alloc(), bytecodeOffset(), memoryBase,
                                      base, *access, value, tlsPointer_);
-    if (!xchg) {
+    if (!xchg) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     curBlock_->add(xchg);
@@ -1248,7 +1248,7 @@ class FunctionCompiler {
   MDefinition* atomicBinopHeap(AtomicOp op, MDefinition* base,
                                MemoryAccessDesc* access, ValType result,
                                MDefinition* value) {
-    if (inDeadCode()) {
+    if (inDeadCode()) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1265,7 +1265,7 @@ class FunctionCompiler {
     MInstruction* binop =
         MWasmAtomicBinopHeap::New(alloc(), bytecodeOffset(), op, memoryBase,
                                   base, *access, value, tlsPointer_);
-    if (!binop) {
+    if (!binop) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     curBlock_->add(binop);
@@ -1434,7 +1434,7 @@ class FunctionCompiler {
   // argument.
   bool passStackResultAreaCallArg(const ResultType& resultType,
                                   CallCompileState* call) {
-    if (inDeadCode()) {
+    if (inDeadCode()) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
     ABIResultIter iter(resultType);
@@ -1447,10 +1447,10 @@ class FunctionCompiler {
     }
 
     auto* stackResultArea = MWasmStackResultArea::New(alloc());
-    if (!stackResultArea) {
+    if (!stackResultArea) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!stackResultArea->init(alloc(), iter.remaining())) {
+    if (!stackResultArea->init(alloc(), iter.remaining())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     for (uint32_t base = iter.index(); !iter.done(); iter.next()) {
@@ -1524,7 +1524,7 @@ class FunctionCompiler {
   bool collectCallResults(const ResultType& type,
                           MWasmStackResultArea* stackResultArea,
                           DefVector* results) {
-    if (!results->reserve(type.length())) {
+    if (!results->reserve(type.length())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1540,7 +1540,7 @@ class FunctionCompiler {
     }
 
     for (iter.switchToPrev(); !iter.done(); iter.prev()) {
-      if (!mirGen().ensureBallast()) {
+      if (!mirGen().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       const ABIResult& result = iter.cur();
@@ -1597,7 +1597,7 @@ class FunctionCompiler {
   bool callDirect(const FuncType& funcType, uint32_t funcIndex,
                   uint32_t lineOrBytecode, const CallCompileState& call,
                   DefVector* results) {
-    if (inDeadCode()) {
+    if (inDeadCode()) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
 
@@ -1619,7 +1619,7 @@ class FunctionCompiler {
   bool callIndirect(uint32_t funcTypeIndex, uint32_t tableIndex,
                     MDefinition* index, uint32_t lineOrBytecode,
                     const CallCompileState& call, DefVector* results) {
-    if (inDeadCode()) {
+    if (inDeadCode()) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
 
@@ -1665,7 +1665,7 @@ class FunctionCompiler {
   bool callImport(unsigned globalDataOffset, uint32_t lineOrBytecode,
                   const CallCompileState& call, const FuncType& funcType,
                   DefVector* results) {
-    if (inDeadCode()) {
+    if (inDeadCode()) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
 
@@ -1752,7 +1752,7 @@ class FunctionCompiler {
       }
       iter.switchToPrev();
       for (uint32_t i = 0; !iter.done(); iter.prev(), i++) {
-        if (!mirGen().ensureBallast()) {
+        if (!mirGen().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         const ABIResult& result = iter.cur();
@@ -1804,7 +1804,7 @@ class FunctionCompiler {
       return true;
     }
     MOZ_ASSERT(numPushed(curBlock_) == 0);
-    if (!curBlock_->ensureHasSlots(defs.length())) {
+    if (!curBlock_->ensureHasSlots(defs.length())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     for (MDefinition* def : defs) {
@@ -1816,7 +1816,7 @@ class FunctionCompiler {
 
   bool popPushedDefs(DefVector* defs) {
     size_t n = numPushed(curBlock_);
-    if (!defs->resizeUninitialized(n)) {
+    if (!defs->resizeUninitialized(n)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     for (; n > 0; n--) {
@@ -1842,7 +1842,7 @@ class FunctionCompiler {
       *elseBlock = nullptr;
     } else {
       MBasicBlock* thenBlock;
-      if (!newBlock(curBlock_, &thenBlock)) {
+      if (!newBlock(curBlock_, &thenBlock)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (!newBlock(curBlock_, elseBlock)) {
@@ -1860,7 +1860,7 @@ class FunctionCompiler {
 
   bool switchToElse(MBasicBlock* elseBlock, MBasicBlock** thenJoinPred) {
     DefVector values;
-    if (!finishBlock(&values)) {
+    if (!finishBlock(&values)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1880,7 +1880,7 @@ class FunctionCompiler {
 
   bool joinIfElse(MBasicBlock* thenJoinPred, DefVector* defs) {
     DefVector values;
-    if (!finishBlock(&values)) {
+    if (!finishBlock(&values)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1889,7 +1889,7 @@ class FunctionCompiler {
     }
 
     MBasicBlock* elseJoinPred;
-    if (!addJoinPredecessor(values, &elseJoinPred)) {
+    if (!addJoinPredecessor(values, &elseJoinPred)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1902,12 +1902,12 @@ class FunctionCompiler {
       blocks[numJoinPreds++] = elseJoinPred;
     }
 
-    if (numJoinPreds == 0) {
+    if (numJoinPreds == 0) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
 
     MBasicBlock* join;
-    if (!goToNewBlock(blocks[0], &join)) {
+    if (!goToNewBlock(blocks[0], &join)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     for (size_t i = 1; i < numJoinPreds; ++i) {
@@ -1947,7 +1947,7 @@ class FunctionCompiler {
     MOZ_ASSERT(curBlock_->loopDepth() == loopDepth_ - 1);
     *loopHeader = MBasicBlock::New(mirGraph(), info(), curBlock_,
                                    MBasicBlock::PENDING_LOOP_HEADER);
-    if (!*loopHeader) {
+    if (!*loopHeader) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1956,15 +1956,15 @@ class FunctionCompiler {
     curBlock_->end(MGoto::New(alloc(), *loopHeader));
 
     DefVector loopParams;
-    if (!iter().getResults(paramCount, &loopParams)) {
+    if (!iter().getResults(paramCount, &loopParams)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     for (size_t i = 0; i < paramCount; i++) {
       MPhi* phi = MPhi::New(alloc(), loopParams[i]->type());
-      if (!phi) {
+      if (!phi) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
-      if (!phi->reserveLength(2)) {
+      if (!phi->reserveLength(2)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       (*loopHeader)->addPhi(phi);
@@ -1993,7 +1993,7 @@ class FunctionCompiler {
 
   bool setLoopBackedge(MBasicBlock* loopEntry, MBasicBlock* loopBody,
                        MBasicBlock* backedge, size_t paramCount) {
-    if (!loopEntry->setBackedgeWasm(backedge, paramCount)) {
+    if (!loopEntry->setBackedgeWasm(backedge, paramCount)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2065,7 +2065,7 @@ class FunctionCompiler {
     // unfortunate but the optimizer is able to fold these into single jumps
     // to backedges.
     DefVector backedgeValues;
-    if (!bindBranches(headerLabel, &backedgeValues)) {
+    if (!bindBranches(headerLabel, &backedgeValues)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2073,18 +2073,18 @@ class FunctionCompiler {
 
     if (curBlock_) {
       // We're on the loop backedge block, created by bindBranches.
-      for (size_t i = 0, n = numPushed(curBlock_); i != n; i++) {
+      for (size_t i = 0, n = numPushed(curBlock_); i != n; i++) {MOZ_RELEASE_ASSERT(0);
         curBlock_->pop();
       }
 
-      if (!pushDefs(backedgeValues)) {
+      if (!pushDefs(backedgeValues)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       MOZ_ASSERT(curBlock_->loopDepth() == loopDepth_);
       curBlock_->end(MGoto::New(alloc(), loopHeader));
       if (!setLoopBackedge(loopHeader, loopBody, curBlock_,
-                           backedgeValues.length())) {
+                           backedgeValues.length())) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2125,7 +2125,7 @@ class FunctionCompiler {
     }
 
     MGoto* jump = MGoto::New(alloc());
-    if (!addControlFlowPatch(jump, relativeDepth, MGoto::TargetIndex)) {
+    if (!addControlFlowPatch(jump, relativeDepth, MGoto::TargetIndex)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2145,12 +2145,12 @@ class FunctionCompiler {
     }
 
     MBasicBlock* joinBlock = nullptr;
-    if (!newBlock(curBlock_, &joinBlock)) {
+    if (!newBlock(curBlock_, &joinBlock)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     MTest* test = MTest::New(alloc(), condition, joinBlock);
-    if (!addControlFlowPatch(test, relativeDepth, MTest::TrueBranchIndex)) {
+    if (!addControlFlowPatch(test, relativeDepth, MTest::TrueBranchIndex)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2177,10 +2177,10 @@ class FunctionCompiler {
         MTableSwitch::New(alloc(), operand, 0, int32_t(numCases - 1));
 
     size_t defaultIndex;
-    if (!table->addDefault(nullptr, &defaultIndex)) {
+    if (!table->addDefault(nullptr, &defaultIndex)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!addControlFlowPatch(table, defaultDepth, defaultIndex)) {
+    if (!addControlFlowPatch(table, defaultDepth, defaultIndex)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2188,7 +2188,7 @@ class FunctionCompiler {
         HashMap<uint32_t, uint32_t, DefaultHasher<uint32_t>, SystemAllocPolicy>;
 
     IndexToCaseMap indexToCase;
-    if (!indexToCase.put(defaultDepth, defaultIndex)) {
+    if (!indexToCase.put(defaultDepth, defaultIndex)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2198,20 +2198,20 @@ class FunctionCompiler {
       size_t caseIndex;
       IndexToCaseMap::AddPtr p = indexToCase.lookupForAdd(depth);
       if (!p) {
-        if (!table->addSuccessor(nullptr, &caseIndex)) {
+        if (!table->addSuccessor(nullptr, &caseIndex)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
-        if (!addControlFlowPatch(table, depth, caseIndex)) {
+        if (!addControlFlowPatch(table, depth, caseIndex)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
-        if (!indexToCase.add(p, depth, caseIndex)) {
+        if (!indexToCase.add(p, depth, caseIndex)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
         caseIndex = p->value();
       }
 
-      if (!table->addCase(caseIndex)) {
+      if (!table->addCase(caseIndex)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -2276,7 +2276,7 @@ class FunctionCompiler {
     MBasicBlock* pred = ins->block();
 
     MBasicBlock* join = nullptr;
-    if (!newBlock(pred, &join)) {
+    if (!newBlock(pred, &join)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2288,7 +2288,7 @@ class FunctionCompiler {
 
       pred = ins->block();
       if (!pred->isMarked()) {
-        if (!join->addPredecessor(alloc(), pred)) {
+        if (!join->addPredecessor(alloc(), pred)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         pred->mark();
@@ -2302,7 +2302,7 @@ class FunctionCompiler {
       join->getPredecessor(i)->unmark();
     }
 
-    if (curBlock_ && !goToExistingBlock(curBlock_, join)) {
+    if (curBlock_ && !goToExistingBlock(curBlock_, join)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2447,7 +2447,7 @@ static bool EmitElse(FunctionCompiler& f
     return false;
   }
 
-  if (!f.pushDefs(thenValues)) {
+  if (!f.pushDefs(thenValues)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2470,7 +2470,7 @@ static bool EmitEnd(FunctionCompiler& f)
   MBasicBlock* block = f.iter().controlItem();
   f.iter().popEnd();
 
-  if (!f.pushDefs(preJoinDefs)) {
+  if (!f.pushDefs(preJoinDefs)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2609,7 +2609,7 @@ static bool EmitUnreachable(FunctionComp
 }
 
 #ifdef ENABLE_WASM_EXCEPTIONS
-static bool EmitTry(FunctionCompiler& f) {
+static bool EmitTry(FunctionCompiler& f) {MOZ_RELEASE_ASSERT(0);
   ResultType params;
   if (!f.iter().readTry(&params)) {
     return false;
@@ -2618,7 +2618,7 @@ static bool EmitTry(FunctionCompiler& f)
   MOZ_CRASH("NYI");
 }
 
-static bool EmitCatch(FunctionCompiler& f) {
+static bool EmitCatch(FunctionCompiler& f) {MOZ_RELEASE_ASSERT(0);
   LabelKind kind;
   uint32_t eventIndex;
   ResultType paramType, resultType;
@@ -2631,7 +2631,7 @@ static bool EmitCatch(FunctionCompiler& 
   MOZ_CRASH("NYI");
 }
 
-static bool EmitCatchAll(FunctionCompiler& f) {
+static bool EmitCatchAll(FunctionCompiler& f) {MOZ_RELEASE_ASSERT(0);
   LabelKind kind;
   ResultType paramType, resultType;
   DefVector tryValues;
@@ -2642,7 +2642,7 @@ static bool EmitCatchAll(FunctionCompile
   MOZ_CRASH("NYI");
 }
 
-static bool EmitDelegate(FunctionCompiler& f) {
+static bool EmitDelegate(FunctionCompiler& f) {MOZ_RELEASE_ASSERT(0);
   uint32_t relativeDepth;
   ResultType resultType;
   DefVector tryValues;
@@ -2654,7 +2654,7 @@ static bool EmitDelegate(FunctionCompile
   MOZ_CRASH("NYI");
 }
 
-static bool EmitUnwind(FunctionCompiler& f) {
+static bool EmitUnwind(FunctionCompiler& f) {MOZ_RELEASE_ASSERT(0);
   ResultType resultType;
   DefVector tryValues;
 
@@ -2665,7 +2665,7 @@ static bool EmitUnwind(FunctionCompiler&
   MOZ_CRASH("NYI");
 }
 
-static bool EmitThrow(FunctionCompiler& f) {
+static bool EmitThrow(FunctionCompiler& f) {MOZ_RELEASE_ASSERT(0);
   uint32_t exnIndex;
   DefVector argValues;
   if (!f.iter().readThrow(&exnIndex, &argValues)) {
@@ -2675,7 +2675,7 @@ static bool EmitThrow(FunctionCompiler& 
   MOZ_CRASH("NYI");
 }
 
-static bool EmitRethrow(FunctionCompiler& f) {
+static bool EmitRethrow(FunctionCompiler& f) {MOZ_RELEASE_ASSERT(0);
   uint32_t relativeDepth;
   if (!f.iter().readRethrow(&relativeDepth)) {
     return false;
@@ -2688,10 +2688,10 @@ static bool EmitRethrow(FunctionCompiler
 static bool EmitCallArgs(FunctionCompiler& f, const FuncType& funcType,
                          const DefVector& args, CallCompileState* call) {
   for (size_t i = 0, n = funcType.args().length(); i < n; ++i) {
-    if (!f.mirGen().ensureBallast()) {
+    if (!f.mirGen().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!f.passArg(args[i], funcType.args()[i], call)) {
+    if (!f.passArg(args[i], funcType.args()[i], call)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2711,7 +2711,7 @@ static bool EmitCall(FunctionCompiler& f
   DefVector args;
   if (asmJSFuncDef) {
     if (!f.iter().readOldCallDirect(f.moduleEnv().numFuncImports(), &funcIndex,
-                                    &args)) {
+                                    &args)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -2727,7 +2727,7 @@ static bool EmitCall(FunctionCompiler& f
   const FuncType& funcType = *f.moduleEnv().funcs[funcIndex].type;
 
   CallCompileState call;
-  if (!EmitCallArgs(f, funcType, args, &call)) {
+  if (!EmitCallArgs(f, funcType, args, &call)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2736,7 +2736,7 @@ static bool EmitCall(FunctionCompiler& f
     uint32_t globalDataOffset =
         f.moduleEnv().funcImportGlobalDataOffsets[funcIndex];
     if (!f.callImport(globalDataOffset, lineOrBytecode, call, funcType,
-                      &results)) {
+                      &results)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -2758,7 +2758,7 @@ static bool EmitCallIndirect(FunctionCom
   DefVector args;
   if (oldStyle) {
     tableIndex = 0;
-    if (!f.iter().readOldCallIndirect(&funcTypeIndex, &callee, &args)) {
+    if (!f.iter().readOldCallIndirect(&funcTypeIndex, &callee, &args)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -2775,7 +2775,7 @@ static bool EmitCallIndirect(FunctionCom
   const FuncType& funcType = f.moduleEnv().types[funcTypeIndex].funcType();
 
   CallCompileState call;
-  if (!EmitCallArgs(f, funcType, args, &call)) {
+  if (!EmitCallArgs(f, funcType, args, &call)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2823,7 +2823,7 @@ static bool EmitTeeLocal(FunctionCompile
 
 static bool EmitGetGlobal(FunctionCompiler& f) {
   uint32_t id;
-  if (!f.iter().readGetGlobal(&id)) {
+  if (!f.iter().readGetGlobal(&id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2900,10 +2900,10 @@ static bool EmitSetGlobal(FunctionCompil
   if (barrierAddr) {
     const SymbolicAddressSignature& callee = SASigPostBarrierFiltering;
     CallCompileState args;
-    if (!f.passInstance(callee.argTypes[0], &args)) {
+    if (!f.passInstance(callee.argTypes[0], &args)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!f.passArg(barrierAddr, callee.argTypes[1], &args)) {
+    if (!f.passArg(barrierAddr, callee.argTypes[1], &args)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     f.finishCall(&args);
@@ -2996,7 +2996,7 @@ static bool EmitTruncate(FunctionCompile
       if (input && (input->type() == MIRType::Double ||
                     input->type() == MIRType::Float32)) {
         f.iter().setResult(f.unary<MWasmBuiltinTruncateToInt32>(input));
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         f.iter().setResult(f.unary<MTruncateToInt32>(input));
       }
     } else {
@@ -3267,7 +3267,7 @@ static bool EmitTeeStoreWithCoercion(Fun
   LinearMemoryAddress<MDefinition*> addr;
   MDefinition* value;
   if (!f.iter().readTeeStore(resultType, Scalar::byteSize(viewType), &addr,
-                             &value)) {
+                             &value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3323,11 +3323,11 @@ static bool EmitUnaryMathBuiltinCall(Fun
   }
 
   CallCompileState call;
-  if (!f.passArg(input, callee.argTypes[0], &call)) {
-    return false;
-  }
-
-  if (!f.finishCall(&call)) {
+  if (!f.passArg(input, callee.argTypes[0], &call)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.finishCall(&call)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3351,19 +3351,19 @@ static bool EmitBinaryMathBuiltinCall(Fu
   MDefinition* lhs;
   MDefinition* rhs;
   // This call to readBinary assumes both operands have the same type.
-  if (!f.iter().readBinary(ValType(callee.argTypes[0]), &lhs, &rhs)) {
-    return false;
-  }
-
-  if (!f.passArg(lhs, callee.argTypes[0], &call)) {
-    return false;
-  }
-
-  if (!f.passArg(rhs, callee.argTypes[1], &call)) {
-    return false;
-  }
-
-  if (!f.finishCall(&call)) {
+  if (!f.iter().readBinary(ValType(callee.argTypes[0]), &lhs, &rhs)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.passArg(lhs, callee.argTypes[0], &call)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.passArg(rhs, callee.argTypes[1], &call)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.finishCall(&call)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3381,7 +3381,7 @@ static bool EmitMemoryGrow(FunctionCompi
 
   const SymbolicAddressSignature& callee = SASigMemoryGrow;
   CallCompileState args;
-  if (!f.passInstance(callee.argTypes[0], &args)) {
+  if (!f.passInstance(callee.argTypes[0], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3390,7 +3390,7 @@ static bool EmitMemoryGrow(FunctionCompi
     return false;
   }
 
-  if (!f.passArg(delta, callee.argTypes[1], &args)) {
+  if (!f.passArg(delta, callee.argTypes[1], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3415,7 +3415,7 @@ static bool EmitMemorySize(FunctionCompi
     return false;
   }
 
-  if (!f.passInstance(callee.argTypes[0], &args)) {
+  if (!f.passInstance(callee.argTypes[0], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3436,7 +3436,7 @@ static bool EmitAtomicCmpXchg(FunctionCo
   MDefinition* oldValue;
   MDefinition* newValue;
   if (!f.iter().readAtomicCmpXchg(&addr, type, byteSize(viewType), &oldValue,
-                                  &newValue)) {
+                                  &newValue)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3455,7 +3455,7 @@ static bool EmitAtomicCmpXchg(FunctionCo
 static bool EmitAtomicLoad(FunctionCompiler& f, ValType type,
                            Scalar::Type viewType) {
   LinearMemoryAddress<MDefinition*> addr;
-  if (!f.iter().readAtomicLoad(&addr, type, byteSize(viewType))) {
+  if (!f.iter().readAtomicLoad(&addr, type, byteSize(viewType))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3474,7 +3474,7 @@ static bool EmitAtomicRMW(FunctionCompil
                           Scalar::Type viewType, jit::AtomicOp op) {
   LinearMemoryAddress<MDefinition*> addr;
   MDefinition* value;
-  if (!f.iter().readAtomicRMW(&addr, type, byteSize(viewType), &value)) {
+  if (!f.iter().readAtomicRMW(&addr, type, byteSize(viewType), &value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3512,38 +3512,38 @@ static bool EmitWait(FunctionCompiler& f
   const SymbolicAddressSignature& callee =
       type == ValType::I32 ? SASigWaitI32 : SASigWaitI64;
   CallCompileState args;
-  if (!f.passInstance(callee.argTypes[0], &args)) {
+  if (!f.passInstance(callee.argTypes[0], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   LinearMemoryAddress<MDefinition*> addr;
   MDefinition* expected;
   MDefinition* timeout;
-  if (!f.iter().readWait(&addr, type, byteSize, &expected, &timeout)) {
+  if (!f.iter().readWait(&addr, type, byteSize, &expected, &timeout)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MemoryAccessDesc access(type == ValType::I32 ? Scalar::Int32 : Scalar::Int64,
                           addr.align, addr.offset, f.bytecodeOffset());
   MDefinition* ptr = f.computeEffectiveAddress(addr.base, &access);
-  if (!f.inDeadCode() && !ptr) {
-    return false;
-  }
-
-  if (!f.passArg(ptr, callee.argTypes[1], &args)) {
+  if (!f.inDeadCode() && !ptr) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.passArg(ptr, callee.argTypes[1], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MOZ_ASSERT(ToMIRType(type) == callee.argTypes[2]);
-  if (!f.passArg(expected, callee.argTypes[2], &args)) {
-    return false;
-  }
-
-  if (!f.passArg(timeout, callee.argTypes[3], &args)) {
-    return false;
-  }
-
-  if (!f.finishCall(&args)) {
+  if (!f.passArg(expected, callee.argTypes[2], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.passArg(timeout, callee.argTypes[3], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.finishCall(&args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3570,32 +3570,32 @@ static bool EmitWake(FunctionCompiler& f
 
   const SymbolicAddressSignature& callee = SASigWake;
   CallCompileState args;
-  if (!f.passInstance(callee.argTypes[0], &args)) {
+  if (!f.passInstance(callee.argTypes[0], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   LinearMemoryAddress<MDefinition*> addr;
   MDefinition* count;
-  if (!f.iter().readWake(&addr, &count)) {
+  if (!f.iter().readWake(&addr, &count)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MemoryAccessDesc access(Scalar::Int32, addr.align, addr.offset,
                           f.bytecodeOffset());
   MDefinition* ptr = f.computeEffectiveAddress(addr.base, &access);
-  if (!f.inDeadCode() && !ptr) {
-    return false;
-  }
-
-  if (!f.passArg(ptr, callee.argTypes[1], &args)) {
-    return false;
-  }
-
-  if (!f.passArg(count, callee.argTypes[2], &args)) {
-    return false;
-  }
-
-  if (!f.finishCall(&args)) {
+  if (!f.inDeadCode() && !ptr) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.passArg(ptr, callee.argTypes[1], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.passArg(count, callee.argTypes[2], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.finishCall(&args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3612,7 +3612,7 @@ static bool EmitAtomicXchg(FunctionCompi
                            Scalar::Type viewType) {
   LinearMemoryAddress<MDefinition*> addr;
   MDefinition* value;
-  if (!f.iter().readAtomicRMW(&addr, type, byteSize(viewType), &value)) {
+  if (!f.iter().readAtomicRMW(&addr, type, byteSize(viewType), &value)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3635,21 +3635,21 @@ static bool EmitMemCopyCall(FunctionComp
       (f.moduleEnv().usesSharedMemory() ? SASigMemCopyShared32
                                         : SASigMemCopy32);
   CallCompileState args;
-  if (!f.passInstance(callee.argTypes[0], &args)) {
-    return false;
-  }
-
-  if (!f.passArg(dst, callee.argTypes[1], &args)) {
-    return false;
-  }
-  if (!f.passArg(src, callee.argTypes[2], &args)) {
-    return false;
-  }
-  if (!f.passArg(len, callee.argTypes[3], &args)) {
+  if (!f.passInstance(callee.argTypes[0], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.passArg(dst, callee.argTypes[1], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(src, callee.argTypes[2], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(len, callee.argTypes[3], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MDefinition* memoryBase = f.memoryBase();
-  if (!f.passArg(memoryBase, callee.argTypes[4], &args)) {
+  if (!f.passArg(memoryBase, callee.argTypes[4], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!f.finishCall(&args)) {
@@ -3689,7 +3689,7 @@ static bool EmitMemCopyInline(FunctionCo
   for (uint32_t i = 0; i < numCopies8; i++) {
     MemoryAccessDesc access(Scalar::Int64, 1, offset, f.bytecodeOffset());
     auto* load = f.load(src, &access, ValType::I64);
-    if (!load || !loadedValues.append(load)) {
+    if (!load || !loadedValues.append(load)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3700,7 +3700,7 @@ static bool EmitMemCopyInline(FunctionCo
   for (uint32_t i = 0; i < numCopies4; i++) {
     MemoryAccessDesc access(Scalar::Uint32, 1, offset, f.bytecodeOffset());
     auto* load = f.load(src, &access, ValType::I32);
-    if (!load || !loadedValues.append(load)) {
+    if (!load || !loadedValues.append(load)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3710,7 +3710,7 @@ static bool EmitMemCopyInline(FunctionCo
   if (numCopies2) {
     MemoryAccessDesc access(Scalar::Uint16, 1, offset, f.bytecodeOffset());
     auto* load = f.load(src, &access, ValType::I32);
-    if (!load || !loadedValues.append(load)) {
+    if (!load || !loadedValues.append(load)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3720,7 +3720,7 @@ static bool EmitMemCopyInline(FunctionCo
   if (numCopies1) {
     MemoryAccessDesc access(Scalar::Uint8, 1, offset, f.bytecodeOffset());
     auto* load = f.load(src, &access, ValType::I32);
-    if (!load || !loadedValues.append(load)) {
+    if (!load || !loadedValues.append(load)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -3776,7 +3776,7 @@ static bool EmitMemCopy(FunctionCompiler
     return false;
   }
 
-  if (f.inDeadCode()) {
+  if (f.inDeadCode()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -3805,31 +3805,31 @@ static bool EmitTableCopy(FunctionCompil
 
   const SymbolicAddressSignature& callee = SASigTableCopy;
   CallCompileState args;
-  if (!f.passInstance(callee.argTypes[0], &args)) {
-    return false;
-  }
-
-  if (!f.passArg(dst, callee.argTypes[1], &args)) {
-    return false;
-  }
-  if (!f.passArg(src, callee.argTypes[2], &args)) {
-    return false;
-  }
-  if (!f.passArg(len, callee.argTypes[3], &args)) {
+  if (!f.passInstance(callee.argTypes[0], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.passArg(dst, callee.argTypes[1], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(src, callee.argTypes[2], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(len, callee.argTypes[3], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MDefinition* dti = f.constant(Int32Value(dstTableIndex), MIRType::Int32);
-  if (!dti) {
-    return false;
-  }
-  if (!f.passArg(dti, callee.argTypes[4], &args)) {
+  if (!dti) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(dti, callee.argTypes[4], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MDefinition* sti = f.constant(Int32Value(srcTableIndex), MIRType::Int32);
-  if (!sti) {
-    return false;
-  }
-  if (!f.passArg(sti, callee.argTypes[5], &args)) {
+  if (!sti) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(sti, callee.argTypes[5], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!f.finishCall(&args)) {
@@ -3854,13 +3854,13 @@ static bool EmitDataOrElemDrop(FunctionC
   const SymbolicAddressSignature& callee =
       isData ? SASigDataDrop : SASigElemDrop;
   CallCompileState args;
-  if (!f.passInstance(callee.argTypes[0], &args)) {
+  if (!f.passInstance(callee.argTypes[0], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MDefinition* segIndex =
       f.constant(Int32Value(int32_t(segIndexVal)), MIRType::Int32);
-  if (!f.passArg(segIndex, callee.argTypes[1], &args)) {
+  if (!f.passArg(segIndex, callee.argTypes[1], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3878,21 +3878,21 @@ static bool EmitMemFillCall(FunctionComp
   const SymbolicAddressSignature& callee =
       f.moduleEnv().usesSharedMemory() ? SASigMemFillShared32 : SASigMemFill32;
   CallCompileState args;
-  if (!f.passInstance(callee.argTypes[0], &args)) {
-    return false;
-  }
-
-  if (!f.passArg(start, callee.argTypes[1], &args)) {
-    return false;
-  }
-  if (!f.passArg(val, callee.argTypes[2], &args)) {
-    return false;
-  }
-  if (!f.passArg(len, callee.argTypes[3], &args)) {
+  if (!f.passInstance(callee.argTypes[0], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.passArg(start, callee.argTypes[1], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(val, callee.argTypes[2], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(len, callee.argTypes[3], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   MDefinition* memoryBase = f.memoryBase();
-  if (!f.passArg(memoryBase, callee.argTypes[4], &args)) {
+  if (!f.passArg(memoryBase, callee.argTypes[4], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4015,31 +4015,31 @@ static bool EmitMemOrTableInit(FunctionC
   const SymbolicAddressSignature& callee =
       isMem ? SASigMemInit32 : SASigTableInit;
   CallCompileState args;
-  if (!f.passInstance(callee.argTypes[0], &args)) {
-    return false;
-  }
-
-  if (!f.passArg(dstOff, callee.argTypes[1], &args)) {
-    return false;
-  }
-  if (!f.passArg(srcOff, callee.argTypes[2], &args)) {
-    return false;
-  }
-  if (!f.passArg(len, callee.argTypes[3], &args)) {
+  if (!f.passInstance(callee.argTypes[0], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.passArg(dstOff, callee.argTypes[1], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(srcOff, callee.argTypes[2], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(len, callee.argTypes[3], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MDefinition* segIndex =
       f.constant(Int32Value(int32_t(segIndexVal)), MIRType::Int32);
-  if (!f.passArg(segIndex, callee.argTypes[4], &args)) {
+  if (!f.passArg(segIndex, callee.argTypes[4], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!isMem) {
     MDefinition* dti = f.constant(Int32Value(dstTableIndex), MIRType::Int32);
-    if (!dti) {
+    if (!dti) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!f.passArg(dti, callee.argTypes[5], &args)) {
+    if (!f.passArg(dti, callee.argTypes[5], &args)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -4061,7 +4061,7 @@ static bool EmitTableFill(FunctionCompil
     return false;
   }
 
-  if (f.inDeadCode()) {
+  if (f.inDeadCode()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -4069,26 +4069,26 @@ static bool EmitTableFill(FunctionCompil
 
   const SymbolicAddressSignature& callee = SASigTableFill;
   CallCompileState args;
-  if (!f.passInstance(callee.argTypes[0], &args)) {
-    return false;
-  }
-
-  if (!f.passArg(start, callee.argTypes[1], &args)) {
-    return false;
-  }
-  if (!f.passArg(val, callee.argTypes[2], &args)) {
-    return false;
-  }
-  if (!f.passArg(len, callee.argTypes[3], &args)) {
+  if (!f.passInstance(callee.argTypes[0], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.passArg(start, callee.argTypes[1], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(val, callee.argTypes[2], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(len, callee.argTypes[3], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MDefinition* tableIndexArg =
       f.constant(Int32Value(tableIndex), MIRType::Int32);
-  if (!tableIndexArg) {
-    return false;
-  }
-  if (!f.passArg(tableIndexArg, callee.argTypes[4], &args)) {
+  if (!tableIndexArg) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(tableIndexArg, callee.argTypes[4], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4114,24 +4114,24 @@ static bool EmitTableGet(FunctionCompile
 
   const SymbolicAddressSignature& callee = SASigTableGet;
   CallCompileState args;
-  if (!f.passInstance(callee.argTypes[0], &args)) {
-    return false;
-  }
-
-  if (!f.passArg(index, callee.argTypes[1], &args)) {
+  if (!f.passInstance(callee.argTypes[0], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.passArg(index, callee.argTypes[1], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MDefinition* tableIndexArg =
       f.constant(Int32Value(tableIndex), MIRType::Int32);
-  if (!tableIndexArg) {
-    return false;
-  }
-  if (!f.passArg(tableIndexArg, callee.argTypes[2], &args)) {
-    return false;
-  }
-
-  if (!f.finishCall(&args)) {
+  if (!tableIndexArg) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(tableIndexArg, callee.argTypes[2], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.finishCall(&args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4162,28 +4162,28 @@ static bool EmitTableGrow(FunctionCompil
 
   const SymbolicAddressSignature& callee = SASigTableGrow;
   CallCompileState args;
-  if (!f.passInstance(callee.argTypes[0], &args)) {
-    return false;
-  }
-
-  if (!f.passArg(initValue, callee.argTypes[1], &args)) {
-    return false;
-  }
-
-  if (!f.passArg(delta, callee.argTypes[2], &args)) {
+  if (!f.passInstance(callee.argTypes[0], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.passArg(initValue, callee.argTypes[1], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.passArg(delta, callee.argTypes[2], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MDefinition* tableIndexArg =
       f.constant(Int32Value(tableIndex), MIRType::Int32);
-  if (!tableIndexArg) {
-    return false;
-  }
-  if (!f.passArg(tableIndexArg, callee.argTypes[3], &args)) {
-    return false;
-  }
-
-  if (!f.finishCall(&args)) {
+  if (!tableIndexArg) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(tableIndexArg, callee.argTypes[3], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.finishCall(&args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4212,24 +4212,24 @@ static bool EmitTableSet(FunctionCompile
 
   const SymbolicAddressSignature& callee = SASigTableSet;
   CallCompileState args;
-  if (!f.passInstance(callee.argTypes[0], &args)) {
-    return false;
-  }
-
-  if (!f.passArg(index, callee.argTypes[1], &args)) {
-    return false;
-  }
-
-  if (!f.passArg(value, callee.argTypes[2], &args)) {
+  if (!f.passInstance(callee.argTypes[0], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.passArg(index, callee.argTypes[1], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.passArg(value, callee.argTypes[2], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MDefinition* tableIndexArg =
       f.constant(Int32Value(tableIndex), MIRType::Int32);
-  if (!tableIndexArg) {
-    return false;
-  }
-  if (!f.passArg(tableIndexArg, callee.argTypes[3], &args)) {
+  if (!tableIndexArg) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(tableIndexArg, callee.argTypes[3], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4254,20 +4254,20 @@ static bool EmitTableSize(FunctionCompil
 
   const SymbolicAddressSignature& callee = SASigTableSize;
   CallCompileState args;
-  if (!f.passInstance(callee.argTypes[0], &args)) {
+  if (!f.passInstance(callee.argTypes[0], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MDefinition* tableIndexArg =
       f.constant(Int32Value(tableIndex), MIRType::Int32);
-  if (!tableIndexArg) {
-    return false;
-  }
-  if (!f.passArg(tableIndexArg, callee.argTypes[1], &args)) {
-    return false;
-  }
-
-  if (!f.finishCall(&args)) {
+  if (!tableIndexArg) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(tableIndexArg, callee.argTypes[1], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.finishCall(&args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4286,7 +4286,7 @@ static bool EmitRefFunc(FunctionCompiler
     return false;
   }
 
-  if (f.inDeadCode()) {
+  if (f.inDeadCode()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -4294,19 +4294,19 @@ static bool EmitRefFunc(FunctionCompiler
 
   const SymbolicAddressSignature& callee = SASigRefFunc;
   CallCompileState args;
-  if (!f.passInstance(callee.argTypes[0], &args)) {
+  if (!f.passInstance(callee.argTypes[0], &args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   MDefinition* funcIndexArg = f.constant(Int32Value(funcIndex), MIRType::Int32);
-  if (!funcIndexArg) {
-    return false;
-  }
-  if (!f.passArg(funcIndexArg, callee.argTypes[1], &args)) {
-    return false;
-  }
-
-  if (!f.finishCall(&args)) {
+  if (!funcIndexArg) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (!f.passArg(funcIndexArg, callee.argTypes[1], &args)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+
+  if (!f.finishCall(&args)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4552,7 +4552,7 @@ static bool EmitStoreLaneSimd128(Functio
 #endif
 
 static bool EmitBodyExprs(FunctionCompiler& f) {
-  if (!f.iter().readFunctionStart(f.funcIndex())) {
+  if (!f.iter().readFunctionStart(f.funcIndex())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4561,7 +4561,7 @@ static bool EmitBodyExprs(FunctionCompil
   break
 
   while (true) {
-    if (!f.mirGen().ensureBallast()) {
+    if (!f.mirGen().ensureBallast()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -5696,7 +5696,7 @@ bool wasm::IonCompileFunctions(const Mod
 
   // Swap in already-allocated empty vectors to avoid malloc/free.
   MOZ_ASSERT(code->empty());
-  if (!code->swap(masm)) {
+  if (!code->swap(masm)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -5722,7 +5722,7 @@ bool wasm::IonCompileFunctions(const Mod
     const FuncType& funcType = *moduleEnv.funcs[func.index].type;
     const TypeIdDesc& funcTypeId = *moduleEnv.funcs[func.index].typeId;
     ValTypeVector locals;
-    if (!locals.appendAll(funcType.args())) {
+    if (!locals.appendAll(funcType.args())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!DecodeLocalEntries(d, moduleEnv.types, moduleEnv.features, &locals)) {
@@ -5741,11 +5741,11 @@ bool wasm::IonCompileFunctions(const Mod
     // Build MIR graph
     {
       FunctionCompiler f(moduleEnv, d, func, locals, mir);
-      if (!f.init()) {
+      if (!f.init()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
-      if (!f.startBlock()) {
+      if (!f.startBlock()) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -5761,12 +5761,12 @@ bool wasm::IonCompileFunctions(const Mod
       jit::SpewBeginWasmFunction(&mir, func.index);
       jit::AutoSpewEndFunction spewEndFunction(&mir);
 
-      if (!OptimizeMIR(&mir)) {
+      if (!OptimizeMIR(&mir)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       LIRGraph* lir = GenerateLIR(&mir);
-      if (!lir) {
+      if (!lir) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -5777,12 +5777,12 @@ bool wasm::IonCompileFunctions(const Mod
       ArgTypeVector args(funcType);
       if (!codegen.generateWasm(funcTypeId, prologueTrapOffset, args,
                                 trapExitLayout, trapExitLayoutNumWords,
-                                &offsets, &code->stackMaps)) {
+                                &offsets, &code->stackMaps)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       if (!code->codeRanges.emplaceBack(func.index, func.lineOrBytecode,
-                                        offsets)) {
+                                        offsets)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
diff --git a/js/src/wasm/WasmJS.cpp b/js/src/wasm/WasmJS.cpp
--- a/js/src/wasm/WasmJS.cpp
+++ b/js/src/wasm/WasmJS.cpp
@@ -312,13 +312,13 @@ bool wasm::IonDisabledByFeatures(JSConte
   bool exn = WasmExceptionsFlag(cx);
   if (reason) {
     char sep = 0;
-    if (debug && !Append(reason, "debug", &sep)) {
+    if (debug && !Append(reason, "debug", &sep)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (functionReferences && !Append(reason, "function-references", &sep)) {
+    if (functionReferences && !Append(reason, "function-references", &sep)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (gc && !Append(reason, "gc", &sep)) {
+    if (gc && !Append(reason, "gc", &sep)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (exn && !Append(reason, "exceptions", &sep)) {
@@ -354,16 +354,16 @@ bool wasm::CraneliftDisabledByFeatures(J
   bool exn = WasmExceptionsFlag(cx);
   if (reason) {
     char sep = 0;
-    if (debug && !Append(reason, "debug", &sep)) {
+    if (debug && !Append(reason, "debug", &sep)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (functionReferences && !Append(reason, "function-references", &sep)) {
+    if (functionReferences && !Append(reason, "function-references", &sep)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (gc && !Append(reason, "gc", &sep)) {
+    if (gc && !Append(reason, "gc", &sep)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (simdOnNonAarch64 && !Append(reason, "simd", &sep)) {
+    if (simdOnNonAarch64 && !Append(reason, "simd", &sep)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (exn && !Append(reason, "exceptions", &sep)) {
@@ -455,28 +455,28 @@ bool wasm::HasPlatformSupport(JSContext*
   return false;
 #endif
 
-  if (gc::SystemPageSize() > wasm::PageSize) {
+  if (gc::SystemPageSize() > wasm::PageSize) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!JitOptions.supportsFloatingPoint) {
+  if (!JitOptions.supportsFloatingPoint) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!JitOptions.supportsUnalignedAccesses) {
+  if (!JitOptions.supportsUnalignedAccesses) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!wasm::EnsureFullSignalHandlers(cx)) {
+  if (!wasm::EnsureFullSignalHandlers(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!jit::JitSupportsAtomics()) {
+  if (!jit::JitSupportsAtomics()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Wasm threads require 8-byte lock-free atomics.
-  if (!jit::AtomicOperations::isLockfree8()) {
+  if (!jit::AtomicOperations::isLockfree8()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -566,7 +566,7 @@ bool js::wasm::GetImports(JSContext* cx,
   const TableDescVector& tables = metadata.tables;
   for (const Import& import : module.imports()) {
     RootedValue v(cx);
-    if (!GetProperty(cx, importObj, import.module.get(), &v)) {
+    if (!GetProperty(cx, importObj, import.module.get(), &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -578,7 +578,7 @@ bool js::wasm::GetImports(JSContext* cx,
     }
 
     RootedObject obj(cx, &v.toObject());
-    if (!GetProperty(cx, obj, import.field.get(), &v)) {
+    if (!GetProperty(cx, obj, import.field.get(), &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -745,7 +745,7 @@ static bool ParseCompileOptions(JSContex
     if (maybeOptions.isObject()) {
       RootedValue wormholeVal(cx);
       RootedObject obj(cx, &maybeOptions.toObject());
-      if (!JS_GetProperty(cx, obj, "simdWormhole", &wormholeVal)) {
+      if (!JS_GetProperty(cx, obj, "simdWormhole", &wormholeVal)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (wormholeVal.isBoolean()) {
@@ -760,7 +760,7 @@ static SharedCompileArgs InitCompileArgs
                                          HandleValue maybeOptions,
                                          const char* introducer) {
   ScriptedCaller scriptedCaller;
-  if (!DescribeScriptedCaller(cx, &scriptedCaller, introducer)) {
+  if (!DescribeScriptedCaller(cx, &scriptedCaller, introducer)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -777,40 +777,40 @@ static SharedCompileArgs InitCompileArgs
 bool wasm::Eval(JSContext* cx, Handle<TypedArrayObject*> code,
                 HandleObject importObj, HandleValue maybeOptions,
                 MutableHandleWasmInstanceObject instanceObj) {
-  if (!GlobalObject::ensureConstructor(cx, cx->global(), JSProto_WebAssembly)) {
+  if (!GlobalObject::ensureConstructor(cx, cx->global(), JSProto_WebAssembly)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   MutableBytes bytecode = cx->new_<ShareableBytes>();
-  if (!bytecode) {
+  if (!bytecode) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   if (!bytecode->append((uint8_t*)code->dataPointerEither().unwrap(),
-                        code->byteLength().get())) {
+                        code->byteLength().get())) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   SharedCompileArgs compileArgs =
       InitCompileArgs(cx, maybeOptions, "wasm_eval");
-  if (!compileArgs) {
+  if (!compileArgs) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   UniqueChars error;
   UniqueCharsVector warnings;
   SharedModule module =
       CompileBuffer(*compileArgs, *bytecode, &error, &warnings, nullptr);
-  if (!module) {
-    if (error) {
+  if (!module) {MOZ_RELEASE_ASSERT(0);
+    if (error) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberUTF8(cx, GetErrorMessage, nullptr,
                                JSMSG_WASM_COMPILE_ERROR, error.get());
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   Rooted<ImportValues> imports(cx);
   if (!GetImports(cx, *module, importObj, imports.address())) {
@@ -841,7 +841,7 @@ struct MOZ_STACK_CLASS SerializeListener
 bool wasm::CompileAndSerialize(const ShareableBytes& bytecode,
                                Bytes* serialized) {
   MutableCompileArgs compileArgs = js_new<CompileArgs>(ScriptedCaller());
-  if (!compileArgs) {
+  if (!compileArgs) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -899,12 +899,12 @@ static bool EnforceRangeU32(JSContext* c
                             const char* noun, uint32_t* u32) {
   // Step 4.
   double x;
-  if (!ToNumber(cx, v, &x)) {
+  if (!ToNumber(cx, v, &x)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Step 5.
-  if (mozilla::IsNegativeZero(x)) {
+  if (mozilla::IsNegativeZero(x)) {MOZ_RELEASE_ASSERT(0);
     x = 0.0;
   }
 
@@ -933,13 +933,13 @@ static bool EnforceRangeU32(JSContext* c
 static bool GetLimits(JSContext* cx, HandleObject obj, uint32_t maximumField,
                       const char* kind, Limits* limits, Shareable allowShared) {
   JSAtom* initialAtom = Atomize(cx, "initial", strlen("initial"));
-  if (!initialAtom) {
+  if (!initialAtom) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedId initialId(cx, AtomToId(initialAtom));
 
   RootedValue initialVal(cx);
-  if (!GetProperty(cx, obj, obj, initialId, &initialVal)) {
+  if (!GetProperty(cx, obj, obj, initialId, &initialVal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -959,7 +959,7 @@ static bool GetLimits(JSContext* cx, Han
 #ifdef ENABLE_WASM_TYPE_REFLECTIONS
   // Get minimum parameter.
   JSAtom* minimumAtom = Atomize(cx, "minimum", strlen("minimum"));
-  if (!minimumAtom) {
+  if (!minimumAtom) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedId minimumId(cx, AtomToId(minimumAtom));
@@ -971,7 +971,7 @@ static bool GetLimits(JSContext* cx, Han
 
   uint32_t minimum = 0;
   if (!minimumVal.isUndefined() &&
-      !EnforceRangeU32(cx, minimumVal, kind, "initial size", &minimum)) {
+      !EnforceRangeU32(cx, minimumVal, kind, "initial size", &minimum)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!minimumVal.isUndefined()) {
@@ -981,13 +981,13 @@ static bool GetLimits(JSContext* cx, Han
 
   // Get maximum parameter.
   JSAtom* maximumAtom = Atomize(cx, "maximum", strlen("maximum"));
-  if (!maximumAtom) {
+  if (!maximumAtom) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedId maximumId(cx, AtomToId(maximumAtom));
 
   RootedValue maxVal(cx);
-  if (!GetProperty(cx, obj, obj, maximumId, &maxVal)) {
+  if (!GetProperty(cx, obj, obj, maximumId, &maxVal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1010,13 +1010,13 @@ static bool GetLimits(JSContext* cx, Han
 
   if (allowShared == Shareable::True) {
     JSAtom* sharedAtom = Atomize(cx, "shared", strlen("shared"));
-    if (!sharedAtom) {
+    if (!sharedAtom) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     RootedId sharedId(cx, AtomToId(sharedAtom));
 
     RootedValue sharedVal(cx);
-    if (!GetProperty(cx, obj, obj, sharedId, &sharedVal)) {
+    if (!GetProperty(cx, obj, obj, sharedId, &sharedVal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1034,7 +1034,7 @@ static bool GetLimits(JSContext* cx, Han
 
         if (!cx->realm()
                  ->creationOptions()
-                 .getSharedMemoryAndAtomicsEnabled()) {
+                 .getSharedMemoryAndAtomicsEnabled()) {MOZ_RELEASE_ASSERT(0);
           JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                     JSMSG_WASM_NO_SHMEM_LINK);
           return false;
@@ -1170,26 +1170,26 @@ struct KindNames {
 
 static bool InitKindNames(JSContext* cx, KindNames* names) {
   JSAtom* kind = Atomize(cx, "kind", strlen("kind"));
-  if (!kind) {
+  if (!kind) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   names->kind = kind->asPropertyName();
 
   JSAtom* table = Atomize(cx, "table", strlen("table"));
-  if (!table) {
+  if (!table) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   names->table = table->asPropertyName();
 
   JSAtom* memory = Atomize(cx, "memory", strlen("memory"));
-  if (!memory) {
+  if (!memory) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   names->memory = memory->asPropertyName();
 
 #ifdef ENABLE_WASM_EXCEPTIONS
   JSAtom* event = Atomize(cx, "event", strlen("event"));
-  if (!event) {
+  if (!event) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   names->event = event->asPropertyName();
@@ -1226,44 +1226,44 @@ static JSString* KindToString(JSContext*
 
 static JSString* FuncTypeToString(JSContext* cx, const FuncType& funcType) {
   JSStringBuilder buf(cx);
-  if (!buf.append('(')) {
+  if (!buf.append('(')) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   bool first = true;
   for (ValType arg : funcType.args()) {
-    if (!first && !buf.append(", ", strlen(", "))) {
+    if (!first && !buf.append(", ", strlen(", "))) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     UniqueChars argStr = ToString(arg);
-    if (!argStr) {
+    if (!argStr) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (!buf.append(argStr.get(), strlen(argStr.get()))) {
+    if (!buf.append(argStr.get(), strlen(argStr.get()))) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     first = false;
   }
 
-  if (!buf.append(") -> (", strlen(") -> ("))) {
+  if (!buf.append(") -> (", strlen(") -> ("))) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   first = true;
   for (ValType result : funcType.results()) {
-    if (!first && !buf.append(", ", strlen(", "))) {
+    if (!first && !buf.append(", ", strlen(", "))) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     UniqueChars resultStr = ToString(result);
-    if (!resultStr) {
+    if (!resultStr) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
-    if (!buf.append(resultStr.get(), strlen(resultStr.get()))) {
+    if (!buf.append(resultStr.get(), strlen(resultStr.get()))) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1292,12 +1292,12 @@ bool WasmModuleObject::imports(JSContext
   }
 
   KindNames names(cx);
-  if (!InitKindNames(cx, &names)) {
+  if (!InitKindNames(cx, &names)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedValueVector elems(cx);
-  if (!elems.reserve(module->imports().length())) {
+  if (!elems.reserve(module->imports().length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1307,46 +1307,46 @@ bool WasmModuleObject::imports(JSContext
   size_t numFuncImport = 0;
   for (const Import& import : module->imports()) {
     Rooted<IdValueVector> props(cx, IdValueVector(cx));
-    if (!props.reserve(3)) {
+    if (!props.reserve(3)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     JSString* moduleStr = UTF8CharsToString(cx, import.module.get());
-    if (!moduleStr) {
+    if (!moduleStr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     props.infallibleAppend(
         IdValuePair(NameToId(cx->names().module), StringValue(moduleStr)));
 
     JSString* nameStr = UTF8CharsToString(cx, import.field.get());
-    if (!nameStr) {
+    if (!nameStr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     props.infallibleAppend(
         IdValuePair(NameToId(cx->names().name), StringValue(nameStr)));
 
     JSString* kindStr = KindToString(cx, names, import.kind);
-    if (!kindStr) {
+    if (!kindStr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     props.infallibleAppend(
         IdValuePair(NameToId(names.kind), StringValue(kindStr)));
 
-    if (fuzzingSafe && import.kind == DefinitionKind::Function) {
+    if (fuzzingSafe && import.kind == DefinitionKind::Function) {MOZ_RELEASE_ASSERT(0);
       JSString* ftStr =
           FuncTypeToString(cx, funcImports[numFuncImport++].funcType());
-      if (!ftStr) {
+      if (!ftStr) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       if (!props.append(
-              IdValuePair(NameToId(names.signature), StringValue(ftStr)))) {
+              IdValuePair(NameToId(names.signature), StringValue(ftStr)))) {MOZ_RELEASE_ASSERT(0);
         return false;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
     JSObject* obj = NewPlainObjectWithProperties(cx, props.begin(),
                                                  props.length(), GenericObject);
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1372,30 +1372,30 @@ bool WasmModuleObject::exports(JSContext
   }
 
   KindNames names(cx);
-  if (!InitKindNames(cx, &names)) {
+  if (!InitKindNames(cx, &names)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedValueVector elems(cx);
-  if (!elems.reserve(module->exports().length())) {
+  if (!elems.reserve(module->exports().length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   for (const Export& exp : module->exports()) {
     Rooted<IdValueVector> props(cx, IdValueVector(cx));
-    if (!props.reserve(2)) {
+    if (!props.reserve(2)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     JSString* nameStr = UTF8CharsToString(cx, exp.fieldName());
-    if (!nameStr) {
+    if (!nameStr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     props.infallibleAppend(
         IdValuePair(NameToId(cx->names().name), StringValue(nameStr)));
 
     JSString* kindStr = KindToString(cx, names, exp.kind());
-    if (!kindStr) {
+    if (!kindStr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     props.infallibleAppend(
@@ -1405,18 +1405,18 @@ bool WasmModuleObject::exports(JSContext
       const FuncExport& fe = module->metadata(module->code().stableTier())
                                  .lookupFuncExport(exp.funcIndex());
       JSString* ftStr = FuncTypeToString(cx, fe.funcType());
-      if (!ftStr) {
+      if (!ftStr) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (!props.append(
-              IdValuePair(NameToId(names.signature), StringValue(ftStr)))) {
+              IdValuePair(NameToId(names.signature), StringValue(ftStr)))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
 
     JSObject* obj = NewPlainObjectWithProperties(cx, props.begin(),
                                                  props.length(), GenericObject);
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1445,17 +1445,17 @@ bool WasmModuleObject::customSections(JS
   Vector<char, 8> name(cx);
   {
     RootedString str(cx, ToString(cx, args.get(1)));
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     Rooted<JSLinearString*> linear(cx, str->ensureLinear(cx));
-    if (!linear) {
+    if (!linear) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (!name.initLengthUninitialized(
-            JS::GetDeflatedUTF8StringLength(linear))) {
+            JS::GetDeflatedUTF8StringLength(linear))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1474,12 +1474,12 @@ bool WasmModuleObject::customSections(JS
     }
 
     buf = ArrayBufferObject::createZeroed(cx, BufferSize(cs.payload->length()));
-    if (!buf) {
+    if (!buf) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     memcpy(buf->dataPointer(), cs.payload->begin(), cs.payload->length());
-    if (!elems.append(ObjectValue(*buf))) {
+    if (!elems.append(ObjectValue(*buf))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1519,7 +1519,7 @@ WasmModuleObject* WasmModuleObject::crea
 static bool GetBufferSource(JSContext* cx, JSObject* obj, unsigned errorNumber,
                             MutableBytes* bytecode) {
   *bytecode = cx->new_<ShareableBytes>();
-  if (!*bytecode) {
+  if (!*bytecode) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1546,12 +1546,12 @@ static bool ReportCompileWarnings(JSCont
   size_t numWarnings = std::min<size_t>(warnings.length(), 3);
 
   for (size_t i = 0; i < numWarnings; i++) {
-    if (!WarnNumberASCII(cx, JSMSG_WASM_COMPILE_WARNING, warnings[i].get())) {
+    if (!WarnNumberASCII(cx, JSMSG_WASM_COMPILE_WARNING, warnings[i].get())) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (warnings.length() > numWarnings) {
+  if (warnings.length() > numWarnings) {MOZ_RELEASE_ASSERT(0);
     if (!WarnNumberASCII(cx, JSMSG_WASM_COMPILE_WARNING,
                          "other warnings suppressed")) {
       return false;
@@ -1602,18 +1602,18 @@ bool WasmModuleObject::construct(JSConte
       JS_ReportErrorNumberUTF8(cx, GetErrorMessage, nullptr,
                                JSMSG_WASM_COMPILE_ERROR, error.get());
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
 
-  if (!ReportCompileWarnings(cx, warnings)) {
+  if (!ReportCompileWarnings(cx, warnings)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject proto(cx);
   if (!GetPrototypeFromBuiltinConstructor(cx, callArgs, JSProto_WasmModule,
-                                          &proto)) {
+                                          &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!proto) {
@@ -1761,14 +1761,14 @@ WasmInstanceObject* WasmInstanceObject::
     const WasmGlobalObjectVector& globalObjs, HandleObject proto,
     UniqueDebugState maybeDebug) {
   UniquePtr<ExportMap> exports = js::MakeUnique<ExportMap>(cx->zone());
-  if (!exports) {
+  if (!exports) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
 
   UniquePtr<WasmFunctionScopeMap> scopes =
       js::MakeUnique<WasmFunctionScopeMap>(cx->zone(), cx->zone());
-  if (!scopes) {
+  if (!scopes) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -1783,7 +1783,7 @@ WasmInstanceObject* WasmInstanceObject::
 
   Rooted<UniquePtr<GlobalObjectVector>> indirectGlobalObjs(
       cx, js::MakeUnique<GlobalObjectVector>(cx->zone()));
-  if (!indirectGlobalObjs || !indirectGlobalObjs->resize(indirectGlobals)) {
+  if (!indirectGlobalObjs || !indirectGlobalObjs->resize(indirectGlobals)) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -1806,7 +1806,7 @@ WasmInstanceObject* WasmInstanceObject::
     // calling Instance::init as that may allocate new objects.
     AutoSetNewObjectMetadata metadata(cx);
     obj = NewObjectWithGivenProto<WasmInstanceObject>(cx, proto);
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1832,7 +1832,7 @@ WasmInstanceObject* WasmInstanceObject::
     instance = cx->new_<Instance>(cx, obj, code, std::move(tlsData), memory,
                                   std::move(exceptionTags), std::move(tables),
                                   std::move(maybeDebug));
-    if (!instance) {
+    if (!instance) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -1893,7 +1893,7 @@ bool WasmInstanceObject::construct(JSCon
 
   RootedObject instanceProto(cx);
   if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_WasmInstance,
-                                          &instanceProto)) {
+                                          &instanceProto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!instanceProto) {
@@ -2210,13 +2210,13 @@ bool WasmInstanceObject::getExportedFunc
     // asm.js needs to act like a normal JS function which means having the
     // name from the original source and being callable as a constructor.
     RootedAtom name(cx, instance.getFuncDisplayAtom(cx, funcIndex));
-    if (!name) {
+    if (!name) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     fun.set(NewNativeConstructor(cx, WasmCall, numArgs, name,
                                  gc::AllocKind::FUNCTION_EXTENDED,
                                  TenuredObject, FunctionFlags::ASMJS_CTOR));
-    if (!fun) {
+    if (!fun) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2224,14 +2224,14 @@ bool WasmInstanceObject::getExportedFunc
     fun->setWasmFuncIndex(funcIndex);
   } else {
     RootedAtom name(cx, NumberToAtom(cx, funcIndex));
-    if (!name) {
+    if (!name) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     fun.set(NewNativeFunction(cx, WasmCall, numArgs, name,
                               gc::AllocKind::FUNCTION_EXTENDED, TenuredObject,
                               FunctionFlags::WASM));
-    if (!fun) {
+    if (!fun) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2242,7 +2242,7 @@ bool WasmInstanceObject::getExportedFunc
     // until Instance::callExport() to create the fast entry stubs.
     if (funcExport.canHaveJitEntry()) {
       if (!funcExport.hasEagerStubs()) {
-        if (!EnsureBuiltinThunksInitialized()) {
+        if (!EnsureBuiltinThunksInitialized()) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         void* provisionalLazyJitEntryStub = ProvisionalLazyJitEntryStub();
@@ -2309,13 +2309,13 @@ WasmFunctionScope* WasmInstanceObject::g
 
   Rooted<WasmInstanceScope*> instanceScope(
       cx, WasmInstanceObject::getScope(cx, instanceObj));
-  if (!instanceScope) {
+  if (!instanceScope) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   Rooted<WasmFunctionScope*> funcScope(
       cx, WasmFunctionScope::create(cx, instanceScope, funcIndex));
-  if (!funcScope) {
+  if (!funcScope) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2450,7 +2450,7 @@ bool WasmMemoryObject::construct(JSConte
 
   RootedObject proto(cx);
   if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_WasmMemory,
-                                          &proto)) {
+                                          &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!proto) {
@@ -2486,7 +2486,7 @@ bool WasmMemoryObject::bufferGetterImpl(
           cx,
           SharedArrayBufferObject::New(cx, memoryObj->sharedArrayRawBuffer(),
                                        BufferSize(memoryLength)));
-      if (!newBuffer) {
+      if (!newBuffer) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       // OK to addReference after we try to allocate because the memoryObj
@@ -2577,7 +2577,7 @@ bool WasmMemoryObject::typeImpl(JSContex
   if (bufferMaxSize.isSome()) {
     uint32_t maximumPages = bufferMaxSize.value() / wasm::PageSize;
     if (!props.append(IdValuePair(NameToId(cx->names().maximum),
-                                  Int32Value(maximumPages)))) {
+                                  Int32Value(maximumPages)))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2585,12 +2585,12 @@ bool WasmMemoryObject::typeImpl(JSContex
   uint32_t minimumPages = mozilla::AssertedCast<uint32_t>(
       memoryObj->volatileMemoryLength().get() / wasm::PageSize);
   if (!props.append(IdValuePair(NameToId(cx->names().minimum),
-                                Int32Value(minimumPages)))) {
+                                Int32Value(minimumPages)))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (!props.append(IdValuePair(NameToId(cx->names().shared),
-                                BooleanValue(memoryObj->isShared())))) {
+                                BooleanValue(memoryObj->isShared())))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2687,7 +2687,7 @@ bool WasmMemoryObject::addMovingGrowObse
   MOZ_ASSERT(movingGrowable());
 
   InstanceSet* observers = getOrCreateObservers(cx);
-  if (!observers) {
+  if (!observers) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2711,7 +2711,7 @@ uint32_t WasmMemoryObject::growShared(Ha
   CheckedInt<size_t> newSize = oldNumPages;
   newSize += delta;
   newSize *= PageSize;
-  if (!newSize.isValid()) {
+  if (!newSize.isValid()) {MOZ_RELEASE_ASSERT(0);
     return -1;
   }
 
@@ -2760,7 +2760,7 @@ uint32_t WasmMemoryObject::grow(HandleWa
   CheckedInt<size_t> newSize = oldNumPages;
   newSize += delta;
   newSize *= PageSize;
-  if (!newSize.isValid()) {
+  if (!newSize.isValid()) {MOZ_RELEASE_ASSERT(0);
     return -1;
   }
 
@@ -2775,7 +2775,7 @@ uint32_t WasmMemoryObject::grow(HandleWa
   if (memory->movingGrowable()) {
     MOZ_ASSERT(!memory->isHuge());
     if (!ArrayBufferObject::wasmMovingGrowToSize(BufferSize(newSize.value()),
-                                                 oldBuf, &newBuf, cx)) {
+                                                 oldBuf, &newBuf, cx)) {MOZ_RELEASE_ASSERT(0);
       return -1;
     }
   } else {
@@ -2786,7 +2786,7 @@ uint32_t WasmMemoryObject::grow(HandleWa
     }
 
     if (!ArrayBufferObject::wasmGrowToSizeInPlace(BufferSize(newSize.value()),
-                                                  oldBuf, &newBuf, cx)) {
+                                                  oldBuf, &newBuf, cx)) {MOZ_RELEASE_ASSERT(0);
       return -1;
     }
   }
@@ -2887,7 +2887,7 @@ WasmTableObject* WasmTableObject::create
   AutoSetNewObjectMetadata metadata(cx);
   RootedWasmTableObject obj(
       cx, NewObjectWithGivenProto<WasmTableObject>(cx, proto));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2931,23 +2931,23 @@ bool WasmTableObject::construct(JSContex
   RootedObject obj(cx, &args[0].toObject());
 
   JSAtom* elementAtom = Atomize(cx, "element", strlen("element"));
-  if (!elementAtom) {
+  if (!elementAtom) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   RootedId elementId(cx, AtomToId(elementAtom));
 
   RootedValue elementVal(cx);
-  if (!GetProperty(cx, obj, obj, elementId, &elementVal)) {
+  if (!GetProperty(cx, obj, obj, elementId, &elementVal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedString elementStr(cx, ToString(cx, elementVal));
-  if (!elementStr) {
+  if (!elementStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedLinearString elementLinearStr(cx, elementStr->ensureLinear(cx));
-  if (!elementLinearStr) {
+  if (!elementLinearStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2957,7 +2957,7 @@ bool WasmTableObject::construct(JSContex
     tableType = RefType::func();
 #ifdef ENABLE_WASM_REFTYPES
   } else if (StringEqualsLiteral(elementLinearStr, "externref")) {
-    if (!ReftypesAvailable(cx)) {
+    if (!ReftypesAvailable(cx)) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberUTF8(cx, GetErrorMessage, nullptr,
                                JSMSG_WASM_BAD_ELEMENT);
       return false;
@@ -2966,7 +2966,7 @@ bool WasmTableObject::construct(JSContex
 #endif
 #ifdef ENABLE_WASM_GC
   } else if (StringEqualsLiteral(elementLinearStr, "eqref")) {
-    if (!GcTypesAvailable(cx)) {
+    if (!GcTypesAvailable(cx)) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorNumberUTF8(cx, GetErrorMessage, nullptr,
                                JSMSG_WASM_BAD_ELEMENT);
       return false;
@@ -2998,7 +2998,7 @@ bool WasmTableObject::construct(JSContex
 
   RootedObject proto(cx);
   if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_WasmTable,
-                                          &proto)) {
+                                          &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!proto) {
@@ -3016,7 +3016,7 @@ bool WasmTableObject::construct(JSContex
   RootedWasmTableObject table(
       cx, WasmTableObject::create(cx, initialLength, maximumLength, tableType,
                                   proto));
-  if (!table) {
+  if (!table) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3096,23 +3096,23 @@ bool WasmTableObject::typeImpl(JSContext
       MOZ_CRASH("Should not happen");
   }
   JSString* elementString = UTF8CharsToString(cx, elementValue);
-  if (!elementString) {
+  if (!elementString) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!props.append(IdValuePair(NameToId(cx->names().element),
-                                StringValue(elementString)))) {
+                                StringValue(elementString)))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (table.maximum().isSome()) {
     if (!props.append(IdValuePair(NameToId(cx->names().maximum),
-                                  Int32Value(table.maximum().value())))) {
+                                  Int32Value(table.maximum().value())))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
   if (!props.append(IdValuePair(NameToId(cx->names().minimum),
-                                Int32Value(table.length())))) {
+                                Int32Value(table.length())))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3372,7 +3372,7 @@ WasmGlobalObject* WasmGlobalObject::crea
   AutoSetNewObjectMetadata metadata(cx);
   RootedWasmGlobalObject obj(
       cx, NewObjectWithGivenProto<WasmGlobalObject>(cx, proto));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -3419,22 +3419,22 @@ bool WasmGlobalObject::construct(JSConte
   // Extract properties in lexicographic order per spec.
 
   RootedValue mutableVal(cx);
-  if (!JS_GetProperty(cx, obj, "mutable", &mutableVal)) {
+  if (!JS_GetProperty(cx, obj, "mutable", &mutableVal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedValue typeVal(cx);
-  if (!JS_GetProperty(cx, obj, "value", &typeVal)) {
+  if (!JS_GetProperty(cx, obj, "value", &typeVal)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedString typeStr(cx, ToString(cx, typeVal));
-  if (!typeStr) {
+  if (!typeStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedLinearString typeLinearStr(cx, typeStr->ensureLinear(cx));
-  if (!typeLinearStr) {
+  if (!typeLinearStr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3486,7 +3486,7 @@ bool WasmGlobalObject::construct(JSConte
 
   RootedObject proto(cx);
   if (!GetPrototypeFromBuiltinConstructor(cx, args, JSProto_WasmGlobal,
-                                          &proto)) {
+                                          &proto)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!proto) {
@@ -3588,16 +3588,16 @@ bool WasmGlobalObject::typeImpl(JSContex
   Rooted<IdValueVector> props(cx, IdValueVector(cx));
 
   if (!props.append(IdValuePair(NameToId(cx->names().mutable_),
-                                BooleanValue(global->isMutable())))) {
+                                BooleanValue(global->isMutable())))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JSString* valueType = UTF8CharsToString(cx, ToString(global->type()).get());
-  if (!valueType) {
+  if (!valueType) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!props.append(
-          IdValuePair(NameToId(cx->names().value), StringValue(valueType)))) {
+          IdValuePair(NameToId(cx->names().value), StringValue(valueType)))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3686,14 +3686,14 @@ WasmExceptionObject* WasmExceptionObject
   AutoSetNewObjectMetadata metadata(cx);
   RootedWasmExceptionObject obj(
       cx, NewObjectWithGivenProto<WasmExceptionObject>(cx, proto));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   MOZ_ASSERT(obj->isNewborn());
 
   SharedExceptionTag tag = SharedExceptionTag(cx->new_<ExceptionTag>());
-  if (!tag) {
+  if (!tag) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return nullptr;
   }
@@ -3861,7 +3861,7 @@ static bool WebAssembly_toSource(JSConte
 
 static bool RejectWithPendingException(JSContext* cx,
                                        Handle<PromiseObject*> promise) {
-  if (!cx->isExceptionPending()) {
+  if (!cx->isExceptionPending()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3875,7 +3875,7 @@ static bool RejectWithPendingException(J
 
 static bool Reject(JSContext* cx, const CompileArgs& args,
                    Handle<PromiseObject*> promise, const UniqueChars& error) {
-  if (!error) {
+  if (!error) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return RejectWithPendingException(cx, promise);
   }
@@ -3883,7 +3883,7 @@ static bool Reject(JSContext* cx, const 
   RootedObject stack(cx, promise->allocationSite());
   RootedString filename(
       cx, JS_NewStringCopyZ(cx, args.scriptedCaller.filename.get()));
-  if (!filename) {
+  if (!filename) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3893,13 +3893,13 @@ static bool Reject(JSContext* cx, const 
   // way to create an ErrorObject for an arbitrary error code with multiple
   // replacements.
   UniqueChars str(JS_smprintf("wasm validation error: %s", error.get()));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   size_t len = strlen(str.get());
   RootedString message(cx, NewStringCopyN<CanGC>(cx, str.get(), len));
-  if (!message) {
+  if (!message) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3952,7 +3952,7 @@ class AsyncInstantiateTask : public OffT
       resolutionValue = ObjectValue(*instanceObj);
     } else {
       RootedObject resultObj(cx, JS_NewPlainObject(cx));
-      if (!resultObj) {
+      if (!resultObj) {MOZ_RELEASE_ASSERT(0);
         return RejectWithPendingException(cx, promise);
       }
 
@@ -3960,18 +3960,18 @@ class AsyncInstantiateTask : public OffT
           cx, &cx->global()->getPrototype(JSProto_WasmModule).toObject());
       RootedObject moduleObj(
           cx, WasmModuleObject::create(cx, *module_, moduleProto));
-      if (!moduleObj) {
+      if (!moduleObj) {MOZ_RELEASE_ASSERT(0);
         return RejectWithPendingException(cx, promise);
       }
 
       RootedValue val(cx, ObjectValue(*moduleObj));
-      if (!JS_DefineProperty(cx, resultObj, "module", val, JSPROP_ENUMERATE)) {
+      if (!JS_DefineProperty(cx, resultObj, "module", val, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
         return RejectWithPendingException(cx, promise);
       }
 
       val = ObjectValue(*instanceObj);
       if (!JS_DefineProperty(cx, resultObj, "instance", val,
-                             JSPROP_ENUMERATE)) {
+                             JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
         return RejectWithPendingException(cx, promise);
       }
 
@@ -3991,7 +3991,7 @@ static bool AsyncInstantiate(JSContext* 
                              HandleObject importObj, Ret ret,
                              Handle<PromiseObject*> promise) {
   auto task = js::MakeUnique<AsyncInstantiateTask>(cx, module, ret, promise);
-  if (!task || !task->init(cx)) {
+  if (!task || !task->init(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4008,7 +4008,7 @@ static bool ResolveCompile(JSContext* cx
   RootedObject proto(
       cx, &cx->global()->getPrototype(JSProto_WasmModule).toObject());
   RootedObject moduleObj(cx, WasmModuleObject::create(cx, module, proto));
-  if (!moduleObj) {
+  if (!moduleObj) {MOZ_RELEASE_ASSERT(0);
     return RejectWithPendingException(cx, promise);
   }
 
@@ -4102,14 +4102,14 @@ static bool GetBufferSource(JSContext* c
 }
 
 static bool WebAssembly_compile(JSContext* cx, unsigned argc, Value* vp) {
-  if (!EnsurePromiseSupport(cx)) {
+  if (!EnsurePromiseSupport(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Log(cx, "async compile() started");
 
   Rooted<PromiseObject*> promise(cx, PromiseObject::createSkippingExecutor(cx));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4151,14 +4151,14 @@ static bool GetInstantiateArgs(JSContext
 }
 
 static bool WebAssembly_instantiate(JSContext* cx, unsigned argc, Value* vp) {
-  if (!EnsurePromiseSupport(cx)) {
+  if (!EnsurePromiseSupport(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Log(cx, "async instantiate() started");
 
   Rooted<PromiseObject*> promise(cx, PromiseObject::createSkippingExecutor(cx));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4172,7 +4172,7 @@ static bool WebAssembly_instantiate(JSCo
 
   const Module* module;
   if (IsModuleObject(firstArg, &module)) {
-    if (!AsyncInstantiate(cx, *module, importObj, Ret::Instance, promise)) {
+    if (!AsyncInstantiate(cx, *module, importObj, Ret::Instance, promise)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -4211,7 +4211,7 @@ static bool WebAssembly_validate(JSConte
   // If the reason for validation failure was OOM (signalled by null error
   // message), report out-of-memory so that validate's return is always
   // correct.
-  if (!validated && !error) {
+  if (!validated && !error) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -4228,7 +4228,7 @@ static bool WebAssembly_validate(JSConte
 static bool EnsureStreamSupport(JSContext* cx) {
   // This should match wasm::StreamingCompilationAvailable().
 
-  if (!EnsurePromiseSupport(cx)) {
+  if (!EnsurePromiseSupport(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4513,7 +4513,7 @@ class CompileStreamTask : public Promise
 
     if (module_) {
       MOZ_ASSERT(!streamFailed_ && !streamError_ && !compileError_);
-      if (!ReportCompileWarnings(cx, warnings_)) {
+      if (!ReportCompileWarnings(cx, warnings_)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (instantiate_) {
@@ -4650,7 +4650,7 @@ static bool ResolveResponse_OnFulfilled(
 
   auto task = cx->make_unique<CompileStreamTask>(cx, promise, compileArgs,
                                                  instantiate, importObj);
-  if (!task || !task->init(cx)) {
+  if (!task || !task->init(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4703,21 +4703,21 @@ static bool ResolveResponse(JSContext* c
   RootedObject closure(
       cx, ResolveResponseClosure::create(cx, *compileArgs, promise, instantiate,
                                          importObj));
-  if (!closure) {
+  if (!closure) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedFunction onResolved(
       cx, NewNativeFunction(cx, ResolveResponse_OnFulfilled, 1, nullptr,
                             gc::AllocKind::FUNCTION_EXTENDED, GenericObject));
-  if (!onResolved) {
+  if (!onResolved) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedFunction onRejected(
       cx, NewNativeFunction(cx, ResolveResponse_OnRejected, 1, nullptr,
                             gc::AllocKind::FUNCTION_EXTENDED, GenericObject));
-  if (!onRejected) {
+  if (!onRejected) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4742,7 +4742,7 @@ static bool WebAssembly_compileStreaming
   Log(cx, "async compileStreaming() started");
 
   Rooted<PromiseObject*> promise(cx, PromiseObject::createSkippingExecutor(cx));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4758,14 +4758,14 @@ static bool WebAssembly_compileStreaming
 
 static bool WebAssembly_instantiateStreaming(JSContext* cx, unsigned argc,
                                              Value* vp) {
-  if (!EnsureStreamSupport(cx)) {
+  if (!EnsureStreamSupport(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Log(cx, "async instantiateStreaming() started");
 
   Rooted<PromiseObject*> promise(cx, PromiseObject::createSkippingExecutor(cx));
-  if (!promise) {
+  if (!promise) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -4839,13 +4839,13 @@ static bool WebAssemblyClassFinish(JSCon
     JSProtoKey key = entry.key;
 
     JSObject* ctor = GlobalObject::getOrCreateConstructor(cx, key);
-    if (!ctor) {
+    if (!ctor) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     ctorValue.setObject(*ctor);
 
     JSAtom* className = Atomize(cx, name, strlen(name));
-    if (!className) {
+    if (!className) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     id.set(AtomToId(className));
diff --git a/js/src/wasm/WasmModule.cpp b/js/src/wasm/WasmModule.cpp
--- a/js/src/wasm/WasmModule.cpp
+++ b/js/src/wasm/WasmModule.cpp
@@ -115,7 +115,7 @@ bool Module::finishTier2(const LinkData&
   // Install the data in the data structures. They will not be visible
   // until commitTier2().
 
-  if (!code().setTier2(std::move(code2), linkData2)) {
+  if (!code().setTier2(std::move(code2), linkData2)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -146,7 +146,7 @@ bool Module::finishTier2(const LinkData&
       if (!stubs1->hasStub(fe.funcIndex())) {
         continue;
       }
-      if (!funcExportIndices.emplaceBack(i)) {
+      if (!funcExportIndices.emplaceBack(i)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -154,7 +154,7 @@ bool Module::finishTier2(const LinkData&
     const CodeTier& tier2 = code().codeTier(Tier::Optimized);
 
     Maybe<size_t> stub2Index;
-    if (!stubs2->createTier2(funcExportIndices, tier2, &stub2Index)) {
+    if (!stubs2->createTier2(funcExportIndices, tier2, &stub2Index)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -251,7 +251,7 @@ MutableModule Module::deserialize(const 
   MutableMetadata metadata(maybeMetadata);
   if (!metadata) {
     metadata = js_new<Metadata>();
-    if (!metadata) {
+    if (!metadata) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
   }
@@ -259,13 +259,13 @@ MutableModule Module::deserialize(const 
   const uint8_t* cursor = begin;
 
   JS::BuildIdCharVector currentBuildId;
-  if (!GetOptimizedEncodingBuildId(&currentBuildId)) {
+  if (!GetOptimizedEncodingBuildId(&currentBuildId)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   JS::BuildIdCharVector deserializedBuildId;
   cursor = DeserializePodVector(cursor, &deserializedBuildId);
-  if (!cursor) {
+  if (!cursor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -273,43 +273,43 @@ MutableModule Module::deserialize(const 
 
   LinkData linkData(Tier::Serialized);
   cursor = linkData.deserialize(cursor);
-  if (!cursor) {
+  if (!cursor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   ImportVector imports;
   cursor = DeserializeVector(cursor, &imports);
-  if (!cursor) {
+  if (!cursor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   ExportVector exports;
   cursor = DeserializeVector(cursor, &exports);
-  if (!cursor) {
+  if (!cursor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   DataSegmentVector dataSegments;
   cursor = DeserializeVector(cursor, &dataSegments);
-  if (!cursor) {
+  if (!cursor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   ElemSegmentVector elemSegments;
   cursor = DeserializeVector(cursor, &elemSegments);
-  if (!cursor) {
+  if (!cursor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   CustomSectionVector customSections;
   cursor = DeserializeVector(cursor, &customSections);
-  if (!cursor) {
+  if (!cursor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   SharedCode code;
   cursor = Code::deserialize(cursor, linkData, *metadata, &code);
-  if (!cursor) {
+  if (!cursor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -365,14 +365,14 @@ bool wasm::GetOptimizedEncodingBuildId(J
   // cause machine code to become invalid, so include both the actual build-id
   // and cpu-id.
 
-  if (!GetBuildId || !GetBuildId(buildId)) {
+  if (!GetBuildId || !GetBuildId(buildId)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   uint32_t cpu = ObservedCPUFeatures();
 
   if (!buildId->reserve(buildId->length() +
-                        12 /* "()" + 8 nibbles + "m[+-]" */)) {
+                        12 /* "()" + 8 nibbles + "m[+-]" */)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -393,7 +393,7 @@ bool wasm::GetOptimizedEncodingBuildId(J
 void Module::addSizeOfMisc(MallocSizeOf mallocSizeOf,
                            Metadata::SeenSet* seenMetadata,
                            Code::SeenSet* seenCode, size_t* code,
-                           size_t* data) const {
+                           size_t* data) const {MOZ_RELEASE_ASSERT(0);
   code_->addSizeOfMiscIfNotSeen(mallocSizeOf, seenMetadata, seenCode, code,
                                 data);
   *data += mallocSizeOf(this) +
@@ -425,7 +425,7 @@ void Module::initGCMallocBytesExcludingC
 bool Module::extractCode(JSContext* cx, Tier tier,
                          MutableHandleValue vp) const {
   RootedPlainObject result(cx, NewBuiltinClassInstance<PlainObject>(cx));
-  if (!result) {
+  if (!result) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -433,14 +433,14 @@ bool Module::extractCode(JSContext* cx, 
   // block on tiered compilation to complete.
   testingBlockOnTier2Complete();
 
-  if (!code_->hasTier(tier)) {
+  if (!code_->hasTier(tier)) {MOZ_RELEASE_ASSERT(0);
     vp.setNull();
     return true;
   }
 
   const ModuleSegment& moduleSegment = code_->segment(tier);
   RootedObject code(cx, JS_NewUint8Array(cx, moduleSegment.length()));
-  if (!code) {
+  if (!code) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -448,57 +448,57 @@ bool Module::extractCode(JSContext* cx, 
          moduleSegment.base(), moduleSegment.length());
 
   RootedValue value(cx, ObjectValue(*code));
-  if (!JS_DefineProperty(cx, result, "code", value, JSPROP_ENUMERATE)) {
+  if (!JS_DefineProperty(cx, result, "code", value, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   RootedObject segments(cx, NewDenseEmptyArray(cx));
-  if (!segments) {
+  if (!segments) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   for (const CodeRange& p : metadata(tier).codeRanges) {
     RootedObject segment(cx, NewObjectWithGivenProto<PlainObject>(cx, nullptr));
-    if (!segment) {
+    if (!segment) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     value.setNumber((uint32_t)p.begin());
-    if (!JS_DefineProperty(cx, segment, "begin", value, JSPROP_ENUMERATE)) {
+    if (!JS_DefineProperty(cx, segment, "begin", value, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     value.setNumber((uint32_t)p.end());
-    if (!JS_DefineProperty(cx, segment, "end", value, JSPROP_ENUMERATE)) {
+    if (!JS_DefineProperty(cx, segment, "end", value, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     value.setNumber((uint32_t)p.kind());
-    if (!JS_DefineProperty(cx, segment, "kind", value, JSPROP_ENUMERATE)) {
+    if (!JS_DefineProperty(cx, segment, "kind", value, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (p.isFunction()) {
       value.setNumber((uint32_t)p.funcIndex());
       if (!JS_DefineProperty(cx, segment, "funcIndex", value,
-                             JSPROP_ENUMERATE)) {
+                             JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       value.setNumber((uint32_t)p.funcUncheckedCallEntry());
       if (!JS_DefineProperty(cx, segment, "funcBodyBegin", value,
-                             JSPROP_ENUMERATE)) {
+                             JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       value.setNumber((uint32_t)p.end());
       if (!JS_DefineProperty(cx, segment, "funcBodyEnd", value,
-                             JSPROP_ENUMERATE)) {
+                             JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
 
-    if (!NewbornArrayPush(cx, segments, ObjectValue(*segment))) {
+    if (!NewbornArrayPush(cx, segments, ObjectValue(*segment))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -560,7 +560,7 @@ bool Module::initSegments(JSContext* cx,
         return false;
       }
 
-      if (!instance.initElems(seg->tableIndex, *seg, offset, 0, count)) {
+      if (!instance.initElems(seg->tableIndex, *seg, offset, 0, count)) {MOZ_RELEASE_ASSERT(0);
         return false;  // OOM
       }
     }
@@ -676,7 +676,7 @@ static bool CheckLimits(JSContext* cx, T
 
 static bool CheckSharing(JSContext* cx, bool declaredShared, bool isShared) {
   if (isShared &&
-      !cx->realm()->creationOptions().getSharedMemoryAndAtomicsEnabled()) {
+      !cx->realm()->creationOptions().getSharedMemoryAndAtomicsEnabled()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_WASM_NO_SHMEM_LINK);
     return false;
@@ -781,7 +781,7 @@ bool Module::instantiateLocalException(J
                                        uint32_t exnIndex) const {
   SharedExceptionTag tag;
   // Extend exnObjs in anticipation of an exported exception object.
-  if (exnObjs.length() <= exnIndex && !exnObjs.resize(exnIndex + 1)) {
+  if (exnObjs.length() <= exnIndex && !exnObjs.resize(exnIndex + 1)) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -793,7 +793,7 @@ bool Module::instantiateLocalException(J
         cx, &cx->global()->getPrototype(JSProto_WasmException).toObject());
     RootedWasmExceptionObject exnObj(
         cx, WasmExceptionObject::create(cx, ed.type, proto));
-    if (!exnObj) {
+    if (!exnObj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     // Take the exception tag that was created inside the WasmExceptionObject.
@@ -803,7 +803,7 @@ bool Module::instantiateLocalException(J
   } else {
     // Create a new tag for every non exported exception.
     tag = SharedExceptionTag(cx->new_<ExceptionTag>());
-    if (!tag) {
+    if (!tag) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     // The exnObj is null if the exception is neither exported nor imported.
@@ -824,7 +824,7 @@ bool Module::instantiateExceptions(JSCon
   for (const EventDesc& ed : metadata().events) {
     if (exnIndex < exnObjs.length()) {
       Rooted<WasmExceptionObject*> exnObj(cx, exnObjs[exnIndex]);
-      if (!instantiateImportedException(cx, exnObj, exnObjs, tags)) {
+      if (!instantiateImportedException(cx, exnObj, exnObjs, tags)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -853,7 +853,7 @@ bool Module::instantiateImportedTable(JS
     return false;
   }
 
-  if (!tables->append(&table)) {
+  if (!tables->append(&table)) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -882,20 +882,20 @@ bool Module::instantiateLocalTable(JSCon
         cx, &cx->global()->getPrototype(JSProto_WasmTable).toObject());
     tableObj.set(WasmTableObject::create(cx, td.initialLength, td.maximumLength,
                                          td.elemType, proto));
-    if (!tableObj) {
+    if (!tableObj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     table = &tableObj->table();
   } else {
     table = Table::create(cx, td, /* HandleWasmTableObject = */ nullptr);
-    if (!table) {
+    if (!table) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
   }
 
   // Note, appending a null pointer for non-exported local tables.
-  if (!tableObjs->append(tableObj.get())) {
+  if (!tableObjs->append(tableObj.get())) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -957,7 +957,7 @@ static bool EnsureExportedGlobalObject(J
       cx, &cx->global()->getPrototype(JSProto_WasmGlobal).toObject());
   RootedWasmGlobalObject go(
       cx, WasmGlobalObject::create(cx, val, global.isMutable(), proto));
-  if (!go) {
+  if (!go) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -989,7 +989,7 @@ bool Module::instantiateGlobals(JSContex
     unsigned globalIndex = exp.globalIndex();
     const GlobalDesc& global = globals[globalIndex];
     if (!EnsureExportedGlobalObject(cx, globalImportValues, globalIndex, global,
-                                    globalObjs)) {
+                                    globalObjs)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1033,24 +1033,24 @@ SharedCode Module::getDebugEnabledCode()
   Tier tier = Tier::Baseline;
   auto segment =
       ModuleSegment::create(tier, *debugUnlinkedCode_, *debugLinkData_);
-  if (!segment) {
+  if (!segment) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   UniqueMetadataTier metadataTier = js::MakeUnique<MetadataTier>(tier);
-  if (!metadataTier || !metadataTier->clone(metadata(tier))) {
+  if (!metadataTier || !metadataTier->clone(metadata(tier))) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   auto codeTier =
       js::MakeUnique<CodeTier>(std::move(metadataTier), std::move(segment));
-  if (!codeTier) {
+  if (!codeTier) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   JumpTables jumpTables;
   if (!jumpTables.init(CompileMode::Once, codeTier->segment(),
-                       metadata(tier).codeRanges)) {
+                       metadata(tier).codeRanges)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1155,7 +1155,7 @@ static bool CreateExportObject(JSContext
       strlen(exports[0].fieldName()) == 0) {
     RootedFunction func(cx);
     if (!GetFunctionExport(cx, instanceObj, funcImports, exports[0].funcIndex(),
-                           &func)) {
+                           &func)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     instanceObj->initExportsObj(*func.get());
@@ -1171,14 +1171,14 @@ static bool CreateExportObject(JSContext
     exportObj = NewObjectWithGivenProto<PlainObject>(cx, nullptr);
     propertyAttr |= JSPROP_READONLY | JSPROP_PERMANENT;
   }
-  if (!exportObj) {
+  if (!exportObj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   for (const Export& exp : exports) {
     JSAtom* atom =
         AtomizeUTF8Chars(cx, exp.fieldName(), strlen(exp.fieldName()));
-    if (!atom) {
+    if (!atom) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1219,7 +1219,7 @@ static bool CreateExportObject(JSContext
 #endif
     }
 
-    if (!JS_DefinePropertyById(cx, exportObj, id, val, propertyAttr)) {
+    if (!JS_DefinePropertyById(cx, exportObj, id, val, propertyAttr)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1257,7 +1257,7 @@ bool Module::instantiate(JSContext* cx, 
 
   SharedExceptionTagVector tags;
 #ifdef ENABLE_WASM_EXCEPTIONS
-  if (!instantiateExceptions(cx, imports.exceptionObjs, &tags)) {
+  if (!instantiateExceptions(cx, imports.exceptionObjs, &tags)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 #endif
@@ -1271,12 +1271,12 @@ bool Module::instantiate(JSContext* cx, 
     return false;
   }
 
-  if (!instantiateGlobals(cx, imports.globalValues, imports.globalObjs)) {
+  if (!instantiateGlobals(cx, imports.globalValues, imports.globalObjs)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   UniqueTlsData tlsData = CreateTlsData(metadata().globalDataLength);
-  if (!tlsData) {
+  if (!tlsData) {MOZ_RELEASE_ASSERT(0);
     ReportOutOfMemory(cx);
     return false;
   }
@@ -1285,13 +1285,13 @@ bool Module::instantiate(JSContext* cx, 
   UniqueDebugState maybeDebug;
   if (metadata().debugEnabled) {
     code = getDebugEnabledCode();
-    if (!code) {
+    if (!code) {MOZ_RELEASE_ASSERT(0);
       ReportOutOfMemory(cx);
       return false;
     }
 
     maybeDebug = cx->make_unique<DebugState>(*code, *this);
-    if (!maybeDebug) {
+    if (!maybeDebug) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -1303,13 +1303,13 @@ bool Module::instantiate(JSContext* cx, 
       std::move(tags), std::move(tables), imports.funcs, metadata().globals,
       imports.globalValues, imports.globalObjs, instanceProto,
       std::move(maybeDebug)));
-  if (!instance) {
+  if (!instance) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (!CreateExportObject(cx, instance, imports.funcs, tableObjs.get(), memory,
                           imports.exceptionObjs, imports.globalValues,
-                          imports.globalObjs, exports_)) {
+                          imports.globalObjs, exports_)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1318,7 +1318,7 @@ bool Module::instantiate(JSContext* cx, 
   // require a fully-initialized instance and must precede initSegments as the
   // final pre-requisite for a live instance.
 
-  if (!cx->realm()->wasm.registerInstance(cx, instance)) {
+  if (!cx->realm()->wasm.registerInstance(cx, instance)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/wasm/WasmProcess.cpp b/js/src/wasm/WasmProcess.cpp
--- a/js/src/wasm/WasmProcess.cpp
+++ b/js/src/wasm/WasmProcess.cpp
@@ -142,7 +142,7 @@ class ProcessCodeSegmentMap {
                                     CodeSegmentPC(cs->base()), &index));
 
     if (!mutableCodeSegments_->insert(mutableCodeSegments_->begin() + index,
-                                      cs)) {
+                                      cs)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -251,12 +251,12 @@ const CodeSegment* wasm::LookupCodeSegme
   sNumActiveLookups++;
 
   ProcessCodeSegmentMap* map = sProcessCodeSegmentMap;
-  if (!map) {
+  if (!map) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   if (const CodeSegment* found = map->lookup(pc)) {
-    if (codeRange) {
+    if (codeRange) {MOZ_RELEASE_ASSERT(0);
       *codeRange = found->isModule() ? found->asModule()->lookupRange(pc)
                                      : found->asLazyStub()->lookupRange(pc);
     }
@@ -353,7 +353,7 @@ bool wasm::DisableHugeMemory() {
 
 void ConfigureHugeMemory() {
 #ifdef WASM_SUPPORTS_HUGE_MEMORY
-  if (gc::SystemAddressBits() < MinAddressBitsForHugeMemory) {
+  if (gc::SystemAddressBits() < MinAddressBitsForHugeMemory) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
diff --git a/js/src/wasm/WasmRealm.cpp b/js/src/wasm/WasmRealm.cpp
--- a/js/src/wasm/WasmRealm.cpp
+++ b/js/src/wasm/WasmRealm.cpp
@@ -72,7 +72,7 @@ bool wasm::Realm::registerInstance(JSCon
   }
 
   {
-    if (!instances_.reserve(instances_.length() + 1)) {
+    if (!instances_.reserve(instances_.length() + 1)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
diff --git a/js/src/wasm/WasmSignalHandlers.cpp b/js/src/wasm/WasmSignalHandlers.cpp
--- a/js/src/wasm/WasmSignalHandlers.cpp
+++ b/js/src/wasm/WasmSignalHandlers.cpp
@@ -707,7 +707,7 @@ static bool HandleUnalignedTrap(CONTEXT*
 
   Trap trap;
   BytecodeOffset bytecode;
-  if (!segment.code().lookupTrap(pc, &trap, &bytecode)) {
+  if (!segment.code().lookupTrap(pc, &trap, &bytecode)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -723,7 +723,7 @@ static bool HandleUnalignedTrap(CONTEXT*
                      trap == Trap::IndirectCallBadSig);
 
   if (isUnalignedSignal) {
-    if (trap != Trap::OutOfBounds) {
+    if (trap != Trap::OutOfBounds) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (HandleUnalignedTrap(context, pc, instance)) {
@@ -756,11 +756,11 @@ static const unsigned sThreadLocalArrayP
 
 static LONG WINAPI WasmTrapHandler(LPEXCEPTION_POINTERS exception) {
   // Make sure TLS is initialized before reading sAlreadyHandlingTrap.
-  if (!NtCurrentTeb()->Reserved1[sThreadLocalArrayPointerIndex]) {
+  if (!NtCurrentTeb()->Reserved1[sThreadLocalArrayPointerIndex]) {MOZ_RELEASE_ASSERT(0);
     return EXCEPTION_CONTINUE_SEARCH;
   }
 
-  if (sAlreadyHandlingTrap.get()) {
+  if (sAlreadyHandlingTrap.get()) {MOZ_RELEASE_ASSERT(0);
     return EXCEPTION_CONTINUE_SEARCH;
   }
   AutoHandlingTrap aht;
@@ -949,7 +949,7 @@ static void WasmTrapHandler(int signum, 
     if (HandleTrap((CONTEXT*)context, signum == SIGBUS, TlsContext.get())) {
       return;
     }
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   struct sigaction* previousSignal = nullptr;
   switch (signum) {
@@ -977,10 +977,10 @@ static void WasmTrapHandler(int signum, 
   // signal to it's original disposition and returning.
   //
   // Note: the order of these tests matter.
-  if (previousSignal->sa_flags & SA_SIGINFO) {
+  if (previousSignal->sa_flags & SA_SIGINFO) {MOZ_RELEASE_ASSERT(0);
     previousSignal->sa_sigaction(signum, info, context);
   } else if (previousSignal->sa_handler == SIG_DFL ||
-             previousSignal->sa_handler == SIG_IGN) {
+             previousSignal->sa_handler == SIG_IGN) {MOZ_RELEASE_ASSERT(0);
     sigaction(signum, previousSignal, nullptr);
   } else {
     previousSignal->sa_handler(signum);
@@ -1038,7 +1038,7 @@ void wasm::EnsureEagerProcessSignalHandl
   // such as MemoryProtectionExceptionHandler that assume we are crashing.
   const bool firstHandler = true;
 #  endif
-  if (!AddVectoredExceptionHandler(firstHandler, WasmTrapHandler)) {
+  if (!AddVectoredExceptionHandler(firstHandler, WasmTrapHandler)) {MOZ_RELEASE_ASSERT(0);
     // Windows has all sorts of random security knobs for disabling things
     // so make this a dynamic failure that disables wasm, not a MOZ_CRASH().
     return;
@@ -1056,7 +1056,7 @@ void wasm::EnsureEagerProcessSignalHandl
   faultHandler.sa_flags = SA_SIGINFO | SA_NODEFER | SA_ONSTACK;
   faultHandler.sa_sigaction = WasmTrapHandler;
   sigemptyset(&faultHandler.sa_mask);
-  if (sigaction(SIGSEGV, &faultHandler, &sPrevSEGVHandler)) {
+  if (sigaction(SIGSEGV, &faultHandler, &sPrevSEGVHandler)) {MOZ_RELEASE_ASSERT(0);
     MOZ_CRASH("unable to install segv handler");
   }
 
@@ -1136,12 +1136,12 @@ bool wasm::EnsureFullSignalHandlers(JSCo
   {
     auto eagerInstallState = sEagerInstallState.lock();
     MOZ_RELEASE_ASSERT(eagerInstallState->tried);
-    if (!eagerInstallState->success) {
+    if (!eagerInstallState->success) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
 
-  if (!EnsureLazyProcessSignalHandlers()) {
+  if (!EnsureLazyProcessSignalHandlers()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1170,20 +1170,20 @@ bool wasm::EnsureFullSignalHandlers(JSCo
 }
 
 bool wasm::MemoryAccessTraps(const RegisterState& regs, uint8_t* addr,
-                             uint32_t numBytes, uint8_t** newPC) {
+                             uint32_t numBytes, uint8_t** newPC) {MOZ_RELEASE_ASSERT(0);
   const wasm::CodeSegment* codeSegment = wasm::LookupCodeSegment(regs.pc);
-  if (!codeSegment || !codeSegment->isModule()) {
+  if (!codeSegment || !codeSegment->isModule()) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   const wasm::ModuleSegment& segment = *codeSegment->asModule();
 
   Trap trap;
   BytecodeOffset bytecode;
   if (!segment.code().lookupTrap(regs.pc, &trap, &bytecode) ||
-      trap != Trap::OutOfBounds) {
+      trap != Trap::OutOfBounds) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   Instance& instance =
       *GetNearestEffectiveTls(Frame::fromUntaggedWasmExitFP(regs.fp))->instance;
@@ -1200,11 +1200,11 @@ bool wasm::MemoryAccessTraps(const Regis
 }
 
 bool wasm::HandleIllegalInstruction(const RegisterState& regs,
-                                    uint8_t** newPC) {
+                                    uint8_t** newPC) {MOZ_RELEASE_ASSERT(0);
   const wasm::CodeSegment* codeSegment = wasm::LookupCodeSegment(regs.pc);
-  if (!codeSegment || !codeSegment->isModule()) {
+  if (!codeSegment || !codeSegment->isModule()) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   const wasm::ModuleSegment& segment = *codeSegment->asModule();
 
diff --git a/js/src/wasm/WasmStubs.cpp b/js/src/wasm/WasmStubs.cpp
--- a/js/src/wasm/WasmStubs.cpp
+++ b/js/src/wasm/WasmStubs.cpp
@@ -1066,7 +1066,7 @@ static bool GenerateJitEntry(MacroAssemb
 
   GenerateJitEntryLoadTls(masm, frameSize);
 
-  if (fe.funcType().hasUnexposableArgOrRet()) {
+  if (fe.funcType().hasUnexposableArgOrRet()) {MOZ_RELEASE_ASSERT(0);
     CallSymbolicAddress(masm, !fe.hasEagerStubs(),
                         SymbolicAddress::ReportV128JSCall);
     GenerateJitEntryThrow(masm, frameSize);
@@ -1438,7 +1438,7 @@ static bool GenerateJitEntry(MacroAssemb
     // argument 0: function export index.
     if (argsIter->kind() == ABIArg::GPR) {
       masm.movePtr(ImmWord(funcExportIndex), argsIter->gpr());
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       masm.storePtr(ImmWord(funcExportIndex),
                     Address(sp, argsIter->offsetFromArgBase()));
     }
@@ -1447,7 +1447,7 @@ static bool GenerateJitEntry(MacroAssemb
     // argument 1: tlsData
     if (argsIter->kind() == ABIArg::GPR) {
       masm.movePtr(WasmTlsReg, argsIter->gpr());
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       masm.storePtr(WasmTlsReg, Address(sp, argsIter->offsetFromArgBase()));
     }
     argsIter++;
@@ -1737,7 +1737,7 @@ static void StackCopy(MacroAssembler& ma
     masm.load32(src, scratch);
     GenPrintIsize(DebugChannel::Import, masm, scratch);
     masm.store32(scratch, dst);
-  } else if (type == MIRType::Int64) {
+  } else if (type == MIRType::Int64) {MOZ_RELEASE_ASSERT(0);
 #if JS_BITS_PER_WORD == 32
     GenPrintf(DebugChannel::Import, masm, "i64(");
     masm.load32(LowWord(src), scratch);
@@ -2054,11 +2054,11 @@ bool wasm::GenerateImportFunctions(const
 
     FuncOffsets offsets;
     if (!GenerateImportFunction(masm, fi, *env.funcs[funcIndex].typeId,
-                                &offsets)) {
+                                &offsets)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!code->codeRanges.emplaceBack(funcIndex, /* bytecodeOffset = */ 0,
-                                      offsets)) {
+                                      offsets)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -2124,7 +2124,7 @@ static bool GenerateImportInterpExit(Mac
   Address instancePtr(WasmTlsReg, offsetof(TlsData, instance));
   if (i->kind() == ABIArg::GPR) {
     masm.loadPtr(instancePtr, i->gpr());
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     masm.loadPtr(instancePtr, scratch);
     masm.storePtr(scratch,
                   Address(masm.getStackPointer(), i->offsetFromArgBase()));
@@ -2134,7 +2134,7 @@ static bool GenerateImportInterpExit(Mac
   // argument 1: funcImportIndex
   if (i->kind() == ABIArg::GPR) {
     masm.mov(ImmWord(funcImportIndex), i->gpr());
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     masm.store32(Imm32(funcImportIndex),
                  Address(masm.getStackPointer(), i->offsetFromArgBase()));
   }
@@ -2144,7 +2144,7 @@ static bool GenerateImportInterpExit(Mac
   unsigned argc = abiArgCount;
   if (i->kind() == ABIArg::GPR) {
     masm.mov(ImmWord(argc), i->gpr());
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     masm.store32(Imm32(argc),
                  Address(masm.getStackPointer(), i->offsetFromArgBase()));
   }
@@ -2154,7 +2154,7 @@ static bool GenerateImportInterpExit(Mac
   Address argv(masm.getStackPointer(), argOffset);
   if (i->kind() == ABIArg::GPR) {
     masm.computeEffectiveAddress(argv, i->gpr());
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     masm.computeEffectiveAddress(argv, scratch);
     masm.storePtr(scratch,
                   Address(masm.getStackPointer(), i->offsetFromArgBase()));
@@ -2512,7 +2512,7 @@ static bool GenerateImportJitExit(MacroA
     Address argv(masm.getStackPointer(), offsetToCoerceArgv);
     if (i->kind() == ABIArg::GPR) {
       masm.computeEffectiveAddress(argv, i->gpr());
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       masm.computeEffectiveAddress(argv, scratch);
       masm.storePtr(scratch,
                     Address(masm.getStackPointer(), i->offsetFromArgBase()));
@@ -2981,11 +2981,11 @@ bool wasm::GenerateEntryStubs(MacroAssem
   MOZ_ASSERT_IF(isAsmJS, fe.hasEagerStubs());
 
   Offsets offsets;
-  if (!GenerateInterpEntry(masm, fe, callee, &offsets)) {
+  if (!GenerateInterpEntry(masm, fe, callee, &offsets)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!codeRanges->emplaceBack(CodeRange::InterpEntry, fe.funcIndex(),
-                               offsets)) {
+                               offsets)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3004,7 +3004,7 @@ bool wasm::GenerateEntryStubs(MacroAssem
     return true;
   }
 
-  if (!GenerateJitEntry(masm, funcExportIndex, fe, callee, &offsets)) {
+  if (!GenerateJitEntry(masm, funcExportIndex, fe, callee, &offsets)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!codeRanges->emplaceBack(CodeRange::JitEntry, fe.funcIndex(), offsets)) {
@@ -3060,7 +3060,7 @@ bool wasm::GenerateStubs(const ModuleEnv
   WasmMacroAssembler masm(alloc, env);
 
   // Swap in already-allocated empty vectors to avoid malloc/free.
-  if (!code->swap(masm)) {
+  if (!code->swap(masm)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3073,11 +3073,11 @@ bool wasm::GenerateStubs(const ModuleEnv
 
     CallableOffsets interpOffsets;
     if (!GenerateImportInterpExit(masm, fi, funcIndex, &throwLabel,
-                                  &interpOffsets)) {
+                                  &interpOffsets)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!code->codeRanges.emplaceBack(CodeRange::ImportInterpExit, funcIndex,
-                                      interpOffsets)) {
+                                      interpOffsets)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3098,10 +3098,10 @@ bool wasm::GenerateStubs(const ModuleEnv
     }
 
     JitExitOffsets jitOffsets;
-    if (!GenerateImportJitExit(masm, fi, funcIndex, &throwLabel, &jitOffsets)) {
+    if (!GenerateImportJitExit(masm, fi, funcIndex, &throwLabel, &jitOffsets)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-    if (!code->codeRanges.emplaceBack(funcIndex, jitOffsets)) {
+    if (!code->codeRanges.emplaceBack(funcIndex, jitOffsets)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -3115,7 +3115,7 @@ bool wasm::GenerateStubs(const ModuleEnv
       continue;
     }
     if (!GenerateEntryStubs(masm, i, fe, noAbsolute, env.isAsmJS(),
-                            &code->codeRanges)) {
+                            &code->codeRanges)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -3124,25 +3124,25 @@ bool wasm::GenerateStubs(const ModuleEnv
 
   Offsets offsets;
 
-  if (!GenerateTrapExit(masm, &throwLabel, &offsets)) {
+  if (!GenerateTrapExit(masm, &throwLabel, &offsets)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!code->codeRanges.emplaceBack(CodeRange::TrapExit, offsets)) {
+  if (!code->codeRanges.emplaceBack(CodeRange::TrapExit, offsets)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   CallableOffsets callableOffsets;
-  if (!GenerateDebugTrapStub(masm, &throwLabel, &callableOffsets)) {
+  if (!GenerateDebugTrapStub(masm, &throwLabel, &callableOffsets)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!code->codeRanges.emplaceBack(CodeRange::DebugTrap, callableOffsets)) {
+  if (!code->codeRanges.emplaceBack(CodeRange::DebugTrap, callableOffsets)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!GenerateThrowStub(masm, &throwLabel, &offsets)) {
+  if (!GenerateThrowStub(masm, &throwLabel, &offsets)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!code->codeRanges.emplaceBack(CodeRange::Throw, offsets)) {
+  if (!code->codeRanges.emplaceBack(CodeRange::Throw, offsets)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/src/wasm/WasmTable.cpp b/js/src/wasm/WasmTable.cpp
--- a/js/src/wasm/WasmTable.cpp
+++ b/js/src/wasm/WasmTable.cpp
@@ -383,7 +383,7 @@ bool Table::addMovingGrowObserver(JSCont
   return true;
 }
 
-size_t Table::sizeOfExcludingThis(MallocSizeOf mallocSizeOf) const {
+size_t Table::sizeOfExcludingThis(MallocSizeOf mallocSizeOf) const {MOZ_RELEASE_ASSERT(0);
   if (isFunction()) {
     return mallocSizeOf(functions_.get());
   }
diff --git a/js/src/wasm/WasmTypes.cpp b/js/src/wasm/WasmTypes.cpp
--- a/js/src/wasm/WasmTypes.cpp
+++ b/js/src/wasm/WasmTypes.cpp
@@ -122,7 +122,7 @@ void Val::trace(JSTracer* trc) const {
 bool wasm::CheckRefType(JSContext* cx, RefType targetType, HandleValue v,
                         MutableHandleFunction fnval,
                         MutableHandleAnyRef refval) {
-  if (!targetType.isNullable() && v.isNull()) {
+  if (!targetType.isNullable() && v.isNull()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorNumberUTF8(cx, GetErrorMessage, nullptr,
                              JSMSG_WASM_BAD_REF_NONNULLABLE_VALUE);
     return false;
@@ -295,7 +295,7 @@ template <typename Debug = NoDebug>
 bool ToWebAssemblyValue_externref(JSContext* cx, HandleValue val, void** loc,
                                   bool mustWrite64) {
   RootedAnyRef result(cx, AnyRef::null());
-  if (!BoxAnyRef(cx, val, &result)) {
+  if (!BoxAnyRef(cx, val, &result)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   *loc = result.get().forCompiledCode();
@@ -503,7 +503,7 @@ bool wasm::ToJSValue(JSContext* cx, cons
   return wasm::ToJSValue(cx, src, FieldType(type.packed()), dst);
 }
 
-void AnyRef::trace(JSTracer* trc) {
+void AnyRef::trace(JSTracer* trc) {MOZ_RELEASE_ASSERT(0);
   if (value_) {
     TraceManuallyBarrieredEdge(trc, &value_, "wasm anyref referent");
   }
@@ -784,7 +784,7 @@ TypeIdDesc TypeIdDesc::immediate(const T
   return TypeIdDesc(TypeIdDescKind::Immediate, immediate);
 }
 
-size_t TypeDef::serializedSize() const {
+size_t TypeDef::serializedSize() const {MOZ_RELEASE_ASSERT(0);
   size_t size = sizeof(kind_);
   switch (kind_) {
     case TypeDefKind::Struct: {
@@ -804,7 +804,7 @@ size_t TypeDef::serializedSize() const {
   return size;
 }
 
-uint8_t* TypeDef::serialize(uint8_t* cursor) const {
+uint8_t* TypeDef::serialize(uint8_t* cursor) const {MOZ_RELEASE_ASSERT(0);
   cursor = WriteBytes(cursor, &kind_, sizeof(kind_));
   switch (kind_) {
     case TypeDefKind::Struct: {
@@ -824,7 +824,7 @@ uint8_t* TypeDef::serialize(uint8_t* cur
   return cursor;
 }
 
-const uint8_t* TypeDef::deserialize(const uint8_t* cursor) {
+const uint8_t* TypeDef::deserialize(const uint8_t* cursor) {MOZ_RELEASE_ASSERT(0);
   cursor = ReadBytes(cursor, &kind_, sizeof(kind_));
   switch (kind_) {
     case TypeDefKind::Struct: {
@@ -844,7 +844,7 @@ const uint8_t* TypeDef::deserialize(cons
   return cursor;
 }
 
-size_t TypeDef::sizeOfExcludingThis(MallocSizeOf mallocSizeOf) const {
+size_t TypeDef::sizeOfExcludingThis(MallocSizeOf mallocSizeOf) const {MOZ_RELEASE_ASSERT(0);
   switch (kind_) {
     case TypeDefKind::Struct: {
       return structType_.sizeOfExcludingThis(mallocSizeOf);
@@ -917,7 +917,7 @@ class StructLayout {
 
     // Align the pointer.
     CheckedInt32 offset = RoundUpToAlignment(sizeSoFar, fieldAlignment);
-    if (!offset.isValid()) {
+    if (!offset.isValid()) {MOZ_RELEASE_ASSERT(0);
       return offset;
     }
 
@@ -941,7 +941,7 @@ bool StructType::computeLayout() {
   StructLayout layout;
   for (StructField& field : fields_) {
     CheckedInt32 offset = layout.addField(field.type);
-    if (!offset.isValid()) {
+    if (!offset.isValid()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     field.offset = offset.value();
@@ -979,19 +979,19 @@ size_t StructType::sizeOfExcludingThis(M
 TypeResult TypeContext::isRefEquivalent(RefType one, RefType two,
                                         TypeCache* cache) const {
   // Anything's equal to itself.
-  if (one == two) {
+  if (one == two) {MOZ_RELEASE_ASSERT(0);
     return TypeResult::True;
   }
 
 #ifdef ENABLE_WASM_FUNCTION_REFERENCES
   if (features_.functionReferences) {
     // Two references must have the same nullability to be equal
-    if (one.isNullable() != two.isNullable()) {
+    if (one.isNullable() != two.isNullable()) {MOZ_RELEASE_ASSERT(0);
       return TypeResult::False;
     }
 
     // Non type-index references are equal if they have the same kind
-    if (!one.isTypeIndex() && !two.isTypeIndex() && one.kind() == two.kind()) {
+    if (!one.isTypeIndex() && !two.isTypeIndex() && one.kind() == two.kind()) {MOZ_RELEASE_ASSERT(0);
       return TypeResult::True;
     }
 
@@ -1010,7 +1010,7 @@ TypeResult TypeContext::isTypeIndexEquiv
   MOZ_ASSERT(features_.functionReferences);
 
   // Anything's equal to itself.
-  if (one == two) {
+  if (one == two) {MOZ_RELEASE_ASSERT(0);
     return TypeResult::True;
   }
 
@@ -1035,7 +1035,7 @@ TypeResult TypeContext::isTypeIndexEquiv
 #ifdef ENABLE_WASM_GC
 TypeResult TypeContext::isStructEquivalent(uint32_t oneIndex, uint32_t twoIndex,
                                            TypeCache* cache) const {
-  if (cache->isEquivalent(oneIndex, twoIndex)) {
+  if (cache->isEquivalent(oneIndex, twoIndex)) {MOZ_RELEASE_ASSERT(0);
     return TypeResult::True;
   }
 
@@ -1049,11 +1049,11 @@ TypeResult TypeContext::isStructEquivale
 
   // Assume these structs are equal while checking fields. If any field is
   // not equal then we remove the assumption.
-  if (!cache->markEquivalent(oneIndex, twoIndex)) {
+  if (!cache->markEquivalent(oneIndex, twoIndex)) {MOZ_RELEASE_ASSERT(0);
     return TypeResult::OOM;
   }
 
-  for (uint32_t i = 0; i < two.fields_.length(); i++) {
+  for (uint32_t i = 0; i < two.fields_.length(); i++) {MOZ_RELEASE_ASSERT(0);
     TypeResult result =
         isStructFieldEquivalent(one.fields_[i], two.fields_[i], cache);
     if (result != TypeResult::True) {
@@ -1077,18 +1077,18 @@ TypeResult TypeContext::isStructFieldEqu
 
 TypeResult TypeContext::isArrayEquivalent(uint32_t oneIndex, uint32_t twoIndex,
                                           TypeCache* cache) const {
-  if (cache->isEquivalent(oneIndex, twoIndex)) {
+  if (cache->isEquivalent(oneIndex, twoIndex)) {MOZ_RELEASE_ASSERT(0);
     return TypeResult::True;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   const ArrayType& one = arrayType(oneIndex);
   const ArrayType& two = arrayType(twoIndex);
 
   // Assume these arrays are equal while checking fields. If the array
   // element is not equal then we remove the assumption.
-  if (!cache->markEquivalent(oneIndex, twoIndex)) {
+  if (!cache->markEquivalent(oneIndex, twoIndex)) {MOZ_RELEASE_ASSERT(0);
     return TypeResult::OOM;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   TypeResult result = isArrayElementEquivalent(one, two, cache);
   if (result != TypeResult::True) {
@@ -1112,7 +1112,7 @@ TypeResult TypeContext::isArrayElementEq
 TypeResult TypeContext::isRefSubtypeOf(RefType one, RefType two,
                                        TypeCache* cache) const {
   // Anything's a subtype of itself.
-  if (one == two) {
+  if (one == two) {MOZ_RELEASE_ASSERT(0);
     return TypeResult::True;
   }
 
@@ -1192,7 +1192,7 @@ TypeResult TypeContext::isStructSubtypeO
 
   // Assume these structs are subtypes while checking fields. If any field
   // fails a check then we remove the assumption.
-  if (!cache->markSubtypeOf(oneIndex, twoIndex)) {
+  if (!cache->markSubtypeOf(oneIndex, twoIndex)) {MOZ_RELEASE_ASSERT(0);
     return TypeResult::OOM;
   }
 
@@ -1232,7 +1232,7 @@ TypeResult TypeContext::isArraySubtypeOf
 
   // Assume these arrays are subtypes while checking elements. If the elements
   // fail the check then we remove the assumption.
-  if (!cache->markSubtypeOf(oneIndex, twoIndex)) {
+  if (!cache->markSubtypeOf(oneIndex, twoIndex)) {MOZ_RELEASE_ASSERT(0);
     return TypeResult::OOM;
   }
 
@@ -1395,13 +1395,13 @@ uint8_t* CustomSection::serialize(uint8_
 
 const uint8_t* CustomSection::deserialize(const uint8_t* cursor) {
   cursor = DeserializePodVector(cursor, &name);
-  if (!cursor) {
+  if (!cursor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   Bytes bytes;
   cursor = DeserializePodVector(cursor, &bytes);
-  if (!cursor) {
+  if (!cursor) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   payload = js_new<ShareableBytes>(std::move(bytes));
@@ -1521,13 +1521,13 @@ bool DebugFrame::getLocal(uint32_t local
   size_t argsLength;
   StackResults stackResults;
   if (!instance()->debug().debugGetLocalTypes(funcIndex(), &locals, &argsLength,
-                                              &stackResults)) {
+                                              &stackResults)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   ValTypeVector args;
   MOZ_ASSERT(argsLength <= locals.length());
-  if (!args.append(locals.begin(), argsLength)) {
+  if (!args.append(locals.begin(), argsLength)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   ArgTypeVector abiArgs(args, stackResults);
@@ -1612,8 +1612,8 @@ void DebugFrame::leave(JSContext* cx) {
   }
 }
 
-bool TrapSiteVectorArray::empty() const {
-  for (Trap trap : MakeEnumeratedRange(Trap::Limit)) {
+bool TrapSiteVectorArray::empty() const {MOZ_RELEASE_ASSERT(0);
+  for (Trap trap : MakeEnumeratedRange(Trap::Limit)) {MOZ_RELEASE_ASSERT(0);
     if (!(*this)[trap].empty()) {
       return false;
     }
@@ -1666,7 +1666,7 @@ const uint8_t* TrapSiteVectorArray::dese
 }
 
 size_t TrapSiteVectorArray::sizeOfExcludingThis(
-    MallocSizeOf mallocSizeOf) const {
+    MallocSizeOf mallocSizeOf) const {MOZ_RELEASE_ASSERT(0);
   size_t ret = 0;
   for (Trap trap : MakeEnumeratedRange(Trap::Limit)) {
     ret += (*this)[trap].sizeOfExcludingThis(mallocSizeOf);
@@ -1804,12 +1804,12 @@ void wasm::Log(JSContext* cx, const char
 
   if (!cx->options().wasmVerbose()) {
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   va_list args;
   va_start(args, fmt);
 
-  if (UniqueChars chars = JS_vsmprintf(fmt, args)) {
+  if (UniqueChars chars = JS_vsmprintf(fmt, args)) {MOZ_RELEASE_ASSERT(0);
     WarnNumberASCII(cx, JSMSG_WASM_VERBOSE, chars.get());
     if (cx->isExceptionPending()) {
       cx->clearPendingException();
diff --git a/js/src/wasm/WasmValidate.cpp b/js/src/wasm/WasmValidate.cpp
--- a/js/src/wasm/WasmValidate.cpp
+++ b/js/src/wasm/WasmValidate.cpp
@@ -82,7 +82,7 @@ bool Decoder::fail(size_t errorOffset, c
 }
 
 bool Decoder::readSectionHeader(uint8_t* id, SectionRange* range) {
-  if (!readFixedU8(id)) {
+  if (!readFixedU8(id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -163,7 +163,7 @@ fail:
 
 bool Decoder::finishSection(const SectionRange& range,
                             const char* sectionName) {
-  if (resilientMode_) {
+  if (resilientMode_) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
   if (range.size != currentOffset() - range.start) {
@@ -215,7 +215,7 @@ bool Decoder::startCustomSection(const c
     // metadata which can be queried by the user via Module.customSections.
     // Note: after an entry is appended, it may be popped if this loop or
     // the loop in startSection needs to rewind.
-    if (!env->customSections.append(sec)) {
+    if (!env->customSections.append(sec)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -253,7 +253,7 @@ void Decoder::finishCustomSection(const 
 
   uint32_t actualSize = currentOffset() - range.start;
   if (range.size != actualSize) {
-    if (actualSize < range.size) {
+    if (actualSize < range.size) {MOZ_RELEASE_ASSERT(0);
       warnf("in the '%s' custom section: %" PRIu32 " unconsumed bytes", name,
             uint32_t(range.size - actualSize));
     } else {
@@ -330,7 +330,7 @@ bool Decoder::finishNameSubsection(uint3
 
 bool Decoder::skipNameSubsection() {
   uint8_t nameTypeValue;
-  if (!readFixedU8(&nameTypeValue)) {
+  if (!readFixedU8(&nameTypeValue)) {MOZ_RELEASE_ASSERT(0);
     return fail("unable to read name subsection id");
   }
 
@@ -369,7 +369,7 @@ bool wasm::EncodeLocalEntries(Encoder& e
     }
   }
 
-  if (!e.writeVarU32(numLocalEntries)) {
+  if (!e.writeVarU32(numLocalEntries)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -378,17 +378,17 @@ bool wasm::EncodeLocalEntries(Encoder& e
     uint32_t count = 1;
     for (uint32_t i = 1; i < locals.length(); i++, count++) {
       if (prev != locals[i]) {
-        if (!e.writeVarU32(count)) {
+        if (!e.writeVarU32(count)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
-        if (!e.writeValType(prev)) {
+        if (!e.writeValType(prev)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         prev = locals[i];
         count = 0;
       }
     }
-    if (!e.writeVarU32(count)) {
+    if (!e.writeVarU32(count)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!e.writeValType(prev)) {
@@ -403,13 +403,13 @@ bool wasm::DecodeLocalEntries(Decoder& d
                               const FeatureArgs& features,
                               ValTypeVector* locals) {
   uint32_t numLocalEntries;
-  if (!d.readVarU32(&numLocalEntries)) {
+  if (!d.readVarU32(&numLocalEntries)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("failed to read number of local entries");
   }
 
   for (uint32_t i = 0; i < numLocalEntries; i++) {
     uint32_t count;
-    if (!d.readVarU32(&count)) {
+    if (!d.readVarU32(&count)) {MOZ_RELEASE_ASSERT(0);
       return d.fail("failed to read local entry count");
     }
 
@@ -507,7 +507,7 @@ static bool DecodeFunctionBodyExprs(cons
                                     const uint8_t* bodyEnd, Decoder* d) {
   ValidatingOpIter iter(env, *d);
 
-  if (!iter.readFunctionStart(funcIndex)) {
+  if (!iter.readFunctionStart(funcIndex)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1725,7 +1725,7 @@ bool wasm::ValidateFunctionBody(const Mo
                                 uint32_t funcIndex, uint32_t bodySize,
                                 Decoder& d) {
   ValTypeVector locals;
-  if (!locals.appendAll(env.funcs[funcIndex].type->args())) {
+  if (!locals.appendAll(env.funcs[funcIndex].type->args())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1746,7 +1746,7 @@ bool wasm::ValidateFunctionBody(const Mo
 // Section macros.
 
 static bool DecodePreamble(Decoder& d) {
-  if (d.bytesRemain() > MaxModuleBytes) {
+  if (d.bytesRemain() > MaxModuleBytes) {MOZ_RELEASE_ASSERT(0);
     return d.fail("module too big");
   }
 
@@ -1800,7 +1800,7 @@ static bool FuncTypeIsJSCompatible(Decod
 static bool DecodeTypeVector(Decoder& d, ModuleEnvironment* env,
                              TypeStateVector* typeState, uint32_t count,
                              ValTypeVector* types) {
-  if (!types->resize(count)) {
+  if (!types->resize(count)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1833,7 +1833,7 @@ static bool DecodeFuncType(Decoder& d, M
   if (!d.readVarU32(&numResults)) {
     return d.fail("bad number of function returns");
   }
-  if (numResults > env->funcMaxResults()) {
+  if (numResults > env->funcMaxResults()) {MOZ_RELEASE_ASSERT(0);
     return d.fail("too many returns in signature");
   }
   ValTypeVector results;
@@ -1859,40 +1859,40 @@ static bool DecodeStructType(Decoder& d,
   }
 
   if ((*typeState)[typeIndex] != TypeState::None &&
-      (*typeState)[typeIndex] != TypeState::ForwardGc) {
+      (*typeState)[typeIndex] != TypeState::ForwardGc) {MOZ_RELEASE_ASSERT(0);
     return d.fail("gc type entry referenced as function");
   }
 
   uint32_t numFields;
-  if (!d.readVarU32(&numFields)) {
+  if (!d.readVarU32(&numFields)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("Bad number of fields");
   }
 
-  if (numFields > MaxStructFields) {
+  if (numFields > MaxStructFields) {MOZ_RELEASE_ASSERT(0);
     return d.fail("too many fields in struct");
   }
 
   StructFieldVector fields;
-  if (!fields.resize(numFields)) {
+  if (!fields.resize(numFields)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   for (uint32_t i = 0; i < numFields; i++) {
     if (!d.readPackedType(env->types.length(), env->features,
-                          &fields[i].type)) {
+                          &fields[i].type)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     uint8_t flags;
-    if (!d.readFixedU8(&flags)) {
+    if (!d.readFixedU8(&flags)) {MOZ_RELEASE_ASSERT(0);
       return d.fail("expected flag");
     }
-    if ((flags & ~uint8_t(FieldFlags::AllowedMask)) != 0) {
+    if ((flags & ~uint8_t(FieldFlags::AllowedMask)) != 0) {MOZ_RELEASE_ASSERT(0);
       return d.fail("garbage flag bits");
     }
     fields[i].isMutable = flags & uint8_t(FieldFlags::Mutable);
 
-    if (!ValidateTypeState(d, typeState, fields[i].type)) {
+    if (!ValidateTypeState(d, typeState, fields[i].type)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1911,25 +1911,25 @@ static bool DecodeStructType(Decoder& d,
 
 static bool DecodeArrayType(Decoder& d, ModuleEnvironment* env,
                             TypeStateVector* typeState, uint32_t typeIndex) {
-  if (!env->gcTypesEnabled()) {
+  if (!env->gcTypesEnabled()) {MOZ_RELEASE_ASSERT(0);
     return d.fail("gc types not enabled");
   }
 
   if ((*typeState)[typeIndex] != TypeState::None &&
-      (*typeState)[typeIndex] != TypeState::ForwardGc) {
+      (*typeState)[typeIndex] != TypeState::ForwardGc) {MOZ_RELEASE_ASSERT(0);
     return d.fail("gc type entry referenced as function");
   }
 
   FieldType elementType;
-  if (!d.readFieldType(env->types.length(), env->features, &elementType)) {
+  if (!d.readFieldType(env->types.length(), env->features, &elementType)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   uint8_t flags;
-  if (!d.readFixedU8(&flags)) {
+  if (!d.readFixedU8(&flags)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("expected flag");
   }
-  if ((flags & ~uint8_t(FieldFlags::AllowedMask)) != 0) {
+  if ((flags & ~uint8_t(FieldFlags::AllowedMask)) != 0) {MOZ_RELEASE_ASSERT(0);
     return d.fail("garbage flag bits");
   }
   bool isMutable = flags & uint8_t(FieldFlags::Mutable);
@@ -1954,7 +1954,7 @@ static bool DecodeTypeSection(Decoder& d
   }
 
   uint32_t numTypes;
-  if (!d.readVarU32(&numTypes)) {
+  if (!d.readVarU32(&numTypes)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("expected number of types");
   }
 
@@ -1962,12 +1962,12 @@ static bool DecodeTypeSection(Decoder& d
     return d.fail("too many types");
   }
 
-  if (!env->types.resize(numTypes) || !env->typeIds.resize(numTypes)) {
+  if (!env->types.resize(numTypes) || !env->typeIds.resize(numTypes)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   TypeStateVector typeState;
-  if (!typeState.appendN(TypeState::None, numTypes)) {
+  if (!typeState.appendN(TypeState::None, numTypes)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2007,7 +2007,7 @@ static UniqueChars DecodeName(Decoder& d
     return nullptr;
   }
 
-  if (numBytes > MaxStringBytes) {
+  if (numBytes > MaxStringBytes) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -2061,7 +2061,7 @@ static bool DecodeLimits(Decoder& d, Lim
                      ? uint8_t(MemoryMasks::AllowShared)
                      : uint8_t(MemoryMasks::AllowUnshared);
 
-  if (flags & ~uint8_t(mask)) {
+  if (flags & ~uint8_t(mask)) {MOZ_RELEASE_ASSERT(0);
     return d.failf("unexpected bits set in flags: %" PRIu32,
                    uint32_t(flags & ~uint8_t(mask)));
   }
@@ -2111,7 +2111,7 @@ static bool DecodeTableTypeAndLimits(Dec
   if (!d.readRefType(types, features.withRefTypes(true), &tableElemType)) {
     return false;
   }
-  if (!features.refTypes && !tableElemType.isFunc()) {
+  if (!features.refTypes && !tableElemType.isFunc()) {MOZ_RELEASE_ASSERT(0);
     return d.fail("expected 'funcref' element type");
   }
   if (!tableElemType.isNullable()) {
@@ -2128,11 +2128,11 @@ static bool DecodeTableTypeAndLimits(Dec
   // we don't repeat it here.
   if (limits.initial > MaxTableLimitField ||
       ((limits.maximum.isSome() &&
-        limits.maximum.value() > MaxTableLimitField))) {
+        limits.maximum.value() > MaxTableLimitField))) {MOZ_RELEASE_ASSERT(0);
     return d.fail("too many table elements");
   }
 
-  if (tables->length() >= MaxTables) {
+  if (tables->length() >= MaxTables) {MOZ_RELEASE_ASSERT(0);
     return d.fail("too many tables");
   }
 
@@ -2191,7 +2191,7 @@ static bool DecodeGlobalType(Decoder& d,
   }
 
   uint8_t flags;
-  if (!d.readFixedU8(&flags)) {
+  if (!d.readFixedU8(&flags)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("expected global flags");
   }
 
@@ -2273,7 +2273,7 @@ static bool DecodeEvent(Decoder& d, Modu
   if (*funcTypeIndex >= env->numTypes()) {
     return d.fail("function type index in event out of bounds");
   }
-  if (!env->types[*funcTypeIndex].isFuncType()) {
+  if (!env->types[*funcTypeIndex].isFuncType()) {MOZ_RELEASE_ASSERT(0);
     return d.fail("function type index must index a function type");
   }
   if (env->types[*funcTypeIndex].funcType().results().length() != 0) {
@@ -2322,12 +2322,12 @@ static bool DecodeImport(Decoder& d, Mod
   CStringPairSet::AddPtr p = dupSet->lookupForAdd(pair);
   if (p) {
     env->usesDuplicateImports = true;
-  } else if (!dupSet->add(p, pair)) {
+  } else if (!dupSet->add(p, pair)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   uint8_t rawImportKind;
-  if (!d.readFixedU8(&rawImportKind)) {
+  if (!d.readFixedU8(&rawImportKind)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("failed to read import kind");
   }
 
@@ -2434,7 +2434,7 @@ static bool DecodeImportSection(Decoder&
     return d.fail("failed to read number of imports");
   }
 
-  if (numImports > MaxImports) {
+  if (numImports > MaxImports) {MOZ_RELEASE_ASSERT(0);
     return d.fail("too many imports");
   }
 
@@ -2467,17 +2467,17 @@ static bool DecodeFunctionSection(Decode
   }
 
   uint32_t numDefs;
-  if (!d.readVarU32(&numDefs)) {
+  if (!d.readVarU32(&numDefs)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("expected number of function definitions");
   }
 
   CheckedInt<uint32_t> numFuncs = env->funcs.length();
   numFuncs += numDefs;
-  if (!numFuncs.isValid() || numFuncs.value() > MaxFuncs) {
+  if (!numFuncs.isValid() || numFuncs.value() > MaxFuncs) {MOZ_RELEASE_ASSERT(0);
     return d.fail("too many functions");
   }
 
-  if (!env->funcs.reserve(numFuncs.value())) {
+  if (!env->funcs.reserve(numFuncs.value())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2504,7 +2504,7 @@ static bool DecodeTableSection(Decoder& 
   }
 
   uint32_t numTables;
-  if (!d.readVarU32(&numTables)) {
+  if (!d.readVarU32(&numTables)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("failed to read number of tables");
   }
 
@@ -2527,7 +2527,7 @@ static bool DecodeMemorySection(Decoder&
   }
 
   uint32_t numMemories;
-  if (!d.readVarU32(&numMemories)) {
+  if (!d.readVarU32(&numMemories)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("failed to read number of memories");
   }
 
@@ -2547,7 +2547,7 @@ static bool DecodeMemorySection(Decoder&
 static bool DecodeInitializerExpression(Decoder& d, ModuleEnvironment* env,
                                         ValType expected, InitExpr* init) {
   OpBytes op;
-  if (!d.readOp(&op)) {
+  if (!d.readOp(&op)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("failed to read initializer type");
   }
 
@@ -2676,17 +2676,17 @@ static bool DecodeGlobalSection(Decoder&
   }
 
   uint32_t numDefs;
-  if (!d.readVarU32(&numDefs)) {
+  if (!d.readVarU32(&numDefs)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("expected number of globals");
   }
 
   CheckedInt<uint32_t> numGlobals = env->globals.length();
   numGlobals += numDefs;
-  if (!numGlobals.isValid() || numGlobals.value() > MaxGlobals) {
+  if (!numGlobals.isValid() || numGlobals.value() > MaxGlobals) {MOZ_RELEASE_ASSERT(0);
     return d.fail("too many globals");
   }
 
-  if (!env->globals.reserve(numGlobals.value())) {
+  if (!env->globals.reserve(numGlobals.value())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2711,7 +2711,7 @@ static bool DecodeGlobalSection(Decoder&
 #ifdef ENABLE_WASM_EXCEPTIONS
 static bool DecodeEventSection(Decoder& d, ModuleEnvironment* env) {
   MaybeSectionRange range;
-  if (!d.startSection(SectionId::Event, env, &range, "event")) {
+  if (!d.startSection(SectionId::Event, env, &range, "event")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!range) {
@@ -2725,11 +2725,11 @@ static bool DecodeEventSection(Decoder& 
 
   CheckedInt<uint32_t> numEvents = env->events.length();
   numEvents += numDefs;
-  if (!numEvents.isValid() || numEvents.value() > MaxEvents) {
+  if (!numEvents.isValid() || numEvents.value() > MaxEvents) {MOZ_RELEASE_ASSERT(0);
     return d.fail("too many events");
   }
 
-  if (!env->events.reserve(numEvents.value())) {
+  if (!env->events.reserve(numEvents.value())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2782,7 +2782,7 @@ static bool DecodeExport(Decoder& d, Mod
   }
 
   uint8_t exportKind;
-  if (!d.readFixedU8(&exportKind)) {
+  if (!d.readFixedU8(&exportKind)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("failed to read export kind");
   }
 
@@ -2891,11 +2891,11 @@ static bool DecodeExportSection(Decoder&
   CStringSet dupSet;
 
   uint32_t numExports;
-  if (!d.readVarU32(&numExports)) {
+  if (!d.readVarU32(&numExports)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("failed to read number of exports");
   }
 
-  if (numExports > MaxExports) {
+  if (numExports > MaxExports) {MOZ_RELEASE_ASSERT(0);
     return d.fail("too many exports");
   }
 
@@ -2918,7 +2918,7 @@ static bool DecodeStartSection(Decoder& 
   }
 
   uint32_t funcIndex;
-  if (!d.readVarU32(&funcIndex)) {
+  if (!d.readVarU32(&funcIndex)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("failed to read start func index");
   }
 
@@ -2967,15 +2967,15 @@ static bool DecodeElemSection(Decoder& d
   }
 
   uint32_t numSegments;
-  if (!d.readVarU32(&numSegments)) {
+  if (!d.readVarU32(&numSegments)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("failed to read number of elem segments");
   }
 
-  if (numSegments > MaxElemSegments) {
+  if (numSegments > MaxElemSegments) {MOZ_RELEASE_ASSERT(0);
     return d.fail("too many elem segments");
   }
 
-  if (!env->elemSegments.reserve(numSegments)) {
+  if (!env->elemSegments.reserve(numSegments)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2991,7 +2991,7 @@ static bool DecodeElemSection(Decoder& d
     }
 
     MutableElemSegment seg = js_new<ElemSegment>();
-    if (!seg) {
+    if (!seg) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3006,7 +3006,7 @@ static bool DecodeElemSection(Decoder& d
 
       uint32_t tableIndex = 0;
       if (kind == ElemSegmentKind::ActiveWithTableIndex &&
-          !d.readVarU32(&tableIndex)) {
+          !d.readVarU32(&tableIndex)) {MOZ_RELEASE_ASSERT(0);
         return d.fail("expected table index");
       }
       if (tableIndex >= env->tables.length()) {
@@ -3082,15 +3082,15 @@ static bool DecodeElemSection(Decoder& d
     seg->elemType = elemType;
 
     uint32_t numElems;
-    if (!d.readVarU32(&numElems)) {
+    if (!d.readVarU32(&numElems)) {MOZ_RELEASE_ASSERT(0);
       return d.fail("expected segment size");
     }
 
-    if (numElems > MaxElemSegmentLength) {
+    if (numElems > MaxElemSegmentLength) {MOZ_RELEASE_ASSERT(0);
       return d.fail("too many table elements");
     }
 
-    if (!seg->elemFuncIndices.reserve(numElems)) {
+    if (!seg->elemFuncIndices.reserve(numElems)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3114,7 +3114,7 @@ static bool DecodeElemSection(Decoder& d
 
       if (payload == ElemSegmentPayload::ElemExpression) {
         OpBytes op;
-        if (!d.readOp(&op)) {
+        if (!d.readOp(&op)) {MOZ_RELEASE_ASSERT(0);
           return d.fail("failed to read initializer operation");
         }
 
@@ -3133,14 +3133,14 @@ static bool DecodeElemSection(Decoder& d
             return d.fail("failed to read initializer operation");
         }
         if (!CheckIsSubtypeOf(d, *env, d.currentOffset(), ValType(initType),
-                              ValType(elemType), &cache)) {
+                              ValType(elemType), &cache)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
 
       uint32_t funcIndex = NullFuncIndex;
       if (needIndex) {
-        if (!d.readVarU32(&funcIndex)) {
+        if (!d.readVarU32(&funcIndex)) {MOZ_RELEASE_ASSERT(0);
           return d.fail("failed to read element function index");
         }
         if (funcIndex >= env->numFuncs()) {
@@ -3175,7 +3175,7 @@ static bool DecodeElemSection(Decoder& d
 
 static bool DecodeDataCountSection(Decoder& d, ModuleEnvironment* env) {
   MaybeSectionRange range;
-  if (!d.startSection(SectionId::DataCount, env, &range, "datacount")) {
+  if (!d.startSection(SectionId::DataCount, env, &range, "datacount")) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!range) {
@@ -3197,7 +3197,7 @@ bool wasm::StartsCodeSection(const uint8
   UniqueChars unused;
   Decoder d(begin, end, 0, &unused);
 
-  if (!DecodePreamble(d)) {
+  if (!DecodePreamble(d)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3268,7 +3268,7 @@ bool wasm::DecodeModuleEnvironment(Decod
     return false;
   }
 
-  if (!DecodeDataCountSection(d, env)) {
+  if (!DecodeDataCountSection(d, env)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -3286,11 +3286,11 @@ bool wasm::DecodeModuleEnvironment(Decod
 static bool DecodeFunctionBody(Decoder& d, const ModuleEnvironment& env,
                                uint32_t funcIndex) {
   uint32_t bodySize;
-  if (!d.readVarU32(&bodySize)) {
+  if (!d.readVarU32(&bodySize)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("expected number of function body bytes");
   }
 
-  if (bodySize > MaxFunctionBytes) {
+  if (bodySize > MaxFunctionBytes) {MOZ_RELEASE_ASSERT(0);
     return d.fail("function body too big");
   }
 
@@ -3334,18 +3334,18 @@ static bool DecodeDataSection(Decoder& d
     return false;
   }
   if (!range) {
-    if (env->dataCount.isSome() && *env->dataCount > 0) {
+    if (env->dataCount.isSome() && *env->dataCount > 0) {MOZ_RELEASE_ASSERT(0);
       return d.fail("number of data segments does not match declared count");
     }
     return true;
   }
 
   uint32_t numSegments;
-  if (!d.readVarU32(&numSegments)) {
+  if (!d.readVarU32(&numSegments)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("failed to read number of data segments");
   }
 
-  if (numSegments > MaxDataSegments) {
+  if (numSegments > MaxDataSegments) {MOZ_RELEASE_ASSERT(0);
     return d.fail("too many data segments");
   }
 
@@ -3376,7 +3376,7 @@ static bool DecodeDataSection(Decoder& d
 
     uint32_t memIndex = 0;
     if (initializerKind == DataSegmentKind::ActiveWithMemoryIndex) {
-      if (!d.readVarU32(&memIndex)) {
+      if (!d.readVarU32(&memIndex)) {MOZ_RELEASE_ASSERT(0);
         return d.fail("expected memory index");
       }
       if (memIndex > 0) {
@@ -3388,17 +3388,17 @@ static bool DecodeDataSection(Decoder& d
     if (initializerKind == DataSegmentKind::Active ||
         initializerKind == DataSegmentKind::ActiveWithMemoryIndex) {
       InitExpr segOffset;
-      if (!DecodeInitializerExpression(d, env, ValType::I32, &segOffset)) {
+      if (!DecodeInitializerExpression(d, env, ValType::I32, &segOffset)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       seg.offsetIfActive.emplace(segOffset);
     }
 
-    if (!d.readVarU32(&seg.length)) {
+    if (!d.readVarU32(&seg.length)) {MOZ_RELEASE_ASSERT(0);
       return d.fail("expected segment size");
     }
 
-    if (seg.length > MaxDataSegmentLengthPages * PageSize) {
+    if (seg.length > MaxDataSegmentLengthPages * PageSize) {MOZ_RELEASE_ASSERT(0);
       return d.fail("segment size too big");
     }
 
@@ -3420,7 +3420,7 @@ static bool DecodeModuleNameSubsection(D
                                        const CustomSectionEnv& nameSection,
                                        ModuleEnvironment* env) {
   Maybe<uint32_t> endOffset;
-  if (!d.startNameSubsection(NameType::Module, &endOffset)) {
+  if (!d.startNameSubsection(NameType::Module, &endOffset)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!endOffset) {
@@ -3428,7 +3428,7 @@ static bool DecodeModuleNameSubsection(D
   }
 
   Name moduleName;
-  if (!d.readVarU32(&moduleName.length)) {
+  if (!d.readVarU32(&moduleName.length)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("failed to read module name length");
   }
 
@@ -3437,7 +3437,7 @@ static bool DecodeModuleNameSubsection(D
       d.currentOffset() - nameSection.payloadOffset;
 
   const uint8_t* bytes;
-  if (!d.readBytes(moduleName.length, &bytes)) {
+  if (!d.readBytes(moduleName.length, &bytes)) {MOZ_RELEASE_ASSERT(0);
     return d.fail("failed to read module name bytes");
   }
 
@@ -3462,7 +3462,7 @@ static bool DecodeFunctionNameSubsection
   }
 
   uint32_t nameCount = 0;
-  if (!d.readVarU32(&nameCount) || nameCount > MaxFuncs) {
+  if (!d.readVarU32(&nameCount) || nameCount > MaxFuncs) {MOZ_RELEASE_ASSERT(0);
     return d.fail("bad function name count");
   }
 
@@ -3470,7 +3470,7 @@ static bool DecodeFunctionNameSubsection
 
   for (uint32_t i = 0; i < nameCount; ++i) {
     uint32_t funcIndex = 0;
-    if (!d.readVarU32(&funcIndex)) {
+    if (!d.readVarU32(&funcIndex)) {MOZ_RELEASE_ASSERT(0);
       return d.fail("unable to read function index");
     }
 
@@ -3481,7 +3481,7 @@ static bool DecodeFunctionNameSubsection
 
     Name funcName;
     if (!d.readVarU32(&funcName.length) ||
-        funcName.length > JS::MaxStringLength) {
+        funcName.length > JS::MaxStringLength) {MOZ_RELEASE_ASSERT(0);
       return d.fail("unable to read function name length");
     }
 
@@ -3489,7 +3489,7 @@ static bool DecodeFunctionNameSubsection
       continue;
     }
 
-    if (!funcNames.resize(funcIndex + 1)) {
+    if (!funcNames.resize(funcIndex + 1)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -3516,7 +3516,7 @@ static bool DecodeFunctionNameSubsection
 
 static bool DecodeNameSection(Decoder& d, ModuleEnvironment* env) {
   MaybeSectionRange range;
-  if (!d.startCustomSection(NameSectionName, env, &range)) {
+  if (!d.startCustomSection(NameSectionName, env, &range)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!range) {
@@ -3528,7 +3528,7 @@ static bool DecodeNameSection(Decoder& d
 
   // Once started, custom sections do not report validation errors.
 
-  if (!DecodeModuleNameSubsection(d, nameSection, env)) {
+  if (!DecodeModuleNameSubsection(d, nameSection, env)) {MOZ_RELEASE_ASSERT(0);
     goto finish;
   }
 
@@ -3552,7 +3552,7 @@ bool wasm::DecodeModuleTail(Decoder& d, 
     return false;
   }
 
-  if (!DecodeNameSection(d, env)) {
+  if (!DecodeNameSection(d, env)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/xpconnect/loader/AutoMemMap.cpp b/js/xpconnect/loader/AutoMemMap.cpp
--- a/js/xpconnect/loader/AutoMemMap.cpp
+++ b/js/xpconnect/loader/AutoMemMap.cpp
@@ -41,7 +41,7 @@ Result<Ok, nsresult> AutoMemMap::init(ns
 Result<Ok, nsresult> AutoMemMap::init(const FileDescriptor& file,
                                       PRFileMapProtect prot, size_t maybeSize) {
   MOZ_ASSERT(!fd);
-  if (!file.IsValid()) {
+  if (!file.IsValid()) {MOZ_RELEASE_ASSERT(0);
     return Err(NS_ERROR_INVALID_ARG);
   }
 
@@ -72,7 +72,7 @@ Result<Ok, nsresult> AutoMemMap::initInt
     PRFileInfo64 fileInfo;
     MOZ_TRY(PR_GetOpenFileInfo64(fd.get(), &fileInfo));
 
-    if (fileInfo.size > UINT32_MAX) {
+    if (fileInfo.size > UINT32_MAX) {MOZ_RELEASE_ASSERT(0);
       return Err(NS_ERROR_INVALID_ARG);
     }
     size_ = fileInfo.size;
diff --git a/js/xpconnect/loader/ChromeScriptLoader.cpp b/js/xpconnect/loader/ChromeScriptLoader.cpp
--- a/js/xpconnect/loader/ChromeScriptLoader.cpp
+++ b/js/xpconnect/loader/ChromeScriptLoader.cpp
@@ -138,14 +138,14 @@ bool AsyncScriptCompiler::StartCompile(J
   Rooted<JSObject*> global(aCx, mGlobalObject->GetGlobalJSObject());
 
   JS::SourceText<char16_t> srcBuf;
-  if (!srcBuf.init(aCx, std::move(mScriptText), mScriptLength)) {
+  if (!srcBuf.init(aCx, std::move(mScriptText), mScriptLength)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (JS::CanCompileOffThread(aCx, mOptions, mScriptLength)) {
     if (!JS::CompileOffThread(aCx, mOptions, srcBuf,
                               OffThreadScriptLoaderCallback,
-                              static_cast<void*>(this))) {
+                              static_cast<void*>(this))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -229,7 +229,7 @@ AsyncScriptCompiler::OnStreamComplete(ns
                                       nsISupports* aContext, nsresult aStatus,
                                       uint32_t aLength, const uint8_t* aBuf) {
   AutoJSAPI jsapi;
-  if (!jsapi.Init(mGlobalObject)) {
+  if (!jsapi.Init(mGlobalObject)) {MOZ_RELEASE_ASSERT(0);
     mPromise->MaybeReject(NS_ERROR_FAILURE);
     return NS_OK;
   }
@@ -243,7 +243,7 @@ AsyncScriptCompiler::OnStreamComplete(ns
 
   nsresult rv = ScriptLoader::ConvertToUTF16(
       nullptr, aBuf, aLength, mCharset, nullptr, mScriptText, mScriptLength);
-  if (NS_FAILED(rv)) {
+  if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
     Reject(cx, "Unable to decode script");
     return NS_OK;
   }
@@ -266,7 +266,7 @@ already_AddRefed<Promise> ChromeUtils::C
   MOZ_ASSERT(global);
 
   RefPtr<Promise> promise = Promise::Create(global, aRv);
-  if (aRv.Failed()) {
+  if (aRv.Failed()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
diff --git a/js/xpconnect/loader/ScriptCacheActors.cpp b/js/xpconnect/loader/ScriptCacheActors.cpp
--- a/js/xpconnect/loader/ScriptCacheActors.cpp
+++ b/js/xpconnect/loader/ScriptCacheActors.cpp
@@ -39,7 +39,7 @@ void ScriptCacheChild::SendScriptsAndFin
 
   nsTArray<ScriptData> dataArray;
   for (auto& script : IterHash(scripts, matcher)) {
-    if (!script->mSize && !script->XDREncode(jsapi.cx())) {
+    if (!script->mSize && !script->XDREncode(jsapi.cx())) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
@@ -65,7 +65,7 @@ void ScriptCacheChild::ActorDestroy(Acto
 }
 
 IPCResult ScriptCacheParent::Recv__delete__(nsTArray<ScriptData>&& scripts) {
-  if (!mWantCacheData && scripts.Length()) {
+  if (!mWantCacheData && scripts.Length()) {MOZ_RELEASE_ASSERT(0);
     return IPC_FAIL(this, "UnexpectedScriptData");
   }
 
diff --git a/js/xpconnect/loader/ScriptPreloader.cpp b/js/xpconnect/loader/ScriptPreloader.cpp
--- a/js/xpconnect/loader/ScriptPreloader.cpp
+++ b/js/xpconnect/loader/ScriptPreloader.cpp
@@ -514,14 +514,14 @@ Result<Ok, nsresult> ScriptPreloader::In
   auto size = mCacheData.size();
 
   uint32_t headerSize;
-  if (size < sizeof(MAGIC) + sizeof(headerSize)) {
+  if (size < sizeof(MAGIC) + sizeof(headerSize)) {MOZ_RELEASE_ASSERT(0);
     return Err(NS_ERROR_UNEXPECTED);
   }
 
   auto data = mCacheData.get<uint8_t>();
   auto end = data + size;
 
-  if (memcmp(MAGIC, data.get(), sizeof(MAGIC))) {
+  if (memcmp(MAGIC, data.get(), sizeof(MAGIC))) {MOZ_RELEASE_ASSERT(0);
     return Err(NS_ERROR_UNEXPECTED);
   }
   data += sizeof(MAGIC);
@@ -529,7 +529,7 @@ Result<Ok, nsresult> ScriptPreloader::In
   headerSize = LittleEndian::readUint32(data.get());
   data += sizeof(headerSize);
 
-  if (data + headerSize > end) {
+  if (data + headerSize > end) {MOZ_RELEASE_ASSERT(0);
     return Err(NS_ERROR_UNEXPECTED);
   }
 
@@ -549,13 +549,13 @@ Result<Ok, nsresult> ScriptPreloader::In
       MOZ_RELEASE_ASSERT(script);
 
       auto scriptData = data + script->mOffset;
-      if (scriptData + script->mSize > end) {
+      if (scriptData + script->mSize > end) {MOZ_RELEASE_ASSERT(0);
         return Err(NS_ERROR_UNEXPECTED);
       }
 
       // Make sure offsets match what we'd expect based on script ordering and
       // size, as a basic sanity check.
-      if (script->mOffset != offset) {
+      if (script->mOffset != offset) {MOZ_RELEASE_ASSERT(0);
         return Err(NS_ERROR_UNEXPECTED);
       }
       offset += script->mSize;
@@ -597,7 +597,7 @@ void ScriptPreloader::PrepareCacheWriteI
     }
   });
 
-  if (mDataPrepared) {
+  if (mDataPrepared) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -621,7 +621,7 @@ void ScriptPreloader::PrepareCacheWriteI
       found = true;
     }
 
-    if (!script->mSize && !script->XDREncode(jsapi.cx())) {
+    if (!script->mSize && !script->XDREncode(jsapi.cx())) {MOZ_RELEASE_ASSERT(0);
       script.Remove();
     }
   }
@@ -677,7 +677,7 @@ Result<Ok, nsresult> ScriptPreloader::Wr
 
   bool exists;
   MOZ_TRY(cacheFile->Exists(&exists));
-  if (exists) {
+  if (exists) {MOZ_RELEASE_ASSERT(0);
     MOZ_TRY(cacheFile->Remove(false));
   }
 
@@ -783,7 +783,7 @@ void ScriptPreloader::NoteScript(const n
 
   // Don't bother trying to cache any URLs with cache-busting query
   // parameters.
-  if (cachePath.FindChar('?') >= 0) {
+  if (cachePath.FindChar('?') >= 0) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -1080,7 +1080,7 @@ void ScriptPreloader::DecodeNextBatch(si
       break;
     }
     if (!mParsingScripts.append(script) ||
-        !mParsingSources.emplaceBack(script->Range(), script->mURL.get(), 0)) {
+        !mParsingSources.emplaceBack(script->Range(), script->mURL.get(), 0)) {MOZ_RELEASE_ASSERT(0);
       break;
     }
 
@@ -1105,13 +1105,13 @@ void ScriptPreloader::DecodeNextBatch(si
   if (!JS::CanCompileOffThread(cx, options, size) ||
       !JS::DecodeMultiOffThreadScripts(cx, options, mParsingSources,
                                        OffThreadDecodeCallback,
-                                       static_cast<void*>(this))) {
+                                       static_cast<void*>(this))) {MOZ_RELEASE_ASSERT(0);
     // If we fail here, we don't move on to process the next batch, so make
     // sure we don't have any other scripts left to process.
     MOZ_ASSERT(mPendingScripts.isEmpty());
-    for (auto script : mPendingScripts) {
+    for (auto script : mPendingScripts) {MOZ_RELEASE_ASSERT(0);
       script->mReadyToExecute = true;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     LOG(Info, "Can't decode %lu bytes of scripts off-thread",
         (unsigned long)size);
@@ -1184,7 +1184,7 @@ JSScript* ScriptPreloader::CachedScript:
   if (mScript) {
     if (JS::CheckCompileOptionsMatch(options, mScript.Get())) {
       return mScript.Get();
-    }
+    }MOZ_RELEASE_ASSERT(0);
     LOG(Error, "Cached script %s has different options\n", mURL.get());
     MOZ_DIAGNOSTIC_ASSERT(false, "Cached script has different options");
   }
diff --git a/js/xpconnect/loader/URLPreloader.cpp b/js/xpconnect/loader/URLPreloader.cpp
--- a/js/xpconnect/loader/URLPreloader.cpp
+++ b/js/xpconnect/loader/URLPreloader.cpp
@@ -214,7 +214,7 @@ Result<Ok, nsresult> URLPreloader::Write
 
   bool exists;
   MOZ_TRY(cacheFile->Exists(&exists));
-  if (exists) {
+  if (exists) {MOZ_RELEASE_ASSERT(0);
     MOZ_TRY(cacheFile->Remove(false));
   }
 
@@ -268,14 +268,14 @@ Result<Ok, nsresult> URLPreloader::ReadC
   auto size = cache.size();
 
   uint32_t headerSize;
-  if (size < sizeof(URL_MAGIC) + sizeof(headerSize)) {
+  if (size < sizeof(URL_MAGIC) + sizeof(headerSize)) {MOZ_RELEASE_ASSERT(0);
     return Err(NS_ERROR_UNEXPECTED);
   }
 
   auto data = cache.get<uint8_t>();
   auto end = data + size;
 
-  if (memcmp(URL_MAGIC, data.get(), sizeof(URL_MAGIC))) {
+  if (memcmp(URL_MAGIC, data.get(), sizeof(URL_MAGIC))) {MOZ_RELEASE_ASSERT(0);
     return Err(NS_ERROR_UNEXPECTED);
   }
   data += sizeof(URL_MAGIC);
@@ -283,7 +283,7 @@ Result<Ok, nsresult> URLPreloader::ReadC
   headerSize = LittleEndian::readUint32(data.get());
   data += sizeof(headerSize);
 
-  if (data + headerSize > end) {
+  if (data + headerSize > end) {MOZ_RELEASE_ASSERT(0);
     return Err(NS_ERROR_UNEXPECTED);
   }
 
@@ -363,7 +363,7 @@ void URLPreloader::BackgroundReadFiles()
       }
 
       RefPtr<nsZipArchive> zip = entry->Archive();
-      if (!zip) {
+      if (!zip) {MOZ_RELEASE_ASSERT(0);
         MOZ_CRASH_UNSAFE_PRINTF(
             "Failed to get Omnijar %s archive for entry (path: \"%s\")",
             entry->TypeString(), entry->mPath.get());
@@ -434,7 +434,7 @@ void URLPreloader::BeginBackgroundRead()
   if (!readerThread && !mReaderInitialized && sInitialized) {
     nsresult rv;
     rv = NS_NewNamedThread("BGReadURLs", getter_AddRefs(readerThread));
-    if (NS_WARN_IF(NS_FAILED(rv))) {
+    if (NS_WARN_IF(NS_FAILED(rv))) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
@@ -637,12 +637,12 @@ Result<nsCString, nsresult> URLPreloader
     LOG(Info, "Read in %fms\n", (TimeStamp::Now() - now).ToMilliseconds());
   });
 
-  if (mResultCode == NS_ERROR_NOT_INITIALIZED) {
+  if (mResultCode == NS_ERROR_NOT_INITIALIZED) {MOZ_RELEASE_ASSERT(0);
     MonitorAutoLock mal(GetSingleton().mMonitor);
 
-    while (mResultCode == NS_ERROR_NOT_INITIALIZED) {
+    while (mResultCode == NS_ERROR_NOT_INITIALIZED) {MOZ_RELEASE_ASSERT(0);
       mal.Wait();
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   if (mResultCode == NS_OK && mData.IsVoid()) {
diff --git a/js/xpconnect/loader/mozJSComponentLoader.cpp b/js/xpconnect/loader/mozJSComponentLoader.cpp
--- a/js/xpconnect/loader/mozJSComponentLoader.cpp
+++ b/js/xpconnect/loader/mozJSComponentLoader.cpp
@@ -108,17 +108,17 @@ static bool Dump(JSContext* cx, unsigned
 
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() == 0) {
+  if (args.length() == 0) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   RootedString str(cx, JS::ToString(cx, args[0]));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JS::UniqueChars utf8str = JS_EncodeStringToUTF8(cx, str);
-  if (!utf8str) {
+  if (!utf8str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -128,7 +128,7 @@ static bool Dump(JSContext* cx, unsigned
   __android_log_print(ANDROID_LOG_INFO, "Gecko", "%s", utf8str.get());
 #endif
 #ifdef XP_WIN
-  if (IsDebuggerPresent()) {
+  if (IsDebuggerPresent()) {MOZ_RELEASE_ASSERT(0);
     nsAutoJSString wstr;
     if (!wstr.init(cx, str)) {
       return false;
@@ -170,10 +170,10 @@ class MOZ_STACK_CLASS JSCLContextHelper 
 };
 
 static nsresult MOZ_FORMAT_PRINTF(2, 3)
-    ReportOnCallerUTF8(JSContext* callerContext, const char* format, ...) {
-  if (!callerContext) {
+    ReportOnCallerUTF8(JSContext* callerContext, const char* format, ...) {MOZ_RELEASE_ASSERT(0);
+  if (!callerContext) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   va_list ap;
   va_start(ap, format);
@@ -328,7 +328,7 @@ static JSObject* ResolveModuleObjectProp
   if (JS_HasExtensibleLexicalEnvironment(aModObj)) {
     RootedObject lexical(aCx, JS_ExtensibleLexicalEnvironment(aModObj));
     bool found;
-    if (!JS_HasOwnProperty(aCx, lexical, name, &found)) {
+    if (!JS_HasOwnProperty(aCx, lexical, name, &found)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (found) {
@@ -339,7 +339,7 @@ static JSObject* ResolveModuleObjectProp
 }
 
 const mozilla::Module* mozJSComponentLoader::LoadModule(FileLocation& aFile) {
-  if (!NS_IsMainThread()) {
+  if (!NS_IsMainThread()) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(false, "Don't use JS components off the main thread");
     return nullptr;
   }
@@ -359,7 +359,7 @@ const mozilla::Module* mozJSComponentLoa
   AUTO_PROFILER_MARKER_TEXT("JS XPCOM", JS, MarkerStack::Capture(), spec);
 
   ModuleEntry* mod;
-  if (mModules.Get(spec, &mod)) {
+  if (mModules.Get(spec, &mod)) {MOZ_RELEASE_ASSERT(0);
     return mod;
   }
 
@@ -376,7 +376,7 @@ const mozilla::Module* mozJSComponentLoa
 
   nsCOMPtr<nsIComponentManager> cm;
   rv = NS_GetComponentManager(getter_AddRefs(cm));
-  if (NS_FAILED(rv)) {
+  if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -389,11 +389,11 @@ const mozilla::Module* mozJSComponentLoa
   if (!NSGetFactoryHolder ||
       !JS_GetProperty(cx, NSGetFactoryHolder, "NSGetFactory",
                       &NSGetFactory_val) ||
-      NSGetFactory_val.isUndefined()) {
+      NSGetFactory_val.isUndefined()) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
-  if (JS_TypeOfValue(cx, NSGetFactory_val) != JSTYPE_FUNCTION) {
+  if (JS_TypeOfValue(cx, NSGetFactory_val) != JSTYPE_FUNCTION) {MOZ_RELEASE_ASSERT(0);
     /*
      * spec's encoding is ASCII unless it's zip file, otherwise it's
      * random encoding.  Latin1 variant is safe for random encoding.
@@ -405,7 +405,7 @@ const mozilla::Module* mozJSComponentLoa
 
   RootedObject jsGetFactoryObj(cx);
   if (!JS_ValueToObject(cx, NSGetFactory_val, &jsGetFactoryObj) ||
-      !jsGetFactoryObj) {
+      !jsGetFactoryObj) {MOZ_RELEASE_ASSERT(0);
     /* XXX report error properly */
     return nullptr;
   }
@@ -413,7 +413,7 @@ const mozilla::Module* mozJSComponentLoa
   rv = nsXPConnect::XPConnect()->WrapJS(cx, jsGetFactoryObj,
                                         NS_GET_IID(xpcIJSGetFactory),
                                         getter_AddRefs(entry->getfactoryobj));
-  if (NS_FAILED(rv)) {
+  if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
     /* XXX report error properly */
 #ifdef DEBUG
     fprintf(stderr, "mJCL: couldn't get nsIModule from jsval\n");
@@ -526,7 +526,7 @@ static nsAutoCString MangleURL(const cha
     url.ReplaceSubstring(greDirURI, "<GREDir>/"_ns);
 
     if (FindInReadable("file:"_ns, url)) {
-      if (StringBeginsWith(url, "jar:file:"_ns)) {
+      if (StringBeginsWith(url, "jar:file:"_ns)) {MOZ_RELEASE_ASSERT(0);
         int32_t idx = url.RFindChar('!');
         url = "jar:file://<anonymized>!"_ns + Substring(url, idx);
       } else {
@@ -660,7 +660,7 @@ JSObject* mozJSComponentLoader::PrepareO
         NS_ENSURE_SUCCESS(rv, nullptr);
         NS_ENSURE_TRUE(locationObj, nullptr);
 
-        if (!JS_DefineProperty(aCx, thisObj, "__LOCATION__", locationObj, 0)) {
+        if (!JS_DefineProperty(aCx, thisObj, "__LOCATION__", locationObj, 0)) {MOZ_RELEASE_ASSERT(0);
           return nullptr;
         }
       }
@@ -698,7 +698,7 @@ static mozilla::Result<nsCString, nsresu
 
   /* malloc an internal buf the size of the file */
   nsCString str;
-  if (!str.SetLength(len, fallible)) {
+  if (!str.SetLength(len, fallible)) {MOZ_RELEASE_ASSERT(0);
     return Err(NS_ERROR_OUT_OF_MEMORY);
   }
 
@@ -798,7 +798,7 @@ nsresult mozJSComponentLoader::ObjectFor
       if (srcBuf.init(cx, buf.get(), map.size(),
                       JS::SourceOwnership::Borrowed)) {
         script = Compile(cx, options, srcBuf);
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         MOZ_ASSERT(!script);
       }
     } else {
@@ -809,14 +809,14 @@ nsresult mozJSComponentLoader::ObjectFor
       if (srcBuf.init(cx, str.get(), str.Length(),
                       JS::SourceOwnership::Borrowed)) {
         script = Compile(cx, options, srcBuf);
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         MOZ_ASSERT(!script);
       }
     }
     // Propagate the exception, if one exists. Also, don't leave the stale
     // exception on this context.
     if (!script && aPropagateExceptions && jsapi.HasException()) {
-      if (!jsapi.StealException(aException)) {
+      if (!jsapi.StealException(aException)) {MOZ_RELEASE_ASSERT(0);
         return NS_ERROR_OUT_OF_MEMORY;
       }
     }
@@ -860,7 +860,7 @@ nsresult mozJSComponentLoader::ObjectFor
     JSContext* aescx = aes.cx();
 
     bool executeOk = false;
-    if (JS_IsGlobalObject(obj)) {
+    if (JS_IsGlobalObject(obj)) {MOZ_RELEASE_ASSERT(0);
       JS::RootedValue rval(cx);
       executeOk = JS::CloneAndExecuteScript(aescx, script, &rval);
     } else {
@@ -931,11 +931,11 @@ nsresult mozJSComponentLoader::ImportInt
       // content by passing a raw content JS object (where Xrays aren't
       // possible), we aim for consistency here. Waive xray.
       if (WrapperFactory::IsXrayWrapper(&targetVal.toObject()) &&
-          !WrapperFactory::WaiveXrayAndWrap(cx, &targetVal)) {
+          !WrapperFactory::WaiveXrayAndWrap(cx, &targetVal)) {MOZ_RELEASE_ASSERT(0);
         return NS_ERROR_FAILURE;
       }
       targetObject = &targetVal.toObject();
-    } else if (!targetVal.isNull()) {
+    } else if (!targetVal.isNull()) {MOZ_RELEASE_ASSERT(0);
       // If targetVal isNull(), we actually want to leave targetObject null.
       // Not doing so breaks |make package|.
       return ReportOnCallerUTF8(cx, ERROR_SCOPE_OBJ,
@@ -943,7 +943,7 @@ nsresult mozJSComponentLoader::ImportInt
     }
   } else {
     FindTargetObject(cx, &targetObject);
-    if (!targetObject) {
+    if (!targetObject) {MOZ_RELEASE_ASSERT(0);
       return ReportOnCallerUTF8(cx, ERROR_NO_TARGET_OBJECT,
                                 PromiseFlatCString(registryLocation).get());
     }
@@ -1039,7 +1039,7 @@ static JSObject* ResolveModuleObjectProp
   if (JS_HasExtensibleLexicalEnvironment(aModObj)) {
     RootedObject lexical(aCx, JS_ExtensibleLexicalEnvironment(aModObj));
     bool found;
-    if (!JS_HasOwnPropertyById(aCx, lexical, id, &found)) {
+    if (!JS_HasOwnPropertyById(aCx, lexical, id, &found)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     if (found) {
@@ -1059,7 +1059,7 @@ nsresult mozJSComponentLoader::ImportInt
 
   if (targetObj) {
     JS::Rooted<JS::IdVector> ids(cx, JS::IdVector(cx));
-    if (!JS_Enumerate(cx, exports, &ids)) {
+    if (!JS_Enumerate(cx, exports, &ids)) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_OUT_OF_MEMORY;
     }
 
@@ -1096,13 +1096,13 @@ nsresult mozJSComponentLoader::ExtractEx
   {
     RootedObject obj(
         cx, ResolveModuleObjectProperty(cx, aMod->obj, "EXPORTED_SYMBOLS"));
-    if (!obj || !JS_GetProperty(cx, obj, "EXPORTED_SYMBOLS", &symbols)) {
+    if (!obj || !JS_GetProperty(cx, obj, "EXPORTED_SYMBOLS", &symbols)) {MOZ_RELEASE_ASSERT(0);
       return ReportOnCallerUTF8(cxhelper, ERROR_NOT_PRESENT, aInfo);
     }
   }
 
   bool isArray;
-  if (!JS::IsArrayObject(cx, symbols, &isArray)) {
+  if (!JS::IsArrayObject(cx, symbols, &isArray)) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
   if (!isArray) {
@@ -1114,7 +1114,7 @@ nsresult mozJSComponentLoader::ExtractEx
   // Iterate over symbols array, installing symbols on targetObj:
 
   uint32_t symbolCount = 0;
-  if (!JS::GetArrayLength(cx, symbolsObj, &symbolCount)) {
+  if (!JS::GetArrayLength(cx, symbolsObj, &symbolCount)) {MOZ_RELEASE_ASSERT(0);
     return ReportOnCallerUTF8(cxhelper, ERROR_GETTING_ARRAY_LENGTH, aInfo);
   }
 
@@ -1123,7 +1123,7 @@ nsresult mozJSComponentLoader::ExtractEx
 #endif
 
   aExports.set(JS_NewPlainObject(cx));
-  if (!aExports) {
+  if (!aExports) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
@@ -1140,12 +1140,12 @@ nsresult mozJSComponentLoader::ExtractEx
 
     symbolHolder = ResolveModuleObjectPropertyById(cx, aMod->obj, symbolId);
     if (!symbolHolder ||
-        !JS_GetPropertyById(cx, symbolHolder, symbolId, &value)) {
+        !JS_GetPropertyById(cx, symbolHolder, symbolId, &value)) {MOZ_RELEASE_ASSERT(0);
       RootedString symbolStr(cx, JSID_TO_STRING(symbolId));
       JS::UniqueChars bytes = JS_EncodeStringToUTF8(cx, symbolStr);
-      if (!bytes) {
+      if (!bytes) {MOZ_RELEASE_ASSERT(0);
         return NS_ERROR_FAILURE;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       return ReportOnCallerUTF8(cxhelper, ERROR_GETTING_SYMBOL, aInfo,
                                 bytes.get());
     }
@@ -1155,7 +1155,7 @@ nsresult mozJSComponentLoader::ExtractEx
     if (value.isMagic(JS_UNINITIALIZED_LEXICAL)) {
       RootedString symbolStr(cx, JSID_TO_STRING(symbolId));
       JS::UniqueChars bytes = JS_EncodeStringToUTF8(cx, symbolStr);
-      if (!bytes) {
+      if (!bytes) {MOZ_RELEASE_ASSERT(0);
         return NS_ERROR_FAILURE;
       }
       return ReportOnCallerUTF8(cxhelper, ERROR_UNINITIALIZED_SYMBOL, aInfo,
@@ -1166,12 +1166,12 @@ nsresult mozJSComponentLoader::ExtractEx
       missing = true;
     }
 
-    if (!JS_SetPropertyById(cx, aExports, symbolId, value)) {
+    if (!JS_SetPropertyById(cx, aExports, symbolId, value)) {MOZ_RELEASE_ASSERT(0);
       RootedString symbolStr(cx, JSID_TO_STRING(symbolId));
       JS::UniqueChars bytes = JS_EncodeStringToUTF8(cx, symbolStr);
-      if (!bytes) {
+      if (!bytes) {MOZ_RELEASE_ASSERT(0);
         return NS_ERROR_FAILURE;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       return ReportOnCallerUTF8(cxhelper, ERROR_GETTING_SYMBOL, aInfo,
                                 bytes.get());
     }
@@ -1224,7 +1224,7 @@ nsresult mozJSComponentLoader::Import(JS
       !mInProgressImports.Get(info.Key(), &mod)) {
     // We're trying to import a new JSM, but we're late in shutdown and this
     // will likely not succeed and might even crash, so fail here.
-    if (PastShutdownPhase(ShutdownPhase::XPCOMShutdownFinal)) {
+    if (PastShutdownPhase(ShutdownPhase::XPCOMShutdownFinal)) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_ILLEGAL_DURING_SHUTDOWN;
     }
 
@@ -1282,7 +1282,7 @@ nsresult mozJSComponentLoader::Import(JS
       if (!exception.isUndefined()) {
         // An exception was thrown during compilation. Propagate it
         // out to our caller so they can report it.
-        if (!JS_WrapValue(aCx, &exception)) {
+        if (!JS_WrapValue(aCx, &exception)) {MOZ_RELEASE_ASSERT(0);
           return NS_ERROR_OUT_OF_MEMORY;
         }
         JS_SetPendingException(aCx, exception);
@@ -1310,7 +1310,7 @@ nsresult mozJSComponentLoader::Import(JS
     MOZ_TRY(ExtractExports(aCx, info, mod, &exports));
   }
 
-  if (exports && !JS_WrapObject(aCx, &exports)) {
+  if (exports && !JS_WrapObject(aCx, &exports)) {MOZ_RELEASE_ASSERT(0);
     mLocations.Remove(newEntry->resolvedURL);
     return NS_ERROR_FAILURE;
   }
@@ -1325,7 +1325,7 @@ nsresult mozJSComponentLoader::Import(JS
 }
 
 nsresult mozJSComponentLoader::Unload(const nsACString& aLocation) {
-  if (!mInitialized) {
+  if (!mInitialized) {MOZ_RELEASE_ASSERT(0);
     return NS_OK;
   }
 
diff --git a/js/xpconnect/loader/mozJSSubScriptLoader.cpp b/js/xpconnect/loader/mozJSSubScriptLoader.cpp
--- a/js/xpconnect/loader/mozJSSubScriptLoader.cpp
+++ b/js/xpconnect/loader/mozJSSubScriptLoader.cpp
@@ -105,7 +105,7 @@ static void ReportError(JSContext* cx, c
 }
 
 static void ReportError(JSContext* cx, const char* origMsg, nsIURI* uri) {
-  if (!uri) {
+  if (!uri) {MOZ_RELEASE_ASSERT(0);
     ReportError(cx, nsDependentCString(origMsg));
     return;
   }
@@ -140,7 +140,7 @@ static bool EvalScript(JSContext* cx, Ha
   MOZ_ASSERT(!js::IsWrapper(targetObj));
 
   if (JS_IsGlobalObject(targetObj)) {
-    if (!JS::CloneAndExecuteScript(cx, script, retval)) {
+    if (!JS::CloneAndExecuteScript(cx, script, retval)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else if (JS::IsJSMEnvironment(targetObj)) {
@@ -150,7 +150,7 @@ static bool EvalScript(JSContext* cx, Ha
     retval.setUndefined();
   } else {
     JS::RootedObjectVector envChain(cx);
-    if (!envChain.append(targetObj)) {
+    if (!envChain.append(targetObj)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!loadScope) {
@@ -171,12 +171,12 @@ static bool EvalScript(JSContext* cx, Ha
         return false;
       }
     } else if (JS_IsGlobalObject(loadScope)) {
-      if (!JS::CloneAndExecuteScript(cx, envChain, script, retval)) {
+      if (!JS::CloneAndExecuteScript(cx, envChain, script, retval)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
       MOZ_ASSERT(JS::IsJSMEnvironment(loadScope));
-      if (!JS::ExecuteInJSMEnvironment(cx, script, loadScope, envChain)) {
+      if (!JS::ExecuteInJSMEnvironment(cx, script, loadScope, envChain)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       retval.setUndefined();
@@ -184,7 +184,7 @@ static bool EvalScript(JSContext* cx, Ha
   }
 
   JSAutoRealm rar(cx, targetObj);
-  if (!JS_WrapValue(cx, retval)) {
+  if (!JS_WrapValue(cx, retval)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -261,12 +261,12 @@ bool mozJSSubScriptLoader::ReadScript(JS
   int64_t len = -1;
 
   rv = chan->GetContentLength(&len);
-  if (NS_FAILED(rv)) {
+  if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
     ReportError(cx, LOAD_ERROR_NOCONTENT, uri);
     return false;
   }
 
-  if (len > INT32_MAX) {
+  if (len > INT32_MAX) {MOZ_RELEASE_ASSERT(0);
     ReportError(cx, LOAD_ERROR_CONTENTTOOBIG, uri);
     return false;
   }
@@ -337,7 +337,7 @@ mozJSSubScriptLoader::LoadSubScriptWithO
                                                HandleValue optionsVal,
                                                JSContext* cx,
                                                MutableHandleValue retval) {
-  if (!optionsVal.isObject()) {
+  if (!optionsVal.isObject()) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_INVALID_ARG;
   }
 
@@ -365,7 +365,7 @@ nsresult mozJSSubScriptLoader::DoLoadSub
   }
 
   targetObj = JS_FindCompilationScope(cx, targetObj);
-  if (!targetObj || !loadScope) {
+  if (!targetObj || !loadScope) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
 
@@ -384,7 +384,7 @@ nsresult mozJSSubScriptLoader::DoLoadSub
 
   // Figure out who's calling us
   JS::AutoFilename filename;
-  if (!JS::DescribeScriptedCaller(cx, &filename)) {
+  if (!JS::DescribeScriptedCaller(cx, &filename)) {MOZ_RELEASE_ASSERT(0);
     // No scripted frame means we don't know who's calling, bail.
     return NS_ERROR_FAILURE;
   }
@@ -392,7 +392,7 @@ nsresult mozJSSubScriptLoader::DoLoadSub
   JSAutoRealm ar(cx, targetObj);
 
   nsCOMPtr<nsIIOService> serv = do_GetService(NS_IOSERVICE_CONTRACTID);
-  if (!serv) {
+  if (!serv) {MOZ_RELEASE_ASSERT(0);
     ReportError(cx, nsLiteralCString(LOAD_ERROR_NOSERVICE));
     return NS_OK;
   }
@@ -414,13 +414,13 @@ nsresult mozJSSubScriptLoader::DoLoadSub
   }
 
   rv = uri->GetSpec(uriStr);
-  if (NS_FAILED(rv)) {
+  if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
     ReportError(cx, nsLiteralCString(LOAD_ERROR_NOSPEC));
     return NS_OK;
   }
 
   rv = uri->GetScheme(scheme);
-  if (NS_FAILED(rv)) {
+  if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
     ReportError(cx, LOAD_ERROR_NOSCHEME, uri);
     return NS_OK;
   }
@@ -461,7 +461,7 @@ nsresult mozJSSubScriptLoader::DoLoadSub
   compileOptions.setFileAndLine(uriStr.get(), 1);
   compileOptions.setNonSyntacticScope(!JS_IsGlobalObject(targetObj));
 
-  if (options.wantReturnValue) {
+  if (options.wantReturnValue) {MOZ_RELEASE_ASSERT(0);
     compileOptions.setNoScriptRval(false);
   }
 
diff --git a/js/xpconnect/loader/nsImportModule.cpp b/js/xpconnect/loader/nsImportModule.cpp
--- a/js/xpconnect/loader/nsImportModule.cpp
+++ b/js/xpconnect/loader/nsImportModule.cpp
@@ -30,7 +30,7 @@ nsresult ImportModule(const char* aURI, 
 
   if (aExportName) {
     JS::RootedValue namedExport(cx);
-    if (!JS_GetProperty(cx, exports, aExportName, &namedExport)) {
+    if (!JS_GetProperty(cx, exports, aExportName, &namedExport)) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_FAILURE;
     }
     if (!namedExport.isObject()) {
diff --git a/js/xpconnect/src/ExportHelpers.cpp b/js/xpconnect/src/ExportHelpers.cpp
--- a/js/xpconnect/src/ExportHelpers.cpp
+++ b/js/xpconnect/src/ExportHelpers.cpp
@@ -58,7 +58,7 @@ class MOZ_STACK_CLASS StackScopedCloneDa
       MOZ_ASSERT(!aData);
 
       size_t idx;
-      if (!JS_ReadBytes(aReader, &idx, sizeof(size_t))) {
+      if (!JS_ReadBytes(aReader, &idx, sizeof(size_t))) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -67,7 +67,7 @@ class MOZ_STACK_CLASS StackScopedCloneDa
       MOZ_ASSERT(IsReflector(reflector, aCx),
                  "Object pointer must be a reflector!");
 
-      if (!JS_WrapObject(aCx, &reflector)) {
+      if (!JS_WrapObject(aCx, &reflector)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -80,13 +80,13 @@ class MOZ_STACK_CLASS StackScopedCloneDa
       RootedValue functionValue(aCx);
       RootedObject obj(aCx, mFunctions[aData]);
 
-      if (!JS_WrapObject(aCx, &obj)) {
+      if (!JS_WrapObject(aCx, &obj)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
       FunctionForwarderOptions forwarderOptions;
       if (!xpc::NewFunctionForwarder(aCx, JSID_VOIDHANDLE, obj,
-                                     forwarderOptions, &functionValue)) {
+                                     forwarderOptions, &functionValue)) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -97,7 +97,7 @@ class MOZ_STACK_CLASS StackScopedCloneDa
       MOZ_ASSERT(!aData);
 
       size_t idx;
-      if (!JS_ReadBytes(aReader, &idx, sizeof(size_t))) {
+      if (!JS_ReadBytes(aReader, &idx, sizeof(size_t))) {MOZ_RELEASE_ASSERT(0);
         return nullptr;
       }
 
@@ -110,7 +110,7 @@ class MOZ_STACK_CLASS StackScopedCloneDa
       JS::Rooted<JS::Value> val(aCx);
       {
         RefPtr<Blob> blob = Blob::Create(global, mBlobImpls[idx]);
-        if (NS_WARN_IF(!blob)) {
+        if (NS_WARN_IF(!blob)) {MOZ_RELEASE_ASSERT(0);
           return nullptr;
         }
 
@@ -147,15 +147,15 @@ class MOZ_STACK_CLASS StackScopedCloneDa
     }
 
     if (mOptions->wrapReflectors && IsReflector(aObj, aCx)) {
-      if (!mReflectors.append(aObj)) {
+      if (!mReflectors.append(aObj)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       size_t idx = mReflectors.length() - 1;
-      if (!JS_WriteUint32Pair(aWriter, SCTAG_REFLECTOR, 0)) {
+      if (!JS_WriteUint32Pair(aWriter, SCTAG_REFLECTOR, 0)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
-      if (!JS_WriteBytes(aWriter, &idx, sizeof(size_t))) {
+      if (!JS_WriteBytes(aWriter, &idx, sizeof(size_t))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       return true;
@@ -163,7 +163,7 @@ class MOZ_STACK_CLASS StackScopedCloneDa
 
     if (JS::IsCallable(aObj)) {
       if (mOptions->cloneFunctions) {
-        if (!mFunctions.append(aObj)) {
+        if (!mFunctions.append(aObj)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         return JS_WriteUint32Pair(aWriter, SCTAG_FUNCTION,
@@ -210,7 +210,7 @@ bool StackScopedClone(JSContext* cx, Sta
   }
 
   // Now recreate the clones in the target realm.
-  if (!data.Read(cx, val)) {
+  if (!data.Read(cx, val)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -287,7 +287,7 @@ static void MaybeSanitizeException(JSCon
     // compartment.  In either case, treating this as uncatchable exception,
     // by returning without setting any exception on the JSContext,
     // seems fine.
-    if (!JS::GetPendingExceptionStack(cx, &exnStack)) {
+    if (!JS::GetPendingExceptionStack(cx, &exnStack)) {MOZ_RELEASE_ASSERT(0);
       JS_ClearPendingException(cx);
       return;
     }
@@ -330,7 +330,7 @@ static bool FunctionForwarder(JSContext*
   RootedObject optionsObj(
       cx, &js::GetFunctionNativeReserved(&args.callee(), 1).toObject());
   FunctionForwarderOptions options(cx, optionsObj);
-  if (!options.Parse()) {
+  if (!options.Parse()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -341,7 +341,7 @@ static bool FunctionForwarder(JSContext*
   RootedValue thisVal(cx, NullValue());
   if (!args.isConstructing()) {
     RootedObject thisObject(cx);
-    if (!args.computeThis(cx, &thisObject)) {
+    if (!args.computeThis(cx, &thisObject)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     thisVal.setObject(*thisObject);
@@ -357,7 +357,7 @@ static bool FunctionForwarder(JSContext*
         JS::GetCompartment(unwrappedFun) != JS::GetCompartment(&args.callee());
     if (crossCompartment) {
       if (!CheckSameOriginArg(cx, options, thisVal) ||
-          !JS_WrapValue(cx, &thisVal)) {
+          !JS_WrapValue(cx, &thisVal)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -415,7 +415,7 @@ bool NewFunctionForwarder(JSContext* cx,
   // let the underlying function throw for construct calls if it wants.
   JSFunction* fun = js::NewFunctionByIdWithReserved(
       cx, FunctionForwarder, nargs, JSFUN_CONSTRUCTOR, id);
-  if (!fun) {
+  if (!fun) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -439,7 +439,7 @@ bool ExportFunction(JSContext* cx, Handl
                     HandleValue voptions, MutableHandleValue rval) {
   bool hasOptions = !voptions.isUndefined();
   if (!vscope.isObject() || !vfunction.isObject() ||
-      (hasOptions && !voptions.isObject())) {
+      (hasOptions && !voptions.isObject())) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Invalid argument");
     return false;
   }
@@ -448,7 +448,7 @@ bool ExportFunction(JSContext* cx, Handl
   RootedObject targetScope(cx, &vscope.toObject());
   ExportFunctionOptions options(cx,
                                 hasOptions ? &voptions.toObject() : nullptr);
-  if (hasOptions && !options.Parse()) {
+  if (hasOptions && !options.Parse()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -465,7 +465,7 @@ bool ExportFunction(JSContext* cx, Handl
     return false;
   }
 
-  if (js::IsScriptedProxy(targetScope)) {
+  if (js::IsScriptedProxy(targetScope)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Defining property on proxy object is not allowed");
     return false;
   }
@@ -477,7 +477,7 @@ bool ExportFunction(JSContext* cx, Handl
 
     // Unwrapping to see if we have a callable.
     funObj = UncheckedUnwrap(funObj);
-    if (!JS::IsCallable(funObj)) {
+    if (!JS::IsCallable(funObj)) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "First argument must be a function");
       return false;
     }
@@ -497,7 +497,7 @@ bool ExportFunction(JSContext* cx, Handl
       }
       JS_MarkCrossZoneIdValue(cx, StringValue(funName));
 
-      if (!JS_StringToId(cx, funName, &id)) {
+      if (!JS_StringToId(cx, funName, &id)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -508,7 +508,7 @@ bool ExportFunction(JSContext* cx, Handl
     // The function forwarder will live in the target compartment. Since
     // this function will be referenced from its private slot, to avoid a
     // GC hazard, we must wrap it to the same compartment.
-    if (!JS_WrapObject(cx, &funObj)) {
+    if (!JS_WrapObject(cx, &funObj)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -517,7 +517,7 @@ bool ExportFunction(JSContext* cx, Handl
     FunctionForwarderOptions forwarderOptions;
     forwarderOptions.allowCrossOriginArguments =
         options.allowCrossOriginArguments;
-    if (!NewFunctionForwarder(cx, id, funObj, forwarderOptions, rval)) {
+    if (!NewFunctionForwarder(cx, id, funObj, forwarderOptions, rval)) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "Exporting function failed");
       return false;
     }
@@ -526,7 +526,7 @@ bool ExportFunction(JSContext* cx, Handl
     // defineAs was set, we also need to define it as a property on
     // the target.
     if (!JSID_IS_VOID(options.defineAs)) {
-      if (!JS_DefinePropertyById(cx, targetScope, id, rval, JSPROP_ENUMERATE)) {
+      if (!JS_DefinePropertyById(cx, targetScope, id, rval, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -543,14 +543,14 @@ bool ExportFunction(JSContext* cx, Handl
 
 bool CreateObjectIn(JSContext* cx, HandleValue vobj,
                     CreateObjectInOptions& options, MutableHandleValue rval) {
-  if (!vobj.isObject()) {
+  if (!vobj.isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Expected an object as the target scope");
     return false;
   }
 
   // cx represents the caller Realm.
   RootedObject scope(cx, js::CheckedUnwrapDynamic(&vobj.toObject(), cx));
-  if (!scope) {
+  if (!scope) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(
         cx, "Permission denied to create object in the target scope");
     return false;
@@ -558,7 +558,7 @@ bool CreateObjectIn(JSContext* cx, Handl
 
   bool define = !JSID_IS_VOID(options.defineAs);
 
-  if (define && js::IsScriptedProxy(scope)) {
+  if (define && js::IsScriptedProxy(scope)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Defining property on proxy object is not allowed");
     return false;
   }
@@ -569,11 +569,11 @@ bool CreateObjectIn(JSContext* cx, Handl
     JS_MarkCrossZoneId(cx, options.defineAs);
 
     obj = JS_NewPlainObject(cx);
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    if (define) {
+    if (define) {MOZ_RELEASE_ASSERT(0);
       if (!JS_DefinePropertyById(cx, scope, options.defineAs, obj,
                                  JSPROP_ENUMERATE))
         return false;
diff --git a/js/xpconnect/src/JSServices.cpp b/js/xpconnect/src/JSServices.cpp
--- a/js/xpconnect/src/JSServices.cpp
+++ b/js/xpconnect/src/JSServices.cpp
@@ -49,7 +49,7 @@ static bool Services_NewEnumerate(JSCont
                                   bool enumerableOnly) {
   auto services = xpcom::StaticComponents::GetJSServices();
 
-  if (!properties.reserve(services.Length())) {
+  if (!properties.reserve(services.Length())) {MOZ_RELEASE_ASSERT(0);
     JS_ReportOutOfMemory(cx);
     return false;
   }
@@ -81,7 +81,7 @@ static bool GetServiceImpl(JSContext* cx
                            JS::MutableHandleObject aObj, ErrorResult& aRv) {
   nsresult rv;
   nsCOMPtr<nsISupports> inst = service.Module().GetService(&rv);
-  if (!inst) {
+  if (!inst) {MOZ_RELEASE_ASSERT(0);
     aRv.Throw(rv);
     return false;
   }
@@ -137,7 +137,7 @@ static bool Services_Resolve(JSContext* 
                              bool* resolvedp) {
   *resolvedp = false;
   JSLinearString* name = GetNameIfLatin1(id);
-  if (!name) {
+  if (!name) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
diff --git a/js/xpconnect/src/Sandbox.cpp b/js/xpconnect/src/Sandbox.cpp
--- a/js/xpconnect/src/Sandbox.cpp
+++ b/js/xpconnect/src/Sandbox.cpp
@@ -144,24 +144,24 @@ already_AddRefed<nsIXPCComponents_utils_
 }
 
 static bool SandboxDump(JSContext* cx, unsigned argc, Value* vp) {
-  if (!nsJSUtils::DumpEnabled()) {
+  if (!nsJSUtils::DumpEnabled()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() == 0) {
+  if (args.length() == 0) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   RootedString str(cx, ToString(cx, args[0]));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JS::UniqueChars utf8str = JS_EncodeStringToUTF8(cx, str);
   char* cstr = utf8str.get();
-  if (!cstr) {
+  if (!cstr) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -198,7 +198,7 @@ static bool SandboxDebug(JSContext* cx, 
 static bool SandboxImport(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() < 1 || args[0].isPrimitive()) {
+  if (args.length() < 1 || args[0].isPrimitive()) {MOZ_RELEASE_ASSERT(0);
     XPCThrower::Throw(NS_ERROR_INVALID_ARG, cx);
     return false;
   }
@@ -207,7 +207,7 @@ static bool SandboxImport(JSContext* cx,
   if (args.length() > 1) {
     // Use the second parameter as the function name.
     funname = ToString(cx, args[1]);
-    if (!funname) {
+    if (!funname) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -221,14 +221,14 @@ static bool SandboxImport(JSContext* cx,
 
     RootedValue funval(cx, ObjectValue(*funobj));
     JSFunction* fun = JS_ValueToFunction(cx, funval);
-    if (!fun) {
+    if (!fun) {MOZ_RELEASE_ASSERT(0);
       XPCThrower::Throw(NS_ERROR_INVALID_ARG, cx);
       return false;
     }
 
     // Use the actual function name as the name.
     funname = JS_GetFunctionId(fun);
-    if (!funname) {
+    if (!funname) {MOZ_RELEASE_ASSERT(0);
       XPCThrower::Throw(NS_ERROR_INVALID_ARG, cx);
       return false;
     }
@@ -236,7 +236,7 @@ static bool SandboxImport(JSContext* cx,
   JS_MarkCrossZoneIdValue(cx, StringValue(funname));
 
   RootedId id(cx);
-  if (!JS_StringToId(cx, funname, &id)) {
+  if (!JS_StringToId(cx, funname, &id)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -244,7 +244,7 @@ static bool SandboxImport(JSContext* cx,
   // unbound and should still work and act on the original sandbox.
 
   RootedObject thisObject(cx);
-  if (!args.computeThis(cx, &thisObject)) {
+  if (!args.computeThis(cx, &thisObject)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -288,10 +288,10 @@ static bool SetFetchRequestFromValue(JSC
   RequestOrUSVStringArgument requestHolder(request);
   bool noMatch = true;
   if (requestOrUrl.isObject() &&
-      !requestHolder.TrySetToRequest(cx, requestOrUrl, noMatch, false)) {
+      !requestHolder.TrySetToRequest(cx, requestOrUrl, noMatch, false)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (noMatch && !requestHolder.TrySetToUSVString(cx, requestOrUrl, noMatch)) {
+  if (noMatch && !requestHolder.TrySetToUSVString(cx, requestOrUrl, noMatch)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (noMatch) {
@@ -302,24 +302,24 @@ static bool SetFetchRequestFromValue(JSC
 
 static bool SandboxFetch(JSContext* cx, JS::HandleObject scope,
                          const CallArgs& args) {
-  if (args.length() < 1) {
+  if (args.length() < 1) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "fetch requires at least 1 argument");
     return false;
   }
 
   RequestOrUSVString request;
-  if (!SetFetchRequestFromValue(cx, request, args[0])) {
+  if (!SetFetchRequestFromValue(cx, request, args[0])) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "fetch requires a string or Request in argument 1");
     return false;
   }
   RootedDictionary<dom::RequestInit> options(cx);
   BindingCallContext callCx(cx, "fetch");
   if (!options.Init(cx, args.hasDefined(1) ? args[1] : JS::NullHandleValue,
-                    "Argument 2", false)) {
+                    "Argument 2", false)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   nsCOMPtr<nsIGlobalObject> global = xpc::NativeGlobal(scope);
-  if (!global) {
+  if (!global) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   dom::CallerType callerType = nsContentUtils::IsSystemCaller(cx)
@@ -356,7 +356,7 @@ static bool SandboxCreateFetch(JSContext
 
 static bool SandboxIsProxy(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (args.length() < 1) {
+  if (args.length() < 1) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Function requires at least 1 argument");
     return false;
   }
@@ -398,7 +398,7 @@ static bool SandboxExportFunction(JSCont
 
 static bool SandboxCreateObjectIn(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (args.length() < 1) {
+  if (args.length() < 1) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Function requires at least 1 argument");
     return false;
   }
@@ -406,7 +406,7 @@ static bool SandboxCreateObjectIn(JSCont
   RootedObject optionsObj(cx);
   bool calledWithOptions = args.length() > 1;
   if (calledWithOptions) {
-    if (!args[1].isObject()) {
+    if (!args[1].isObject()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(
           cx, "Expected the 2nd argument (options) to be an object");
       return false;
@@ -632,7 +632,7 @@ bool SandboxCallableProxyHandler::call(J
   RootedValue thisVal(cx, args.thisv());
   if (isXray) {
     RootedObject thisObject(cx);
-    if (!args.computeThis(cx, &thisObject)) {
+    if (!args.computeThis(cx, &thisObject)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     thisVal.setObject(*thisObject);
@@ -704,7 +704,7 @@ bool SandboxProxyHandler::getPropertyDes
   MOZ_ASSERT(JS::GetCompartment(obj) == JS::GetCompartment(proxy));
 
   if (getOwn) {
-    if (!JS_GetOwnPropertyDescriptorById(cx, obj, id, desc)) {
+    if (!JS_GetOwnPropertyDescriptorById(cx, obj, id, desc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   } else {
@@ -719,11 +719,11 @@ bool SandboxProxyHandler::getPropertyDes
 
   // Now fix up the getter/setter/value as needed to be bound to desc->obj.
   if (desc.hasGetterObject() &&
-      !WrapAccessorFunction(cx, desc.getterObject(), proxy)) {
+      !WrapAccessorFunction(cx, desc.getterObject(), proxy)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (desc.hasSetterObject() &&
-      !WrapAccessorFunction(cx, desc.setterObject(), proxy)) {
+      !WrapAccessorFunction(cx, desc.setterObject(), proxy)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (desc.value().isObject()) {
@@ -830,12 +830,12 @@ bool xpc::GlobalProperties::Parse(JSCont
     RootedValue nameValue(cx);
     ok = JS_GetElement(cx, obj, i, &nameValue);
     NS_ENSURE_TRUE(ok, false);
-    if (!nameValue.isString()) {
+    if (!nameValue.isString()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx, "Property names must be strings");
       return false;
     }
     JSLinearString* nameStr = JS_EnsureLinearString(cx, nameValue.toString());
-    if (!nameStr) {
+    if (!nameStr) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (JS_LinearStringEqualsLiteral(nameStr, "Blob")) {
@@ -874,11 +874,11 @@ bool xpc::GlobalProperties::Parse(JSCont
       MessageChannel = true;
     } else if (JS_LinearStringEqualsLiteral(nameStr, "Node")) {
       Node = true;
-    } else if (JS_LinearStringEqualsLiteral(nameStr, "NodeFilter")) {
+    } else if (JS_LinearStringEqualsLiteral(nameStr, "NodeFilter")) {MOZ_RELEASE_ASSERT(0);
       NodeFilter = true;
     } else if (JS_LinearStringEqualsLiteral(nameStr, "Performance")) {
       Performance = true;
-    } else if (JS_LinearStringEqualsLiteral(nameStr, "PromiseDebugging")) {
+    } else if (JS_LinearStringEqualsLiteral(nameStr, "PromiseDebugging")) {MOZ_RELEASE_ASSERT(0);
       PromiseDebugging = true;
     } else if (JS_LinearStringEqualsLiteral(nameStr, "Range")) {
       Range = true;
@@ -894,7 +894,7 @@ bool xpc::GlobalProperties::Parse(JSCont
       URLSearchParams = true;
     } else if (JS_LinearStringEqualsLiteral(nameStr, "XMLHttpRequest")) {
       XMLHttpRequest = true;
-    } else if (JS_LinearStringEqualsLiteral(nameStr, "XMLSerializer")) {
+    } else if (JS_LinearStringEqualsLiteral(nameStr, "XMLSerializer")) {MOZ_RELEASE_ASSERT(0);
       XMLSerializer = true;
     } else if (JS_LinearStringEqualsLiteral(nameStr, "atob")) {
       atob = true;
@@ -915,7 +915,7 @@ bool xpc::GlobalProperties::Parse(JSCont
     } else if (JS_LinearStringEqualsLiteral(nameStr, "GleanPings")) {
       gleanPings = true;
 #ifdef MOZ_WEBRTC
-    } else if (JS_LinearStringEqualsLiteral(nameStr, "rtcIdentityProvider")) {
+    } else if (JS_LinearStringEqualsLiteral(nameStr, "rtcIdentityProvider")) {MOZ_RELEASE_ASSERT(0);
       rtcIdentityProvider = true;
 #endif
     } else {
@@ -941,34 +941,34 @@ bool xpc::GlobalProperties::Define(JSCon
   // |wantGlobalProperties| of a sandbox.
   if (Blob && !dom::Blob_Binding::GetConstructorObject(cx)) return false;
 
-  if (ChromeUtils && !dom::ChromeUtils_Binding::GetConstructorObject(cx)) {
+  if (ChromeUtils && !dom::ChromeUtils_Binding::GetConstructorObject(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (CSS && !dom::CSS_Binding::GetConstructorObject(cx)) {
+  if (CSS && !dom::CSS_Binding::GetConstructorObject(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (CSSRule && !dom::CSSRule_Binding::GetConstructorObject(cx)) {
+  if (CSSRule && !dom::CSSRule_Binding::GetConstructorObject(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   if (Directory && !dom::Directory_Binding::GetConstructorObject(cx))
     return false;
 
-  if (Document && !dom::Document_Binding::GetConstructorObject(cx)) {
+  if (Document && !dom::Document_Binding::GetConstructorObject(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (DOMException && !dom::DOMException_Binding::GetConstructorObject(cx)) {
+  if (DOMException && !dom::DOMException_Binding::GetConstructorObject(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (DOMParser && !dom::DOMParser_Binding::GetConstructorObject(cx)) {
+  if (DOMParser && !dom::DOMParser_Binding::GetConstructorObject(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (DOMTokenList && !dom::DOMTokenList_Binding::GetConstructorObject(cx)) {
+  if (DOMTokenList && !dom::DOMTokenList_Binding::GetConstructorObject(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -978,16 +978,16 @@ bool xpc::GlobalProperties::Define(JSCon
 
   if (File && !dom::File_Binding::GetConstructorObject(cx)) return false;
 
-  if (FileReader && !dom::FileReader_Binding::GetConstructorObject(cx)) {
+  if (FileReader && !dom::FileReader_Binding::GetConstructorObject(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   if (FormData && !dom::FormData_Binding::GetConstructorObject(cx))
     return false;
 
-  if (Headers && !dom::Headers_Binding::GetConstructorObject(cx)) {
+  if (Headers && !dom::Headers_Binding::GetConstructorObject(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   if (InspectorUtils && !dom::InspectorUtils_Binding::GetConstructorObject(cx))
     return false;
@@ -997,30 +997,30 @@ bool xpc::GlobalProperties::Define(JSCon
        !dom::MessagePort_Binding::GetConstructorObject(cx)))
     return false;
 
-  if (Node && !dom::Node_Binding::GetConstructorObject(cx)) {
+  if (Node && !dom::Node_Binding::GetConstructorObject(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (NodeFilter && !dom::NodeFilter_Binding::GetConstructorObject(cx)) {
+  if (NodeFilter && !dom::NodeFilter_Binding::GetConstructorObject(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (Performance && !dom::Performance_Binding::GetConstructorObject(cx)) {
+  if (Performance && !dom::Performance_Binding::GetConstructorObject(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (PromiseDebugging &&
-      !dom::PromiseDebugging_Binding::GetConstructorObject(cx)) {
+      !dom::PromiseDebugging_Binding::GetConstructorObject(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (Range && !dom::Range_Binding::GetConstructorObject(cx)) {
+  if (Range && !dom::Range_Binding::GetConstructorObject(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (Selection && !dom::Selection_Binding::GetConstructorObject(cx)) {
+  if (Selection && !dom::Selection_Binding::GetConstructorObject(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   if (TextDecoder && !dom::TextDecoder_Binding::GetConstructorObject(cx))
     return false;
@@ -1044,15 +1044,15 @@ bool xpc::GlobalProperties::Define(JSCon
 
   if (btoa && !JS_DefineFunction(cx, obj, "btoa", Btoa, 1, 0)) return false;
 
-  if (caches && !dom::cache::CacheStorage::DefineCaches(cx, obj)) {
+  if (caches && !dom::cache::CacheStorage::DefineCaches(cx, obj)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (crypto && !SandboxCreateCrypto(cx, obj)) {
+  if (crypto && !SandboxCreateCrypto(cx, obj)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (fetch && !SandboxCreateFetch(cx, obj)) {
+  if (fetch && !SandboxCreateFetch(cx, obj)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1075,7 +1075,7 @@ bool xpc::GlobalProperties::Define(JSCon
 }
 
 bool xpc::GlobalProperties::DefineInXPCComponents(JSContext* cx,
-                                                  JS::HandleObject obj) {
+                                                  JS::HandleObject obj) {MOZ_RELEASE_ASSERT(0);
   if (indexedDB && !IndexedDatabaseManager::DefineIndexedDB(cx, obj))
     return false;
 
@@ -1106,7 +1106,7 @@ bool xpc::GlobalProperties::DefineInSand
  */
 nsresult ApplyAddonContentScriptCSP(nsISupports* prinOrSop) {
   nsCOMPtr<nsIPrincipal> principal = do_QueryInterface(prinOrSop);
-  if (!principal) {
+  if (!principal) {MOZ_RELEASE_ASSERT(0);
     return NS_OK;
   }
 
@@ -1231,7 +1231,7 @@ nsresult xpc::CreateSandboxObject(JSCont
 
   RootedObject sandbox(
       cx, xpc::CreateGlobalObject(cx, clasp, principal, realmOptions));
-  if (!sandbox) {
+  if (!sandbox) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
 
@@ -1277,13 +1277,13 @@ nsresult xpc::CreateSandboxObject(JSCont
 
     // Ensure |Object.prototype| is instantiated before prototype-
     // splicing below.
-    if (!JS::GetRealmObjectPrototype(cx)) {
+    if (!JS::GetRealmObjectPrototype(cx)) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_XPC_UNEXPECTED;
     }
 
     if (options.proto) {
       bool ok = JS_WrapObject(cx, &options.proto);
-      if (!ok) {
+      if (!ok) {MOZ_RELEASE_ASSERT(0);
         return NS_ERROR_XPC_UNEXPECTED;
       }
 
@@ -1317,29 +1317,29 @@ nsresult xpc::CreateSandboxObject(JSCont
         RootedValue priv(cx, ObjectValue(*options.proto));
         options.proto =
             js::NewProxyObject(cx, &sandboxProxyHandler, priv, nullptr);
-        if (!options.proto) {
+        if (!options.proto) {MOZ_RELEASE_ASSERT(0);
           return NS_ERROR_OUT_OF_MEMORY;
         }
       }
 
       ok = JS_SetPrototype(cx, sandbox, options.proto);
-      if (!ok) {
+      if (!ok) {MOZ_RELEASE_ASSERT(0);
         return NS_ERROR_XPC_UNEXPECTED;
       }
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     bool allowComponents = principal->IsSystemPrincipal();
     if (options.wantComponents && allowComponents &&
         !ObjectScope(sandbox)->AttachComponentsObject(cx))
       return NS_ERROR_XPC_UNEXPECTED;
 
-    if (!XPCNativeWrapper::AttachNewConstructorObject(cx, sandbox)) {
+    if (!XPCNativeWrapper::AttachNewConstructorObject(cx, sandbox)) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_XPC_UNEXPECTED;
     }
 
-    if (!JS_DefineFunctions(cx, sandbox, SandboxFunctions)) {
+    if (!JS_DefineFunctions(cx, sandbox, SandboxFunctions)) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_XPC_UNEXPECTED;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     if (options.wantExportHelpers &&
         (!JS_DefineFunction(cx, sandbox, "exportFunction",
@@ -1350,7 +1350,7 @@ nsresult xpc::CreateSandboxObject(JSCont
          !JS_DefineFunction(cx, sandbox, "isProxy", SandboxIsProxy, 1, 0)))
       return NS_ERROR_XPC_UNEXPECTED;
 
-    if (!options.globalProperties.DefineInSandbox(cx, sandbox)) {
+    if (!options.globalProperties.DefineInSandbox(cx, sandbox)) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_XPC_UNEXPECTED;
     }
   }
@@ -1402,7 +1402,7 @@ bool ParsePrincipal(JSContext* cx, Handl
   nsAutoJSString contentStr;
   NS_ENSURE_TRUE(contentStr.init(cx, contentUrl), false);
   nsresult rv = NS_NewURI(getter_AddRefs(uri), contentStr);
-  if (NS_FAILED(rv)) {
+  if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Creating URI from string failed");
     return false;
   }
@@ -1455,10 +1455,10 @@ static bool GetExpandedPrincipal(JSConte
   MOZ_ASSERT(out);
   uint32_t length;
 
-  if (!JS::GetArrayLength(cx, arrayObj, &length)) {
+  if (!JS::GetArrayLength(cx, arrayObj, &length)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!length) {
+  if (!length) {MOZ_RELEASE_ASSERT(0);
     // We need a whitelist of principals or uri strings to create an
     // expanded principal, if we got an empty array or something else
     // report error.
@@ -1480,7 +1480,7 @@ static bool GetExpandedPrincipal(JSConte
   if (options.originAttributes) {
     attrs.emplace();
     JS::RootedValue val(cx, JS::ObjectValue(*options.originAttributes));
-    if (!attrs->Init(cx, val)) {
+    if (!attrs->Init(cx, val)) {MOZ_RELEASE_ASSERT(0);
       // The originAttributes option, if specified, must be valid!
       JS_ReportErrorASCII(cx, "Expected a valid OriginAttributes object");
       return false;
@@ -1502,7 +1502,7 @@ static bool GetExpandedPrincipal(JSConte
   // First pass:
   for (uint32_t i = 0; i < length; ++i) {
     RootedValue allowed(cx);
-    if (!JS_GetElement(cx, arrayObj, i, &allowed)) {
+    if (!JS_GetElement(cx, arrayObj, i, &allowed)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1512,7 +1512,7 @@ static bool GetExpandedPrincipal(JSConte
       // ScriptObjectPrincipal.
       nsCOMPtr<nsISupports> prinOrSop;
       RootedObject obj(cx, &allowed.toObject());
-      if (!GetPrincipalOrSOP(cx, obj, getter_AddRefs(prinOrSop))) {
+      if (!GetPrincipalOrSOP(cx, obj, getter_AddRefs(prinOrSop))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -1527,7 +1527,7 @@ static bool GetExpandedPrincipal(JSConte
         const OriginAttributes prinAttrs = principal->OriginAttributesRef();
         if (attrs.isNothing()) {
           attrs.emplace(prinAttrs);
-        } else if (prinAttrs != attrs.ref()) {
+        } else if (prinAttrs != attrs.ref()) {MOZ_RELEASE_ASSERT(0);
           // If attrs is from a previously encountered principal in the
           // array, we need to ensure that it matches the OA of the
           // principal we have here.
@@ -1539,7 +1539,7 @@ static bool GetExpandedPrincipal(JSConte
 
       // We do not allow ExpandedPrincipals to contain any system principals.
       bool isSystem = principal->IsSystemPrincipal();
-      if (isSystem) {
+      if (isSystem) {MOZ_RELEASE_ASSERT(0);
         JS_ReportErrorASCII(
             cx, "System principal is not allowed in an expanded principal");
         return false;
@@ -1547,7 +1547,7 @@ static bool GetExpandedPrincipal(JSConte
       allowedDomains[i] = principal;
     } else if (allowed.isString()) {
       // Skip any string arguments - we handle them in the next pass.
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       // Don't know what this is.
       return false;
     }
@@ -1562,7 +1562,7 @@ static bool GetExpandedPrincipal(JSConte
   // Second pass:
   for (uint32_t i = 0; i < length; ++i) {
     RootedValue allowed(cx);
-    if (!JS_GetElement(cx, arrayObj, i, &allowed)) {
+    if (!JS_GetElement(cx, arrayObj, i, &allowed)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1575,7 +1575,7 @@ static bool GetExpandedPrincipal(JSConte
       // originAttributes option isn't specified, and no object in the array
       // provides a principal.  Otherwise it's either the forced principal, or
       // the principal found before, so we can use it here.
-      if (!ParsePrincipal(cx, str, attrs.ref(), getter_AddRefs(principal))) {
+      if (!ParsePrincipal(cx, str, attrs.ref(), getter_AddRefs(principal))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       NS_ENSURE_TRUE(principal, false);
@@ -1658,13 +1658,13 @@ bool OptionsBase::ParseObject(const char
 /*
  * Helper that tries to get an object property from the options object.
  */
-bool OptionsBase::ParseJSString(const char* name, MutableHandleString prop) {
+bool OptionsBase::ParseJSString(const char* name, MutableHandleString prop) {MOZ_RELEASE_ASSERT(0);
   RootedValue value(mCx);
   bool found;
   bool ok = ParseValue(name, &value, &found);
   NS_ENSURE_TRUE(ok, false);
 
-  if (!found) {
+  if (!found) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -1703,20 +1703,20 @@ bool OptionsBase::ParseString(const char
 /*
  * Helper that tries to get a string property from the options object.
  */
-bool OptionsBase::ParseString(const char* name, nsString& prop) {
+bool OptionsBase::ParseString(const char* name, nsString& prop) {MOZ_RELEASE_ASSERT(0);
   RootedValue value(mCx);
   bool found;
   bool ok = ParseValue(name, &value, &found);
   NS_ENSURE_TRUE(ok, false);
 
-  if (!found) {
+  if (!found) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
-  if (!value.isString()) {
+  if (!value.isString()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(mCx, "Expected a string value for property %s", name);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   nsAutoJSString strVal;
   if (!strVal.init(mCx, value.toString())) {
@@ -1778,7 +1778,7 @@ bool SandboxOptions::ParseGlobalProperti
     return true;
   }
 
-  if (!value.isObject()) {
+  if (!value.isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(mCx,
                         "Expected an array value for wantGlobalProperties");
     return false;
@@ -1786,7 +1786,7 @@ bool SandboxOptions::ParseGlobalProperti
 
   RootedObject ctors(mCx, &value.toObject());
   bool isArray;
-  if (!JS::IsArrayObject(mCx, ctors, &isArray)) {
+  if (!JS::IsArrayObject(mCx, ctors, &isArray)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (!isArray) {
@@ -1873,7 +1873,7 @@ static nsresult AssembleSandboxMemoryRep
 nsresult nsXPCComponents_utils_Sandbox::CallOrConstruct(
     nsIXPConnectWrappedNative* wrapper, JSContext* cx, HandleObject obj,
     const CallArgs& args, bool* _retval) {
-  if (args.length() < 1) {
+  if (args.length() < 1) {MOZ_RELEASE_ASSERT(0);
     return ThrowAndFail(NS_ERROR_XPC_NOT_ENOUGH_ARGS, cx, _retval);
   }
 
@@ -1902,7 +1902,7 @@ nsresult nsXPCComponents_utils_Sandbox::
     OriginAttributes attrs;
     if (options.originAttributes) {
       JS::RootedValue val(cx, JS::ObjectValue(*options.originAttributes));
-      if (!attrs.Init(cx, val)) {
+      if (!attrs.Init(cx, val)) {MOZ_RELEASE_ASSERT(0);
         // The originAttributes option, if specified, must be valid!
         JS_ReportErrorASCII(cx, "Expected a valid OriginAttributes object");
         return ThrowAndFail(NS_ERROR_INVALID_ARG, cx, _retval);
@@ -1914,10 +1914,10 @@ nsresult nsXPCComponents_utils_Sandbox::
   } else if (args[0].isObject()) {
     RootedObject obj(cx, &args[0].toObject());
     bool isArray;
-    if (!JS::IsArrayObject(cx, obj, &isArray)) {
+    if (!JS::IsArrayObject(cx, obj, &isArray)) {MOZ_RELEASE_ASSERT(0);
       ok = false;
     } else if (isArray) {
-      if (options.userContextId != 0) {
+      if (options.userContextId != 0) {MOZ_RELEASE_ASSERT(0);
         // We don't support passing a userContextId with an array.
         ok = false;
       } else {
@@ -1935,11 +1935,11 @@ nsresult nsXPCComponents_utils_Sandbox::
     ok = true;
   }
 
-  if (!ok) {
+  if (!ok) {MOZ_RELEASE_ASSERT(0);
     return ThrowAndFail(NS_ERROR_INVALID_ARG, cx, _retval);
   }
 
-  if (NS_FAILED(AssembleSandboxMemoryReporterName(cx, options.sandboxName))) {
+  if (NS_FAILED(AssembleSandboxMemoryReporterName(cx, options.sandboxName))) {MOZ_RELEASE_ASSERT(0);
     return ThrowAndFail(NS_ERROR_INVALID_ARG, cx, _retval);
   }
 
@@ -1948,7 +1948,7 @@ nsresult nsXPCComponents_utils_Sandbox::
     RootedObject callerGlobal(cx, JS::GetScriptedCallerGlobal(cx));
     if (IsSandbox(callerGlobal)) {
       rv = GetSandboxMetadata(cx, callerGlobal, &options.metadata);
-      if (NS_WARN_IF(NS_FAILED(rv))) {
+      if (NS_WARN_IF(NS_FAILED(rv))) {MOZ_RELEASE_ASSERT(0);
         return rv;
       }
     }
@@ -1975,7 +1975,7 @@ nsresult xpc::EvalInSandbox(JSContext* c
   // CheckedUnwrapStatic is fine here, since we're checking for "is it a
   // sandbox".
   RootedObject sandbox(cx, js::CheckedUnwrapStatic(sandboxArg));
-  if (!sandbox || !IsSandbox(sandbox)) {
+  if (!sandbox || !IsSandbox(sandbox)) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_INVALID_ARG;
   }
 
@@ -2021,7 +2021,7 @@ nsresult xpc::EvalInSandbox(JSContext* c
 
     // If the sandbox threw an exception, grab it off the context.
     if (aes.HasException()) {
-      if (!aes.StealException(&exn)) {
+      if (!aes.StealException(&exn)) {MOZ_RELEASE_ASSERT(0);
         return NS_ERROR_OUT_OF_MEMORY;
       }
     }
@@ -2035,7 +2035,7 @@ nsresult xpc::EvalInSandbox(JSContext* c
   if (!ok) {
     // If we end up without an exception, it was probably due to OOM along
     // the way, in which case we thow. Otherwise, wrap it.
-    if (exn.isUndefined() || !JS_WrapValue(cx, &exn)) {
+    if (exn.isUndefined() || !JS_WrapValue(cx, &exn)) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_OUT_OF_MEMORY;
     }
 
diff --git a/js/xpconnect/src/XPCCallContext.cpp b/js/xpconnect/src/XPCCallContext.cpp
--- a/js/xpconnect/src/XPCCallContext.cpp
+++ b/js/xpconnect/src/XPCCallContext.cpp
@@ -41,7 +41,7 @@ XPCCallContext::XPCCallContext(
   MOZ_ASSERT(cx);
   MOZ_ASSERT(cx == nsContentUtils::GetCurrentJSContext());
 
-  if (!mXPC) {
+  if (!mXPC) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -64,7 +64,7 @@ XPCCallContext::XPCCallContext(
 
   JSObject* unwrapped =
       js::CheckedUnwrapDynamic(obj, cx, /* stopAtWindowProxy = */ false);
-  if (!unwrapped) {
+  if (!unwrapped) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(mJSContext,
                         "Permission denied to call method on |this|");
     mState = INIT_FAILED;
@@ -136,7 +136,7 @@ void XPCCallContext::SetCallInfo(XPCNati
   // by id.
 
   // don't be tricked if method is called with wrong 'this'
-  if (mTearOff && mTearOff->GetInterface() != iface) {
+  if (mTearOff && mTearOff->GetInterface() != iface) {MOZ_RELEASE_ASSERT(0);
     mTearOff = nullptr;
   }
 
@@ -172,10 +172,10 @@ void XPCCallContext::SetArgsAndResultPtr
 nsresult XPCCallContext::CanCallNow() {
   nsresult rv;
 
-  if (!HasInterfaceAndMember()) {
+  if (!HasInterfaceAndMember()) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_UNEXPECTED;
   }
-  if (mState < HAVE_ARGS) {
+  if (mState < HAVE_ARGS) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_UNEXPECTED;
   }
 
@@ -194,7 +194,7 @@ nsresult XPCCallContext::CanCallNow() {
   return NS_OK;
 }
 
-void XPCCallContext::SystemIsBeingShutDown() {
+void XPCCallContext::SystemIsBeingShutDown() {MOZ_RELEASE_ASSERT(0);
   // XXX This is pretty questionable since the per thread cleanup stuff
   // can be making this call on one thread for call contexts on another
   // thread.
diff --git a/js/xpconnect/src/XPCComponents.cpp b/js/xpconnect/src/XPCComponents.cpp
--- a/js/xpconnect/src/XPCComponents.cpp
+++ b/js/xpconnect/src/XPCComponents.cpp
@@ -171,7 +171,7 @@ nsXPCComponents_Interfaces::NewEnumerate
                                          JSContext* cx, JSObject* obj,
                                          JS::MutableHandleIdVector properties,
                                          bool enumerableOnly, bool* _retval) {
-  if (!properties.reserve(nsXPTInterfaceInfo::InterfaceCount())) {
+  if (!properties.reserve(nsXPTInterfaceInfo::InterfaceCount())) {MOZ_RELEASE_ASSERT(0);
     *_retval = false;
     return NS_OK;
   }
@@ -179,17 +179,17 @@ nsXPCComponents_Interfaces::NewEnumerate
   for (uint32_t index = 0; index < nsXPTInterfaceInfo::InterfaceCount();
        index++) {
     const nsXPTInterfaceInfo* interface = nsXPTInterfaceInfo::ByIndex(index);
-    if (!interface) {
+    if (!interface) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
     const char* name = interface->Name();
-    if (!name) {
+    if (!name) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
     RootedString idstr(cx, JS_NewStringCopyZ(cx, name));
-    if (!idstr) {
+    if (!idstr) {MOZ_RELEASE_ASSERT(0);
       *_retval = false;
       return NS_OK;
     }
@@ -326,24 +326,24 @@ nsXPCComponents_Classes::NewEnumerate(ns
                                       bool enumerableOnly, bool* _retval) {
   nsCOMPtr<nsIComponentRegistrar> compMgr;
   if (NS_FAILED(NS_GetComponentRegistrar(getter_AddRefs(compMgr))) ||
-      !compMgr) {
+      !compMgr) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_UNEXPECTED;
   }
 
   nsTArray<nsCString> contractIDs;
-  if (NS_FAILED(compMgr->GetContractIDs(contractIDs))) {
+  if (NS_FAILED(compMgr->GetContractIDs(contractIDs))) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_UNEXPECTED;
   }
 
   for (const auto& name : contractIDs) {
     RootedString idstr(cx, JS_NewStringCopyN(cx, name.get(), name.Length()));
-    if (!idstr) {
+    if (!idstr) {MOZ_RELEASE_ASSERT(0);
       *_retval = false;
       return NS_OK;
     }
 
     RootedId id(cx);
-    if (!JS_StringToId(cx, idstr, &id)) {
+    if (!JS_StringToId(cx, idstr, &id)) {MOZ_RELEASE_ASSERT(0);
       *_retval = false;
       return NS_OK;
     }
@@ -470,13 +470,13 @@ nsXPCComponents_Results::NewEnumerate(ns
   const void* iter = nullptr;
   while (nsXPCException::IterateNSResults(nullptr, &name, nullptr, &iter)) {
     RootedString idstr(cx, JS_NewStringCopyZ(cx, name));
-    if (!idstr) {
+    if (!idstr) {MOZ_RELEASE_ASSERT(0);
       *_retval = false;
       return NS_OK;
     }
 
     RootedId id(cx);
-    if (!JS_StringToId(cx, idstr, &id)) {
+    if (!JS_StringToId(cx, idstr, &id)) {MOZ_RELEASE_ASSERT(0);
       *_retval = false;
       return NS_OK;
     }
@@ -626,29 +626,29 @@ nsresult nsXPCComponents_ID::CallOrConst
                                              bool* _retval) {
   // make sure we have at least one arg
 
-  if (args.length() < 1) {
+  if (args.length() < 1) {MOZ_RELEASE_ASSERT(0);
     return ThrowAndFail(NS_ERROR_XPC_NOT_ENOUGH_ARGS, cx, _retval);
   }
 
   // Prevent non-chrome code from creating ID objects.
-  if (!nsContentUtils::IsCallerChrome()) {
+  if (!nsContentUtils::IsCallerChrome()) {MOZ_RELEASE_ASSERT(0);
     return ThrowAndFail(NS_ERROR_DOM_XPCONNECT_ACCESS_DENIED, cx, _retval);
   }
 
   // convert the first argument into a string and see if it looks like an id
 
   JSString* jsstr = ToString(cx, args[0]);
-  if (!jsstr) {
+  if (!jsstr) {MOZ_RELEASE_ASSERT(0);
     return ThrowAndFail(NS_ERROR_XPC_BAD_ID_STRING, cx, _retval);
   }
 
   JS::UniqueChars bytes = JS_EncodeStringToLatin1(cx, jsstr);
-  if (!bytes) {
+  if (!bytes) {MOZ_RELEASE_ASSERT(0);
     return ThrowAndFail(NS_ERROR_XPC_BAD_ID_STRING, cx, _retval);
   }
 
   nsID id;
-  if (!id.Parse(bytes.get())) {
+  if (!id.Parse(bytes.get())) {MOZ_RELEASE_ASSERT(0);
     return ThrowAndFail(NS_ERROR_XPC_BAD_ID_STRING, cx, _retval);
   }
 
@@ -929,7 +929,7 @@ nsresult nsXPCComponents_Exception::Call
 
   // Parse the arguments to the Exception constructor.
   ExceptionArgParser parser(cx, xpc);
-  if (!parser.parse(args)) {
+  if (!parser.parse(args)) {MOZ_RELEASE_ASSERT(0);
     return ThrowAndFail(NS_ERROR_XPC_BAD_CONVERT_JS, cx, _retval);
   }
 
@@ -1068,10 +1068,10 @@ bool nsXPCComponents_Constructor::InnerC
   RootedValue initializer(cx);
   if (!JS_GetPropertyById(cx, callee, classIDProp, &classIDv) ||
       !JS_GetPropertyById(cx, callee, interfaceIDProp, &interfaceID) ||
-      !JS_GetPropertyById(cx, callee, initializerProp, &initializer)) {
+      !JS_GetPropertyById(cx, callee, initializerProp, &initializer)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!classIDv.isObject() || !interfaceID.isObject()) {
+  if (!classIDv.isObject() || !interfaceID.isObject()) {MOZ_RELEASE_ASSERT(0);
     XPCThrower::Throw(NS_ERROR_UNEXPECTED, cx);
     return false;
   }
@@ -1080,10 +1080,10 @@ bool nsXPCComponents_Constructor::InnerC
   RootedValue instancev(cx);
   RootedObject classID(cx, &classIDv.toObject());
   if (!JS_CallFunctionName(cx, classID, "createInstance",
-                           HandleValueArray(interfaceID), &instancev)) {
+                           HandleValueArray(interfaceID), &instancev)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!instancev.isObject()) {
+  if (!instancev.isObject()) {MOZ_RELEASE_ASSERT(0);
     XPCThrower::Throw(NS_ERROR_FAILURE, cx);
     return false;
   }
@@ -1127,7 +1127,7 @@ nsresult nsXPCComponents_Constructor::Ca
     const CallArgs& args, bool* _retval) {
   // make sure we have at least one arg
 
-  if (args.length() < 1) {
+  if (args.length() < 1) {MOZ_RELEASE_ASSERT(0);
     return ThrowAndFail(NS_ERROR_XPC_NOT_ENOUGH_ARGS, cx, _retval);
   }
 
@@ -1145,18 +1145,18 @@ nsresult nsXPCComponents_Constructor::Ca
   XPCWrappedNativeScope* scope = ObjectScope(obj);
   nsCOMPtr<nsIXPCComponents> comp;
 
-  if (!xpc || !scope || !(comp = scope->GetComponents())) {
+  if (!xpc || !scope || !(comp = scope->GetComponents())) {MOZ_RELEASE_ASSERT(0);
     return ThrowAndFail(NS_ERROR_XPC_UNEXPECTED, cx, _retval);
   }
 
   // Prevent non-chrome code from creating constructor objects.
-  if (!nsContentUtils::IsCallerChrome()) {
+  if (!nsContentUtils::IsCallerChrome()) {MOZ_RELEASE_ASSERT(0);
     return ThrowAndFail(NS_ERROR_DOM_XPCONNECT_ACCESS_DENIED, cx, _retval);
   }
 
   JSFunction* ctorfn = JS_NewFunction(cx, InnerConstructor, 0,
                                       JSFUN_CONSTRUCTOR, "XPCOM_Constructor");
-  if (!ctorfn) {
+  if (!ctorfn) {MOZ_RELEASE_ASSERT(0);
     return ThrowAndFail(NS_ERROR_OUT_OF_MEMORY, cx, _retval);
   }
 
@@ -1167,7 +1167,7 @@ nsresult nsXPCComponents_Constructor::Ca
     RootedString str(cx, ToString(cx, args[2]));
     if (!JS_DefinePropertyById(
             cx, ctor, initializerProp, str,
-            JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT)) {
+            JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT)) {MOZ_RELEASE_ASSERT(0);
       return ThrowAndFail(NS_ERROR_FAILURE, cx, _retval);
     }
   }
@@ -1179,7 +1179,7 @@ nsresult nsXPCComponents_Constructor::Ca
     ifaceName = JS_NewStringCopyZ(cx, "nsISupports");
   }
 
-  if (!ifaceName) {
+  if (!ifaceName) {MOZ_RELEASE_ASSERT(0);
     return ThrowAndFail(NS_ERROR_XPC_BAD_CONVERT_JS, cx, _retval);
   }
 
@@ -1196,23 +1196,23 @@ nsresult nsXPCComponents_Constructor::Ca
         NS_FAILED(xpc->WrapNative(cx, obj, ifaces,
                                   NS_GET_IID(nsIXPCComponents_Interfaces),
                                   ifacesObj.address())) ||
-        !ifacesObj) {
+        !ifacesObj) {MOZ_RELEASE_ASSERT(0);
       return ThrowAndFail(NS_ERROR_XPC_UNEXPECTED, cx, _retval);
     }
 
     RootedId id(cx);
-    if (!JS_StringToId(cx, ifaceName, &id)) {
+    if (!JS_StringToId(cx, ifaceName, &id)) {MOZ_RELEASE_ASSERT(0);
       return ThrowAndFail(NS_ERROR_XPC_BAD_CONVERT_JS, cx, _retval);
     }
 
     RootedValue val(cx);
-    if (!JS_GetPropertyById(cx, ifacesObj, id, &val) || val.isPrimitive()) {
+    if (!JS_GetPropertyById(cx, ifacesObj, id, &val) || val.isPrimitive()) {MOZ_RELEASE_ASSERT(0);
       return ThrowAndFail(NS_ERROR_XPC_BAD_IID, cx, _retval);
     }
 
     if (!JS_DefinePropertyById(
             cx, ctor, interfaceIDProp, val,
-            JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT)) {
+            JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT)) {MOZ_RELEASE_ASSERT(0);
       return ThrowAndFail(NS_ERROR_FAILURE, cx, _retval);
     }
   }
@@ -1232,18 +1232,18 @@ nsresult nsXPCComponents_Constructor::Ca
         NS_FAILED(xpc->WrapNative(cx, obj, classes,
                                   NS_GET_IID(nsIXPCComponents_Classes),
                                   classesObj.address())) ||
-        !classesObj) {
+        !classesObj) {MOZ_RELEASE_ASSERT(0);
       return ThrowAndFail(NS_ERROR_XPC_UNEXPECTED, cx, _retval);
     }
 
     RootedString str(cx, ToString(cx, args[0]));
     RootedId id(cx);
-    if (!str || !JS_StringToId(cx, str, &id)) {
+    if (!str || !JS_StringToId(cx, str, &id)) {MOZ_RELEASE_ASSERT(0);
       return ThrowAndFail(NS_ERROR_XPC_BAD_CONVERT_JS, cx, _retval);
     }
 
     RootedValue val(cx);
-    if (!JS_GetPropertyById(cx, classesObj, id, &val) || val.isPrimitive()) {
+    if (!JS_GetPropertyById(cx, classesObj, id, &val) || val.isPrimitive()) {MOZ_RELEASE_ASSERT(0);
       return ThrowAndFail(NS_ERROR_XPC_BAD_CID, cx, _retval);
     }
 
@@ -1322,7 +1322,7 @@ nsXPCComponents_Utils::ReportError(Handl
 
   nsCOMPtr<nsIConsoleService> console(
       do_GetService(NS_CONSOLESERVICE_CONTRACTID));
-  if (!console) {
+  if (!console) {MOZ_RELEASE_ASSERT(0);
     return NS_OK;
   }
 
@@ -1370,7 +1370,7 @@ nsXPCComponents_Utils::ReportError(Handl
           JS::GetRealmPrincipals(js::GetContextRealm(cx));
 
       if (GetSavedFrameLine(cx, principals, stackObj, &lineNo) !=
-          SavedFrameResult::Ok) {
+          SavedFrameResult::Ok) {MOZ_RELEASE_ASSERT(0);
         JS_ClearPendingException(cx);
       }
 
@@ -1380,7 +1380,7 @@ nsXPCComponents_Utils::ReportError(Handl
               SavedFrameResult::Ok &&
           str.init(cx, source)) {
         fileName = str;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         JS_ClearPendingException(cx);
       }
     } else {
@@ -1408,7 +1408,7 @@ nsXPCComponents_Utils::ReportError(Handl
   }
 
   JSErrorReport* err = errorObj ? JS_ErrorFromException(cx, errorObj) : nullptr;
-  if (err) {
+  if (err) {MOZ_RELEASE_ASSERT(0);
     // It's a proper JS Error
     nsAutoString fileUni;
     CopyUTF8toUTF16(mozilla::MakeStringSpan(err->filename), fileUni);
@@ -1435,7 +1435,7 @@ nsXPCComponents_Utils::ReportError(Handl
 
   // It's not a JS Error object, so we synthesize as best we're able.
   RootedString msgstr(cx, ToString(cx, error));
-  if (!msgstr) {
+  if (!msgstr) {MOZ_RELEASE_ASSERT(0);
     return NS_OK;
   }
 
@@ -1521,7 +1521,7 @@ NS_IMETHODIMP
 nsXPCComponents_Utils::SetSandboxMetadata(HandleValue sandboxVal,
                                           HandleValue metadataVal,
                                           JSContext* cx) {
-  if (!sandboxVal.isObject()) {
+  if (!sandboxVal.isObject()) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_INVALID_ARG;
   }
 
@@ -1580,7 +1580,7 @@ nsXPCComponents_Utils::ImportGlobalPrope
 
   // Don't allow doing this if the global is a Window.
   nsGlobalWindowInner* win;
-  if (NS_SUCCEEDED(UNWRAP_NON_WRAPPER_OBJECT(Window, global, win))) {
+  if (NS_SUCCEEDED(UNWRAP_NON_WRAPPER_OBJECT(Window, global, win))) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_NOT_AVAILABLE;
   }
 
@@ -1589,10 +1589,10 @@ nsXPCComponents_Utils::ImportGlobalPrope
 
   RootedObject propertyList(cx, &aPropertyList.toObject());
   bool isArray;
-  if (NS_WARN_IF(!JS::IsArrayObject(cx, propertyList, &isArray))) {
+  if (NS_WARN_IF(!JS::IsArrayObject(cx, propertyList, &isArray))) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
-  if (NS_WARN_IF(!isArray)) {
+  if (NS_WARN_IF(!isArray)) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_INVALID_ARG;
   }
 
@@ -1701,7 +1701,7 @@ nsXPCComponents_Utils::SchedulePreciseSh
 }
 
 NS_IMETHODIMP
-nsXPCComponents_Utils::UnlinkGhostWindows() {
+nsXPCComponents_Utils::UnlinkGhostWindows() {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
   nsWindowMemoryReporter::UnlinkGhostWindows();
 
@@ -1775,7 +1775,7 @@ nsXPCComponents_Utils::GetFunctionSource
 
   RootedValue filenameVal(cx);
   if (!xpc::NonVoidStringToJsval(cx, filename, &filenameVal) ||
-      !JS_DefineProperty(cx, res, "filename", filenameVal, JSPROP_ENUMERATE)) {
+      !JS_DefineProperty(cx, res, "filename", filenameVal, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
@@ -1795,16 +1795,16 @@ nsXPCComponents_Utils::CallFunctionWithA
                                                   MutableHandleValue retval) {
   nsresult rv;
 
-  if (!stack || asyncCause.IsEmpty()) {
+  if (!stack || asyncCause.IsEmpty()) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_INVALID_ARG;
   }
 
   JS::Rooted<JS::Value> asyncStack(cx);
   rv = stack->GetNativeSavedFrame(&asyncStack);
-  if (NS_FAILED(rv)) {
+  if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
     return rv;
   }
-  if (!asyncStack.isObject()) {
+  if (!asyncStack.isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Must use a native JavaScript stack frame");
     return NS_ERROR_INVALID_ARG;
   }
@@ -1828,7 +1828,7 @@ NS_IMETHODIMP
 nsXPCComponents_Utils::GetGlobalForObject(HandleValue object, JSContext* cx,
                                           MutableHandleValue retval) {
   // First argument must be an object.
-  if (object.isPrimitive()) {
+  if (object.isPrimitive()) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_XPC_BAD_CONVERT_JS;
   }
 
@@ -1883,7 +1883,7 @@ nsXPCComponents_Utils::CreateObjectIn(Ha
   RootedObject optionsObject(
       cx, voptions.isObject() ? &voptions.toObject() : nullptr);
   CreateObjectInOptions options(cx, optionsObject);
-  if (voptions.isObject() && !options.Parse()) {
+  if (voptions.isObject() && !options.Parse()) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
 
@@ -1895,19 +1895,19 @@ nsXPCComponents_Utils::CreateObjectIn(Ha
 
 NS_IMETHODIMP
 nsXPCComponents_Utils::MakeObjectPropsNormal(HandleValue vobj, JSContext* cx) {
-  if (!cx) {
+  if (!cx) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
 
   // first argument must be an object
-  if (vobj.isPrimitive()) {
+  if (vobj.isPrimitive()) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_XPC_BAD_CONVERT_JS;
   }
 
   RootedObject obj(cx, js::UncheckedUnwrap(&vobj.toObject()));
   JSAutoRealm ar(cx, obj);
   Rooted<IdVector> ida(cx, IdVector(cx));
-  if (!JS_Enumerate(cx, obj, &ida)) {
+  if (!JS_Enumerate(cx, obj, &ida)) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
 
@@ -1916,11 +1916,11 @@ nsXPCComponents_Utils::MakeObjectPropsNo
   for (size_t i = 0; i < ida.length(); ++i) {
     id = ida[i];
 
-    if (!JS_GetPropertyById(cx, obj, id, &v)) {
+    if (!JS_GetPropertyById(cx, obj, id, &v)) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_FAILURE;
     }
 
-    if (v.isPrimitive()) {
+    if (v.isPrimitive()) {MOZ_RELEASE_ASSERT(0);
       continue;
     }
 
@@ -1966,7 +1966,7 @@ nsXPCComponents_Utils::IsRemoteProxy(Han
 }
 
 NS_IMETHODIMP
-nsXPCComponents_Utils::RecomputeWrappers(HandleValue vobj, JSContext* cx) {
+nsXPCComponents_Utils::RecomputeWrappers(HandleValue vobj, JSContext* cx) {MOZ_RELEASE_ASSERT(0);
   // Determine the compartment of the given object, if any.
   JS::Compartment* c =
       vobj.isObject()
@@ -2011,11 +2011,11 @@ nsXPCComponents_Utils::Dispatch(HandleVa
   Maybe<JSAutoRealm> ar;
   if (scope.isObject()) {
     JSObject* scopeObj = js::UncheckedUnwrap(&scope.toObject());
-    if (!scopeObj) {
+    if (!scopeObj) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_FAILURE;
     }
     ar.emplace(cx, scopeObj);
-    if (!JS_WrapValue(cx, &runnable)) {
+    if (!JS_WrapValue(cx, &runnable)) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_FAILURE;
     }
   }
@@ -2174,7 +2174,7 @@ nsXPCComponents_Utils::UnwaiveXrays(Hand
 NS_IMETHODIMP
 nsXPCComponents_Utils::GetClassName(HandleValue aObj, bool aUnwrap,
                                     JSContext* aCx, char** aRv) {
-  if (!aObj.isObject()) {
+  if (!aObj.isObject()) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_INVALID_ARG;
   }
   RootedObject obj(aCx, &aObj.toObject());
@@ -2198,12 +2198,12 @@ nsXPCComponents_Utils::GetIncumbentGloba
   nsCOMPtr<nsIGlobalObject> global = mozilla::dom::GetIncumbentGlobal();
   RootedValue globalVal(aCx);
 
-  if (!global) {
+  if (!global) {MOZ_RELEASE_ASSERT(0);
     globalVal = NullValue();
   } else {
     // Note: We rely on the wrap call for outerization.
     globalVal = ObjectValue(*global->GetGlobalJSObject());
-    if (!JS_WrapValue(aCx, &globalVal)) {
+    if (!JS_WrapValue(aCx, &globalVal)) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_FAILURE;
     }
   }
@@ -2257,9 +2257,9 @@ NS_IMETHODIMP
 nsXPCComponents_Utils::GenerateXPCWrappedJS(HandleValue aObj,
                                             HandleValue aScope, JSContext* aCx,
                                             nsISupports** aOut) {
-  if (!aObj.isObject()) {
+  if (!aObj.isObject()) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_INVALID_ARG;
-  }
+  }MOZ_RELEASE_ASSERT(0);
   RootedObject obj(aCx, &aObj.toObject());
   RootedObject scope(aCx, aScope.isObject()
                               ? js::UncheckedUnwrap(&aScope.toObject())
@@ -2297,7 +2297,7 @@ nsXPCComponents_Utils::GetWatchdogTimest
 
 NS_IMETHODIMP
 nsXPCComponents_Utils::GetJSEngineTelemetryValue(JSContext* cx,
-                                                 MutableHandleValue rval) {
+                                                 MutableHandleValue rval) {MOZ_RELEASE_ASSERT(0);
   RootedObject obj(cx, JS_NewPlainObject(cx));
   if (!obj) {
     return NS_ERROR_OUT_OF_MEMORY;
@@ -2323,7 +2323,7 @@ bool xpc::CloneInto(JSContext* aCx, Hand
     return false;
   }
 
-  if (!aOptions.isUndefined() && !aOptions.isObject()) {
+  if (!aOptions.isUndefined() && !aOptions.isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(aCx, "Invalid argument");
     return false;
   }
@@ -2331,7 +2331,7 @@ bool xpc::CloneInto(JSContext* aCx, Hand
   RootedObject optionsObject(
       aCx, aOptions.isObject() ? &aOptions.toObject() : nullptr);
   StackScopedCloneOptions options(aCx, optionsObject);
-  if (aOptions.isObject() && !options.Parse()) {
+  if (aOptions.isObject() && !options.Parse()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/xpconnect/src/XPCConvert.cpp b/js/xpconnect/src/XPCConvert.cpp
--- a/js/xpconnect/src/XPCConvert.cpp
+++ b/js/xpconnect/src/XPCConvert.cpp
@@ -900,7 +900,7 @@ bool XPCConvert::NativeInterface2JSObjec
   // optimal -- we could detect this and roll the functionality into a
   // single wrapper, but the current solution is good enough for now.
   XPCWrappedNativeScope* xpcscope = ObjectScope(JS::CurrentGlobalOrNull(cx));
-  if (!xpcscope) {
+  if (!xpcscope) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -915,12 +915,12 @@ bool XPCConvert::NativeInterface2JSObjec
   if (!flat && cache) {
     RootedObject global(cx, CurrentGlobalOrNull(cx));
     flat = cache->WrapObject(cx, nullptr);
-    if (!flat) {
+    if (!flat) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
   if (flat) {
-    if (allowNativeWrapper && !JS_WrapObject(cx, &flat)) {
+    if (allowNativeWrapper && !JS_WrapObject(cx, &flat)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     d.setObjectOrNull(flat);
@@ -929,7 +929,7 @@ bool XPCConvert::NativeInterface2JSObjec
 
   // Go ahead and create an XPCWrappedNative for this object.
   RefPtr<XPCNativeInterface> iface = XPCNativeInterface::GetNewOrUsed(cx, iid);
-  if (!iface) {
+  if (!iface) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -959,7 +959,7 @@ bool XPCConvert::NativeInterface2JSObjec
   // The call to wrap here handles both cross-compartment and same-compartment
   // security wrappers.
   RootedObject original(cx, flat);
-  if (!JS_WrapObject(cx, &flat)) {
+  if (!JS_WrapObject(cx, &flat)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1011,9 +1011,9 @@ bool XPCConvert::JSObject2NativeInterfac
         cx, js::CheckedUnwrapDynamic(src, cx,
                                      /* stopAtWindowProxy = */ false));
     if (!inner) {
-      if (pErr) {
+      if (pErr) {MOZ_RELEASE_ASSERT(0);
         *pErr = NS_ERROR_XPC_SECURITY_MANAGER_VETO;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1040,7 +1040,7 @@ bool XPCConvert::JSObject2NativeInterfac
         if (nsCOMPtr<mozIDOMWindow> inner = do_QueryInterface(iface)) {
           iface = nsPIDOMWindowInner::From(inner)->GetOuterWindow();
           return NS_SUCCEEDED(iface->QueryInterface(*iid, dest));
-        }
+        }MOZ_RELEASE_ASSERT(0);
       }
 
       return false;
@@ -1102,7 +1102,7 @@ nsresult XPCConvert::ConstructException(
     }
   }
   if (!msg) {
-    if (!nsXPCException::NameAndFormatForNSResult(rv, nullptr, &msg) || !msg) {
+    if (!nsXPCException::NameAndFormatForNSResult(rv, nullptr, &msg) || !msg) {MOZ_RELEASE_ASSERT(0);
       msg = "<error>";
     }
   }
@@ -1150,9 +1150,9 @@ static nsresult JSErrorToXPCException(JS
     if (report->message()) {
       CopyUTF8toUTF16(mozilla::MakeStringSpan(report->message().c_str()),
                       bestMessage);
-    } else if (toStringResult) {
+    } else if (toStringResult) {MOZ_RELEASE_ASSERT(0);
       CopyUTF8toUTF16(mozilla::MakeStringSpan(toStringResult), bestMessage);
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       bestMessage.AssignLiteral("JavaScript Error");
     }
 
@@ -1195,7 +1195,7 @@ nsresult XPCConvert::JSValToXPCException
     // we have a JSObject
     RootedObject obj(cx, s.toObjectOrNull());
 
-    if (!obj) {
+    if (!obj) {MOZ_RELEASE_ASSERT(0);
       NS_ERROR("when is an object not an object?");
       return NS_ERROR_FAILURE;
     }
@@ -1203,7 +1203,7 @@ nsresult XPCConvert::JSValToXPCException
     // is this really a native xpcom object with a wrapper?
     JSObject* unwrapped =
         js::CheckedUnwrapDynamic(obj, cx, /* stopAtWindowProxy = */ false);
-    if (!unwrapped) {
+    if (!unwrapped) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_XPC_SECURITY_MANAGER_VETO;
     }
     // It's OK to use ReflectorToISupportsStatic, because we have already
@@ -1215,7 +1215,7 @@ nsresult XPCConvert::JSValToXPCException
         // just pass through the exception (with extra ref and all)
         iface.forget(exceptn);
         return NS_OK;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       // it is a wrapped native, but not an exception!
       return ConstructException(NS_ERROR_XPC_JS_THREW_NATIVE_OBJECT, nullptr,
@@ -1235,7 +1235,7 @@ nsresult XPCConvert::JSValToXPCException
         }
         return JSErrorToXPCException(cx, toStringResult.get(), ifaceName,
                                      methodName, report, exceptn);
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       // XXX we should do a check against 'js_ErrorClass' here and
       // do the right thing - even though it has no JSErrorReport,
@@ -1245,14 +1245,14 @@ nsresult XPCConvert::JSValToXPCException
       // otherwise we'll just try to convert it to a string
 
       JSString* str = ToString(cx, s);
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         return NS_ERROR_FAILURE;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       JS::UniqueChars strBytes = JS_EncodeStringToLatin1(cx, str);
-      if (!strBytes) {
+      if (!strBytes) {MOZ_RELEASE_ASSERT(0);
         return NS_ERROR_FAILURE;
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       return ConstructException(NS_ERROR_XPC_JS_THREW_JS_OBJECT, strBytes.get(),
                                 ifaceName, methodName, nullptr, exceptn, cx,
@@ -1265,37 +1265,37 @@ nsresult XPCConvert::JSValToXPCException
                               methodName, nullptr, exceptn, cx, s.address());
   }
 
-  if (s.isNumber()) {
+  if (s.isNumber()) {MOZ_RELEASE_ASSERT(0);
     // lets see if it looks like an nsresult
     nsresult rv;
     double number;
     bool isResult = false;
 
-    if (s.isInt32()) {
+    if (s.isInt32()) {MOZ_RELEASE_ASSERT(0);
       rv = (nsresult)s.toInt32();
-      if (NS_FAILED(rv)) {
+      if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
         isResult = true;
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         number = (double)s.toInt32();
       }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       number = s.toDouble();
       if (number > 0.0 && number < (double)0xffffffff &&
-          0.0 == fmod(number, 1)) {
+          0.0 == fmod(number, 1)) {MOZ_RELEASE_ASSERT(0);
         // Visual Studio 9 doesn't allow casting directly from a
         // double to an enumeration type, contrary to 5.2.9(10) of
         // C++11, so add an intermediate cast.
         rv = (nsresult)(uint32_t)number;
-        if (NS_FAILED(rv)) {
+        if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
           isResult = true;
-        }
+        }MOZ_RELEASE_ASSERT(0);
       }
     }
 
-    if (isResult) {
+    if (isResult) {MOZ_RELEASE_ASSERT(0);
       return ConstructException(rv, nullptr, ifaceName, methodName, nullptr,
                                 exceptn, cx, s.address());
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       // XXX all this nsISupportsDouble code seems a little redundant
       // now that we're storing the Value in the exception...
       nsCOMPtr<nsISupportsDouble> data;
@@ -1309,7 +1309,7 @@ nsresult XPCConvert::JSValToXPCException
       rv = ConstructException(NS_ERROR_XPC_JS_THREW_NUMBER, nullptr, ifaceName,
                               methodName, data, exceptn, cx, s.address());
       return rv;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   // otherwise we'll just try to convert it to a string
@@ -1338,7 +1338,7 @@ bool XPCConvert::NativeArray2JS(JSContex
   MOZ_ASSERT(buf || count == 0, "Must have buf or 0 elements");
 
   RootedObject array(cx, JS::NewArrayObject(cx, count));
-  if (!array) {
+  if (!array) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1347,7 +1347,7 @@ bool XPCConvert::NativeArray2JS(JSContex
   }
 
   RootedValue current(cx, JS::NullValue());
-  for (uint32_t i = 0; i < count; ++i) {
+  for (uint32_t i = 0; i < count; ++i) {MOZ_RELEASE_ASSERT(0);
     if (!NativeData2JS(cx, &current, type.ElementPtr(buf, i), type, iid, 0,
                        pErr) ||
         !JS_DefineElement(cx, array, i, current, JSPROP_ENUMERATE))
@@ -1449,7 +1449,7 @@ bool XPCConvert::JSArray2Native(JSContex
       // nsTArray and code below uses uint32_t lengths, so reject large typed
       // arrays.
       size_t fullLength = JS_GetTypedArrayLength(jsarray);
-      if (fullLength > UINT32_MAX) {
+      if (fullLength > UINT32_MAX) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       length = uint32_t(fullLength);
@@ -1465,7 +1465,7 @@ bool XPCConvert::JSArray2Native(JSContex
     const void* data = JS_GetArrayBufferViewData(jsarray, &isShared, nogc);
 
     // Require opting in to shared memory - a future project.
-    if (isShared) {
+    if (isShared) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1479,14 +1479,14 @@ bool XPCConvert::JSArray2Native(JSContex
   bool isArray = false;
   if (!JS::IsArrayObject(cx, jsarray, &isArray) || !isArray ||
       !JS::GetArrayLength(cx, jsarray, &length)) {
-    if (pErr) {
+    if (pErr) {MOZ_RELEASE_ASSERT(0);
       *pErr = NS_ERROR_XPC_CANT_CONVERT_OBJECT_TO_ARRAY;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   void* buf = allocFixupLen(&length);
-  if (!buf) {
+  if (!buf) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/xpconnect/src/XPCDebug.cpp b/js/xpconnect/src/XPCDebug.cpp
--- a/js/xpconnect/src/XPCDebug.cpp
+++ b/js/xpconnect/src/XPCDebug.cpp
@@ -20,7 +20,7 @@
 #  include <android/log.h>
 #endif
 
-static void DebugDump(const char* str) {
+static void DebugDump(const char* str) {MOZ_RELEASE_ASSERT(0);
 #ifdef XP_WIN
   if (IsDebuggerPresent()) {
     nsPrintfCString output("%s\n", str);
@@ -32,9 +32,9 @@ static void DebugDump(const char* str) {
   printf("%s\n", str);
 }
 
-bool xpc_DumpJSStack(bool showArgs, bool showLocals, bool showThisProps) {
+bool xpc_DumpJSStack(bool showArgs, bool showLocals, bool showThisProps) {MOZ_RELEASE_ASSERT(0);
   JSContext* cx = nsContentUtils::GetCurrentJSContext();
-  if (!cx) {
+  if (!cx) {MOZ_RELEASE_ASSERT(0);
     printf("there is no JSContext on the stack!\n");
   } else if (JS::UniqueChars buf =
                  xpc_PrintJSStack(cx, showArgs, showLocals, showThisProps)) {
diff --git a/js/xpconnect/src/XPCJSContext.cpp b/js/xpconnect/src/XPCJSContext.cpp
--- a/js/xpconnect/src/XPCJSContext.cpp
+++ b/js/xpconnect/src/XPCJSContext.cpp
@@ -132,12 +132,12 @@ class Watchdog {
   void Init() {
     MOZ_ASSERT(NS_IsMainThread());
     mLock = PR_NewLock();
-    if (!mLock) {
+    if (!mLock) {MOZ_RELEASE_ASSERT(0);
       MOZ_CRASH("PR_NewLock failed.");
     }
 
     mWakeup = PR_NewCondVar(mLock);
-    if (!mWakeup) {
+    if (!mWakeup) {MOZ_RELEASE_ASSERT(0);
       MOZ_CRASH("PR_NewCondVar failed.");
     }
 
@@ -283,7 +283,7 @@ class WatchdogManager {
     MOZ_ASSERT(NS_IsMainThread());
     AutoLockWatchdog lock(mWatchdog.get());
 
-    if (aContext->mActive == XPCJSContext::CONTEXT_ACTIVE) {
+    if (aContext->mActive == XPCJSContext::CONTEXT_ACTIVE) {MOZ_RELEASE_ASSERT(0);
       mActiveContexts.insertBack(aContext);
     } else {
       mInactiveContexts.insertBack(aContext);
@@ -506,7 +506,7 @@ static void WatchdogMain(void* arg) {
       if (dbg) {
         dbg->GetIsDebuggerAttached(&debuggerAttached);
       }
-      if (debuggerAttached) {
+      if (debuggerAttached) {MOZ_RELEASE_ASSERT(0);
         // We won't be interrupting these scripts anyway.
         continue;
       }
@@ -606,7 +606,7 @@ bool XPCJSContext::InterruptCallback(JSC
 
   // Sometimes we get called back during XPConnect initialization, before Gecko
   // has finished bootstrapping. Avoid crashing in nsContentUtils below.
-  if (!nsContentUtils::IsInitialized()) {
+  if (!nsContentUtils::IsInitialized()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -665,26 +665,26 @@ bool XPCJSContext::InterruptCallback(JSC
   // to terminate. However, if this is the case we won't be able to map the
   // script global to a window and we'll bail out below.
   if (XRE_IsContentProcess() &&
-      StaticPrefs::dom_max_script_run_time_require_critical_input()) {
+      StaticPrefs::dom_max_script_run_time_require_critical_input()) {MOZ_RELEASE_ASSERT(0);
     // Call possibly slow PeekMessages after the other common early returns in
     // this method.
     ContentChild* contentChild = ContentChild::GetSingleton();
     mozilla::ipc::MessageChannel* channel =
         contentChild ? contentChild->GetIPCChannel() : nullptr;
-    if (channel) {
+    if (channel) {MOZ_RELEASE_ASSERT(0);
       bool foundInputEvent = false;
       channel->PeekMessages(
-          [&foundInputEvent](const IPC::Message& aMsg) -> bool {
-            if (nsContentUtils::IsMessageCriticalInputEvent(aMsg)) {
+          [&foundInputEvent](const IPC::Message& aMsg) -> bool {MOZ_RELEASE_ASSERT(0);
+            if (nsContentUtils::IsMessageCriticalInputEvent(aMsg)) {MOZ_RELEASE_ASSERT(0);
               foundInputEvent = true;
               return false;
             }
             return true;
           });
-      if (!foundInputEvent) {
+      if (!foundInputEvent) {MOZ_RELEASE_ASSERT(0);
         return true;
-      }
-    }
+      }MOZ_RELEASE_ASSERT(0);
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   // We use a fixed value of 2 from browser_parent_process_hang_telemetry.js
@@ -708,12 +708,12 @@ bool XPCJSContext::InterruptCallback(JSC
     win = SandboxWindowOrNull(global, cx);
   }
 
-  if (!win) {
+  if (!win) {MOZ_RELEASE_ASSERT(0);
     NS_WARNING("No active window");
     return true;
   }
 
-  if (win->IsDying()) {
+  if (win->IsDying()) {MOZ_RELEASE_ASSERT(0);
     // The window is being torn down. When that happens we try to prevent
     // the dispatch of new runnables, so it also makes sense to kill any
     // long-running script. The user is primarily interested in this page
@@ -741,7 +741,7 @@ bool XPCJSContext::InterruptCallback(JSC
 
   // The user chose to continue the script. Reset the timer, and disable this
   // machinery with a pref if the user opted out of future slow-script dialogs.
-  if (response != nsGlobalWindowInner::ContinueSlowScriptAndKeepNotifying) {
+  if (response != nsGlobalWindowInner::ContinueSlowScriptAndKeepNotifying) {MOZ_RELEASE_ASSERT(0);
     self->mSlowScriptCheckpoint = TimeStamp::NowLoRes();
   }
 
@@ -767,7 +767,7 @@ static mozilla::Atomic<bool> sWeakRefsEx
 static mozilla::Atomic<bool> sIteratorHelpersEnabled(false);
 
 static JS::WeakRefSpecifier GetWeakRefsEnabled() {
-  if (!sWeakRefsEnabled) {
+  if (!sWeakRefsEnabled) {MOZ_RELEASE_ASSERT(0);
     return JS::WeakRefSpecifier::Disabled;
   }
 
@@ -821,7 +821,7 @@ static void LoadStartupJSPrefs(XPCJSCont
       StaticPrefs::javascript_options_blinterp_DoNotUseDirectly());
 
   // Disable most JITs in Safe-Mode.
-  if (safeMode) {
+  if (safeMode) {MOZ_RELEASE_ASSERT(0);
     JS_SetGlobalJitCompilerOption(cx, JSJITCOMPILER_BASELINE_ENABLE, false);
     JS_SetGlobalJitCompilerOption(cx, JSJITCOMPILER_ION_ENABLE, false);
     JS_SetGlobalJitCompilerOption(
@@ -1083,7 +1083,7 @@ XPCJSContext::~XPCJSContext() {
     mWatchdogManager->UnregisterContext(this);
     mWatchdogManager->Shutdown();
     sWatchdogInstance = nullptr;
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     // Otherwise, simply remove ourselves from the list.
     mWatchdogManager->UnregisterContext(this);
   }
@@ -1168,7 +1168,7 @@ CycleCollectedJSRuntime* XPCJSContext::C
 nsresult XPCJSContext::Initialize() {
   nsresult rv =
       CycleCollectedJSContext::Initialize(nullptr, JS::DefaultHeapMaxBytes);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
+  if (NS_WARN_IF(NS_FAILED(rv))) {MOZ_RELEASE_ASSERT(0);
     return rv;
   }
 
@@ -1329,7 +1329,7 @@ nsresult XPCJSContext::Initialize() {
 
   // Initialize the MIME type used for the bytecode cache, after calling
   // SetProcessBuildIdOp and loading JS prefs.
-  if (!nsContentUtils::InitJSBytecodeMimeType()) {
+  if (!nsContentUtils::InitJSBytecodeMimeType()) {MOZ_RELEASE_ASSERT(0);
     NS_ABORT_OOM(0);  // Size is unknown.
   }
 
@@ -1370,7 +1370,7 @@ WatchdogManager* XPCJSContext::GetWatchd
 XPCJSContext* XPCJSContext::NewXPCJSContext() {
   XPCJSContext* self = new XPCJSContext();
   nsresult rv = self->Initialize();
-  if (NS_FAILED(rv)) {
+  if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
     MOZ_CRASH("new XPCJSContext failed to initialize.");
   }
 
diff --git a/js/xpconnect/src/XPCJSID.cpp b/js/xpconnect/src/XPCJSID.cpp
--- a/js/xpconnect/src/XPCJSID.cpp
+++ b/js/xpconnect/src/XPCJSID.cpp
@@ -101,7 +101,7 @@ static const JSClass sCID_Class = {
  */
 static JSObject* GetIDPrototype(JSContext* aCx, const JSClass* aClass) {
   XPCWrappedNativeScope* scope = ObjectScope(CurrentGlobalOrNull(aCx));
-  if (NS_WARN_IF(!scope)) {
+  if (NS_WARN_IF(!scope)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -148,7 +148,7 @@ static JSObject* GetIDPrototype(JSContex
         JS_DefineFunction(aCx, idProto, "toString", ID_GetNumber, 0, kFlags) &&
         JS_DefineFunction(aCx, iidProto, "toString", IID_GetName, 0, kFlags) &&
         JS_DefineFunction(aCx, cidProto, "toString", CID_GetName, 0, kFlags);
-    if (!ok) {
+    if (!ok) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
@@ -201,7 +201,7 @@ Maybe<nsID> JSValue2ID(JSContext* aCx, H
 
   // We only care about ID objects here, so CheckedUnwrapStatic is fine.
   RootedObject obj(aCx, js::CheckedUnwrapStatic(&aVal.toObject()));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return Nothing();
   }
 
@@ -233,7 +233,7 @@ Maybe<nsID> JSValue2ID(JSContext* aCx, H
 
     nsCOMPtr<nsIComponentRegistrar> registrar;
     nsresult rv = NS_GetComponentRegistrar(getter_AddRefs(registrar));
-    if (NS_FAILED(rv) || !registrar) {
+    if (NS_FAILED(rv) || !registrar) {MOZ_RELEASE_ASSERT(0);
       return Nothing();
     }
 
@@ -298,7 +298,7 @@ bool ContractID2JSValue(JSContext* aCx, 
     // ContractID, but is usually a bug.
     nsCOMPtr<nsIComponentRegistrar> registrar;
     NS_GetComponentRegistrar(getter_AddRefs(registrar));
-    if (!registrar) {
+    if (!registrar) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -331,7 +331,7 @@ static bool ID_GetNumber(JSContext* aCx,
   CallArgs args = CallArgsFromVp(aArgc, aVp);
 
   Maybe<nsID> id = JSValue2ID(aCx, args.thisv());
-  if (!id) {
+  if (!id) {MOZ_RELEASE_ASSERT(0);
     return Throw(aCx, NS_ERROR_XPC_BAD_CONVERT_JS);
   }
 
@@ -348,7 +348,7 @@ static bool ID_GetNumber(JSContext* aCx,
 
 static bool ID_Equals(JSContext* aCx, unsigned aArgc, Value* aVp) {
   CallArgs args = CallArgsFromVp(aArgc, aVp);
-  if (!args.requireAtLeast(aCx, "nsID.equals", 1)) {
+  if (!args.requireAtLeast(aCx, "nsID.equals", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -397,7 +397,7 @@ static nsresult FindObjectForHasInstance
 
     // Walk the prototype chain from the perspective of the callee (i.e.
     // respecting Xrays if they exist).
-    if (!js::GetObjectProto(cx, obj, &proto)) {
+    if (!js::GetObjectProto(cx, obj, &proto)) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_FAILURE;
     }
     if (!proto) {
@@ -414,7 +414,7 @@ nsresult HasInstance(JSContext* cx, Hand
 
   RootedObject obj(cx);
   nsresult rv = FindObjectForHasInstance(cx, objArg, &obj);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
+  if (NS_WARN_IF(NS_FAILED(rv))) {MOZ_RELEASE_ASSERT(0);
     return rv;
   }
 
@@ -446,12 +446,12 @@ nsresult HasInstance(JSContext* cx, Hand
 
 static bool IID_HasInstance(JSContext* aCx, unsigned aArgc, Value* aVp) {
   CallArgs args = CallArgsFromVp(aArgc, aVp);
-  if (!args.requireAtLeast(aCx, "nsIID[Symbol.hasInstance]", 1)) {
+  if (!args.requireAtLeast(aCx, "nsIID[Symbol.hasInstance]", 1)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Maybe<nsID> id = JSValue2ID(aCx, args.thisv());
-  if (!id) {
+  if (!id) {MOZ_RELEASE_ASSERT(0);
     return Throw(aCx, NS_ERROR_XPC_BAD_CONVERT_JS);
   }
 
@@ -473,7 +473,7 @@ static bool IID_GetName(JSContext* aCx, 
   CallArgs args = CallArgsFromVp(aArgc, aVp);
 
   RootedObject obj(aCx, GetIDObject(args.thisv(), &sIID_Class));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return Throw(aCx, NS_ERROR_XPC_BAD_CONVERT_JS);
   }
 
@@ -494,7 +494,7 @@ static bool IID_NewEnumerate(JSContext* 
                              bool enumerableOnly) {
   const nsXPTInterfaceInfo* info = GetInterfaceInfo(obj);
 
-  if (!properties.reserve(info->ConstantCount())) {
+  if (!properties.reserve(info->ConstantCount())) {MOZ_RELEASE_ASSERT(0);
     JS_ReportOutOfMemory(cx);
     return false;
   }
@@ -540,7 +540,7 @@ static bool IID_MayResolve(const JSAtomS
     return false;
   }
 
-  if (!maybeObj) {
+  if (!maybeObj) {MOZ_RELEASE_ASSERT(0);
     // Each interface object has its own set of constants, so if we don't know
     // the object, assume any string property may be resolved.
     return true;
@@ -565,7 +565,7 @@ static bool CIGSHelper(JSContext* aCx, u
   // JSValue2ID as this method should only be defined on Contract ID objects,
   // and it allows us to avoid a duplicate hashtable lookup.
   RootedObject obj(aCx, GetIDObject(args.thisv(), &sCID_Class));
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return Throw(aCx, NS_ERROR_XPC_BAD_CONVERT_JS);
   }
   JS::UniqueChars contractID = JS_EncodeStringToLatin1(
@@ -574,7 +574,7 @@ static bool CIGSHelper(JSContext* aCx, u
   // Extract the IID from the first argument, if passed. Default: nsISupports.
   Maybe<nsIID> iid = args.length() >= 1 ? JSValue2ID(aCx, args[0])
                                         : Some(NS_GET_IID(nsISupports));
-  if (!iid) {
+  if (!iid) {MOZ_RELEASE_ASSERT(0);
     return Throw(aCx, NS_ERROR_XPC_BAD_CONVERT_JS);
   }
 
@@ -612,7 +612,7 @@ static bool CID_GetService(JSContext* aC
 
 // NOTE: This method is used both for 'get CID.prototype.name' and
 // 'CID.prototype.toString'.
-static bool CID_GetName(JSContext* aCx, unsigned aArgc, Value* aVp) {
+static bool CID_GetName(JSContext* aCx, unsigned aArgc, Value* aVp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(aArgc, aVp);
   RootedObject obj(aCx, GetIDObject(args.thisv(), &sCID_Class));
   if (!obj) {
diff --git a/js/xpconnect/src/XPCJSRuntime.cpp b/js/xpconnect/src/XPCJSRuntime.cpp
--- a/js/xpconnect/src/XPCJSRuntime.cpp
+++ b/js/xpconnect/src/XPCJSRuntime.cpp
@@ -149,7 +149,7 @@ class AsyncFreeSnowWhite : public Runnab
         uint32_t((TimeStamp::Now() - start).ToMilliseconds()));
     if (hadSnowWhiteObjects && !mContinuation) {
       mContinuation = true;
-      if (NS_FAILED(Dispatch())) {
+      if (NS_FAILED(Dispatch())) {MOZ_RELEASE_ASSERT(0);
         mActive = false;
       }
     } else {
@@ -256,7 +256,7 @@ static bool TryParseLocationURICandidate
   static constexpr auto kToolkit = "chrome://global/"_ns;
   static constexpr auto kBrowser = "chrome://browser/"_ns;
 
-  if (aLocationHint == RealmPrivate::LocationHintAddon) {
+  if (aLocationHint == RealmPrivate::LocationHintAddon) {MOZ_RELEASE_ASSERT(0);
     // Blacklist some known locations which are clearly not add-on related.
     if (StringBeginsWith(uristr, kGRE) || StringBeginsWith(uristr, kToolkit) ||
         StringBeginsWith(uristr, kBrowser))
@@ -269,18 +269,18 @@ static bool TryParseLocationURICandidate
     // object, which we can't allow while we're iterating over the JS heap.
     // So just skip any such URL.
     // -- GROSS HACK ALERT --
-    if (StringBeginsWith(uristr, "xb"_ns)) {
+    if (StringBeginsWith(uristr, "xb"_ns)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
-  }
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
 
   nsCOMPtr<nsIURI> uri;
-  if (NS_FAILED(NS_NewURI(getter_AddRefs(uri), uristr))) {
+  if (NS_FAILED(NS_NewURI(getter_AddRefs(uri), uristr))) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   nsAutoCString scheme;
-  if (NS_FAILED(uri->GetScheme(scheme))) {
+  if (NS_FAILED(uri->GetScheme(scheme))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -297,14 +297,14 @@ static bool TryParseLocationURICandidate
 
 bool RealmPrivate::TryParseLocationURI(RealmPrivate::LocationHint aLocationHint,
                                        nsIURI** aURI) {
-  if (!aURI) {
+  if (!aURI) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   // Need to parse the URI.
-  if (location.IsEmpty()) {
+  if (location.IsEmpty()) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // Handle Sandbox location strings.
   // A sandbox string looks like this, for anonymous sandboxes, and builds
@@ -332,9 +332,9 @@ bool RealmPrivate::TryParseLocationURI(R
 
   // See: XPCComponents.cpp#AssembleSandboxMemoryReporterName
   int32_t idx = location.Find(from);
-  if (idx < 0) {
+  if (idx < 0) {MOZ_RELEASE_ASSERT(0);
     return TryParseLocationURICandidate(location, aLocationHint, aURI);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   // When parsing we're looking for the right-most URI. This URI may be in
   // <sandboxName>, so we try this first.
@@ -353,7 +353,7 @@ bool RealmPrivate::TryParseLocationURI(R
 
   // Loop over the "->" chain. This loop also works for non-chains, or more
   // correctly chains with only one item.
-  for (;;) {
+  for (;;) {MOZ_RELEASE_ASSERT(0);
     idx = chain.RFind(arrow);
     if (idx < 0) {
       // This is the last chain item. Try to parse what is left.
@@ -781,15 +781,15 @@ void XPCJSRuntime::GCSliceCallback(JSCon
 }
 
 /* static */
-void XPCJSRuntime::DoCycleCollectionCallback(JSContext* cx) {
+void XPCJSRuntime::DoCycleCollectionCallback(JSContext* cx) {MOZ_RELEASE_ASSERT(0);
   // The GC has detected that a CC at this point would collect a tremendous
   // amount of garbage that is being revivified unnecessarily.
   NS_DispatchToCurrentThread(
       NS_NewRunnableFunction("XPCJSRuntime::DoCycleCollectionCallback",
-                             []() { nsJSContext::CycleCollectNow(nullptr); }));
+                             []() {MOZ_RELEASE_ASSERT(0); nsJSContext::CycleCollectNow(nullptr); }));
 
   XPCJSRuntime* self = nsXPConnect::GetRuntimeInstance();
-  if (!self) {
+  if (!self) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -947,7 +947,7 @@ void CompartmentPrivate::UpdateWeakPoint
 void XPCJSRuntime::CustomOutOfMemoryCallback() {
   if (!Preferences::GetBool("memory.dump_reports_on_oom")) {
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   nsCOMPtr<nsIMemoryInfoDumper> dumper =
       do_GetService("@mozilla.org/memory-info-dumper;1");
@@ -961,7 +961,7 @@ void XPCJSRuntime::CustomOutOfMemoryCall
                                   /* minimizeMemoryUsage = */ false);
 }
 
-void XPCJSRuntime::OnLargeAllocationFailure() {
+void XPCJSRuntime::OnLargeAllocationFailure() {MOZ_RELEASE_ASSERT(0);
   CycleCollectedJSRuntime::SetLargeAllocationFailure(OOMState::Reporting);
 
   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
@@ -1002,7 +1002,7 @@ class LargeAllocationFailureRunnable fin
     MOZ_ASSERT(!NS_IsMainThread());
   }
 
-  void BlockUntilDone() {
+  void BlockUntilDone() {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(!NS_IsMainThread());
 
     MutexAutoLock lock(mMutex);
@@ -1012,7 +1012,7 @@ class LargeAllocationFailureRunnable fin
   }
 };
 
-static void OnLargeAllocationFailureCallback() {
+static void OnLargeAllocationFailureCallback() {MOZ_RELEASE_ASSERT(0);
   // This callback can be called from any thread, including internal JS helper
   // and DOM worker threads. We need to send the low-memory event via the
   // observer service which can only be called on the main thread, so proxy to
@@ -1020,10 +1020,10 @@ static void OnLargeAllocationFailureCall
   // is to synchronously free some memory so the caller can retry a failed
   // allocation, so block on the completion.
 
-  if (NS_IsMainThread()) {
+  if (NS_IsMainThread()) {MOZ_RELEASE_ASSERT(0);
     XPCJSRuntime::Get()->OnLargeAllocationFailure();
     return;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RefPtr<LargeAllocationFailureRunnable> r = new LargeAllocationFailureRunnable;
   if (NS_WARN_IF(NS_FAILED(NS_DispatchToMainThread(r)))) {
@@ -1035,7 +1035,7 @@ static void OnLargeAllocationFailureCall
 
 bool mozilla::GetBuildId(JS::BuildIdCharVector* aBuildID) {
   nsCOMPtr<nsIPlatformInfo> info = do_GetService("@mozilla.org/xre/app-info;1");
-  if (!info) {
+  if (!info) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1043,7 +1043,7 @@ bool mozilla::GetBuildId(JS::BuildIdChar
   nsresult rv = info->GetPlatformBuildID(buildID);
   NS_ENSURE_SUCCESS(rv, false);
 
-  if (!aBuildID->resize(buildID.Length())) {
+  if (!aBuildID->resize(buildID.Length())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1139,7 +1139,7 @@ static void GetRealmName(JS::Realm* real
     *anonymizeID += 1;
   } else if (JSPrincipals* principals = JS::GetRealmPrincipals(realm)) {
     nsresult rv = nsJSPrincipals::get(principals)->GetScriptLocation(name);
-    if (NS_FAILED(rv)) {
+    if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
       name.AssignLiteral("(unknown)");
     }
 
@@ -1161,22 +1161,22 @@ static void GetRealmName(JS::Realm* real
       // filesystem, which should be omitted if we're anonymizing.
       static const char* filePrefix = "file://";
       int filePos = name.Find(filePrefix);
-      if (filePos >= 0) {
+      if (filePos >= 0) {MOZ_RELEASE_ASSERT(0);
         int pathPos = filePos + strlen(filePrefix);
         int lastSlashPos = -1;
-        for (int i = pathPos; i < int(name.Length()); i++) {
-          if (name[i] == '/' || name[i] == '\\') {
+        for (int i = pathPos; i < int(name.Length()); i++) {MOZ_RELEASE_ASSERT(0);
+          if (name[i] == '/' || name[i] == '\\') {MOZ_RELEASE_ASSERT(0);
             lastSlashPos = i;
-          }
+          }MOZ_RELEASE_ASSERT(0);
         }
-        if (lastSlashPos != -1) {
+        if (lastSlashPos != -1) {MOZ_RELEASE_ASSERT(0);
           name.ReplaceLiteral(pathPos, lastSlashPos - pathPos, "<anonymized>");
-        } else {
+        } else {MOZ_RELEASE_ASSERT(0);
           // Something went wrong. Anonymize the entire path to be
           // safe.
           name.Truncate(pathPos);
           name += "<anonymized?!>";
-        }
+        }MOZ_RELEASE_ASSERT(0);
       }
 
       // We might have a location like this:
@@ -1185,15 +1185,15 @@ static void GetRealmName(JS::Realm* real
       // anonymizing.
       static const char* ownedByPrefix = "inProcessBrowserChildGlobal?ownedBy=";
       int ownedByPos = name.Find(ownedByPrefix);
-      if (ownedByPos >= 0) {
+      if (ownedByPos >= 0) {MOZ_RELEASE_ASSERT(0);
         const char* chrome = "chrome:";
         int ownerPos = ownedByPos + strlen(ownedByPrefix);
         const nsDependentCSubstring& ownerFirstPart =
             Substring(name, ownerPos, strlen(chrome));
-        if (!ownerFirstPart.EqualsASCII(chrome)) {
+        if (!ownerFirstPart.EqualsASCII(chrome)) {MOZ_RELEASE_ASSERT(0);
           name.Truncate(ownerPos);
           name += "<anonymized>";
-        }
+        }MOZ_RELEASE_ASSERT(0);
       }
     }
 
@@ -1208,7 +1208,7 @@ static void GetRealmName(JS::Realm* real
   }
 }
 
-extern void xpc::GetCurrentRealmName(JSContext* cx, nsCString& name) {
+extern void xpc::GetCurrentRealmName(JSContext* cx, nsCString& name) {MOZ_RELEASE_ASSERT(0);
   RootedObject global(cx, JS::CurrentGlobalOrNull(cx));
   if (!global) {
     name.AssignLiteral("no global");
@@ -1490,7 +1490,7 @@ static void ReportZoneStats(const JS::Zo
     // To avoid cluttering up about:memory like this, we stick notable
     // strings which contain "string(length=" into their own bucket.
 #define STRING_LENGTH "string(length="
-    if (FindInReadable(nsLiteralCString(STRING_LENGTH), notableString)) {
+    if (FindInReadable(nsLiteralCString(STRING_LENGTH), notableString)) {MOZ_RELEASE_ASSERT(0);
       stringsNotableAboutMemoryGCHeap += info.gcHeapLatin1;
       stringsNotableAboutMemoryGCHeap += info.gcHeapTwoByte;
       stringsNotableAboutMemoryMallocHeap += info.mallocHeapLatin1;
@@ -1564,7 +1564,7 @@ static void ReportZoneStats(const JS::Zo
                  "Non-inline TwoByte string characters. " MAYBE_OVERALLOCATED);
   }
 
-  if (stringsNotableAboutMemoryGCHeap > 0) {
+  if (stringsNotableAboutMemoryGCHeap > 0) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(!zStats.isTotals);
     REPORT_GC_BYTES(
         pathPrefix + "strings/string(<about-memory>)/gc-heap"_ns,
@@ -1577,7 +1577,7 @@ static void ReportZoneStats(const JS::Zo
         "is refreshed.");
   }
 
-  if (stringsNotableAboutMemoryMallocHeap > 0) {
+  if (stringsNotableAboutMemoryMallocHeap > 0) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(!zStats.isTotals);
     REPORT_BYTES(
         pathPrefix + "strings/string(<about-memory>)/malloc-heap"_ns, KIND_HEAP,
@@ -1679,7 +1679,7 @@ static void ReportClassStats(const Class
                  "Normal (non-wasm) indexed elements.");
   }
 
-  if (classInfo.objectsMallocHeapElementsAsmJS > 0) {
+  if (classInfo.objectsMallocHeapElementsAsmJS > 0) {MOZ_RELEASE_ASSERT(0);
     REPORT_BYTES(path + "objects/malloc-heap/elements/asm.js"_ns, KIND_HEAP,
                  classInfo.objectsMallocHeapElementsAsmJS,
                  "asm.js array buffer elements allocated in the malloc heap.");
@@ -1690,13 +1690,13 @@ static void ReportClassStats(const Class
                  classInfo.objectsMallocHeapMisc, "Miscellaneous object data.");
   }
 
-  if (classInfo.objectsNonHeapElementsNormal > 0) {
+  if (classInfo.objectsNonHeapElementsNormal > 0) {MOZ_RELEASE_ASSERT(0);
     REPORT_BYTES(path + "objects/non-heap/elements/normal"_ns, KIND_NONHEAP,
                  classInfo.objectsNonHeapElementsNormal,
                  "Memory-mapped non-shared array buffer elements.");
   }
 
-  if (classInfo.objectsNonHeapElementsShared > 0) {
+  if (classInfo.objectsNonHeapElementsShared > 0) {MOZ_RELEASE_ASSERT(0);
     REPORT_BYTES(
         path + "objects/non-heap/elements/shared"_ns, KIND_NONHEAP,
         classInfo.objectsNonHeapElementsShared,
@@ -1709,14 +1709,14 @@ static void ReportClassStats(const Class
   // these under sundries, because (a) in practice they're almost always
   // larger than the sundries threshold, and (b) we'd need a third category of
   // sundries ("non-heap"), which would be a pain.
-  if (classInfo.objectsNonHeapElementsWasm > 0) {
+  if (classInfo.objectsNonHeapElementsWasm > 0) {MOZ_RELEASE_ASSERT(0);
     REPORT_BYTES(path + "objects/non-heap/elements/wasm"_ns, KIND_NONHEAP,
                  classInfo.objectsNonHeapElementsWasm,
                  "wasm/asm.js array buffer elements allocated outside both the "
                  "malloc heap and the GC heap.");
   }
 
-  if (classInfo.objectsNonHeapCodeWasm > 0) {
+  if (classInfo.objectsNonHeapCodeWasm > 0) {MOZ_RELEASE_ASSERT(0);
     REPORT_BYTES(path + "objects/non-heap/code/wasm"_ns, KIND_NONHEAP,
                  classInfo.objectsNonHeapCodeWasm,
                  "AOT-compiled wasm/asm.js code.");
@@ -1932,7 +1932,7 @@ void ReportJSRuntimeExplicitTreeStats(co
   ReportScriptSourceStats(rtStats.runtime.scriptSourceInfo, nonNotablePath,
                           handleReport, data, rtTotal);
 
-  for (size_t i = 0; i < rtStats.runtime.notableScriptSources.length(); i++) {
+  for (size_t i = 0; i < rtStats.runtime.notableScriptSources.length(); i++) {MOZ_RELEASE_ASSERT(0);
     const JS::NotableScriptSourceInfo& scriptSourceInfo =
         rtStats.runtime.notableScriptSources[i];
 
@@ -1942,13 +1942,13 @@ void ReportJSRuntimeExplicitTreeStats(co
     // about:memory) will convert them back to / after doing path
     // splitting.
     nsCString escapedFilename;
-    if (anonymize) {
+    if (anonymize) {MOZ_RELEASE_ASSERT(0);
       escapedFilename.AppendPrintf("<anonymized-source-%d>", int(i));
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       nsDependentCString filename(scriptSourceInfo.filename_.get());
       escapedFilename.Append(filename);
       escapedFilename.ReplaceSubstring("/", "\\");
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     nsCString notablePath =
         rtPath +
@@ -2201,7 +2201,7 @@ class XPCJSRuntimeStats : public JS::Run
         extras->domPathPrefix.AssignLiteral(
             "explicit/dom/non-window-global?!/");
       }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       extras->jsPathPrefix.AssignLiteral("explicit/js-non-window/zones/");
       extras->domPathPrefix.AssignLiteral("explicit/dom/no-global?!/");
     }
@@ -2247,7 +2247,7 @@ void JSReporter::CollectReports(WindowPa
   XPCJSRuntimeStats rtStats(windowPaths, topWindowPaths, anonymize);
   OrphanReporter orphanReporter(XPCConvert::GetISupportsFromJSObject);
   JSContext* cx = XPCJSContext::Get()->Context();
-  if (!JS::CollectRuntimeStats(cx, &rtStats, &orphanReporter, anonymize)) {
+  if (!JS::CollectRuntimeStats(cx, &rtStats, &orphanReporter, anonymize)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -2705,7 +2705,7 @@ static nsresult ReadSourceFromFilename(J
   // mozJSSubScriptLoader prefixes the filenames of the scripts it loads with
   // the filename of its caller. Axe that if present.
   const char* arrow;
-  while ((arrow = strstr(filename, " -> "))) {
+  while ((arrow = strstr(filename, " -> "))) {MOZ_RELEASE_ASSERT(0);
     filename = arrow + strlen(" -> ");
   }
 
@@ -2728,7 +2728,7 @@ static nsresult ReadSourceFromFilename(J
   nsCString scheme;
   rv = actualUri->GetScheme(scheme);
   NS_ENSURE_SUCCESS(rv, rv);
-  if (!scheme.EqualsLiteral("file") && !scheme.EqualsLiteral("jar")) {
+  if (!scheme.EqualsLiteral("file") && !scheme.EqualsLiteral("jar")) {MOZ_RELEASE_ASSERT(0);
     return NS_OK;
   }
 
@@ -2743,14 +2743,14 @@ static nsresult ReadSourceFromFilename(J
   uint64_t rawLen;
   rv = scriptStream->Available(&rawLen);
   NS_ENSURE_SUCCESS(rv, rv);
-  if (!rawLen) {
+  if (!rawLen) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
 
   // Technically, this should be SIZE_MAX, but we don't run on machines
   // where that would be less than UINT32_MAX, and the latter is already
   // well beyond a reasonable limit.
-  if (rawLen > UINT32_MAX) {
+  if (rawLen > UINT32_MAX) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FILE_TOO_BIG;
   }
 
@@ -2758,7 +2758,7 @@ static nsresult ReadSourceFromFilename(J
   // contents of the file.  Use the JS allocator so that if UTF-8 source was
   // requested, we can return this memory directly.
   JS::UniqueChars buf(js_pod_malloc<char>(rawLen));
-  if (!buf) {
+  if (!buf) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
@@ -2767,7 +2767,7 @@ static nsresult ReadSourceFromFilename(J
   while (ptr < end) {
     uint32_t bytesRead;
     rv = scriptStream->Read(ptr, PointerRangeSize(ptr, end), &bytesRead);
-    if (NS_FAILED(rv)) {
+    if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
       return rv;
     }
     MOZ_ASSERT(bytesRead > 0, "stream promised more bytes before EOF");
@@ -2813,11 +2813,11 @@ class XPCJSSourceHook : public js::Sourc
       *utf8Source = nullptr;
     }
 
-    if (!nsContentUtils::IsSystemCaller(cx)) {
+    if (!nsContentUtils::IsSystemCaller(cx)) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
 
-    if (!filename) {
+    if (!filename) {MOZ_RELEASE_ASSERT(0);
       return true;
     }
 
@@ -2882,7 +2882,7 @@ js::UniquePtr<EdgeRange> ReflectorNode::
                                               bool wantNames) const {
   js::UniquePtr<SimpleEdgeRange> range(static_cast<SimpleEdgeRange*>(
       Concrete<JSObject>::edges(cx, wantNames).release()));
-  if (!range) {
+  if (!range) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   // UNWRAP_NON_WRAPPER_OBJECT assumes the object is completely initialized,
@@ -3051,7 +3051,7 @@ bool XPCJSRuntime::InitializeStrings(JSC
     RootedString str(cx);
     for (unsigned i = 0; i < XPCJSContext::IDX_TOTAL_COUNT; i++) {
       str = JS_AtomizeAndPinString(cx, mStrings[i]);
-      if (!str) {
+      if (!str) {MOZ_RELEASE_ASSERT(0);
         mStrIDs[0] = JSID_VOID;
         return false;
       }
@@ -3105,7 +3105,7 @@ bool XPCJSRuntime::NoteCustomGCThingXPCO
 
 /***************************************************************************/
 
-void XPCJSRuntime::DebugDump(int16_t depth) {
+void XPCJSRuntime::DebugDump(int16_t depth) {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
   depth--;
   XPC_LOG_ALWAYS(("XPCJSRuntime @ %p", this));
@@ -3180,7 +3180,7 @@ void XPCJSRuntime::AddGCCallback(xpcGCCa
   extraGCCallbacks.AppendElement(cb);
 }
 
-void XPCJSRuntime::RemoveGCCallback(xpcGCCallback cb) {
+void XPCJSRuntime::RemoveGCCallback(xpcGCCallback cb) {MOZ_RELEASE_ASSERT(0);
   MOZ_ASSERT(cb, "null callback");
   bool found = extraGCCallbacks.RemoveElement(cb);
   if (!found) {
diff --git a/js/xpconnect/src/XPCJSWeakReference.cpp b/js/xpconnect/src/XPCJSWeakReference.cpp
--- a/js/xpconnect/src/XPCJSWeakReference.cpp
+++ b/js/xpconnect/src/XPCJSWeakReference.cpp
@@ -32,7 +32,7 @@ nsresult xpcJSWeakReference::Init(JSCont
     supportsWeakRef->GetWeakReference(getter_AddRefs(mReferent));
     if (mReferent) {
       return NS_OK;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
   // If it's not a wrapped native, or it is a wrapped native that does not
   // support weak references, fall back to getting a weak ref to the object.
@@ -71,7 +71,7 @@ xpcJSWeakReference::Get(JSContext* aCx, 
   }
 
   JS::RootedObject obj(aCx, wrappedObj->GetJSObject());
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return NS_OK;
   }
 
diff --git a/js/xpconnect/src/XPCMaps.cpp b/js/xpconnect/src/XPCMaps.cpp
--- a/js/xpconnect/src/XPCMaps.cpp
+++ b/js/xpconnect/src/XPCMaps.cpp
@@ -215,7 +215,7 @@ bool NativeSetMap::Entry::Match(const PL
   }
 
   uint16_t count = Set->GetInterfaceCount();
-  if (count + (Addition ? 1 : 0) != SetInTable->GetInterfaceCount()) {
+  if (count + (Addition ? 1 : 0) != SetInTable->GetInterfaceCount()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/xpconnect/src/XPCShellImpl.cpp b/js/xpconnect/src/XPCShellImpl.cpp
--- a/js/xpconnect/src/XPCShellImpl.cpp
+++ b/js/xpconnect/src/XPCShellImpl.cpp
@@ -145,7 +145,7 @@ static nsAutoString* gWorkingDirectory =
 
 static bool GetLocationProperty(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (!args.thisv().isObject()) {
+  if (!args.thisv().isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Unexpected this value for GetLocationProperty");
     return false;
   }
@@ -214,13 +214,13 @@ static bool GetLocationProperty(JSContex
 #endif
 }
 
-static bool GetLine(JSContext* cx, char* bufp, FILE* file, const char* prompt) {
+static bool GetLine(JSContext* cx, char* bufp, FILE* file, const char* prompt) {MOZ_RELEASE_ASSERT(0);
   fputs(prompt, gOutFile);
   fflush(gOutFile);
 
   char line[4096] = {'\0'};
-  while (true) {
-    if (fgets(line, sizeof line, file)) {
+  while (true) {MOZ_RELEASE_ASSERT(0);
+    if (fgets(line, sizeof line, file)) {MOZ_RELEASE_ASSERT(0);
       strcpy(bufp, line);
       return true;
     }
@@ -230,7 +230,7 @@ static bool GetLine(JSContext* cx, char*
   }
 }
 
-static bool ReadLine(JSContext* cx, unsigned argc, Value* vp) {
+static bool ReadLine(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   CallArgs args = CallArgsFromVp(argc, vp);
 
   // While 4096 might be quite arbitrary, this is something to be fixed in
@@ -239,31 +239,31 @@ static bool ReadLine(JSContext* cx, unsi
   RootedString str(cx);
 
   /* If a prompt was specified, construct the string */
-  if (args.length() > 0) {
+  if (args.length() > 0) {MOZ_RELEASE_ASSERT(0);
     str = JS::ToString(cx, args[0]);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     str = JS_GetEmptyString(cx);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   /* Get a line from the infile */
   JS::UniqueChars strBytes = JS_EncodeStringToLatin1(cx, str);
-  if (!strBytes || !GetLine(cx, buf, gInFile, strBytes.get())) {
+  if (!strBytes || !GetLine(cx, buf, gInFile, strBytes.get())) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   /* Strip newline character added by GetLine() */
   unsigned int buflen = strlen(buf);
-  if (buflen == 0) {
-    if (feof(gInFile)) {
+  if (buflen == 0) {MOZ_RELEASE_ASSERT(0);
+    if (feof(gInFile)) {MOZ_RELEASE_ASSERT(0);
       args.rval().setNull();
       return true;
     }
-  } else if (buf[buflen - 1] == '\n') {
+  } else if (buf[buflen - 1] == '\n') {MOZ_RELEASE_ASSERT(0);
     --buflen;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   /* Turn buf into a JSString */
   str = JS_NewStringCopyN(cx, buf, buflen);
@@ -284,12 +284,12 @@ static bool Print(JSContext* cx, unsigne
 
   for (unsigned i = 0; i < args.length(); i++) {
     str = ToString(cx, args[i]);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     JS::UniqueChars utf8str = JS_EncodeStringToUTF8(cx, str);
-    if (!utf8str) {
+    if (!utf8str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -308,17 +308,17 @@ static bool Dump(JSContext* cx, unsigned
   CallArgs args = CallArgsFromVp(argc, vp);
   args.rval().setUndefined();
 
-  if (!args.length()) {
+  if (!args.length()) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
   RootedString str(cx, ToString(cx, args[0]));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   JS::UniqueChars utf8str = JS_EncodeStringToUTF8(cx, str);
-  if (!utf8str) {
+  if (!utf8str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -326,7 +326,7 @@ static bool Dump(JSContext* cx, unsigned
   __android_log_print(ANDROID_LOG_INFO, "Gecko", "%s", utf8str.get());
 #endif
 #ifdef XP_WIN
-  if (IsDebuggerPresent()) {
+  if (IsDebuggerPresent()) {MOZ_RELEASE_ASSERT(0);
     nsAutoJSString wstr;
     if (!wstr.init(cx, str)) {
       return false;
@@ -343,10 +343,10 @@ static bool Load(JSContext* cx, unsigned
   CallArgs args = CallArgsFromVp(argc, vp);
 
   JS::RootedObject thisObject(cx);
-  if (!args.computeThis(cx, &thisObject)) {
+  if (!args.computeThis(cx, &thisObject)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!JS_IsGlobalObject(thisObject)) {
+  if (!JS_IsGlobalObject(thisObject)) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Trying to load() into a non-global object");
     return false;
   }
@@ -354,17 +354,17 @@ static bool Load(JSContext* cx, unsigned
   RootedString str(cx);
   for (unsigned i = 0; i < args.length(); i++) {
     str = ToString(cx, args[i]);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     JS::UniqueChars filename = JS_EncodeStringToLatin1(cx, str);
-    if (!filename) {
+    if (!filename) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     FILE* file = fopen(filename.get(), "r");
     if (!file) {
       filename = JS_EncodeStringToUTF8(cx, str);
-      if (!filename) {
+      if (!filename) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       JS_ReportErrorUTF8(cx, "cannot open file '%s' for reading",
@@ -406,11 +406,11 @@ static bool Quit(JSContext* cx, unsigned
   return false;
 }
 
-static bool DumpXPC(JSContext* cx, unsigned argc, Value* vp) {
+static bool DumpXPC(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   JS::CallArgs args = CallArgsFromVp(argc, vp);
 
   uint16_t depth = 2;
-  if (args.length() > 0) {
+  if (args.length() > 0) {MOZ_RELEASE_ASSERT(0);
     if (!JS::ToUint16(cx, args[0], &depth)) {
       return false;
     }
@@ -447,18 +447,18 @@ static bool GCZeal(JSContext* cx, unsign
 static bool SendCommand(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (args.length() == 0) {
+  if (args.length() == 0) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Function takes at least one argument!");
     return false;
   }
 
   RootedString str(cx, ToString(cx, args[0]));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Could not convert argument 1 to string!");
     return false;
   }
 
-  if (args.get(1).isObject() && !JS_ObjectIsFunction(&args[1].toObject())) {
+  if (args.get(1).isObject() && !JS_ObjectIsFunction(&args[1].toObject())) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Could not convert argument 2 to function!");
     return false;
   }
@@ -473,43 +473,43 @@ static bool SendCommand(JSContext* cx, u
   return true;
 }
 
-static bool Options(JSContext* cx, unsigned argc, Value* vp) {
+static bool Options(JSContext* cx, unsigned argc, Value* vp) {MOZ_RELEASE_ASSERT(0);
   JS::CallArgs args = CallArgsFromVp(argc, vp);
   ContextOptions oldContextOptions = ContextOptionsRef(cx);
 
   RootedString str(cx);
   JS::UniqueChars opt;
-  for (unsigned i = 0; i < args.length(); ++i) {
+  for (unsigned i = 0; i < args.length(); ++i) {MOZ_RELEASE_ASSERT(0);
     str = ToString(cx, args[i]);
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
+      return false;
+    }MOZ_RELEASE_ASSERT(0);
+
+    opt = JS_EncodeStringToUTF8(cx, str);
+    if (!opt) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
-    opt = JS_EncodeStringToUTF8(cx, str);
-    if (!opt) {
-      return false;
-    }
-
-    if (strcmp(opt.get(), "strict_mode") == 0) {
+    if (strcmp(opt.get(), "strict_mode") == 0) {MOZ_RELEASE_ASSERT(0);
       ContextOptionsRef(cx).toggleStrictMode();
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorUTF8(cx,
                          "unknown option name '%s'. The valid name is "
                          "strict_mode.",
                          opt.get());
       return false;
-    }
-  }
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
 
   UniqueChars names;
-  if (names && oldContextOptions.strictMode()) {
+  if (names && oldContextOptions.strictMode()) {MOZ_RELEASE_ASSERT(0);
     names = JS_sprintf_append(std::move(names), "%s%s", names ? "," : "",
                               "strict_mode");
-    if (!names) {
+    if (!names) {MOZ_RELEASE_ASSERT(0);
       JS_ReportOutOfMemory(cx);
       return false;
-    }
-  }
+    }MOZ_RELEASE_ASSERT(0);
+  }MOZ_RELEASE_ASSERT(0);
 
   str = JS_NewStringCopyZ(cx, names.get());
   if (!str) {
@@ -551,7 +551,7 @@ static bool SetInterruptCallback(JSConte
 
   // Sanity-check args.
   JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
-  if (args.length() != 1) {
+  if (args.length() != 1) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Wrong number of arguments");
     return false;
   }
@@ -592,11 +592,11 @@ static bool SimulateNoScriptActivity(JSC
 
 static bool RegisterAppManifest(JSContext* cx, unsigned argc, Value* vp) {
   JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
-  if (args.length() != 1) {
+  if (args.length() != 1) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Wrong number of arguments");
     return false;
   }
-  if (!args[0].isObject()) {
+  if (!args[0].isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx,
                         "Expected object as argument 1 to registerAppManifest");
     return false;
@@ -606,7 +606,7 @@ static bool RegisterAppManifest(JSContex
   nsCOMPtr<nsIFile> file;
   nsresult rv = nsXPConnect::XPConnect()->WrapJS(cx, arg1, NS_GET_IID(nsIFile),
                                                  getter_AddRefs(file));
-  if (NS_FAILED(rv)) {
+  if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
     XPCThrower::Throw(rv, cx);
     return false;
   }
@@ -621,7 +621,7 @@ static bool RegisterAppManifest(JSContex
 #ifdef ENABLE_TESTS
 static bool RegisterXPCTestComponents(JSContext* cx, unsigned argc, Value* vp) {
   JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
-  if (args.length() != 0) {
+  if (args.length() != 0) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Wrong number of arguments");
     return false;
   }
@@ -685,7 +685,7 @@ static const JSErrorFormatString* my_Get
 }
 
 static bool ProcessUtf8Line(AutoJSAPI& jsapi, const char* buffer,
-                            int startline) {
+                            int startline) {MOZ_RELEASE_ASSERT(0);
   JSContext* cx = jsapi.cx();
   JS::CompileOptions options(cx);
   options.setFileAndLine("typein", startline)
@@ -693,31 +693,31 @@ static bool ProcessUtf8Line(AutoJSAPI& j
       .setSkipFilenameValidation(true);
 
   JS::SourceText<mozilla::Utf8Unit> srcBuf;
-  if (!srcBuf.init(cx, buffer, strlen(buffer), JS::SourceOwnership::Borrowed)) {
+  if (!srcBuf.init(cx, buffer, strlen(buffer), JS::SourceOwnership::Borrowed)) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }MOZ_RELEASE_ASSERT(0);
+
+  JS::RootedScript script(cx, JS::Compile(cx, options, srcBuf));
+  if (!script) {MOZ_RELEASE_ASSERT(0);
+    return false;
+  }
+  if (compileOnly) {MOZ_RELEASE_ASSERT(0);
+    return true;
+  }MOZ_RELEASE_ASSERT(0);
+
+  JS::RootedValue result(cx);
+  if (!JS_ExecuteScript(cx, script, &result)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  JS::RootedScript script(cx, JS::Compile(cx, options, srcBuf));
-  if (!script) {
-    return false;
-  }
-  if (compileOnly) {
+  if (result.isUndefined()) {MOZ_RELEASE_ASSERT(0);
     return true;
-  }
-
-  JS::RootedValue result(cx);
-  if (!JS_ExecuteScript(cx, script, &result)) {
-    return false;
-  }
-
-  if (result.isUndefined()) {
-    return true;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   RootedString str(cx, JS::ToString(cx, result));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   JS::UniqueChars bytes = JS_EncodeStringToLatin1(cx, str);
   if (!bytes) {
@@ -734,7 +734,7 @@ static bool ProcessFile(AutoJSAPI& jsapi
   JS::Rooted<JSObject*> global(cx, JS::CurrentGlobalOrNull(cx));
   MOZ_ASSERT(global);
 
-  if (forceTTY) {
+  if (forceTTY) {MOZ_RELEASE_ASSERT(0);
     file = stdin;
   } else if (!isatty(fileno(file))) {
     /*
@@ -747,11 +747,11 @@ static bool ProcessFile(AutoJSAPI& jsapi
      */
     int ch = fgetc(file);
     if (ch == '#') {
-      while ((ch = fgetc(file)) != EOF) {
-        if (ch == '\n' || ch == '\r') {
+      while ((ch = fgetc(file)) != EOF) {MOZ_RELEASE_ASSERT(0);
+        if (ch == '\n' || ch == '\r') {MOZ_RELEASE_ASSERT(0);
           break;
         }
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
     ungetc(ch, file);
 
@@ -763,16 +763,16 @@ static bool ProcessFile(AutoJSAPI& jsapi
         .setNoScriptRval(true)
         .setSkipFilenameValidation(true);
     script = JS::CompileUtf8File(cx, options, file);
-    if (!script) {
+    if (!script) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     return compileOnly || JS_ExecuteScript(cx, script, &unused);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   /* It's an interactive filehandle; drop into read-eval-print loop. */
   int lineno = 1;
   bool hitEOF = false;
-  do {
+  do {MOZ_RELEASE_ASSERT(0);
     char buffer[4096];
     char* bufp = buffer;
     *bufp = '\0';
@@ -784,11 +784,11 @@ static bool ProcessFile(AutoJSAPI& jsapi
      * coincides with the end of a line.
      */
     int startline = lineno;
-    do {
-      if (!GetLine(cx, bufp, file, startline == lineno ? "js> " : "")) {
+    do {MOZ_RELEASE_ASSERT(0);
+      if (!GetLine(cx, bufp, file, startline == lineno ? "js> " : "")) {MOZ_RELEASE_ASSERT(0);
         hitEOF = true;
         break;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       bufp += strlen(bufp);
       lineno++;
     } while (
@@ -806,11 +806,11 @@ static bool ProcessFile(AutoJSAPI& jsapi
 static bool Process(AutoJSAPI& jsapi, const char* filename, bool forceTTY) {
   FILE* file;
 
-  if (forceTTY || !filename || strcmp(filename, "-") == 0) {
+  if (forceTTY || !filename || strcmp(filename, "-") == 0) {MOZ_RELEASE_ASSERT(0);
     file = stdin;
   } else {
     file = fopen(filename, "r");
-    if (!file) {
+    if (!file) {MOZ_RELEASE_ASSERT(0);
       /*
        * Use Latin1 variant here because the encoding of the return value
        * of strerror function can be non-UTF-8.
@@ -855,13 +855,13 @@ static bool ProcessArgs(AutoJSAPI& jsapi
   bool forceTTY = false;
 
   rcfile = fopen(rcfilename, "r");
-  if (rcfile) {
+  if (rcfile) {MOZ_RELEASE_ASSERT(0);
     printf("[loading '%s'...]\n", rcfilename);
     bool ok = ProcessFile(jsapi, rcfilename, rcfile, false);
     fclose(rcfile);
-    if (!ok) {
+    if (!ok) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
   }
 
   JS::Rooted<JSObject*> global(cx, JS::CurrentGlobalOrNull(cx));
@@ -895,16 +895,16 @@ static bool ProcessArgs(AutoJSAPI& jsapi
    * GC calls nested below, and so it is available to -f <file> arguments.
    */
   argsObj = JS::NewArrayObject(cx, 0);
-  if (!argsObj) {
+  if (!argsObj) {MOZ_RELEASE_ASSERT(0);
     return 1;
   }
-  if (!JS_DefineProperty(cx, global, "arguments", argsObj, 0)) {
+  if (!JS_DefineProperty(cx, global, "arguments", argsObj, 0)) {MOZ_RELEASE_ASSERT(0);
     return 1;
   }
 
   for (int j = 0, length = argc - rootPosition; j < length; j++) {
     RootedString str(cx, JS_NewStringCopyZ(cx, argv[rootPosition++]));
-    if (!str || !JS_DefineElement(cx, argsObj, j, str, JSPROP_ENUMERATE)) {
+    if (!str || !JS_DefineElement(cx, argsObj, j, str, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
       return 1;
     }
   }
@@ -1067,17 +1067,17 @@ int XRE_XPCShellMain(int argc, char** ar
   PR_SetEnv("MOZ_DISABLE_ASAN_REPORTER=1");
 #endif
 
-  if (PR_GetEnv("MOZ_CHAOSMODE")) {
+  if (PR_GetEnv("MOZ_CHAOSMODE")) {MOZ_RELEASE_ASSERT(0);
     ChaosFeature feature = ChaosFeature::Any;
     long featureInt = strtol(PR_GetEnv("MOZ_CHAOSMODE"), nullptr, 16);
-    if (featureInt) {
+    if (featureInt) {MOZ_RELEASE_ASSERT(0);
       // NOTE: MOZ_CHAOSMODE=0 or a non-hex value maps to Any feature.
       feature = static_cast<ChaosFeature>(featureInt);
-    }
+    }MOZ_RELEASE_ASSERT(0);
     ChaosMode::SetChaosFeature(feature);
   }
 
-  if (ChaosMode::isActive(ChaosFeature::Any)) {
+  if (ChaosMode::isActive(ChaosFeature::Any)) {MOZ_RELEASE_ASSERT(0);
     printf_stderr(
         "*** You are running in chaos test mode. See ChaosMode.h. ***\n");
   }
@@ -1088,13 +1088,13 @@ int XRE_XPCShellMain(int argc, char** ar
   {  // Start scoping nsCOMPtrs
     nsCOMPtr<nsIFile> appFile;
     rv = XRE_GetBinaryPath(getter_AddRefs(appFile));
-    if (NS_FAILED(rv)) {
+    if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
       printf("Couldn't find application file.\n");
       return 1;
     }
     nsCOMPtr<nsIFile> appDir;
     rv = appFile->GetParent(getter_AddRefs(appDir));
-    if (NS_FAILED(rv)) {
+    if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
       printf("Couldn't get application directory.\n");
       return 1;
     }
@@ -1103,12 +1103,12 @@ int XRE_XPCShellMain(int argc, char** ar
 
     nsCOMPtr<nsIFile> greDir;
     if (argc > 1 && !strcmp(argv[1], "-g")) {
-      if (argc < 3) {
+      if (argc < 3) {MOZ_RELEASE_ASSERT(0);
         return usage();
       }
 
       rv = XRE_GetFileFromPath(argv[2], getter_AddRefs(greDir));
-      if (NS_FAILED(rv)) {
+      if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
         printf("Couldn't use given GRE dir.\n");
         return 1;
       }
@@ -1135,12 +1135,12 @@ int XRE_XPCShellMain(int argc, char** ar
       dirprovider.SetGREDirs(greDir);
 #else
       nsAutoString workingDir;
-      if (!GetCurrentWorkingDirectory(workingDir)) {
+      if (!GetCurrentWorkingDirectory(workingDir)) {MOZ_RELEASE_ASSERT(0);
         printf("GetCurrentWorkingDirectory failed.\n");
         return 1;
       }
       rv = NS_NewLocalFile(workingDir, true, getter_AddRefs(greDir));
-      if (NS_FAILED(rv)) {
+      if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
         printf("NS_NewLocalFile failed.\n");
         return 1;
       }
@@ -1148,7 +1148,7 @@ int XRE_XPCShellMain(int argc, char** ar
     }
 
     if (argc > 1 && !strcmp(argv[1], "-a")) {
-      if (argc < 3) {
+      if (argc < 3) {MOZ_RELEASE_ASSERT(0);
         return usage();
       }
 
@@ -1158,7 +1158,7 @@ int XRE_XPCShellMain(int argc, char** ar
         appDir = dir;
         dirprovider.SetAppDir(appDir);
       }
-      if (NS_FAILED(rv)) {
+      if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
         printf("Couldn't use given appdir.\n");
         return 1;
       }
@@ -1167,16 +1167,16 @@ int XRE_XPCShellMain(int argc, char** ar
     }
 
     while (argc > 1 && !strcmp(argv[1], "-r")) {
-      if (argc < 3) {
+      if (argc < 3) {MOZ_RELEASE_ASSERT(0);
         return usage();
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       nsCOMPtr<nsIFile> lf;
       rv = XRE_GetFileFromPath(argv[2], getter_AddRefs(lf));
-      if (NS_FAILED(rv)) {
+      if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
         printf("Couldn't get manifest file.\n");
         return 1;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       XRE_AddManifestLocation(NS_APP_LOCATION, lf);
 
       argc -= 2;
@@ -1186,14 +1186,14 @@ int XRE_XPCShellMain(int argc, char** ar
     const char* val = getenv("MOZ_CRASHREPORTER");
     if (val && *val && !CrashReporter::IsDummy()) {
       rv = CrashReporter::SetExceptionHandler(greDir, true);
-      if (NS_FAILED(rv)) {
+      if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
         printf("CrashReporter::SetExceptionHandler failed!\n");
         return 1;
       }
       MOZ_ASSERT(CrashReporter::GetEnabled());
     }
 
-    if (argc > 1 && !strcmp(argv[1], "--greomni")) {
+    if (argc > 1 && !strcmp(argv[1], "--greomni")) {MOZ_RELEASE_ASSERT(0);
       nsCOMPtr<nsIFile> greOmni;
       XRE_GetFileFromPath(argv[2], getter_AddRefs(greOmni));
       XRE_InitOmnijar(greOmni, greOmni);
@@ -1202,7 +1202,7 @@ int XRE_XPCShellMain(int argc, char** ar
     }
 
     rv = NS_InitXPCOM(nullptr, appDir, &dirprovider);
-    if (NS_FAILED(rv)) {
+    if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
       printf("NS_InitXPCOM failed!\n");
       return 1;
     }
@@ -1237,7 +1237,7 @@ int XRE_XPCShellMain(int argc, char** ar
       if (NS_SUCCEEDED(rv) && securityManager) {
         rv = securityManager->GetSystemPrincipal(
             getter_AddRefs(systemprincipal));
-        if (NS_FAILED(rv)) {
+        if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
           fprintf(gErrFile,
                   "+++ Failed to obtain SystemPrincipal from "
                   "ScriptSecurityManager service.\n");
@@ -1246,7 +1246,7 @@ int XRE_XPCShellMain(int argc, char** ar
           gJSPrincipals = nsJSPrincipals::get(systemprincipal);
           JS_HoldPrincipals(gJSPrincipals);
         }
-      } else {
+      } else {MOZ_RELEASE_ASSERT(0);
         fprintf(gErrFile,
                 "+++ Failed to get ScriptSecurityManager service, running "
                 "without principals");
@@ -1277,7 +1277,7 @@ int XRE_XPCShellMain(int argc, char** ar
     rv = xpc::InitClassesWithNewWrappedGlobal(
         cx, static_cast<nsIGlobalObject*>(backstagePass), systemprincipal, 0,
         options, &glob);
-    if (NS_FAILED(rv)) {
+    if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
       return 1;
     }
 
@@ -1312,12 +1312,12 @@ int XRE_XPCShellMain(int argc, char** ar
 #endif
 
     {
-      if (!glob) {
+      if (!glob) {MOZ_RELEASE_ASSERT(0);
         return 1;
       }
 
       nsCOMPtr<nsIAppStartup> appStartup(components::AppStartup::Service());
-      if (!appStartup) {
+      if (!appStartup) {MOZ_RELEASE_ASSERT(0);
         return 1;
       }
       appStartup->DoneStartingUp();
@@ -1326,11 +1326,11 @@ int XRE_XPCShellMain(int argc, char** ar
 
       JSAutoRealm ar(cx, glob);
 
-      if (!JS_InitReflectParse(cx, glob)) {
+      if (!JS_InitReflectParse(cx, glob)) {MOZ_RELEASE_ASSERT(0);
         return 1;
       }
 
-      if (!JS_DefineFunctions(cx, glob, glob_functions)) {
+      if (!JS_DefineFunctions(cx, glob, glob_functions)) {MOZ_RELEASE_ASSERT(0);
         return 1;
       }
 
@@ -1351,13 +1351,13 @@ int XRE_XPCShellMain(int argc, char** ar
         // appropriately, and then let the AutoEntryScript destructor report
         // the error to the console.
         if (!ProcessArgs(aes, argv, argc, &dirprovider)) {
-          if (gExitCode) {
+          if (gExitCode) {MOZ_RELEASE_ASSERT(0);
             result = gExitCode;
-          } else if (gQuitting) {
+          } else if (gQuitting) {MOZ_RELEASE_ASSERT(0);
             result = 0;
-          } else {
+          } else {MOZ_RELEASE_ASSERT(0);
             result = EXITCODE_RUNTIME_ERROR;
-          }
+          }MOZ_RELEASE_ASSERT(0);
         }
       }
 
@@ -1381,7 +1381,7 @@ int XRE_XPCShellMain(int argc, char** ar
     dirprovider.ClearAppFile();
   }  // this scopes the nsCOMPtrs
 
-  if (!XRE_ShutdownTestShell()) {
+  if (!XRE_ShutdownTestShell()) {MOZ_RELEASE_ASSERT(0);
     NS_ERROR("problem shutting down testshell");
   }
 
@@ -1464,7 +1464,7 @@ XPCShellDirProvider::GetFile(const char*
 
 NS_IMETHODIMP
 XPCShellDirProvider::GetFiles(const char* prop, nsISimpleEnumerator** result) {
-  if (mGREDir && !strcmp(prop, "ChromeML")) {
+  if (mGREDir && !strcmp(prop, "ChromeML")) {MOZ_RELEASE_ASSERT(0);
     nsCOMArray<nsIFile> dirs;
 
     nsCOMPtr<nsIFile> file;
@@ -1474,9 +1474,9 @@ XPCShellDirProvider::GetFiles(const char
 
     nsresult rv =
         NS_GetSpecialDirectory(NS_APP_CHROME_DIR, getter_AddRefs(file));
-    if (NS_SUCCEEDED(rv)) {
+    if (NS_SUCCEEDED(rv)) {MOZ_RELEASE_ASSERT(0);
       dirs.AppendObject(file);
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     return NS_NewArrayEnumerator(result, dirs, NS_GET_IID(nsIFile));
   } else if (!strcmp(prop, NS_APP_PREFS_DEFAULTS_DIR_LIST)) {
@@ -1486,26 +1486,26 @@ XPCShellDirProvider::GetFiles(const char
     if (mAppDir && NS_SUCCEEDED(mAppDir->Clone(getter_AddRefs(appDir))) &&
         NS_SUCCEEDED(appDir->AppendNative("defaults"_ns)) &&
         NS_SUCCEEDED(appDir->AppendNative("preferences"_ns)) &&
-        NS_SUCCEEDED(appDir->Exists(&exists)) && exists) {
+        NS_SUCCEEDED(appDir->Exists(&exists)) && exists) {MOZ_RELEASE_ASSERT(0);
       dirs.AppendObject(appDir);
       return NS_NewArrayEnumerator(result, dirs, NS_GET_IID(nsIFile));
     }
     return NS_ERROR_FAILURE;
-  } else if (!strcmp(prop, NS_APP_PLUGINS_DIR_LIST)) {
+  } else if (!strcmp(prop, NS_APP_PLUGINS_DIR_LIST)) {MOZ_RELEASE_ASSERT(0);
     nsCOMArray<nsIFile> dirs;
     // Add the test plugin location passed in by the caller or through
     // runxpcshelltests.
-    if (mPluginDir) {
+    if (mPluginDir) {MOZ_RELEASE_ASSERT(0);
       dirs.AppendObject(mPluginDir);
       // If there was no path specified, default to the one set up by automation
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       nsCOMPtr<nsIFile> file;
       bool exists;
       // We have to add this path, buildbot copies the test plugin directory
       // to (app)/bin when unpacking test zips.
-      if (mGREDir) {
+      if (mGREDir) {MOZ_RELEASE_ASSERT(0);
         mGREDir->Clone(getter_AddRefs(file));
-        if (NS_SUCCEEDED(mGREDir->Clone(getter_AddRefs(file)))) {
+        if (NS_SUCCEEDED(mGREDir->Clone(getter_AddRefs(file)))) {MOZ_RELEASE_ASSERT(0);
           file->AppendNative("plugins"_ns);
           if (NS_SUCCEEDED(file->Exists(&exists)) && exists) {
             dirs.AppendObject(file);
diff --git a/js/xpconnect/src/XPCString.cpp b/js/xpconnect/src/XPCString.cpp
--- a/js/xpconnect/src/XPCString.cpp
+++ b/js/xpconnect/src/XPCString.cpp
@@ -96,7 +96,7 @@ bool XPCStringConvert::ReadableToJSVal(J
   nsStringBuffer* buf = nsStringBuffer::FromString(readable);
   if (buf) {
     bool shared;
-    if (!StringBufferToJSVal(cx, buf, length, vp, &shared)) {
+    if (!StringBufferToJSVal(cx, buf, length, vp, &shared)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (shared) {
@@ -119,7 +119,7 @@ namespace xpc {
 bool NonVoidStringToJsval(JSContext* cx, nsAString& str,
                           MutableHandleValue rval) {
   nsStringBuffer* sharedBuffer;
-  if (!XPCStringConvert::ReadableToJSVal(cx, str, &sharedBuffer, rval)) {
+  if (!XPCStringConvert::ReadableToJSVal(cx, str, &sharedBuffer, rval)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/xpconnect/src/XPCThrower.cpp b/js/xpconnect/src/XPCThrower.cpp
--- a/js/xpconnect/src/XPCThrower.cpp
+++ b/js/xpconnect/src/XPCThrower.cpp
@@ -67,11 +67,11 @@ void XPCThrower::Throw(nsresult rv, XPCC
   char* sz;
   const char* format;
 
-  if (CheckForPendingException(rv, ccx)) {
+  if (CheckForPendingException(rv, ccx)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
-  if (!nsXPCException::NameAndFormatForNSResult(rv, nullptr, &format)) {
+  if (!nsXPCException::NameAndFormatForNSResult(rv, nullptr, &format)) {MOZ_RELEASE_ASSERT(0);
     format = "";
   }
 
@@ -113,7 +113,7 @@ void XPCThrower::ThrowBadResult(nsresult
   // else...
 
   if (!nsXPCException::NameAndFormatForNSResult(rv, nullptr, &format) ||
-      !format) {
+      !format) {MOZ_RELEASE_ASSERT(0);
     format = "";
   }
 
@@ -142,7 +142,7 @@ void XPCThrower::ThrowBadParam(nsresult 
   char* sz;
   const char* format;
 
-  if (!nsXPCException::NameAndFormatForNSResult(rv, nullptr, &format)) {
+  if (!nsXPCException::NameAndFormatForNSResult(rv, nullptr, &format)) {MOZ_RELEASE_ASSERT(0);
     format = "";
   }
 
@@ -172,7 +172,7 @@ void XPCThrower::Verbosify(XPCCallContex
     if (!JSID_IS_VOID(id)) {
       bytes = JS_EncodeStringToLatin1(ccx, JSID_TO_STRING(id));
       name = bytes ? bytes.get() : "";
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       name = "Unknown";
     }
     sz =
diff --git a/js/xpconnect/src/XPCVariant.cpp b/js/xpconnect/src/XPCVariant.cpp
--- a/js/xpconnect/src/XPCVariant.cpp
+++ b/js/xpconnect/src/XPCVariant.cpp
@@ -171,13 +171,13 @@ bool XPCArrayHomogenizer::GetTypeForArra
   RootedValue val(cx);
   RootedObject jsobj(cx);
   for (uint32_t i = 0; i < length; i++) {
-    if (!JS_GetElement(cx, array, i, &val)) {
+    if (!JS_GetElement(cx, array, i, &val)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     if (val.isInt32()) {
       type = tInt;
-    } else if (val.isDouble()) {
+    } else if (val.isDouble()) {MOZ_RELEASE_ASSERT(0);
       type = tDbl;
     } else if (val.isBoolean()) {
       type = tBool;
@@ -193,13 +193,13 @@ bool XPCArrayHomogenizer::GetTypeForArra
       jsobj = &val.toObject();
 
       bool isArray;
-      if (!JS::IsArrayObject(cx, jsobj, &isArray)) {
+      if (!JS::IsArrayObject(cx, jsobj, &isArray)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
-      if (isArray) {
+      if (isArray) {MOZ_RELEASE_ASSERT(0);
         type = tArr;
-      } else if (xpc::JSValue2ID(cx, val)) {
+      } else if (xpc::JSValue2ID(cx, val)) {MOZ_RELEASE_ASSERT(0);
         type = tID;
       } else {
         type = tISup;
@@ -261,7 +261,7 @@ bool XPCArrayHomogenizer::GetTypeForArra
 }
 
 bool XPCVariant::InitializeData(JSContext* cx) {
-  if (!js::CheckRecursionLimit(cx)) {
+  if (!js::CheckRecursionLimit(cx)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -290,7 +290,7 @@ bool XPCVariant::InitializeData(JSContex
   }
   if (val.isString()) {
     RootedString str(cx, val.toString());
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -301,14 +301,14 @@ bool XPCVariant::InitializeData(JSContex
     mData.AllocateWStringWithSize(length);
 
     mozilla::Range<char16_t> destChars(mData.u.wstr.mWStringValue, length);
-    if (!JS_CopyStringChars(cx, destChars, str)) {
+    if (!JS_CopyStringChars(cx, destChars, str)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
     MOZ_ASSERT(mData.u.wstr.mWStringValue[length] == '\0');
     return true;
   }
-  if (Maybe<nsID> id = xpc::JSValue2ID(cx, val)) {
+  if (Maybe<nsID> id = xpc::JSValue2ID(cx, val)) {MOZ_RELEASE_ASSERT(0);
     mData.SetFromID(id.ref());
     return true;
   }
@@ -324,7 +324,7 @@ bool XPCVariant::InitializeData(JSContex
 
   bool isArray;
   if (!JS::IsArrayObject(cx, jsobj, &isArray) ||
-      (isArray && !JS::GetArrayLength(cx, jsobj, &len))) {
+      (isArray && !JS::GetArrayLength(cx, jsobj, &len))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -338,9 +338,9 @@ bool XPCVariant::InitializeData(JSContex
     nsXPTType type;
     nsID id;
 
-    if (!XPCArrayHomogenizer::GetTypeForArray(cx, jsobj, len, &type, &id)) {
+    if (!XPCArrayHomogenizer::GetTypeForArray(cx, jsobj, len, &type, &id)) {MOZ_RELEASE_ASSERT(0);
       return false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     if (!XPCConvert::JSData2Native(cx, &mData.u.array.mArrayValue, val, type,
                                    &id, len, nullptr))
@@ -390,7 +390,7 @@ bool XPCVariant::VariantDataToJS(JSConte
       (realVal.isPrimitive() || type == nsIDataType::VTYPE_ARRAY ||
        type == nsIDataType::VTYPE_EMPTY_ARRAY ||
        type == nsIDataType::VTYPE_ID)) {
-    if (!JS_WrapValue(cx, &realVal)) {
+    if (!JS_WrapValue(cx, &realVal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     pJSVal.set(realVal);
@@ -403,7 +403,7 @@ bool XPCVariant::VariantDataToJS(JSConte
                    type == nsIDataType::VTYPE_INTERFACE_IS,
                "Weird variant");
 
-    if (!JS_WrapValue(cx, &realVal)) {
+    if (!JS_WrapValue(cx, &realVal)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     pJSVal.set(realVal);
diff --git a/js/xpconnect/src/XPCWrappedJS.cpp b/js/xpconnect/src/XPCWrappedJS.cpp
--- a/js/xpconnect/src/XPCWrappedJS.cpp
+++ b/js/xpconnect/src/XPCWrappedJS.cpp
@@ -165,7 +165,7 @@ nsXPCWrappedJS::AggregatedQueryInterface
   MOZ_ASSERT(IsAggregatedToNative(), "bad AggregatedQueryInterface call");
   *aInstancePtr = nullptr;
 
-  if (!IsValid()) {
+  if (!IsValid()) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_UNEXPECTED;
   }
 
@@ -184,7 +184,7 @@ nsXPCWrappedJS::AggregatedQueryInterface
 
 NS_IMETHODIMP
 nsXPCWrappedJS::QueryInterface(REFNSIID aIID, void** aInstancePtr) {
-  if (nullptr == aInstancePtr) {
+  if (nullptr == aInstancePtr) {MOZ_RELEASE_ASSERT(0);
     MOZ_ASSERT(false, "null pointer");
     return NS_ERROR_NULL_POINTER;
   }
@@ -338,7 +338,7 @@ nsresult nsXPCWrappedJS::GetNewOrUsed(JS
   }
 
   JS::RootedObject rootJSObj(cx, GetRootJSObject(cx, jsObj));
-  if (!rootJSObj) {
+  if (!rootJSObj) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
 
@@ -369,12 +369,12 @@ nsresult nsXPCWrappedJS::GetNewOrUsed(JS
     // a root.
     const nsXPTInterfaceInfo* rootInfo =
         GetInterfaceInfo(NS_GET_IID(nsISupports));
-    if (!rootInfo) {
+    if (!rootInfo) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_FAILURE;
     }
 
     root = new nsXPCWrappedJS(cx, rootJSObj, rootInfo, nullptr, &rv);
-    if (NS_FAILED(rv)) {
+    if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
       return rv;
     }
   }
@@ -404,7 +404,7 @@ nsXPCWrappedJS::nsXPCWrappedJS(JSContext
   if (IsRootWrapper()) {
     MOZ_ASSERT(!IsMultiCompartment(), "mNext is always nullptr here");
     if (!xpc::CompartmentPrivate::Get(mJSObj)->GetWrappedJSMap()->Add(cx,
-                                                                      this)) {
+                                                                      this)) {MOZ_RELEASE_ASSERT(0);
       *rv = NS_ERROR_OUT_OF_MEMORY;
     }
   } else {
@@ -531,7 +531,7 @@ void nsXPCWrappedJS::Unlink() {
 
   if (mOuter) {
     XPCJSRuntime* rt = nsXPConnect::GetRuntimeInstance();
-    if (rt->GCIsRunning()) {
+    if (rt->GCIsRunning()) {MOZ_RELEASE_ASSERT(0);
       DeferredFinalize(mOuter.forget().take());
     } else {
       mOuter = nullptr;
@@ -631,7 +631,7 @@ size_t nsXPCWrappedJS::SizeOfIncludingTh
 /***************************************************************************/
 
 NS_IMETHODIMP
-nsXPCWrappedJS::DebugDump(int16_t depth) {
+nsXPCWrappedJS::DebugDump(int16_t depth) {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
   XPC_LOG_ALWAYS(
       ("nsXPCWrappedJS @ %p with mRefCnt = %" PRIuPTR, this, mRefCnt.get()));
diff --git a/js/xpconnect/src/XPCWrappedJSClass.cpp b/js/xpconnect/src/XPCWrappedJSClass.cpp
--- a/js/xpconnect/src/XPCWrappedJSClass.cpp
+++ b/js/xpconnect/src/XPCWrappedJSClass.cpp
@@ -135,7 +135,7 @@ JSObject* nsXPCWrappedJS::CallQueryInter
 
   // XXX we should install an error reporter that will send reports to
   // the JS error console service.
-  if (!scriptEval.StartEvaluating(scope)) {
+  if (!scriptEval.StartEvaluating(scope)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -154,7 +154,7 @@ JSObject* nsXPCWrappedJS::CallQueryInter
     return nullptr;
   }
 
-  if (!xpc::ID2JSValue(cx, aIID, &arg)) {
+  if (!xpc::ID2JSValue(cx, aIID, &arg)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -178,7 +178,7 @@ JSObject* nsXPCWrappedJS::CallQueryInter
         if (e && e->GetResult() == NS_NOINTERFACE) {
           JS_ClearPendingException(cx);
         }
-      } else if (jsexception.isNumber()) {
+      } else if (jsexception.isNumber()) {MOZ_RELEASE_ASSERT(0);
         nsresult rv;
         // JS often throws an nsresult.
         if (jsexception.isDouble())
@@ -235,7 +235,7 @@ nsCString GetFunctionName(JSContext* cx,
     // return the name of that function property.
 
     Rooted<IdVector> idArray(cx, IdVector(cx));
-    if (!JS_Enumerate(cx, inner, &idArray)) {
+    if (!JS_Enumerate(cx, inner, &idArray)) {MOZ_RELEASE_ASSERT(0);
       JS_ClearPendingException(cx);
       return nsCString("error");
     }
@@ -246,7 +246,7 @@ nsCString GetFunctionName(JSContext* cx,
 
     RootedId id(cx, idArray[0]);
     RootedValue v(cx);
-    if (!JS_GetPropertyById(cx, inner, id, &v)) {
+    if (!JS_GetPropertyById(cx, inner, id, &v)) {MOZ_RELEASE_ASSERT(0);
       JS_ClearPendingException(cx);
       return nsCString("nonfunction");
     }
@@ -339,7 +339,7 @@ nsresult nsXPCWrappedJS::DelegatedQueryI
   AutoEntryScript aes(nativeGlobal, "XPCWrappedJS QueryInterface",
                       /* aIsMainThread = */ true);
   XPCCallContext ccx(aes.cx());
-  if (!ccx.IsValid()) {
+  if (!ccx.IsValid()) {MOZ_RELEASE_ASSERT(0);
     *aInstancePtr = nullptr;
     return NS_NOINTERFACE;
   }
@@ -384,7 +384,7 @@ nsresult nsXPCWrappedJS::DelegatedQueryI
       nsCOMPtr<nsIJSEnumerator> jsEnum;
       if (!XPCConvert::JSObject2NativeInterface(
               aes.cx(), getter_AddRefs(jsEnum), obj,
-              &NS_GET_IID(nsIJSEnumerator), nullptr, &rv)) {
+              &NS_GET_IID(nsIJSEnumerator), nullptr, &rv)) {MOZ_RELEASE_ASSERT(0);
         return rv;
       }
       nsCOMPtr<nsISimpleEnumerator> res = new XPCWrappedJSIterator(jsEnum);
@@ -494,7 +494,7 @@ bool nsXPCWrappedJS::GetArraySizeFromPar
 
   // This should be enforced by the xpidl compiler, but it's not.
   // See bug 695235.
-  if (param.Type().Tag() != nsXPTType::T_U32) {
+  if (param.Type().Tag() != nsXPTType::T_U32) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -518,7 +518,7 @@ bool nsXPCWrappedJS::GetInterfaceTypeFro
   const nsXPTType& inner = type.InnermostType();
   if (inner.Tag() == nsXPTType::T_INTERFACE) {
     // Directly get IID from nsXPTInterfaceInfo.
-    if (!inner.GetInterface()) {
+    if (!inner.GetInterface()) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -527,7 +527,7 @@ bool nsXPCWrappedJS::GetInterfaceTypeFro
     // Get IID from a passed parameter.
     const nsXPTParamInfo& param = method->Param(inner.ArgNum());
     if (param.Type().Tag() != nsXPTType::T_NSID &&
-        param.Type().Tag() != nsXPTType::T_NSIDPTR) {
+        param.Type().Tag() != nsXPTType::T_NSIDPTR) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -576,7 +576,7 @@ void nsXPCWrappedJS::CleanupOutparams(co
     // contain random junk.
     if (param.Type().IsComplex() || param.IsIn() || !inOutOnly) {
       uint32_t arrayLen = 0;
-      if (!GetArraySizeFromParam(info, param.Type(), nativeParams, &arrayLen)) {
+      if (!GetArraySizeFromParam(info, param.Type(), nativeParams, &arrayLen)) {MOZ_RELEASE_ASSERT(0);
         continue;
       }
 
@@ -620,7 +620,7 @@ nsresult nsXPCWrappedJS::CheckForExcepti
     }
 
     /* cleanup and set failed even if we can't build an exception */
-    if (!xpc_exception) {
+    if (!xpc_exception) {MOZ_RELEASE_ASSERT(0);
       xpccx->SetPendingException(nullptr);  // XXX necessary?
     }
   }
@@ -668,7 +668,7 @@ nsresult nsXPCWrappedJS::CheckForExcepti
     }
 
     if (reportable) {
-      if (nsJSUtils::DumpEnabled()) {
+      if (nsJSUtils::DumpEnabled()) {MOZ_RELEASE_ASSERT(0);
         static const char line[] =
             "************************************************************\n";
         static const char preamble[] =
@@ -680,27 +680,27 @@ nsresult nsXPCWrappedJS::CheckForExcepti
         fputs(preamble, stdout);
         nsCString text;
         xpc_exception->ToString(cx, text);
-        if (!text.IsEmpty()) {
+        if (!text.IsEmpty()) {MOZ_RELEASE_ASSERT(0);
           fputs(text.get(), stdout);
           fputs("\n", stdout);
         } else
           fputs(cant_get_text, stdout);
         fputs(line, stdout);
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       // Log the exception to the JS Console, so that users can do
       // something with it.
       nsCOMPtr<nsIConsoleService> consoleService(
           do_GetService(XPC_CONSOLE_CONTRACTID));
-      if (nullptr != consoleService) {
+      if (nullptr != consoleService) {MOZ_RELEASE_ASSERT(0);
         nsCOMPtr<nsIScriptError> scriptError =
             do_QueryInterface(xpc_exception->GetData());
 
-        if (nullptr == scriptError) {
+        if (nullptr == scriptError) {MOZ_RELEASE_ASSERT(0);
           // No luck getting one from the exception, so
           // try to cook one up.
           scriptError = do_CreateInstance(XPC_SCRIPT_ERROR_CONTRACTID);
-          if (nullptr != scriptError) {
+          if (nullptr != scriptError) {MOZ_RELEASE_ASSERT(0);
             nsCString newMessage;
             xpc_exception->ToString(cx, newMessage);
             // try to get filename, lineno from the first
@@ -709,32 +709,32 @@ nsresult nsXPCWrappedJS::CheckForExcepti
             nsString sourceName;
 
             nsCOMPtr<nsIStackFrame> location = xpc_exception->GetLocation();
-            if (location) {
+            if (location) {MOZ_RELEASE_ASSERT(0);
               // Get line number.
               lineNumber = location->GetLineNumber(cx);
 
               // get a filename.
               location->GetFilename(cx, sourceName);
-            }
+            }MOZ_RELEASE_ASSERT(0);
 
             nsresult rv = scriptError->InitWithWindowID(
                 NS_ConvertUTF8toUTF16(newMessage), sourceName, u""_ns,
                 lineNumber, 0, 0, "XPConnect JavaScript",
                 nsJSUtils::GetCurrentlyRunningCodeInnerWindowID(cx));
-            if (NS_FAILED(rv)) {
+            if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
               scriptError = nullptr;
-            }
+            }MOZ_RELEASE_ASSERT(0);
 
             rv = scriptError->InitSourceId(location->GetSourceId(cx));
-            if (NS_FAILED(rv)) {
+            if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
               scriptError = nullptr;
-            }
-          }
+            }MOZ_RELEASE_ASSERT(0);
+          }MOZ_RELEASE_ASSERT(0);
         }
-        if (nullptr != scriptError) {
+        if (nullptr != scriptError) {MOZ_RELEASE_ASSERT(0);
           consoleService->LogMessage(scriptError);
-        }
-      }
+        }MOZ_RELEASE_ASSERT(0);
+      }MOZ_RELEASE_ASSERT(0);
     }
     // Whether or not it passes the 'reportable' test, it might
     // still be an error and we have to do the right thing here...
@@ -782,20 +782,20 @@ nsXPCWrappedJS::CallMethod(uint16_t meth
   AutoEntryScript aes(nativeGlobal, "XPCWrappedJS method call",
                       /* aIsMainThread = */ true);
   XPCCallContext ccx(aes.cx());
-  if (!ccx.IsValid()) {
+  if (!ccx.IsValid()) {MOZ_RELEASE_ASSERT(0);
     return retval;
   }
 
   JSContext* cx = ccx.GetJSContext();
 
-  if (!cx || !info->IsReflectable()) {
+  if (!cx || !info->IsReflectable()) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
 
   const nsXPTInterfaceInfo* interfaceInfo = GetInfo();
   JS::RootedId id(cx);
   const char* name = info->NameOrDescription();
-  if (!info->GetId(cx, id.get())) {
+  if (!info->GetId(cx, id.get())) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
 
@@ -835,7 +835,7 @@ nsXPCWrappedJS::CallMethod(uint16_t meth
     argc -= 1;
   }
 
-  if (!scriptEval.StartEvaluating(scope)) {
+  if (!scriptEval.StartEvaluating(scope)) {MOZ_RELEASE_ASSERT(0);
     goto pre_call_clean_up;
   }
 
@@ -882,7 +882,7 @@ nsXPCWrappedJS::CallMethod(uint16_t meth
     }
   }
 
-  if (!args.resize(argc)) {
+  if (!args.resize(argc)) {MOZ_RELEASE_ASSERT(0);
     retval = NS_ERROR_OUT_OF_MEMORY;
     goto pre_call_clean_up;
   }
@@ -903,7 +903,7 @@ nsXPCWrappedJS::CallMethod(uint16_t meth
     RootedValue val(cx, NullValue());
 
     // Verify that null was not passed for a non-optional 'out' param.
-    if (param.IsOut() && !nativeParams[i].val.p && !param.IsOptional()) {
+    if (param.IsOut() && !nativeParams[i].val.p && !param.IsOptional()) {MOZ_RELEASE_ASSERT(0);
       retval = NS_ERROR_INVALID_ARG;
       goto pre_call_clean_up;
     }
@@ -914,7 +914,7 @@ nsXPCWrappedJS::CallMethod(uint16_t meth
         pv = nativeParams[i].val.p;
       } else {
         pv = &nativeParams[i];
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       if (!GetInterfaceTypeFromParam(info, type, nativeParams, &param_iid) ||
           !GetArraySizeFromParam(info, type, nativeParams, &array_count))
@@ -928,7 +928,7 @@ nsXPCWrappedJS::CallMethod(uint16_t meth
     if (param.IsOut()) {
       // create an 'out' object
       RootedObject out_obj(cx, NewOutObject(cx));
-      if (!out_obj) {
+      if (!out_obj) {MOZ_RELEASE_ASSERT(0);
         retval = NS_ERROR_OUT_OF_MEMORY;
         goto pre_call_clean_up;
       }
@@ -936,7 +936,7 @@ nsXPCWrappedJS::CallMethod(uint16_t meth
       if (param.IsIn()) {
         if (!JS_SetPropertyById(cx, out_obj,
                                 xpcrt->GetStringID(XPCJSContext::IDX_VALUE),
-                                val)) {
+                                val)) {MOZ_RELEASE_ASSERT(0);
           goto pre_call_clean_up;
         }
       }
@@ -1022,12 +1022,12 @@ pre_call_clean_up:
 
     if (&param == info->GetRetval()) {
       val = rval;
-    } else if (argv[i].isPrimitive()) {
+    } else if (argv[i].isPrimitive()) {MOZ_RELEASE_ASSERT(0);
       break;
     } else {
       RootedObject obj(cx, &argv[i].toObject());
       if (!JS_GetPropertyById(
-              cx, obj, xpcrt->GetStringID(XPCJSContext::IDX_VALUE), &val)) {
+              cx, obj, xpcrt->GetStringID(XPCJSContext::IDX_VALUE), &val)) {MOZ_RELEASE_ASSERT(0);
         break;
       }
     }
@@ -1069,10 +1069,10 @@ pre_call_clean_up:
       } else {
         RootedObject obj(cx, &argv[i].toObject());
         if (!JS_GetPropertyById(
-                cx, obj, xpcrt->GetStringID(XPCJSContext::IDX_VALUE), &val)) {
+                cx, obj, xpcrt->GetStringID(XPCJSContext::IDX_VALUE), &val)) {MOZ_RELEASE_ASSERT(0);
           break;
         }
-      }
+      }MOZ_RELEASE_ASSERT(0);
 
       // setup allocator and/or iid
 
diff --git a/js/xpconnect/src/XPCWrappedJSIterator.cpp b/js/xpconnect/src/XPCWrappedJSIterator.cpp
--- a/js/xpconnect/src/XPCWrappedJSIterator.cpp
+++ b/js/xpconnect/src/XPCWrappedJSIterator.cpp
@@ -44,7 +44,7 @@ nsresult XPCWrappedJSIterator::HasMoreEl
     MOZ_TRY(mEnum->Next(cx, &val));
 
     RootedDictionary<IteratorResult> result(cx);
-    if (!result.Init(cx, val)) {
+    if (!result.Init(cx, val)) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_FAILURE;
     }
 
@@ -55,7 +55,7 @@ nsresult XPCWrappedJSIterator::HasMoreEl
         nsresult rv;
         if (!XPCConvert::JSObject2NativeInterface(cx, getter_AddRefs(mNext),
                                                   obj, &NS_GET_IID(nsISupports),
-                                                  nullptr, &rv)) {
+                                                  nullptr, &rv)) {MOZ_RELEASE_ASSERT(0);
           return rv;
         }
       } else {
diff --git a/js/xpconnect/src/XPCWrappedNative.cpp b/js/xpconnect/src/XPCWrappedNative.cpp
--- a/js/xpconnect/src/XPCWrappedNative.cpp
+++ b/js/xpconnect/src/XPCWrappedNative.cpp
@@ -182,7 +182,7 @@ nsresult XPCWrappedNative::WrapNewGlobal
 
   RootedObject global(cx,
                       xpc::CreateGlobalObject(cx, clasp, principal, aOptions));
-  if (!global) {
+  if (!global) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
   XPCWrappedNativeScope* scope = ObjectScope(global);
@@ -192,14 +192,14 @@ nsresult XPCWrappedNative::WrapNewGlobal
   JSAutoRealm ar(cx, global);
 
   // If requested, initialize the standard classes on the global.
-  if (initStandardClasses && !JS::InitRealmStandardClasses(cx)) {
+  if (initStandardClasses && !JS::InitRealmStandardClasses(cx)) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
 
   // Make a proto.
   XPCWrappedNativeProto* proto = XPCWrappedNativeProto::GetNewOrUsed(
       cx, scope, nativeHelper.GetClassInfo(), scrProto);
-  if (!proto) {
+  if (!proto) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
 
@@ -207,7 +207,7 @@ nsresult XPCWrappedNative::WrapNewGlobal
   MOZ_ASSERT(proto->GetJSProtoObject());
   RootedObject protoObj(cx, proto->GetJSProtoObject());
   bool success = JS_SetPrototype(cx, global, protoObj);
-  if (!success) {
+  if (!success) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
 
@@ -285,7 +285,7 @@ nsresult XPCWrappedNative::GetNewOrUsed(
 
   nsCOMPtr<nsISupports> identity = do_QueryInterface(helper.Object());
 
-  if (!identity) {
+  if (!identity) {MOZ_RELEASE_ASSERT(0);
     NS_ERROR("This XPCOM object fails in QueryInterface to nsISupports!");
     return NS_ERROR_FAILURE;
   }
@@ -299,7 +299,7 @@ nsresult XPCWrappedNative::GetNewOrUsed(
   wrapper = map->Find(identity);
 
   if (wrapper) {
-    if (!wrapper->FindTearOff(cx, Interface, false, &rv)) {
+    if (!wrapper->FindTearOff(cx, Interface, false, &rv)) {MOZ_RELEASE_ASSERT(0);
       MOZ_ASSERT(NS_FAILED(rv), "returning NS_OK on failure");
       return rv;
     }
@@ -349,7 +349,7 @@ nsresult XPCWrappedNative::GetNewOrUsed(
   if (scrWrapper && scrWrapper->WantPreCreate()) {
     RootedObject plannedParent(cx, parent);
     nsresult rv = scrWrapper->PreCreate(identity, cx, parent, parent.address());
-    if (NS_FAILED(rv)) {
+    if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
       return rv;
     }
     rv = NS_OK;
@@ -373,9 +373,9 @@ nsresult XPCWrappedNative::GetNewOrUsed(
     // the preCreate call caused the wrapper to get created through some
     // interesting path (the DOM code tends to make this happen sometimes).
 
-    if (cache) {
+    if (cache) {MOZ_RELEASE_ASSERT(0);
       RootedObject cached(cx, cache->GetWrapper());
-      if (cached) {
+      if (cached) {MOZ_RELEASE_ASSERT(0);
         wrapper = XPCWrappedNative::Get(cached);
       }
     } else {
@@ -383,10 +383,10 @@ nsresult XPCWrappedNative::GetNewOrUsed(
     }
 
     if (wrapper) {
-      if (!wrapper->FindTearOff(cx, Interface, false, &rv)) {
+      if (!wrapper->FindTearOff(cx, Interface, false, &rv)) {MOZ_RELEASE_ASSERT(0);
         MOZ_ASSERT(NS_FAILED(rv), "returning NS_OK on failure");
         return rv;
-      }
+      }MOZ_RELEASE_ASSERT(0);
       wrapper.forget(resultWrapper);
       return NS_OK;
     }
@@ -404,21 +404,21 @@ nsresult XPCWrappedNative::GetNewOrUsed(
 
   if (info && !isClassInfoSingleton) {
     proto = XPCWrappedNativeProto::GetNewOrUsed(cx, Scope, info, scrProto);
-    if (!proto) {
+    if (!proto) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_FAILURE;
     }
 
     wrapper = new XPCWrappedNative(std::move(identity), proto);
   } else {
     RefPtr<XPCNativeInterface> iface = Interface;
-    if (!iface) {
+    if (!iface) {MOZ_RELEASE_ASSERT(0);
       iface = XPCNativeInterface::GetISupports(cx);
     }
 
     XPCNativeSetKey key(cx, iface);
     RefPtr<XPCNativeSet> set = XPCNativeSet::GetNewOrUsed(cx, &key);
 
-    if (!set) {
+    if (!set) {MOZ_RELEASE_ASSERT(0);
       return NS_ERROR_FAILURE;
     }
 
@@ -434,7 +434,7 @@ nsresult XPCWrappedNative::GetNewOrUsed(
   // *seen* this happen.
   AutoMarkingWrappedNativePtr wrapperMarker(cx, wrapper);
 
-  if (!wrapper->Init(cx, scrWrapper)) {
+  if (!wrapper->Init(cx, scrWrapper)) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
 
@@ -460,7 +460,7 @@ static nsresult FinishCreate(JSContext* 
   // pre-existing) wrapper that ultimately ends up in the map, which is
   // what we want.
   wrapper = map->Add(inWrapper);
-  if (!wrapper) {
+  if (!wrapper) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
 
@@ -639,7 +639,7 @@ bool XPCWrappedNative::Init(JSContext* c
 
   RootedObject protoJSObject(cx, HasProto() ? GetProto()->GetJSProtoObject()
                                             : JS::GetRealmObjectPrototype(cx));
-  if (!protoJSObject) {
+  if (!protoJSObject) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -732,7 +732,7 @@ NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_LA
  */
 
 void XPCWrappedNative::FlatJSObjectFinalized() {
-  if (!IsValid()) {
+  if (!IsValid()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -760,7 +760,7 @@ void XPCWrappedNative::FlatJSObjectFinal
 
   nsWrapperCache* cache = nullptr;
   CallQueryInterface(mIdentity, &cache);
-  if (cache) {
+  if (cache) {MOZ_RELEASE_ASSERT(0);
     cache->ClearWrapper(mFlatJSObject.unbarrieredGetPtr());
   }
 
@@ -797,7 +797,7 @@ void XPCWrappedNative::FlatJSObjectMoved
 }
 
 void XPCWrappedNative::SystemIsBeingShutDown() {
-  if (!IsValid()) {
+  if (!IsValid()) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -887,7 +887,7 @@ XPCWrappedNativeTearOff* XPCWrappedNativ
         // We shouldn't ever be getting here _during_ our
         // Mark/Sweep cycle, so this should be safe.
         to->Unmark();
-        if (!ok) {
+        if (!ok) {MOZ_RELEASE_ASSERT(0);
           to = nullptr;
           rv = NS_ERROR_OUT_OF_MEMORY;
         }
@@ -960,7 +960,7 @@ nsresult XPCWrappedNative::InitTearOff(J
   // Guard against trying to build a tearoff for a shared nsIClassInfo.
   if (iid->Equals(NS_GET_IID(nsIClassInfo))) {
     nsCOMPtr<nsISupports> alternate_identity(do_QueryInterface(qiResult));
-    if (alternate_identity.get() != identity) {
+    if (alternate_identity.get() != identity) {MOZ_RELEASE_ASSERT(0);
       aTearOff->SetInterface(nullptr);
       return NS_ERROR_NO_INTERFACE;
     }
@@ -982,7 +982,7 @@ nsresult XPCWrappedNative::InitTearOff(J
   nsCOMPtr<nsIXPConnectWrappedJS> wrappedJS(do_QueryInterface(qiResult));
   if (wrappedJS) {
     RootedObject jso(cx, wrappedJS->GetJSObject());
-    if (jso == mFlatJSObject) {
+    if (jso == mFlatJSObject) {MOZ_RELEASE_ASSERT(0);
       // The implementing JSObject is the same as ours! Just say OK
       // without actually extending the set.
       //
@@ -1012,7 +1012,7 @@ nsresult XPCWrappedNative::InitTearOff(J
   // because we unlocked and called out in the interim and the result of the
   // previous call might not be correct anymore.
 
-  if (!mSet->HasInterface(aInterface) && !ExtendSet(cx, aInterface)) {
+  if (!mSet->HasInterface(aInterface) && !ExtendSet(cx, aInterface)) {MOZ_RELEASE_ASSERT(0);
     aTearOff->SetInterface(nullptr);
     return NS_ERROR_NO_INTERFACE;
   }
@@ -1151,7 +1151,7 @@ bool CallMethodHelper::Call() {
     return QueryInterfaceFastPath();
   }
 
-  if (!mMethodInfo) {
+  if (!mMethodInfo) {MOZ_RELEASE_ASSERT(0);
     Throw(NS_ERROR_XPC_CANT_GET_METHOD_INFO, mCallContext);
     return false;
   }
@@ -1226,12 +1226,12 @@ bool CallMethodHelper::GetArraySizeFromP
     bool ok = false;
     if (JS::IsArrayObject(mCallContext, maybeArray, &isArray) && isArray) {
       ok = JS::GetArrayLength(mCallContext, arrayOrNull, lengthp);
-    } else if (JS_IsTypedArrayObject(&maybeArray.toObject())) {
+    } else if (JS_IsTypedArrayObject(&maybeArray.toObject())) {MOZ_RELEASE_ASSERT(0);
       size_t len = JS_GetTypedArrayLength(&maybeArray.toObject());
-      if (len <= UINT32_MAX) {
+      if (len <= UINT32_MAX) {MOZ_RELEASE_ASSERT(0);
         *lengthp = len;
         ok = true;
-      }
+      }MOZ_RELEASE_ASSERT(0);
     }
 
     if (!ok) {
@@ -1249,7 +1249,7 @@ bool CallMethodHelper::GetInterfaceTypeF
 
   const nsXPTType& inner = type.InnermostType();
   if (inner.Tag() == nsXPTType::T_INTERFACE) {
-    if (!inner.GetInterface()) {
+    if (!inner.GetInterface()) {MOZ_RELEASE_ASSERT(0);
       return Throw(NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO, mCallContext);
     }
 
@@ -1257,7 +1257,7 @@ bool CallMethodHelper::GetInterfaceTypeF
   } else if (inner.Tag() == nsXPTType::T_INTERFACE_IS) {
     const nsXPTCVariant* param = GetDispatchParam(inner.ArgNum());
     if (param->type.Tag() != nsXPTType::T_NSID &&
-        param->type.Tag() != nsXPTType::T_NSIDPTR) {
+        param->type.Tag() != nsXPTType::T_NSIDPTR) {MOZ_RELEASE_ASSERT(0);
       return Throw(NS_ERROR_UNEXPECTED, mCallContext);
     }
 
@@ -1310,7 +1310,7 @@ bool CallMethodHelper::GatherAndConvertR
     const nsXPTParamInfo& paramInfo = mMethodInfo->GetParam(i);
     if (!paramInfo.IsOut()) {
       continue;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     const nsXPTType& type = paramInfo.GetType();
     nsXPTCVariant* dp = GetDispatchParam(i);
@@ -1324,7 +1324,7 @@ bool CallMethodHelper::GatherAndConvertR
 
     nsresult err;
     if (!XPCConvert::NativeData2JS(mCallContext, &v, &dp->val, type, &param_iid,
-                                   array_count, &err)) {
+                                   array_count, &err)) {MOZ_RELEASE_ASSERT(0);
       ThrowBadParam(err, i, mCallContext);
       return false;
     }
@@ -1335,7 +1335,7 @@ bool CallMethodHelper::GatherAndConvertR
       // we actually assured this before doing the invoke
       MOZ_ASSERT(mArgv[i].isObject(), "out var is not object");
       RootedObject obj(mCallContext, &mArgv[i].toObject());
-      if (!JS_SetPropertyById(mCallContext, obj, mIdxValueId, v)) {
+      if (!JS_SetPropertyById(mCallContext, obj, mIdxValueId, v)) {MOZ_RELEASE_ASSERT(0);
         ThrowBadParam(NS_ERROR_XPC_CANT_SET_OUT_VAL, i, mCallContext);
         return false;
       }
@@ -1352,7 +1352,7 @@ bool CallMethodHelper::QueryInterfaceFas
   MOZ_ASSERT(mVTableIndex == 0,
              "Using the QI fast-path for a method other than QueryInterface");
 
-  if (mArgc < 1) {
+  if (mArgc < 1) {MOZ_RELEASE_ASSERT(0);
     Throw(NS_ERROR_XPC_NOT_ENOUGH_ARGS, mCallContext);
     return false;
   }
@@ -1364,7 +1364,7 @@ bool CallMethodHelper::QueryInterfaceFas
 
   JS::RootedValue iidarg(mCallContext, mArgv[0]);
   Maybe<nsID> iid = xpc::JSValue2ID(mCallContext, iidarg);
-  if (!iid) {
+  if (!iid) {MOZ_RELEASE_ASSERT(0);
     ThrowBadParam(NS_ERROR_XPC_BAD_CONVERT_JS, 0, mCallContext);
     return false;
   }
@@ -1534,7 +1534,7 @@ bool CallMethodHelper::ConvertIndependen
   nsID param_iid = {0};
   const nsXPTType& inner = type.InnermostType();
   if (inner.Tag() == nsXPTType::T_INTERFACE) {
-    if (!inner.GetInterface()) {
+    if (!inner.GetInterface()) {MOZ_RELEASE_ASSERT(0);
       return ThrowBadParam(NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO, i,
                            mCallContext);
     }
@@ -1578,7 +1578,7 @@ bool CallMethodHelper::ConvertDependentP
   //
   // This is a no-op for 'in' params.
   RootedValue src(mCallContext);
-  if (!GetOutParamSource(i, &src)) {
+  if (!GetOutParamSource(i, &src)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1597,7 +1597,7 @@ bool CallMethodHelper::ConvertDependentP
     MOZ_ASSERT(i < mArgc || paramInfo.IsOptional(),
                "Expected either enough arguments or an optional argument");
     src = i < mArgc ? mArgv[i] : JS::NullValue();
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   nsID param_iid;
   uint32_t array_count;
@@ -1628,14 +1628,14 @@ static void TraceParam(JSTracer* aTrc, v
   if (aType.Tag() == nsXPTType::T_JSVAL) {
     JS::UnsafeTraceRoot(aTrc, (JS::Value*)aVal,
                         "XPCWrappedNative::CallMethod param");
-  } else if (aType.Tag() == nsXPTType::T_ARRAY) {
+  } else if (aType.Tag() == nsXPTType::T_ARRAY) {MOZ_RELEASE_ASSERT(0);
     auto* array = (xpt::detail::UntypedTArray*)aVal;
     const nsXPTType& elty = aType.ArrayElementType();
 
-    for (uint32_t i = 0; i < array->Length(); ++i) {
+    for (uint32_t i = 0; i < array->Length(); ++i) {MOZ_RELEASE_ASSERT(0);
       TraceParam(aTrc, elty.ElementPtr(array->Elements(), i), elty);
     }
-  } else if (aType.Tag() == nsXPTType::T_LEGACY_ARRAY && *(void**)aVal) {
+  } else if (aType.Tag() == nsXPTType::T_LEGACY_ARRAY && *(void**)aVal) {MOZ_RELEASE_ASSERT(0);
     const nsXPTType& elty = aType.ArrayElementType();
 
     for (uint32_t i = 0; i < aArrayLen; ++i) {
@@ -1666,7 +1666,7 @@ void CallMethodHelper::trace(JSTracer* a
 
 JSObject* XPCWrappedNative::GetJSObject() { return GetFlatJSObject(); }
 
-NS_IMETHODIMP XPCWrappedNative::DebugDump(int16_t depth) {
+NS_IMETHODIMP XPCWrappedNative::DebugDump(int16_t depth) {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
   depth--;
   XPC_LOG_ALWAYS(
@@ -1725,7 +1725,7 @@ char* XPCWrappedNative::ToString(
   if (scr) {
     name = JS_smprintf("%s", scr->GetJSClass()->name);
   }
-  if (to) {
+  if (to) {MOZ_RELEASE_ASSERT(0);
     const char* fmt = name ? " (%s)" : "%s";
     name = JS_sprintf_append(std::move(name), fmt,
                              to->GetInterface()->GetNameString());
@@ -1755,7 +1755,7 @@ char* XPCWrappedNative::ToString(
     }
   }
 
-  if (!name) {
+  if (!name) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   const char* fmt = "[xpconnect wrapped %s" FMT_ADDR FMT_STR(" (native")
diff --git a/js/xpconnect/src/XPCWrappedNativeInfo.cpp b/js/xpconnect/src/XPCWrappedNativeInfo.cpp
--- a/js/xpconnect/src/XPCWrappedNativeInfo.cpp
+++ b/js/xpconnect/src/XPCWrappedNativeInfo.cpp
@@ -47,7 +47,7 @@ bool XPCNativeMember::NewFunctionObject(
 bool XPCNativeMember::Resolve(XPCCallContext& ccx, XPCNativeInterface* iface,
                               HandleObject parent, Value* vp) {
   MOZ_ASSERT(iface == GetInterface());
-  if (IsConstant()) {
+  if (IsConstant()) {MOZ_RELEASE_ASSERT(0);
     RootedValue resultVal(ccx);
     nsCString name;
     if (NS_FAILED(iface->GetInterfaceInfo()->GetConstant(mIndex, &resultVal,
@@ -67,7 +67,7 @@ bool XPCNativeMember::Resolve(XPCCallCon
 
   if (IsMethod()) {
     const nsXPTMethodInfo* info;
-    if (NS_FAILED(iface->GetInterfaceInfo()->GetMethodInfo(mIndex, &info))) {
+    if (NS_FAILED(iface->GetInterfaceInfo()->GetMethodInfo(mIndex, &info))) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -90,7 +90,7 @@ bool XPCNativeMember::Resolve(XPCCallCon
   } else {
     fun = js::NewFunctionWithReserved(ccx, callback, argc, 0, nullptr);
   }
-  if (!fun) {
+  if (!fun) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -123,7 +123,7 @@ already_AddRefed<XPCNativeInterface> XPC
   XPCJSRuntime* rt = XPCJSRuntime::Get();
 
   IID2NativeInterfaceMap* map = rt->GetIID2NativeInterfaceMap();
-  if (!map) {
+  if (!map) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -139,12 +139,12 @@ already_AddRefed<XPCNativeInterface> XPC
   }
 
   iface = NewInstance(cx, info);
-  if (!iface) {
+  if (!iface) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   XPCNativeInterface* iface2 = map->Add(iface);
-  if (!iface2) {
+  if (!iface2) {MOZ_RELEASE_ASSERT(0);
     NS_ERROR("failed to add our interface!");
     iface = nullptr;
   } else if (iface2 != iface) {
@@ -162,7 +162,7 @@ already_AddRefed<XPCNativeInterface> XPC
   XPCJSRuntime* rt = XPCJSRuntime::Get();
 
   IID2NativeInterfaceMap* map = rt->GetIID2NativeInterfaceMap();
-  if (!map) {
+  if (!map) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -173,12 +173,12 @@ already_AddRefed<XPCNativeInterface> XPC
   }
 
   iface = NewInstance(cx, info);
-  if (!iface) {
+  if (!iface) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
   RefPtr<XPCNativeInterface> iface2 = map->Add(iface);
-  if (!iface2) {
+  if (!iface2) {MOZ_RELEASE_ASSERT(0);
     NS_ERROR("failed to add our interface!");
     iface = nullptr;
   } else if (iface2 != iface) {
@@ -265,7 +265,7 @@ already_AddRefed<XPCNativeInterface> XPC
     }
 
     jsid name;
-    if (!info.GetId(cx, name)) {
+    if (!info.GetId(cx, name)) {MOZ_RELEASE_ASSERT(0);
       NS_ERROR("bad method name");
       return nullptr;
     }
@@ -282,7 +282,7 @@ already_AddRefed<XPCNativeInterface> XPC
     } else {
       // XXX need better way to find dups
       // MOZ_ASSERT(!LookupMemberByID(name),"duplicate method name");
-      if (realTotalCount == XPCNativeMember::GetMaxIndexInInterface()) {
+      if (realTotalCount == XPCNativeMember::GetMaxIndexInInterface()) {MOZ_RELEASE_ASSERT(0);
         NS_WARNING("Too many members in interface");
         return nullptr;
       }
@@ -301,12 +301,12 @@ already_AddRefed<XPCNativeInterface> XPC
   for (unsigned int i = 0; i < constCount; i++) {
     RootedValue constant(cx);
     nsCString namestr;
-    if (NS_FAILED(aInfo->GetConstant(i, &constant, getter_Copies(namestr)))) {
+    if (NS_FAILED(aInfo->GetConstant(i, &constant, getter_Copies(namestr)))) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
 
     RootedString str(cx, JS_AtomizeAndPinString(cx, namestr.get()));
-    if (!str) {
+    if (!str) {MOZ_RELEASE_ASSERT(0);
       NS_ERROR("bad constant name");
       return nullptr;
     }
@@ -314,7 +314,7 @@ already_AddRefed<XPCNativeInterface> XPC
 
     // XXX need better way to find dups
     // MOZ_ASSERT(!LookupMemberByID(name),"duplicate method/constant name");
-    if (realTotalCount == XPCNativeMember::GetMaxIndexInInterface()) {
+    if (realTotalCount == XPCNativeMember::GetMaxIndexInInterface()) {MOZ_RELEASE_ASSERT(0);
       NS_WARNING("Too many members in interface");
       return nullptr;
     }
@@ -326,11 +326,11 @@ already_AddRefed<XPCNativeInterface> XPC
   }
 
   const char* bytes = aInfo->Name();
-  if (!bytes) {
+  if (!bytes) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   RootedString str(cx, JS_AtomizeAndPinString(cx, bytes));
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -343,7 +343,7 @@ already_AddRefed<XPCNativeInterface> XPC
     size += (realTotalCount - 1) * sizeof(XPCNativeMember);
   }
   void* place = new char[size];
-  if (!place) {
+  if (!place) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -434,7 +434,7 @@ XPCNativeSet::~XPCNativeSet() {
 already_AddRefed<XPCNativeSet> XPCNativeSet::GetNewOrUsed(JSContext* cx,
                                                           const nsIID* iid) {
   RefPtr<XPCNativeInterface> iface = XPCNativeInterface::GetNewOrUsed(cx, iid);
-  if (!iface) {
+  if (!iface) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -442,7 +442,7 @@ already_AddRefed<XPCNativeSet> XPCNative
 
   XPCJSRuntime* xpcrt = XPCJSRuntime::Get();
   NativeSetMap* map = xpcrt->GetNativeSetMap();
-  if (!map) {
+  if (!map) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -453,7 +453,7 @@ already_AddRefed<XPCNativeSet> XPCNative
   }
 
   set = NewInstance(cx, {std::move(iface)});
-  if (!set) {
+  if (!set) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -470,7 +470,7 @@ already_AddRefed<XPCNativeSet> XPCNative
     JSContext* cx, nsIClassInfo* classInfo) {
   XPCJSRuntime* xpcrt = XPCJSRuntime::Get();
   ClassInfo2NativeSetMap* map = xpcrt->GetClassInfo2NativeSetMap();
-  if (!map) {
+  if (!map) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -481,7 +481,7 @@ already_AddRefed<XPCNativeSet> XPCNative
   }
 
   AutoTArray<nsIID, 4> iids;
-  if (NS_FAILED(classInfo->GetInterfaces(iids))) {
+  if (NS_FAILED(classInfo->GetInterfaces(iids))) {MOZ_RELEASE_ASSERT(0);
     // Note: I'm making it OK for this call to fail so that one can add
     // nsIClassInfo to classes implemented in script without requiring this
     // method to be implemented.
@@ -505,13 +505,13 @@ already_AddRefed<XPCNativeSet> XPCNative
     set = NewInstance(cx, std::move(interfaces));
     if (set) {
       NativeSetMap* map2 = xpcrt->GetNativeSetMap();
-      if (!map2) {
+      if (!map2) {MOZ_RELEASE_ASSERT(0);
         return set.forget();
       }
 
       XPCNativeSetKey key(set);
       XPCNativeSet* set2 = map2->Add(&key, set);
-      if (!set2) {
+      if (!set2) {MOZ_RELEASE_ASSERT(0);
         NS_ERROR("failed to add our set");
         return nullptr;
       }
@@ -551,7 +551,7 @@ void XPCNativeSet::ClearCacheEntryForCla
 already_AddRefed<XPCNativeSet> XPCNativeSet::GetNewOrUsed(
     JSContext* cx, XPCNativeSetKey* key) {
   NativeSetMap* map = XPCJSRuntime::Get()->GetNativeSetMap();
-  if (!map) {
+  if (!map) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -567,7 +567,7 @@ already_AddRefed<XPCNativeSet> XPCNative
     set = NewInstance(cx, {key->GetAddition()});
   }
 
-  if (!set) {
+  if (!set) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -631,7 +631,7 @@ already_AddRefed<XPCNativeSet> XPCNative
 // static
 already_AddRefed<XPCNativeSet> XPCNativeSet::NewInstance(
     JSContext* cx, nsTArray<RefPtr<XPCNativeInterface>>&& array) {
-  if (array.Length() == 0) {
+  if (array.Length() == 0) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -683,7 +683,7 @@ already_AddRefed<XPCNativeSet> XPCNative
 
   MOZ_ASSERT(otherSet);
 
-  if (!newInterface) {
+  if (!newInterface) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -716,7 +716,7 @@ size_t XPCNativeSet::SizeOfIncludingThis
   return mallocSizeOf(this);
 }
 
-void XPCNativeSet::DebugDump(int16_t depth) {
+void XPCNativeSet::DebugDump(int16_t depth) {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
   depth--;
   XPC_LOG_ALWAYS(("XPCNativeSet @ %p", this));
diff --git a/js/xpconnect/src/XPCWrappedNativeJSOps.cpp b/js/xpconnect/src/XPCWrappedNativeJSOps.cpp
--- a/js/xpconnect/src/XPCWrappedNativeJSOps.cpp
+++ b/js/xpconnect/src/XPCWrappedNativeJSOps.cpp
@@ -45,11 +45,11 @@ static bool ToStringGuts(XPCCallContext&
 
   if (wrapper) {
     sz.reset(wrapper->ToString(ccx.GetTearOff()));
-  } else {
+  } else {MOZ_RELEASE_ASSERT(0);
     sz = JS_smprintf("[xpconnect wrapped native prototype]");
   }
 
-  if (!sz) {
+  if (!sz) {MOZ_RELEASE_ASSERT(0);
     JS_ReportOutOfMemory(ccx);
     return false;
   }
@@ -69,7 +69,7 @@ static bool XPC_WN_Shared_ToString(JSCon
   CallArgs args = CallArgsFromVp(argc, vp);
 
   RootedObject obj(cx);
-  if (!args.computeThis(cx, &obj)) {
+  if (!args.computeThis(cx, &obj)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -98,7 +98,7 @@ static bool XPC_WN_Shared_toPrimitive(JS
   CallArgs args = CallArgsFromVp(argc, vp);
 
   RootedObject obj(cx);
-  if (!JS_ValueToObject(cx, args.thisv(), &obj)) {
+  if (!JS_ValueToObject(cx, args.thisv(), &obj)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   XPCCallContext ccx(cx, obj);
@@ -106,7 +106,7 @@ static bool XPC_WN_Shared_toPrimitive(JS
   THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
 
   JSType hint;
-  if (!GetFirstArgumentAsTypeHint(cx, args, &hint)) {
+  if (!GetFirstArgumentAsTypeHint(cx, args, &hint)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -121,7 +121,7 @@ static bool XPC_WN_Shared_toPrimitive(JS
 
   XPCNativeMember* member = ccx.GetMember();
   if (member && member->IsMethod()) {
-    if (!XPCWrappedNative::CallMethod(ccx)) {
+    if (!XPCWrappedNative::CallMethod(ccx)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -227,7 +227,7 @@ static bool XPC_WN_DoubleWrappedGetter(J
                                        Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
 
-  if (!args.thisv().isObject()) {
+  if (!args.thisv().isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(
         cx,
         "xpconnect double wrapped getter called on incompatible non-object");
@@ -243,7 +243,7 @@ static bool XPC_WN_DoubleWrappedGetter(J
              "bad function");
 
   RootedObject realObject(cx, GetDoubleWrappedJSObject(ccx, wrapper));
-  if (!realObject) {
+  if (!realObject) {MOZ_RELEASE_ASSERT(0);
     // This is pretty unexpected at this point. The object originally
     // responded to this get property call and now gives no object.
     // XXX Should this throw something at the caller?
@@ -314,7 +314,7 @@ static bool DefinePropertyIfFound(
 
       if (call) {
         RootedFunction fun(ccx, JS_NewFunction(ccx, call, 0, 0, name));
-        if (!fun) {
+        if (!fun) {MOZ_RELEASE_ASSERT(0);
           JS_ReportOutOfMemory(ccx);
           return false;
         }
@@ -347,7 +347,7 @@ static bool DefinePropertyIfFound(
         }
 
         name = JS_EncodeStringToLatin1(ccx, JSID_TO_STRING(id));
-        if (!name) {
+        if (!name) {MOZ_RELEASE_ASSERT(0);
           break;
         }
 
@@ -358,12 +358,12 @@ static bool DefinePropertyIfFound(
 
         to =
             wrapperToReflectInterfaceNames->FindTearOff(ccx, iface2, true, &rv);
-        if (!to) {
+        if (!to) {MOZ_RELEASE_ASSERT(0);
           break;
         }
 
         jso = to->GetJSObject();
-        if (!jso) {
+        if (!jso) {MOZ_RELEASE_ASSERT(0);
           break;
         }
 
@@ -377,7 +377,7 @@ static bool DefinePropertyIfFound(
         }
         return JS_DefinePropertyById(ccx, obj, id, jso,
                                      propFlags & ~JSPROP_ENUMERATE);
-      } else if (NS_FAILED(rv) && rv != NS_ERROR_NO_INTERFACE) {
+      } else if (NS_FAILED(rv) && rv != NS_ERROR_NO_INTERFACE) {MOZ_RELEASE_ASSERT(0);
         return Throw(rv, ccx);
       }
     }
@@ -396,12 +396,12 @@ static bool DefinePropertyIfFound(
 
       fun = JS_NewFunction(ccx, XPC_WN_DoubleWrappedGetter, 0, 0, name);
 
-      if (!fun) {
+      if (!fun) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
       RootedObject funobj(ccx, JS_GetFunctionObject(fun));
-      if (!funobj) {
+      if (!funobj) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -426,11 +426,11 @@ static bool DefinePropertyIfFound(
       XPCWrappedNativeTearOff* to =
           wrapperToReflectInterfaceNames->FindTearOff(ccx, iface, true);
 
-      if (!to) {
+      if (!to) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       RootedObject jso(ccx, to->GetJSObject());
-      if (!jso) {
+      if (!jso) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
 
@@ -441,9 +441,9 @@ static bool DefinePropertyIfFound(
       return JS_DefinePropertyById(ccx, obj, id, jso,
                                    propFlags & ~JSPROP_ENUMERATE);
     }
-    if (resolved) {
+    if (resolved) {MOZ_RELEASE_ASSERT(0);
       *resolved = false;
-    }
+    }MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -455,7 +455,7 @@ static bool DefinePropertyIfFound(
     }
     return member->GetConstantValue(ccx, iface, val.address()) &&
            JS_DefinePropertyById(ccx, obj, id, val, propFlags);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   if (id == xpccx->GetStringID(XPCJSContext::IDX_TO_STRING) ||
       id == xpccx->GetStringID(XPCJSContext::IDX_TO_SOURCE) ||
@@ -464,7 +464,7 @@ static bool DefinePropertyIfFound(
     propFlags &= ~JSPROP_ENUMERATE;
 
   RootedValue funval(ccx);
-  if (!member->NewFunctionObject(ccx, iface, obj, funval.address())) {
+  if (!member->NewFunctionObject(ccx, iface, obj, funval.address())) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -631,7 +631,7 @@ static bool XPC_WN_NoHelper_Resolve(JSCo
   THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
 
   XPCNativeSet* set = ccx.GetSet();
-  if (!set) {
+  if (!set) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -689,7 +689,7 @@ bool XPC_WN_MaybeResolvingPropertyStub(J
 
 bool XPC_WN_MaybeResolvingDeletePropertyStub(JSContext* cx, HandleObject obj,
                                              HandleId id,
-                                             ObjectOpResult& result) {
+                                             ObjectOpResult& result) {MOZ_RELEASE_ASSERT(0);
   XPCCallContext ccx(cx, obj);
   XPCWrappedNative* wrapper = ccx.GetWrapper();
   THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
@@ -739,7 +739,7 @@ bool XPC_WN_Helper_Call(JSContext* cx, u
 bool XPC_WN_Helper_Construct(JSContext* cx, unsigned argc, Value* vp) {
   JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
   RootedObject obj(cx, &args.callee());
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -797,7 +797,7 @@ bool XPC_WN_Helper_Resolve(JSContext* cx
   old = ccx.SetResolveName(old);
   MOZ_ASSERT(old == id, "bad nest");
 
-  if (NS_FAILED(rv)) {
+  if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
     return Throw(rv, cx);
   }
 
@@ -839,11 +839,11 @@ bool XPC_WN_NewEnumerate(JSContext* cx, 
   THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
 
   nsCOMPtr<nsIXPCScriptable> scr = wrapper->GetScriptable();
-  if (!scr || !scr->WantNewEnumerate()) {
+  if (!scr || !scr->WantNewEnumerate()) {MOZ_RELEASE_ASSERT(0);
     return Throw(NS_ERROR_XPC_BAD_OP_ON_WN_PROTO, cx);
   }
 
-  if (!XPC_WN_Shared_Enumerate(cx, obj)) {
+  if (!XPC_WN_Shared_Enumerate(cx, obj)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -905,7 +905,7 @@ bool XPC_WN_CallMethod(JSContext* cx, un
   RootedObject funobj(cx, &args.callee());
 
   RootedObject obj(cx);
-  if (!args.computeThis(cx, &obj)) {
+  if (!args.computeThis(cx, &obj)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -931,7 +931,7 @@ bool XPC_WN_GetterSetter(JSContext* cx, 
              "bad function");
   RootedObject funobj(cx, &args.callee());
 
-  if (!args.thisv().isObject()) {
+  if (!args.thisv().isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(
         cx, "xpconnect getter/setter called on incompatible non-object");
     return false;
@@ -947,7 +947,7 @@ bool XPC_WN_GetterSetter(JSContext* cx, 
   RefPtr<XPCNativeInterface> iface;
   XPCNativeMember* member;
 
-  if (!XPCNativeMember::GetCallInfo(funobj, &iface, &member)) {
+  if (!XPCNativeMember::GetCallInfo(funobj, &iface, &member)) {MOZ_RELEASE_ASSERT(0);
     return Throw(NS_ERROR_XPC_CANT_GET_METHOD_INFO, cx);
   }
 
@@ -970,17 +970,17 @@ bool XPC_WN_GetterSetter(JSContext* cx, 
 static bool XPC_WN_Proto_Enumerate(JSContext* cx, HandleObject obj) {
   MOZ_ASSERT(JS::GetClass(obj) == &XPC_WN_Proto_JSClass, "bad proto");
   XPCWrappedNativeProto* self = (XPCWrappedNativeProto*)xpc_GetJSPrivate(obj);
-  if (!self) {
+  if (!self) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   XPCNativeSet* set = self->GetSet();
-  if (!set) {
+  if (!set) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   XPCCallContext ccx(cx);
-  if (!ccx.IsValid()) {
+  if (!ccx.IsValid()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1029,12 +1029,12 @@ static bool XPC_WN_OnlyIWrite_Proto_AddP
   MOZ_ASSERT(JS::GetClass(obj) == &XPC_WN_Proto_JSClass, "bad proto");
 
   XPCWrappedNativeProto* self = (XPCWrappedNativeProto*)xpc_GetJSPrivate(obj);
-  if (!self) {
+  if (!self) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   XPCCallContext ccx(cx);
-  if (!ccx.IsValid()) {
+  if (!ccx.IsValid()) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1051,7 +1051,7 @@ static bool XPC_WN_Proto_Resolve(JSConte
   MOZ_ASSERT(JS::GetClass(obj) == &XPC_WN_Proto_JSClass, "bad proto");
 
   XPCWrappedNativeProto* self = (XPCWrappedNativeProto*)xpc_GetJSPrivate(obj);
-  if (!self) {
+  if (!self) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1093,7 +1093,7 @@ const JSClass XPC_WN_Proto_JSClass = {
 
 /***************************************************************************/
 
-static bool XPC_WN_TearOff_Enumerate(JSContext* cx, HandleObject obj) {
+static bool XPC_WN_TearOff_Enumerate(JSContext* cx, HandleObject obj) {MOZ_RELEASE_ASSERT(0);
   XPCCallContext ccx(cx, obj);
   XPCWrappedNative* wrapper = ccx.GetWrapper();
   THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
@@ -1101,12 +1101,12 @@ static bool XPC_WN_TearOff_Enumerate(JSC
   XPCWrappedNativeTearOff* to = ccx.GetTearOff();
   XPCNativeInterface* iface;
 
-  if (!to || nullptr == (iface = to->GetInterface())) {
+  if (!to || nullptr == (iface = to->GetInterface())) {MOZ_RELEASE_ASSERT(0);
     return Throw(NS_ERROR_XPC_BAD_OP_ON_WN_PROTO, cx);
-  }
+  }MOZ_RELEASE_ASSERT(0);
 
   uint16_t member_count = iface->GetMemberCount();
-  for (uint16_t k = 0; k < member_count; k++) {
+  for (uint16_t k = 0; k < member_count; k++) {MOZ_RELEASE_ASSERT(0);
     if (!xpc_ForcePropertyResolve(cx, obj, iface->GetMemberAt(k)->GetName())) {
       return false;
     }
diff --git a/js/xpconnect/src/XPCWrappedNativeProto.cpp b/js/xpconnect/src/XPCWrappedNativeProto.cpp
--- a/js/xpconnect/src/XPCWrappedNativeProto.cpp
+++ b/js/xpconnect/src/XPCWrappedNativeProto.cpp
@@ -113,7 +113,7 @@ XPCWrappedNativeProto* XPCWrappedNativeP
   }
 
   RefPtr<XPCNativeSet> set = XPCNativeSet::GetNewOrUsed(cx, classInfo);
-  if (!set) {
+  if (!set) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -129,7 +129,7 @@ XPCWrappedNativeProto* XPCWrappedNativeP
   return proto;
 }
 
-void XPCWrappedNativeProto::DebugDump(int16_t depth) {
+void XPCWrappedNativeProto::DebugDump(int16_t depth) {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
   depth--;
   XPC_LOG_ALWAYS(("XPCWrappedNativeProto @ %p", this));
diff --git a/js/xpconnect/src/XPCWrappedNativeScope.cpp b/js/xpconnect/src/XPCWrappedNativeScope.cpp
--- a/js/xpconnect/src/XPCWrappedNativeScope.cpp
+++ b/js/xpconnect/src/XPCWrappedNativeScope.cpp
@@ -105,7 +105,7 @@ bool XPCWrappedNativeScope::GetComponent
   xpcObjectHelper helper(mComponents);
   bool ok = XPCConvert::NativeInterface2JSObject(cx, &val, helper, nullptr,
                                                  false, nullptr);
-  if (NS_WARN_IF(!ok)) {
+  if (NS_WARN_IF(!ok)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -120,7 +120,7 @@ bool XPCWrappedNativeScope::GetComponent
 static bool DefineSubcomponentProperty(JSContext* aCx, HandleObject aGlobal,
                                        nsISupports* aSubcomponent,
                                        const nsID* aIID,
-                                       unsigned int aStringIndex) {
+                                       unsigned int aStringIndex) {MOZ_RELEASE_ASSERT(0);
   RootedValue subcompVal(aCx);
   xpcObjectHelper helper(aSubcomponent);
   if (!XPCConvert::NativeInterface2JSObject(aCx, &subcompVal, helper, aIID,
@@ -135,7 +135,7 @@ static bool DefineSubcomponentProperty(J
 
 bool XPCWrappedNativeScope::AttachComponentsObject(JSContext* aCx) {
   RootedObject components(aCx);
-  if (!GetComponentsJSObject(aCx, &components)) {
+  if (!GetComponentsJSObject(aCx, &components)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -272,7 +272,7 @@ void XPCWrappedNativeScope::UpdateWeakPo
     mWaiverWrapperMap->Sweep();
   }
 
-  if (!js::IsCompartmentZoneSweepingOrCompacting(mCompartment)) {
+  if (!js::IsCompartmentZoneSweepingOrCompacting(mCompartment)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
@@ -349,7 +349,7 @@ void XPCWrappedNativeScope::SystemIsBein
     cur->mCIDProto = nullptr;
 
     // Similarly, destroy mXrayExpandos to prevent assertion failures.
-    if (cur->mXrayExpandos.initialized()) {
+    if (cur->mXrayExpandos.initialized()) {MOZ_RELEASE_ASSERT(0);
       cur->mXrayExpandos.destroy();
     }
 
@@ -404,7 +404,7 @@ bool XPCWrappedNativeScope::SetExpandoCh
 /***************************************************************************/
 
 // static
-void XPCWrappedNativeScope::DebugDumpAllScopes(int16_t depth) {
+void XPCWrappedNativeScope::DebugDumpAllScopes(int16_t depth) {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
   depth--;
 
@@ -426,7 +426,7 @@ void XPCWrappedNativeScope::DebugDumpAll
 #endif
 }
 
-void XPCWrappedNativeScope::DebugDump(int16_t depth) {
+void XPCWrappedNativeScope::DebugDump(int16_t depth) {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
   depth--;
   XPC_LOG_ALWAYS(("XPCWrappedNativeScope @ %p", this));
diff --git a/js/xpconnect/src/XPCWrapper.cpp b/js/xpconnect/src/XPCWrapper.cpp
--- a/js/xpconnect/src/XPCWrapper.cpp
+++ b/js/xpconnect/src/XPCWrapper.cpp
@@ -42,7 +42,7 @@ static bool UnwrapNW(JSContext* cx, unsi
 
 static bool XrayWrapperConstructor(JSContext* cx, unsigned argc, Value* vp) {
   JS::CallArgs args = CallArgsFromVp(argc, vp);
-  if (args.length() == 0) {
+  if (args.length() == 0) {MOZ_RELEASE_ASSERT(0);
     return ThrowException(NS_ERROR_XPC_NOT_ENOUGH_ARGS, cx);
   }
 
diff --git a/js/xpconnect/src/nsXPConnect.cpp b/js/xpconnect/src/nsXPConnect.cpp
--- a/js/xpconnect/src/nsXPConnect.cpp
+++ b/js/xpconnect/src/nsXPConnect.cpp
@@ -204,7 +204,7 @@ void xpc::ErrorReport::Init(JSErrorRepor
   if (mErrorMsg.IsEmpty()) {
     ErrorReportToMessageString(aReport, mErrorMsg);
   }
-  if (mErrorMsg.IsEmpty()) {
+  if (mErrorMsg.IsEmpty()) {MOZ_RELEASE_ASSERT(0);
     mErrorMsg.AssignLiteral("<unknown>");
   }
 
@@ -220,7 +220,7 @@ void xpc::ErrorReport::Init(JSErrorRepor
   mIsMuted = aReport->isMuted;
 
   if (aReport->notes) {
-    if (!mNotes.SetLength(aReport->notes->length(), fallible)) {
+    if (!mNotes.SetLength(aReport->notes->length(), fallible)) {MOZ_RELEASE_ASSERT(0);
       return;
     }
 
@@ -433,7 +433,7 @@ JSObject* CreateGlobalObject(JSContext* 
 
     global = JS_NewGlobalObject(cx, clasp, nsJSPrincipals::get(principal),
                                 JS::DontFireOnNewGlobalHook, aOptions);
-    if (!global) {
+    if (!global) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     JSAutoRealm ar(cx, global);
@@ -502,7 +502,7 @@ bool InitGlobalObject(JSContext* aJSCont
   if (!(aFlags & xpc::OMIT_COMPONENTS_OBJECT)) {
     // XPCCallContext gives us an active request needed to save/restore.
     if (!ObjectScope(aGlobal)->AttachComponentsObject(aJSContext) ||
-        !XPCNativeWrapper::AttachNewConstructorObject(aJSContext, aGlobal)) {
+        !XPCNativeWrapper::AttachNewConstructorObject(aJSContext, aGlobal)) {MOZ_RELEASE_ASSERT(0);
       return UnexpectedFailure(false);
     }
   }
@@ -543,7 +543,7 @@ nsresult InitClassesWithNewWrappedGlobal
   RootedObject global(aJSContext, wrappedGlobal->GetFlatJSObject());
   MOZ_ASSERT(JS_IsGlobalObject(global));
 
-  if (!InitGlobalObject(aJSContext, global, aFlags)) {
+  if (!InitGlobalObject(aJSContext, global, aFlags)) {MOZ_RELEASE_ASSERT(0);
     return UnexpectedFailure(NS_ERROR_FAILURE);
   }
 
@@ -593,7 +593,7 @@ nsXPConnect::WrapNative(JSContext* aJSCo
   RootedValue v(aJSContext);
   nsresult rv = NativeInterface2JSObject(aJSContext, aScope, aCOMObj, nullptr,
                                          &aIID, true, &v);
-  if (NS_FAILED(rv)) {
+  if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
     return rv;
   }
 
@@ -749,7 +749,7 @@ NS_IMETHODIMP
 nsXPConnect::EvalInSandboxObject(const nsAString& source, const char* filename,
                                  JSContext* cx, JSObject* sandboxArg,
                                  MutableHandleValue rval) {
-  if (!sandboxArg) {
+  if (!sandboxArg) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_INVALID_ARG;
   }
 
@@ -780,7 +780,7 @@ nsXPConnect::DebugDump(int16_t depth) {
 }
 
 NS_IMETHODIMP
-nsXPConnect::DebugDumpObject(nsISupports* p, int16_t depth) {
+nsXPConnect::DebugDumpObject(nsISupports* p, int16_t depth) {MOZ_RELEASE_ASSERT(0);
 #ifdef DEBUG
   if (!depth) {
     return NS_OK;
@@ -864,12 +864,12 @@ bool Base64Encode(JSContext* cx, HandleV
 
   nsAutoCString encodedString;
   BindingCallContext callCx(cx, "Base64Encode");
-  if (!ConvertJSValueToByteString(callCx, val, false, "value", encodedString)) {
+  if (!ConvertJSValueToByteString(callCx, val, false, "value", encodedString)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   nsAutoCString result;
-  if (NS_FAILED(mozilla::Base64Encode(encodedString, result))) {
+  if (NS_FAILED(mozilla::Base64Encode(encodedString, result))) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "Failed to encode base64 data!");
     return false;
   }
@@ -888,7 +888,7 @@ bool Base64Decode(JSContext* cx, HandleV
 
   nsAutoCString encodedString;
   BindingCallContext callCx(cx, "Base64Decode");
-  if (!ConvertJSValueToByteString(callCx, val, false, "value", encodedString)) {
+  if (!ConvertJSValueToByteString(callCx, val, false, "value", encodedString)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -926,7 +926,7 @@ nsXPConnect::WriteScript(nsIObjectOutput
 
   uint8_t flags = 0;  // We don't have flags anymore.
   nsresult rv = stream->Write8(flags);
-  if (NS_FAILED(rv)) {
+  if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
     return rv;
   }
 
@@ -935,17 +935,17 @@ nsXPConnect::WriteScript(nsIObjectOutput
   code = EncodeScript(cx, buffer, script);
 
   if (code != TranscodeResult::Ok) {
-    if (code == TranscodeResult::Throw) {
+    if (code == TranscodeResult::Throw) {MOZ_RELEASE_ASSERT(0);
       JS_ClearPendingException(cx);
       return NS_ERROR_OUT_OF_MEMORY;
-    }
+    }MOZ_RELEASE_ASSERT(0);
 
     MOZ_ASSERT(IsTranscodeFailureResult(code));
     return NS_ERROR_FAILURE;
   }
 
   size_t size = buffer.length();
-  if (size > UINT32_MAX) {
+  if (size > UINT32_MAX) {MOZ_RELEASE_ASSERT(0);
     return NS_ERROR_FAILURE;
   }
   rv = stream->Write32(size);
@@ -963,7 +963,7 @@ nsXPConnect::ReadScript(nsIObjectInputSt
                         JSScript** scriptp) {
   uint8_t flags;
   nsresult rv = stream->Read8(&flags);
-  if (NS_FAILED(rv)) {
+  if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
     return rv;
   }
 
@@ -979,13 +979,13 @@ nsXPConnect::ReadScript(nsIObjectInputSt
 
   uint32_t size;
   rv = stream->Read32(&size);
-  if (NS_FAILED(rv)) {
+  if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
     return rv;
   }
 
   char* data;
   rv = stream->ReadBytes(size, &data);
-  if (NS_FAILED(rv)) {
+  if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
     return rv;
   }
 
@@ -1040,7 +1040,7 @@ extern "C" {
 
 MOZ_EXPORT void DumpJSStack() { xpc_DumpJSStack(true, true, false); }
 
-MOZ_EXPORT void DumpCompleteHeap() {
+MOZ_EXPORT void DumpCompleteHeap() {MOZ_RELEASE_ASSERT(0);
   nsCOMPtr<nsICycleCollectorListener> listener =
       nsCycleCollector_createLogger();
   MOZ_ASSERT(listener);
diff --git a/js/xpconnect/tests/components/native/xpctest_params.cpp b/js/xpconnect/tests/components/native/xpctest_params.cpp
--- a/js/xpconnect/tests/components/native/xpctest_params.cpp
+++ b/js/xpconnect/tests/components/native/xpctest_params.cpp
@@ -351,7 +351,7 @@ nsXPCTestParams::TestJsvalSequence(const
 NS_IMETHODIMP
 nsXPCTestParams::TestSequenceSequence(const nsTArray<nsTArray<short>>& a,
                                       nsTArray<nsTArray<short>>& b,
-                                      nsTArray<nsTArray<short>>& _retval) {
+                                      nsTArray<nsTArray<short>>& _retval) {MOZ_RELEASE_ASSERT(0);
   _retval = std::move(b);
   for (const auto& element : a) {
     b.AppendElement(element.Clone());
diff --git a/js/xpconnect/wrappers/AccessCheck.cpp b/js/xpconnect/wrappers/AccessCheck.cpp
--- a/js/xpconnect/wrappers/AccessCheck.cpp
+++ b/js/xpconnect/wrappers/AccessCheck.cpp
@@ -130,12 +130,12 @@ void AccessCheck::reportCrossOriginDenia
   // Errors, when denying access on cross-origin DOM objects.  It's
   // conceptually pretty similar to
   // AutoEnterPolicy::reportErrorIfExceptionIsNotPending.
-  if (JS_IsExceptionPending(cx)) {
+  if (JS_IsExceptionPending(cx)) {MOZ_RELEASE_ASSERT(0);
     return;
   }
 
   nsAutoCString message;
-  if (JSID_IS_VOID(id)) {
+  if (JSID_IS_VOID(id)) {MOZ_RELEASE_ASSERT(0);
     message = "Permission denied to access object"_ns;
   } else {
     // We want to use JS_ValueToSource here, because that most closely
diff --git a/js/xpconnect/wrappers/FilteringWrapper.cpp b/js/xpconnect/wrappers/FilteringWrapper.cpp
--- a/js/xpconnect/wrappers/FilteringWrapper.cpp
+++ b/js/xpconnect/wrappers/FilteringWrapper.cpp
@@ -48,11 +48,11 @@ bool AppendCrossOriginWhitelistedPropNam
                                            JS::MutableHandleIdVector props) {
   // Add "then" if it's not already in the list.
   RootedIdVector thenProp(cx);
-  if (!thenProp.append(GetJSIDByIndex(cx, XPCJSContext::IDX_THEN))) {
+  if (!thenProp.append(GetJSIDByIndex(cx, XPCJSContext::IDX_THEN))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
-  if (!AppendUnique(cx, props, thenProp)) {
+  if (!AppendUnique(cx, props, thenProp)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -64,7 +64,7 @@ bool AppendCrossOriginWhitelistedPropNam
   }
 #endif
   if (!props.reserve(props.length() +
-                     ArrayLength(sCrossOriginWhitelistedSymbolCodes))) {
+                     ArrayLength(sCrossOriginWhitelistedSymbolCodes))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
diff --git a/js/xpconnect/wrappers/WaiveXrayWrapper.cpp b/js/xpconnect/wrappers/WaiveXrayWrapper.cpp
--- a/js/xpconnect/wrappers/WaiveXrayWrapper.cpp
+++ b/js/xpconnect/wrappers/WaiveXrayWrapper.cpp
@@ -16,7 +16,7 @@ static bool WaiveAccessors(JSContext* cx
                            MutableHandle<PropertyDescriptor> desc) {
   if (desc.hasGetterObject() && desc.getterObject()) {
     RootedValue v(cx, JS::ObjectValue(*desc.getterObject()));
-    if (!WrapperFactory::WaiveXrayAndWrap(cx, &v)) {
+    if (!WrapperFactory::WaiveXrayAndWrap(cx, &v)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     desc.setGetterObject(&v.toObject());
diff --git a/js/xpconnect/wrappers/WrapperFactory.cpp b/js/xpconnect/wrappers/WrapperFactory.cpp
--- a/js/xpconnect/wrappers/WrapperFactory.cpp
+++ b/js/xpconnect/wrappers/WrapperFactory.cpp
@@ -79,7 +79,7 @@ JSObject* WrapperFactory::CreateXrayWaiv
 
   JSAutoRealm ar(cx, obj);
   JSObject* waiver = Wrapper::New(cx, obj, &XrayWaiver);
-  if (!waiver) {
+  if (!waiver) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -256,7 +256,7 @@ void WrapperFactory::PrepareForWrapping(
     // wrapper?"
     nsresult rv = wn->GetScriptable()->PreCreate(wn->Native(), cx, scope,
                                                  wrapScope.address());
-    if (NS_FAILED(rv)) {
+    if (NS_FAILED(rv)) {MOZ_RELEASE_ASSERT(0);
       retObj.set(waive ? WaiveXray(cx, obj) : obj);
       return;
     }
@@ -616,7 +616,7 @@ bool WrapperFactory::WaiveXrayAndWrap(JS
   JS::Compartment* target = js::GetContextCompartment(cx);
   JS::Compartment* origin = JS::GetCompartment(obj);
   obj = AllowWaiver(target, origin) ? WaiveXray(cx, obj) : obj;
-  if (!obj) {
+  if (!obj) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -638,7 +638,7 @@ static bool FixWaiverAfterTransplant(JSC
   MOZ_ASSERT(Wrapper::wrapperHandler(oldWaiver) == &XrayWaiver);
   MOZ_ASSERT(!js::IsCrossCompartmentWrapper(newobj));
 
-  if (crossCompartmentTransplant) {
+  if (crossCompartmentTransplant) {MOZ_RELEASE_ASSERT(0);
     // If the new compartment has a CCW for oldWaiver, nuke this CCW. This
     // prevents confusing RemapAllWrappersForObject: it would call RemapWrapper
     // with two same-compartment objects (the CCW and the new waiver).
@@ -669,7 +669,7 @@ static bool FixWaiverAfterTransplant(JSC
   RootedObject newWaiver(
       cx, WrapperFactory::CreateXrayWaiver(
               cx, newobj, /* allowExisting = */ !crossCompartmentTransplant));
-  if (!newWaiver) {
+  if (!newWaiver) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -680,7 +680,7 @@ static bool FixWaiverAfterTransplant(JSC
 
   // Update all the cross-compartment references to oldWaiver to point to
   // newWaiver.
-  if (!js::RemapAllWrappersForObject(cx, oldWaiver, newWaiver)) {
+  if (!js::RemapAllWrappersForObject(cx, oldWaiver, newWaiver)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -711,7 +711,7 @@ JSObject* TransplantObject(JSContext* cx
   if (!crossCompartmentTransplant) {
     // We might still have been transplanted across realms within a single
     // compartment.
-    if (GetNonCCWObjectRealm(oldWaiver) == GetNonCCWObjectRealm(newIdentity)) {
+    if (GetNonCCWObjectRealm(oldWaiver) == GetNonCCWObjectRealm(newIdentity)) {MOZ_RELEASE_ASSERT(0);
       // The old waiver is same-realm with the new object; nothing else to do
       // here.
       return newIdentity;
diff --git a/js/xpconnect/wrappers/XrayWrapper.cpp b/js/xpconnect/wrappers/XrayWrapper.cpp
--- a/js/xpconnect/wrappers/XrayWrapper.cpp
+++ b/js/xpconnect/wrappers/XrayWrapper.cpp
@@ -206,14 +206,14 @@ bool ReportWrapperDenial(JSContext* cx, 
 
   nsAutoJSString propertyName;
   RootedValue idval(cx);
-  if (!JS_IdToValue(cx, id, &idval)) {
+  if (!JS_IdToValue(cx, id, &idval)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   JSString* str = JS_ValueToSource(cx, idval);
-  if (!str) {
+  if (!str) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
-  if (!propertyName.init(cx, str)) {
+  if (!propertyName.init(cx, str)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   AutoFilename filename;
@@ -230,7 +230,7 @@ bool ReportWrapperDenial(JSContext* cx, 
   // If this isn't the first warning on this topic for this global, we've
   // already bailed out in opt builds. Now that the NS_WARNING is done, bail
   // out in debug builds as well.
-  if (alreadyWarnedOnce) {
+  if (alreadyWarnedOnce) {MOZ_RELEASE_ASSERT(0);
     return true;
   }
 
@@ -313,7 +313,7 @@ bool JSXrayTraits::getOwnPropertyFromTar
   MOZ_ASSERT(outDesc.object() == nullptr);
 
   Rooted<PropertyDescriptor> desc(cx);
-  if (!JS_GetOwnPropertyDescriptorById(cx, target, id, &desc)) {
+  if (!JS_GetOwnPropertyDescriptorById(cx, target, id, &desc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -368,7 +368,7 @@ bool JSXrayTraits::getOwnPropertyFromTar
   RootedObject proto(cx);
   bool foundOnProto = false;
   if (!JS_GetPrototype(cx, wrapper, &proto) ||
-      (proto && !JS_HasPropertyById(cx, proto, id, &foundOnProto))) {
+      (proto && !JS_HasPropertyById(cx, proto, id, &foundOnProto))) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (foundOnProto) {
@@ -405,7 +405,7 @@ static bool TryResolvePropertyFromSpecs(
   if (fsMatch) {
     // Generate an Xrayed version of the method.
     RootedFunction fun(cx, JS::NewFunctionFromSpec(cx, fsMatch, id));
-    if (!fun) {
+    if (!fun) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -442,7 +442,7 @@ static bool TryResolvePropertyFromSpecs(
       if (psMatch->isSelfHosted()) {
         JSFunction* getterFun = JS::GetSelfHostedFunction(
             cx, psMatch->u.accessors.getter.selfHosted.funname, id, 0);
-        if (!getterFun) {
+        if (!getterFun) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         RootedObject getterObj(cx, JS_GetFunctionObject(getterFun));
@@ -451,25 +451,25 @@ static bool TryResolvePropertyFromSpecs(
           MOZ_ASSERT(attrs & JSPROP_SETTER);
           JSFunction* setterFun = JS::GetSelfHostedFunction(
               cx, psMatch->u.accessors.setter.selfHosted.funname, id, 0);
-          if (!setterFun) {
+          if (!setterFun) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
           setterObj = JS_GetFunctionObject(setterFun);
         }
         if (!JS_DefinePropertyById(cx, holder, id, getterObj, setterObj,
-                                   attrs)) {
+                                   attrs)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       } else {
         if (!JS_DefinePropertyById(
                 cx, holder, id, psMatch->u.accessors.getter.native.op,
-                psMatch->u.accessors.setter.native.op, attrs)) {
+                psMatch->u.accessors.setter.native.op, attrs)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
       }
     } else {
       RootedValue v(cx);
-      if (!psMatch->getValue(cx, &v)) {
+      if (!psMatch->getValue(cx, &v)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       if (!JS_DefinePropertyById(cx, holder, id, v, attrs)) {
@@ -518,7 +518,7 @@ bool JSXrayTraits::resolveOwnProperty(JS
   // muddles through by only checking the holder for non-|own| lookups, but
   // that doesn't work for us. So we do an explicit holder check here, and hope
   // that this mess gets fixed up soon.
-  if (!JS_GetOwnPropertyDescriptorById(cx, holder, id, desc)) {
+  if (!JS_GetOwnPropertyDescriptorById(cx, holder, id, desc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (desc.object()) {
@@ -550,7 +550,7 @@ bool JSXrayTraits::resolveOwnProperty(JS
           {
             JSAutoRealm ar(cx, target);
             JS_MarkCrossZoneId(cx, id);
-            if (!JS_GetOwnPropertyDescriptorById(cx, target, id, &innerDesc)) {
+            if (!JS_GetOwnPropertyDescriptorById(cx, target, id, &innerDesc)) {MOZ_RELEASE_ASSERT(0);
               return false;
             }
           }
@@ -574,7 +574,7 @@ bool JSXrayTraits::resolveOwnProperty(JS
         RootedFunction fun(cx, JS_GetObjectFunction(target));
         {
           JSAutoRealm ar(cx, target);
-          if (!JS_GetFunctionLength(cx, fun, &length)) {
+          if (!JS_GetFunctionLength(cx, fun, &length)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -604,13 +604,13 @@ bool JSXrayTraits::resolveOwnProperty(JS
             {
               JSAutoRealm ar(cx, target);
               if (!JS_GetClassPrototype(cx, standardConstructor,
-                                        &standardProto)) {
+                                        &standardProto)) {MOZ_RELEASE_ASSERT(0);
                 return false;
               }
               MOZ_ASSERT(standardProto);
             }
 
-            if (!JS_WrapObject(cx, &standardProto)) {
+            if (!JS_WrapObject(cx, &standardProto)) {MOZ_RELEASE_ASSERT(0);
               return false;
             }
             FillPropertyDescriptor(desc, wrapper,
@@ -625,7 +625,7 @@ bool JSXrayTraits::resolveOwnProperty(JS
 
             if (!TryResolvePropertyFromSpecs(
                     cx, id, holder, clasp->specConstructorFunctions(),
-                    clasp->specConstructorProperties(), desc)) {
+                    clasp->specConstructorProperties(), desc)) {MOZ_RELEASE_ASSERT(0);
               return false;
             }
 
@@ -653,7 +653,7 @@ bool JSXrayTraits::resolveOwnProperty(JS
           id == GetJSIDByIndex(cx, XPCJSContext::IDX_MESSAGE);
       if (isErrorIntProperty || isErrorStringProperty) {
         RootedObject waiver(cx, wrapper);
-        if (!WrapperFactory::WaiveXrayAndWrap(cx, &waiver)) {
+        if (!WrapperFactory::WaiveXrayAndWrap(cx, &waiver)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         if (!JS_GetOwnPropertyDescriptorById(cx, waiver, id, desc)) {
@@ -687,11 +687,11 @@ bool JSXrayTraits::resolveOwnProperty(JS
     RootedObject constructor(cx);
     {
       JSAutoRealm ar(cx, target);
-      if (!JS_GetClassObject(cx, key, &constructor)) {
+      if (!JS_GetClassObject(cx, key, &constructor)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
-    if (!JS_WrapObject(cx, &constructor)) {
+    if (!JS_WrapObject(cx, &constructor)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     desc.object().set(wrapper);
@@ -715,7 +715,7 @@ bool JSXrayTraits::resolveOwnProperty(JS
   // class spec here.
   if (!TryResolvePropertyFromSpecs(cx, id, holder,
                                    clasp->specPrototypeFunctions(),
-                                   clasp->specPrototypeProperties(), desc)) {
+                                   clasp->specPrototypeProperties(), desc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -731,7 +731,7 @@ bool JSXrayTraits::delete_(JSContext* cx
   MOZ_ASSERT(js::IsObjectInContextCompartment(wrapper, cx));
 
   RootedObject holder(cx, ensureHolder(cx, wrapper));
-  if (!holder) {
+  if (!holder) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -748,7 +748,7 @@ bool JSXrayTraits::delete_(JSContext* cx
     JS_MarkCrossZoneId(cx, id);
     Rooted<PropertyDescriptor> desc(cx);
     if (!getOwnPropertyFromTargetIfSafe(cx, target, wrapper, wrapperGlobal, id,
-                                        &desc)) {
+                                        &desc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (desc.object()) {
@@ -764,7 +764,7 @@ bool JSXrayTraits::defineProperty(JSCont
                                   ObjectOpResult& result, bool* defined) {
   *defined = false;
   RootedObject holder(cx, ensureHolder(cx, wrapper));
-  if (!holder) {
+  if (!holder) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -798,7 +798,7 @@ bool JSXrayTraits::defineProperty(JSCont
                           "property on [Object] or [Array] XrayWrapper");
       return false;
     }
-    if (existingDesc.hasGetterOrSetter()) {
+    if (existingDesc.hasGetterOrSetter()) {MOZ_RELEASE_ASSERT(0);
       JS_ReportErrorASCII(cx,
                           "Not allowed to overwrite accessor property on "
                           "[Object] or [Array] XrayWrapper");
@@ -815,7 +815,7 @@ bool JSXrayTraits::defineProperty(JSCont
     JSAutoRealm ar(cx, target);
     JS_MarkCrossZoneId(cx, id);
     if (!JS_WrapPropertyDescriptor(cx, &wrappedDesc) ||
-        !JS_DefinePropertyById(cx, target, id, wrappedDesc, result)) {
+        !JS_DefinePropertyById(cx, target, id, wrappedDesc, result)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     *defined = true;
@@ -859,18 +859,18 @@ static bool AppendNamesFromFunctionAndPr
   // Convert the method and property names to jsids and pass them to the caller.
   for (; fs && fs->name; ++fs) {
     jsid id;
-    if (!PropertySpecNameToPermanentId(cx, fs->name, &id)) {
+    if (!PropertySpecNameToPermanentId(cx, fs->name, &id)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!js::ShouldIgnorePropertyDefinition(cx, key, id)) {
-      if (!MaybeAppend(id, flags, props)) {
+      if (!MaybeAppend(id, flags, props)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
   }
   for (; ps && ps->name; ++ps) {
     jsid id;
-    if (!PropertySpecNameToPermanentId(cx, ps->name, &id)) {
+    if (!PropertySpecNameToPermanentId(cx, ps->name, &id)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!js::ShouldIgnorePropertyDefinition(cx, key, id)) {
@@ -889,7 +889,7 @@ bool JSXrayTraits::enumerateNames(JSCont
 
   RootedObject target(cx, getTargetObject(wrapper));
   RootedObject holder(cx, ensureHolder(cx, wrapper));
-  if (!holder) {
+  if (!holder) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -904,19 +904,19 @@ bool JSXrayTraits::enumerateNames(JSCont
         JSAutoRealm ar(cx, target);
         RootedIdVector targetProps(cx);
         if (!js::GetPropertyKeys(cx, target, flags | JSITER_OWNONLY,
-                                 &targetProps)) {
+                                 &targetProps)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         // Loop over the properties, and only pass along the ones that
         // we determine to be safe.
-        if (!props.reserve(targetProps.length())) {
+        if (!props.reserve(targetProps.length())) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         for (size_t i = 0; i < targetProps.length(); ++i) {
           Rooted<PropertyDescriptor> desc(cx);
           RootedId id(cx, targetProps[i]);
           if (!getOwnPropertyFromTargetIfSafe(cx, target, wrapper,
-                                              wrapperGlobal, id, &desc)) {
+                                              wrapperGlobal, id, &desc)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
           if (desc.object()) {
@@ -943,17 +943,17 @@ bool JSXrayTraits::enumerateNames(JSCont
         return false;
       }
 
-      if (!props.reserve(length)) {
+      if (!props.reserve(length)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       for (int32_t i = 0; i < int32_t(length); ++i) {
         props.infallibleAppend(INT_TO_JSID(i));
       }
     } else if (key == JSProto_Function) {
-      if (!props.append(GetJSIDByIndex(cx, XPCJSContext::IDX_LENGTH))) {
+      if (!props.append(GetJSIDByIndex(cx, XPCJSContext::IDX_LENGTH))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
-      if (!props.append(GetJSIDByIndex(cx, XPCJSContext::IDX_NAME))) {
+      if (!props.append(GetJSIDByIndex(cx, XPCJSContext::IDX_NAME))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       // Handle the .prototype property and static properties on standard
@@ -961,7 +961,7 @@ bool JSXrayTraits::enumerateNames(JSCont
       JSProtoKey standardConstructor = constructorFor(holder);
       if (standardConstructor != JSProto_Null) {
         if (ShouldResolvePrototypeProperty(standardConstructor)) {
-          if (!props.append(GetJSIDByIndex(cx, XPCJSContext::IDX_PROTOTYPE))) {
+          if (!props.append(GetJSIDByIndex(cx, XPCJSContext::IDX_PROTOTYPE))) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -972,7 +972,7 @@ bool JSXrayTraits::enumerateNames(JSCont
 
           if (!AppendNamesFromFunctionAndPropertySpecs(
                   cx, key, clasp->specConstructorFunctions(),
-                  clasp->specConstructorProperties(), flags, props)) {
+                  clasp->specConstructorProperties(), flags, props)) {MOZ_RELEASE_ASSERT(0);
             return false;
           }
         }
@@ -982,11 +982,11 @@ bool JSXrayTraits::enumerateNames(JSCont
           !props.append(GetJSIDByIndex(cx, XPCJSContext::IDX_LINENUMBER)) ||
           !props.append(GetJSIDByIndex(cx, XPCJSContext::IDX_COLUMNNUMBER)) ||
           !props.append(GetJSIDByIndex(cx, XPCJSContext::IDX_STACK)) ||
-          !props.append(GetJSIDByIndex(cx, XPCJSContext::IDX_MESSAGE))) {
+          !props.append(GetJSIDByIndex(cx, XPCJSContext::IDX_MESSAGE))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else if (key == JSProto_RegExp) {
-      if (!props.append(GetJSIDByIndex(cx, XPCJSContext::IDX_LASTINDEX))) {
+      if (!props.append(GetJSIDByIndex(cx, XPCJSContext::IDX_LASTINDEX))) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     }
@@ -1014,7 +1014,7 @@ bool JSXrayTraits::construct(JSContext* 
                              const js::Wrapper& baseInstance) {
   JSXrayTraits& self = JSXrayTraits::singleton;
   JS::RootedObject holder(cx, self.ensureHolder(cx, wrapper));
-  if (!holder) {
+  if (!holder) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1038,7 +1038,7 @@ bool JSXrayTraits::construct(JSContext* 
     // See the comments in js/public/Class.h and PromiseConstructor for
     // details and an example.
     RootedObject ctor(cx);
-    if (!JS_GetClassObject(cx, standardConstructor, &ctor)) {
+    if (!JS_GetClassObject(cx, standardConstructor, &ctor)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -1062,7 +1062,7 @@ JSObject* JSXrayTraits::createHolder(JSC
   RootedObject target(cx, getTargetObject(wrapper));
   RootedObject holder(cx,
                       JS_NewObjectWithGivenProto(cx, &HolderClass, nullptr));
-  if (!holder) {
+  if (!holder) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1331,7 +1331,7 @@ JSObject* XrayTraits::attachExpandoObjec
   MOZ_ASSERT(!strcmp(expandoClass->name, "XrayExpandoObject"));
   RootedObject expandoObject(
       cx, JS_NewObjectWithGivenProto(cx, expandoClass, nullptr));
-  if (!expandoObject) {
+  if (!expandoObject) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
 
@@ -1346,13 +1346,13 @@ JSObject* XrayTraits::attachExpandoObjec
     JSAutoRealm ar(cx, exclusiveWrapperGlobal);
     wrapperHolder =
         JS_NewObjectWithGivenProto(cx, &gWrapperHolderClass, nullptr);
-    if (!wrapperHolder) {
+    if (!wrapperHolder) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     JS_SetReservedSlot(wrapperHolder, JSSLOT_WRAPPER_HOLDER_CONTENTS,
                        ObjectValue(*exclusiveWrapper));
   }
-  if (!JS_WrapObject(cx, &wrapperHolder)) {
+  if (!JS_WrapObject(cx, &wrapperHolder)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   JS_SetReservedSlot(expandoObject, JSSLOT_EXPANDO_EXCLUSIVE_WRAPPER_HOLDER,
@@ -1362,11 +1362,11 @@ JSObject* XrayTraits::attachExpandoObjec
   if (exclusiveWrapper) {
     RootedObject cachedExpandoObject(cx, expandoObject);
     JSAutoRealm ar(cx, exclusiveWrapperGlobal);
-    if (!JS_WrapObject(cx, &cachedExpandoObject)) {
+    if (!JS_WrapObject(cx, &cachedExpandoObject)) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     JSObject* holder = ensureHolder(cx, exclusiveWrapper);
-    if (!holder) {
+    if (!holder) {MOZ_RELEASE_ASSERT(0);
       return nullptr;
     }
     SetCachedXrayExpando(holder, cachedExpandoObject);
@@ -1396,7 +1396,7 @@ JSObject* XrayTraits::ensureExpandoObjec
   // Expando objects live in the target compartment.
   JSAutoRealm ar(cx, target);
   RootedObject expandoObject(cx);
-  if (!getExpandoObject(cx, target, wrapper, &expandoObject)) {
+  if (!getExpandoObject(cx, target, wrapper, &expandoObject)) {MOZ_RELEASE_ASSERT(0);
     return nullptr;
   }
   if (!expandoObject) {
@@ -1441,12 +1441,12 @@ bool XrayTraits::cloneExpandoChain(JSCon
         // will be associated with a clone of |src|'s expando object.
         JSAutoRealm ar(cx, unwrappedHolder);
         exclusiveWrapper = dst;
-        if (!JS_WrapObject(cx, &exclusiveWrapper)) {
+        if (!JS_WrapObject(cx, &exclusiveWrapper)) {MOZ_RELEASE_ASSERT(0);
           return false;
         }
         exclusiveWrapperGlobal = JS::CurrentGlobalOrNull(cx);
       }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       JSAutoRealm ar(cx, oldHead);
       movingIntoXrayCompartment =
           expandoObjectMatchesConsumer(cx, oldHead, GetObjectPrincipal(dst));
@@ -1454,7 +1454,7 @@ bool XrayTraits::cloneExpandoChain(JSCon
 
     if (movingIntoXrayCompartment) {
       // Just copy properties directly onto dst.
-      if (!JS_CopyOwnPropertiesAndPrivateFields(cx, dst, oldHead)) {
+      if (!JS_CopyOwnPropertiesAndPrivateFields(cx, dst, oldHead)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
     } else {
@@ -1558,7 +1558,7 @@ static bool IsWindow(JSContext* cx, JSOb
 
 static bool wrappedJSObject_getter(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
-  if (!args.thisv().isObject()) {
+  if (!args.thisv().isObject()) {MOZ_RELEASE_ASSERT(0);
     JS_ReportErrorASCII(cx, "This value not an object");
     return false;
   }
@@ -1580,7 +1580,7 @@ bool XrayTraits::resolveOwnProperty(JSCo
                                     MutableHandle<PropertyDescriptor> desc) {
   desc.object().set(nullptr);
   RootedObject expando(cx);
-  if (!getExpandoObject(cx, target, wrapper, &expando)) {
+  if (!getExpandoObject(cx, target, wrapper, &expando)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1590,7 +1590,7 @@ bool XrayTraits::resolveOwnProperty(JSCo
   if (expando) {
     JSAutoRealm ar(cx, expando);
     JS_MarkCrossZoneId(cx, id);
-    if (!JS_GetOwnPropertyDescriptorById(cx, expando, id, desc)) {
+    if (!JS_GetOwnPropertyDescriptorById(cx, expando, id, desc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     found = !!desc.object();
@@ -1603,7 +1603,7 @@ bool XrayTraits::resolveOwnProperty(JSCo
     if (key != JSProto_Null) {
       MOZ_ASSERT(key < JSProto_LIMIT);
       RootedObject constructor(cx);
-      if (!JS_GetClassObject(cx, key, &constructor)) {
+      if (!JS_GetClassObject(cx, key, &constructor)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       MOZ_ASSERT(constructor);
@@ -1611,7 +1611,7 @@ bool XrayTraits::resolveOwnProperty(JSCo
       found = true;
     } else if (id == GetJSIDByIndex(cx, XPCJSContext::IDX_EVAL)) {
       RootedObject eval(cx);
-      if (!js::GetRealmOriginalEval(cx, &eval)) {
+      if (!js::GetRealmOriginalEval(cx, &eval)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       desc.value().set(ObjectValue(*eval));
@@ -1628,7 +1628,7 @@ bool XrayTraits::resolveOwnProperty(JSCo
   }
 
   if (found) {
-    if (!JS_WrapPropertyDescriptor(cx, desc)) {
+    if (!JS_WrapPropertyDescriptor(cx, desc)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     // Pretend the property lives on the wrapper.
@@ -1640,11 +1640,11 @@ bool XrayTraits::resolveOwnProperty(JSCo
   // sort out own-ness for the holder.
   if (id == GetJSIDByIndex(cx, XPCJSContext::IDX_WRAPPED_JSOBJECT) &&
       WrapperFactory::AllowWaiver(wrapper)) {
-    if (!JS_AlreadyHasOwnPropertyById(cx, holder, id, &found)) {
+    if (!JS_AlreadyHasOwnPropertyById(cx, holder, id, &found)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!found && !JS_DefinePropertyById(cx, holder, id, wrappedJSObject_getter,
-                                         nullptr, JSPROP_ENUMERATE)) {
+                                         nullptr, JSPROP_ENUMERATE)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (!JS_GetOwnPropertyDescriptorById(cx, holder, id, desc)) {
@@ -1676,7 +1676,7 @@ bool DOMXrayTraits::resolveOwnProperty(J
     if (win) {
       Nullable<WindowProxyHolder> subframe = win->IndexedGetter(index);
       if (!subframe.IsNull()) {
-        if (MOZ_UNLIKELY(!WrapObject(cx, subframe.Value(), desc.value()))) {
+        if (MOZ_UNLIKELY(!WrapObject(cx, subframe.Value(), desc.value()))) {MOZ_RELEASE_ASSERT(0);
           // It's gone?
           return xpc::Throw(cx, NS_ERROR_FAILURE);
         }
@@ -1686,7 +1686,7 @@ bool DOMXrayTraits::resolveOwnProperty(J
     }
   }
 
-  if (!JS_GetOwnPropertyDescriptorById(cx, holder, id, desc)) {
+  if (!JS_GetOwnPropertyDescriptorById(cx, holder, id, desc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   if (desc.object()) {
@@ -1695,7 +1695,7 @@ bool DOMXrayTraits::resolveOwnProperty(J
   }
 
   bool cacheOnHolder;
-  if (!XrayResolveOwnProperty(cx, wrapper, target, id, desc, cacheOnHolder)) {
+  if (!XrayResolveOwnProperty(cx, wrapper, target, id, desc, cacheOnHolder)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1740,12 +1740,12 @@ bool DOMXrayTraits::enumerateNames(JSCon
   nsGlobalWindowInner* win = AsWindow(cx, wrapper);
   if (win) {
     uint32_t length = win->Length();
-    if (!props.reserve(props.length() + length)) {
+    if (!props.reserve(props.length() + length)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     JS::RootedId indexId(cx);
     for (uint32_t i = 0; i < length; ++i) {
-      if (!JS_IndexToId(cx, i, &indexId)) {
+      if (!JS_IndexToId(cx, i, &indexId)) {MOZ_RELEASE_ASSERT(0);
         return false;
       }
       props.infallibleAppend(indexId);
@@ -1799,13 +1799,13 @@ bool DOMXrayTraits::construct(JSContext*
       if (!construct(cx, args.length(), args.base())) {
         return false;
       }
-    } else {
+    } else {MOZ_RELEASE_ASSERT(0);
       RootedValue v(cx, ObjectValue(*wrapper));
       js::ReportIsNotFunction(cx, v);
       return false;
     }
   } else {
-    if (!baseInstance.construct(cx, wrapper, args)) {
+    if (!baseInstance.construct(cx, wrapper, args)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
@@ -1871,7 +1871,7 @@ bool XrayWrapper<Base, Traits>::getOwnPr
                           BaseProxyHandler::GET_PROPERTY_DESCRIPTOR);
   RootedObject target(cx, Traits::getTargetObject(wrapper));
   RootedObject holder(cx, Traits::singleton.ensureHolder(cx, wrapper));
-  if (!holder) {
+  if (!holder) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1952,7 +1952,7 @@ bool XrayWrapper<Base, Traits>::definePr
   assertEnteredPolicy(cx, wrapper, id, BaseProxyHandler::SET);
 
   Rooted<PropertyDescriptor> existing_desc(cx);
-  if (!JS_GetPropertyDescriptorById(cx, wrapper, id, &existing_desc)) {
+  if (!JS_GetPropertyDescriptorById(cx, wrapper, id, &existing_desc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -1968,12 +1968,12 @@ bool XrayWrapper<Base, Traits>::definePr
     if (existing_desc.isAccessorDescriptor() || desc.isAccessorDescriptor() ||
         (desc.hasEnumerable() &&
          existing_desc.enumerable() != desc.enumerable()) ||
-        (desc.hasWritable() && !existing_desc.writable() && desc.writable())) {
+        (desc.hasWritable() && !existing_desc.writable() && desc.writable())) {MOZ_RELEASE_ASSERT(0);
       // We should technically report non-configurability in strict mode, but
       // doing that via JSAPI used to be a lot of trouble. See bug 1135997.
       return result.succeed();
     }
-    if (!existing_desc.writable()) {
+    if (!existing_desc.writable()) {MOZ_RELEASE_ASSERT(0);
       // Same as the above for non-writability.
       return result.succeed();
     }
@@ -1992,7 +1992,7 @@ bool XrayWrapper<Base, Traits>::definePr
   RootedObject target(cx, Traits::getTargetObject(wrapper));
   RootedObject expandoObject(
       cx, Traits::singleton.ensureExpandoObject(cx, wrapper, target));
-  if (!expandoObject) {
+  if (!expandoObject) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2032,7 +2032,7 @@ bool XrayWrapper<Base, Traits>::delete_(
   // Check the expando object.
   RootedObject target(cx, Traits::getTargetObject(wrapper));
   RootedObject expando(cx);
-  if (!Traits::singleton.getExpandoObject(cx, target, wrapper, &expando)) {
+  if (!Traits::singleton.getExpandoObject(cx, target, wrapper, &expando)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2040,7 +2040,7 @@ bool XrayWrapper<Base, Traits>::delete_(
     JSAutoRealm ar(cx, expando);
     JS_MarkCrossZoneId(cx, id);
     bool hasProp;
-    if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
+    if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
     if (hasProp) {
@@ -2060,7 +2060,7 @@ bool XrayWrapper<Base, Traits>::get(JSCo
   // properties.  Since we only need to worry about own properties, we can use
   // getOwnPropertyDescriptor here.
   Rooted<PropertyDescriptor> desc(cx);
-  if (!getOwnPropertyDescriptor(cx, wrapper, id, &desc)) {
+  if (!getOwnPropertyDescriptor(cx, wrapper, id, &desc)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
   desc.assertCompleteIfFound();
@@ -2173,13 +2173,13 @@ bool XrayWrapper<Base, Traits>::getProto
   // |Base|. But doing that statically with templates requires partial method
   // specializations (and therefore a helper class), which is all more trouble
   // than it's worth. Do a dynamic check.
-  if (Base::hasSecurityPolicy()) {
+  if (Base::hasSecurityPolicy()) {MOZ_RELEASE_ASSERT(0);
     return Base::getPrototype(cx, wrapper, protop);
   }
 
   RootedObject target(cx, Traits::getTargetObject(wrapper));
   RootedObject expando(cx);
-  if (!Traits::singleton.getExpandoObject(cx, target, wrapper, &expando)) {
+  if (!Traits::singleton.getExpandoObject(cx, target, wrapper, &expando)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2201,13 +2201,13 @@ bool XrayWrapper<Base, Traits>::getProto
 
   // Check our holder, and cache there if we don't have it cached already.
   RootedObject holder(cx, Traits::singleton.ensureHolder(cx, wrapper));
-  if (!holder) {
+  if (!holder) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   Value cached = JS::GetReservedSlot(holder, Traits::HOLDER_SLOT_CACHED_PROTO);
   if (cached.isUndefined()) {
-    if (!Traits::singleton.getPrototype(cx, wrapper, target, protop)) {
+    if (!Traits::singleton.getPrototype(cx, wrapper, target, protop)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
 
@@ -2226,14 +2226,14 @@ bool XrayWrapper<Base, Traits>::setProto
                                              JS::ObjectOpResult& result) const {
   // Do this only for non-SecurityWrapper-inheriting |Base|. See the comment
   // in getPrototype().
-  if (Base::hasSecurityPolicy()) {
+  if (Base::hasSecurityPolicy()) {MOZ_RELEASE_ASSERT(0);
     return Base::setPrototype(cx, wrapper, proto, result);
   }
 
   RootedObject target(cx, Traits::getTargetObject(wrapper));
   RootedObject expando(
       cx, Traits::singleton.ensureExpandoObject(cx, wrapper, target));
-  if (!expando) {
+  if (!expando) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
@@ -2285,13 +2285,13 @@ bool XrayWrapper<Base, Traits>::getPrope
   // in the target compartment.
   RootedObject target(cx, Traits::getTargetObject(wrapper));
   RootedObject expando(cx);
-  if (!Traits::singleton.getExpandoObject(cx, target, wrapper, &expando)) {
+  if (!Traits::singleton.getExpandoObject(cx, target, wrapper, &expando)) {MOZ_RELEASE_ASSERT(0);
     return false;
   }
 
   if (expando) {
     JSAutoRealm ar(cx, expando);
-    if (!js::GetPropertyKeys(cx, expando, flags, props)) {
+    if (!js::GetPropertyKeys(cx, expando, flags, props)) {MOZ_RELEASE_ASSERT(0);
       return false;
     }
   }
